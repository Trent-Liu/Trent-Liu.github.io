

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="泛型
泛型（Generic）指可以把类型参数化，这个能力使得我们可以定义带类型参数的泛型类、泛型接口、泛型方法，随后编译器会用唯一的具体类型替换它；

主要优点是在编译时（类型不匹配的错误）而不是运行时检测出错误(如果运行时才检查出错误，可能造成严重后果)。泛型类或方法允许用户指定可以和这些类或方法一起工作的对象类型。如果试图使用一个不相容的对象，编译器就会检测出这个错误。

Java的泛型通过擦">
  <meta name="author" content="Trent-Liu">
  <meta name="keywords" content="分享在HUST中的一些学习经历">
  
  <title>Java笔记——泛型 - Pigsty</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"trent-liu.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java笔记——泛型">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-12 18:00" pubdate>
        2021年4月12日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      129
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java笔记——泛型</h1>
            
            <div class="markdown-body">
              <h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul>
<li><p>泛型（Generic）指可以把类型参数化，这个能力使得我们可以定义带类型参数的泛型类、泛型接口、泛型方法，随后编译器会用唯一的具体类型替换它；</p>
</li>
<li><p>主要优点是在<strong>编译时</strong>（类型不匹配的错误）而不是运行时<strong>检测出错误</strong>(如果运行时才检查出错误，可能造成严重后果)。泛型类或方法允许用户指定可以和这些类或方法一起工作的对象类型。<strong>如果试图使用一个不相容的对象，编译器就会检测出这个错误。</strong></p>
</li>
<li><p>Java的泛型通过擦除法实现，和C++模板生成<strong>多个实例类</strong>不同。<strong>编译时会用<em>类型实参</em>代替<em>类型形参</em>进行严格的语法检查</strong>，（通过编译后）然后擦除类型参数、生成所有实例类型共享的唯一原始类型。这样使得泛型代码能兼容老的使用原始类型的遗留代码。</p>
</li>
</ul>
<span id="more"></span>

<blockquote>
<p>若不存在泛型，只能重载</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span>,<span class="hljs-keyword">double</span>)</span></span><br></code></pre></div></td></tr></table></figure>

<p>六个基本类型求和要写六个，但是</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">Sum</span><span class="hljs-params">(T o1,T o2)</span></span>;<br></code></pre></div></td></tr></table></figure>

<p>&lt;T&gt;必须为引用类型，六个基本值类型的包装类</p>
<p>调用</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Sum(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>),<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">2</span>))<br></code></pre></div></td></tr></table></figure>
</blockquote>
<hr>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><ul>
<li><p>泛型类（Generic Class）是带形式化类型参数的类。<strong>形式化类型参数</strong>是一个<strong>逗号分隔的变量名列表</strong>，位于类声明中类名后面的尖括号&lt;&gt;中。下面的代码声明一个泛型类Wrapper，它接受一个形式化类型参数T：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>T是一个类型变量，它可以是Java中的<strong>任何引用类型</strong>，例如String，Integer，Double等。当把一个具体的类型实参传递给类型形参T时，就得到了一系列的<strong>参数化类型</strong>(Parameterized Types)，如Wrapper<String>，Wrapper<Integer> ，这些参数化类型是泛型类Wrapper<T>的<strong>实例类型</strong>（类似于Circle类型有实例对象c1,c2）</T></Integer></String></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Wrapper&lt;String&gt;  stringWrapper = <span class="hljs-keyword">new</span> Wrapper&lt;String&gt;();<br>Wrapper&lt;Circle&gt;  circleWrapper = <span class="hljs-keyword">new</span> Wrapper&lt;Circle&gt;();<br><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>参数化类型(Parameterized Types)是在JLS里面使用的术语，为了方便描述，本章后面称为实例类型</p>
</blockquote>
</li>
</ul>
<h3 id="RTTI（-Run-Time-Type-Identification）：运行时类型识别"><a href="#RTTI（-Run-Time-Type-Identification）：运行时类型识别" class="headerlink" title="RTTI（ Run-Time Type Identification）：运行时类型识别"></a><strong>RTTI（ Run-Time Type Identification）：运行时类型识别</strong></h3><ul>
<li>通过<strong>运行时类型</strong>信息，程序在<strong>运行时</strong>能够检查<strong>父类引用所指的对象</strong>的实际派生类型。</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210412170913361.png" srcset="/img/loading.gif" lazyload alt="image-20210412170913361"></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Shape s =<span class="hljs-keyword">null</span>;<br>s = <span class="hljs-keyword">new</span> Circe();<br>s.draw();  <span class="hljs-comment">//draw a circle</span><br><br>If(s <span class="hljs-keyword">instanceof</span> Circle)&#123;<br>    System.out.println(“s is a Circle”)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>以上代码输出结果s is a Circle，表示s对象是Circle类的实例</p>
<p>上面的例子都是RTTI在起作用，<strong>程序在运行时，JVM知道一块内存到底是什么类型的对象</strong></p>
</blockquote>
<ul>
<li>要理解RTTI在Java中的工作原理，就必须知道类型信息在<strong>运行时是如何表示</strong>的。</li>
<li>类型信息是通过<strong>Class类（类名为Class的类，不是class，是一个类）的<em>对象</em></strong>表示的，Java利用Class对象来执行RTTI。</li>
<li>每个类都有一个对应的Class对象，每当编写并编译了一个类，就会<strong>产生一个Class对象</strong>，这个对象当JVM加载这个类时就产生了。</li>
</ul>
<h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ol>
<li>  <strong>Class.forName方法</strong>，是Class类的静态方法</li>
</ol>
<p>   ch13下有如下三个类</p>
   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>如下代码中，Class clz = Class.forName(“ch13.Manager”);产生ch13.Manager类的Class对象，赋值给Class类型的引用变量clz</p>
</blockquote>
   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class clz = Class.forName(“ch13.Manager”); <span class="hljs-comment">//参数是类完全限定名字符串</span><br>            System.out.println(clz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Manager</span><br>            System.out.println(clz.getSimpleName()); <span class="hljs-comment">//产生简单名Manager</span><br><br>            Class superClz = clz.getSuperclass(); <span class="hljs-comment">//获得直接父类型信息</span><br>            System.out.println(superClz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Employee</span><br>            System.out.println(superClz.getSimpleName()); <span class="hljs-comment">//产生简单名Employee</span><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>注意编译器是无法检查字符串”ch13.Manager”是否为一个正确的类的完全限定名，因此在运行时可能抛出异常，比如当不小心把类名写错了时。</p>
</blockquote>
<ol start="2">
<li> 利用类字面常量：<strong>类名.class</strong>，得到类对应的Class对象</li>
</ol>
<p>   <strong>某个类名.class是Class类型的字面量</strong></p>
<p>   <strong>正如int类型的字面量有1，2，3，</strong></p>
<p>   <strong>Class类型的字面量有Person.class, Employee.class, Manager.class，它们都是Class类型的实例</strong></p>
   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Class clz = Manager.class;  <span class="hljs-comment">// Manager.class得到Manager的Class对象.赋给引用clz</span><br>        System.out.println(clz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Manager</span><br>        System.out.println(clz.getSimpleName()); <span class="hljs-comment">//产生简单名Manager   </span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>类字面常量不仅可以用于类，也可用于数组(int[].class)，接口，<strong>基本类型</strong>，如int.class</li>
<li>相比Class.forName方法，这种方法更安全，<strong>在编译时就会被检查，因此不需要放在Try/Catch块里（见上面的标注里说明）</strong></li>
<li>Class.forName会引起类的静态初始化块的执行，T.class不会引起类的静态初始化块的执行</li>
</ul>
<ol start="3">
<li> <strong>通过对象。</strong>如果获得一个对象的引用o，通过<strong>o.getClass()方法</strong>获得这个对象的类型的Class对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Object o = <span class="hljs-keyword">new</span> Manager();<br>        Class clz = o.getClass();<br>        System.out.println(clz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Manager</span><br>        System.out.println(clz.getSimpleName()); <span class="hljs-comment">//产生简单名Manager</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>getClass返回的是运行时类型</p>
</blockquote>
<h3 id="泛型化的Class引用"><a href="#泛型化的Class引用" class="headerlink" title="泛型化的Class引用"></a>泛型化的Class引用</h3><blockquote>
<p>非泛化的Class引用（即不带类型参数的Class引用）可指向任何类型的Class对象，但这样不安全</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class clz ;     <span class="hljs-comment">//注意警告， Class is a raw type. References to generic type Class&lt;T&gt; should be parameterized</span><br>clz= Manager.class; <span class="hljs-comment">//OK</span><br>clz = <span class="hljs-keyword">int</span>.class; <span class="hljs-comment">//OK</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>有时我们需要限定Class引用能指向的类型：加上&lt;类型参数&gt;。这样可以可以强制编译器进行额外的类型检查，对于类型参数，编译器检测时不看继承关系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class&lt;Person&gt; genericClz;    <span class="hljs-comment">//泛化Class引用，Class&lt;Person&gt;只能指向Person的类型信息， &lt;Person&gt;为类型参数</span><br>genericClz = Person.class;  <span class="hljs-comment">//OK</span><br><span class="hljs-comment">//genericClz = Manager.class; //Error，不能指向非Person类型信息。注意对于类型参数，编译器检测时不看继承关系。</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>能否声明一个可用指向Person及其子类的Class对象的引用？为了放松泛化的限制，用通配符?表示任何类型，并且与extends结合，创建一个范围</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class&lt;? extends Person&gt; clz2;  <span class="hljs-comment">//引用clz2可以指向Person及其子类的类型信息</span><br>clz2 = Person.class;<br>clz2 = Employee.class;<br>clz2 = Manager.class;<br><span class="hljs-comment">//注意Class&lt;?&gt; 与Class效果一样，但本质不同，一个用了泛型，一个没有用泛型。 Class&lt;?&gt; 等价于Class&lt;? extends Object &gt; </span><br></code></pre></div></td></tr></table></figure>

<h2 id="反射（Reflection）：应用案例：实例化对象"><a href="#反射（Reflection）：应用案例：实例化对象" class="headerlink" title="反射（Reflection）：应用案例：实例化对象"></a>反射（Reflection）：应用案例：实例化对象</h2><ul>
<li><p>要完成的功能：输入一个完全限定名字符串（如”java.lang.String”）,创建相应的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o = <span class="hljs-keyword">new</span> String(“Hello”); <span class="hljs-comment">//注意String是类名标识符，不是字符串</span><br></code></pre></div></td></tr></table></figure>

<ol>
<li><p>方案1</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span>( input.equals(“java.lang.String”) )&#123;<br>     o = <span class="hljs-keyword">new</span> String(“”);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ( input.equals(“ch13.Student”) )&#123;<br>    o = <span class="hljs-keyword">new</span> Student();<br>&#125;<br>…更多的<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>语句<br><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>这种方法显然不行，因为事先不知道会输入一个什么类的完全限定名字符串，if语句不可能列出所有可能的类型</p>
</blockquote>
</li>
<li><p>方案2 实例化对象（java.lang.reflect包）</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&quot;unknown&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Name:&quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>clz指向一个类的Class对象时，通过 clz可以得到这个类的所有构造函数对象，一个构造函数对象类型是：</p>
<p>   java.lang.reflect.Constructor</p>
<p>一个Constructor对象代表了类的一个构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class  clz = Class.forName(<span class="hljs-string">&quot;ch13.Student&quot;</span>);<br>            <br>            <span class="hljs-comment">//获取所有的Constructor对象</span><br>            Constructor[] ctors = clz.getConstructors();<br>             <span class="hljs-comment">//ctors是clz构造函数对象的数组</span><br>            <span class="hljs-keyword">for</span>(Constructor c : ctors)&#123;<br>                System.out.println(c.toString());<br>        &#125;<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>输出，打印ch13.student的全部构造函数</p>
<p>public ch13.Student()<br>public ch13.Student(java.lang.String)<br>上述对象得到了这个Class中所有的构造方法，对应的构造方法通过数组返回<br>如果我们要知道一个类中，有那些构造方法，就可以这样去做<br>如下获得一个类中所有的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;<br>          Class clz = Class.forName(<span class="hljs-string">&quot;ch13.Student&quot;</span>);<br>            <span class="hljs-comment">//获取所有的Method</span><br>            <span class="hljs-comment">//Method[] methods = clz.getMethods(); //会显示所有方法，包括继承的</span><br>            Method[] methods = clz.getDeclaredMethods(); <span class="hljs-comment">//本类定义的方法</span><br>            <span class="hljs-keyword">for</span>(Method m: methods)&#123;<br>                System.out.println(m.toString());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>               e.printStackTrace();<br>        &#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>输出，打印ch13.Student类的全部方法</p>
<p><strong>public</strong> <strong>java.lang.String</strong> <strong>ch13.Student.toString()</strong></p>
<p><strong>public</strong> <strong>java.lang.String</strong> <strong>ch13.Student.getName()</strong></p>
<p><strong>public void ch13.Student.setName(java.lang.String)</strong></p>
</blockquote>
<blockquote>
<p>得到了构造与方法，也是为了得到实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">  Class clz = Class.forName(<span class="hljs-string">&quot;ch13.Student&quot;</span>);<br>    <span class="hljs-comment">//实例化对象</span><br>    <span class="hljs-comment">//1：如有缺省构造函数，调用Class对象的newInstance方法</span><br>    Student s1 = (Student)clz.newInstance();<br>    <span class="hljs-comment">//2. 调用带参数的构造函数，Instance返回object</span><br>    Student s2 = (Student)clz.getConstructor(String.class).newInstance(<span class="hljs-string">&quot;John&quot;</span>);<br>    <span class="hljs-comment">//invoke method</span><br>    Method m = clz.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>    m.invoke(s1, <span class="hljs-string">&quot;Marry&quot;</span>); <span class="hljs-comment">//调用s1对象的setName方法，实参&quot;Marry&quot;</span><br>    System.out.println(s1.toString());<br>    System.out.println(s2.toString());        <br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>     e.printStackTrace();<br>     <br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>Student s2 = (Student)clz.getConstructor(String.class).newInstance(“John”);</p>
<p>首先得到参数类型为String的构造函数对象，然后调用它的newInstance方法调用构造函数，参数为“John”。等价于：</p>
<p>Student s2 = new Student(“John”)；</p>
<p>但是是通过反射机制调用的</p>
</blockquote>
<blockquote>
<p>Method m = clz.getMethod(“setName”, String.class);</p>
<p>m.invoke(s1, “Marry”); //调用s1对象的setName方法，实参”Marry”</p>
<p>clz.getMethod(“setName”, String.class);得到方法名为setName,参数为String的方法对象m，类型是Method。</p>
<p>然后通过m.invoke去调用该方法，第一个参数为对象，第二个参数是传递给被调方法的实参。这二条语句等价于s1.setName(“Marry)，但是是通过反射去调的</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="泛型的动机和优点"><a href="#泛型的动机和优点" class="headerlink" title="泛型的动机和优点"></a>泛型的动机和优点</h2><ul>
<li><p>lJDK1.5开始，Java允许定义<strong>泛型类、泛型接口和泛型方法</strong>，API中的一些接口和类使用泛型进行了修改。如java.lang.comparable</p>
<blockquote>
<p>T表示类型形参，之后会用实际的类型实参来替换，称为“泛型实例化”（得到实例类型）。按照惯例，E或T这样的单个大写字母表示泛型类型的参数类型</p>
</blockquote>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414090606567.png" srcset="/img/loading.gif" lazyload alt="image-20210414090606567"></p>
<blockquote>
<p>1.5之前，Data和String都引用了Comparable接口，因此c.compareTo(String)<strong>编译通过</strong>，但是由于类型不同，<strong>运行时就会出错</strong></p>
<p>1.5之后，编译时就会产生错误，因为c的Comparable为Data，String为String，<strong>编译就不通过</strong></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>非泛型类Comparable接口的CompareTo方法的参数声明类型为Object，而传进去的实参”red”确实是Object类型，因此编译器通过。但实际运行时一个Data对象和字符串对象比较大小肯定出错。<strong>因此在非泛型年代，保证传进去的对象与另一个比较大小的对象实际类型的一致性是程序员的责任</strong></p>
</blockquote>
<blockquote>
<p>现在泛型接口Comparable&lt;T&gt;里的comparaTo方法的参数类型必须是T，这就规定了要比较的另外一个对象类型必须是T，即和this对象的类型必须一致，否则编译器就可以检查出类型不一致</p>
<p>Comparable&lt;Data&gt;是Comparable&lt;T&gt;的类型实例，因为Comparable&lt;T&gt;是泛型接口，而Comparable&lt;Date&gt;是具体接口类型</p>
</blockquote>
<ul>
<li><p>以ArrayList为例说明看看定义的不同，注意使用了泛型参数E的地方</p>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414091700351.png" srcset="/img/loading.gif" lazyload alt="image-20210414091700351"></p>
<p><strong>下面举出一个非泛型ArrayList</strong></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList list = <span class="hljs-keyword">new</span> ArrayList();   <span class="hljs-comment">//非泛型的ArrayList</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>存入String，取出String</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">   <span class="hljs-comment">//非泛型的ArrayList的add方法，参数类型是Object </span><br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);                  <br><span class="hljs-comment">//非泛型的ArrayList的get方法，返回类型也是Object，因此要强制类型转换</span><br>      String s = (String) list.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">//运行起来不报错  </span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>存入Data，取Data，编译时不报错，但运行时抛出异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">  <span class="hljs-comment">//但是万一程序员不小心加入了Date对象</span><br>  list.add(<span class="hljs-keyword">new</span> Date()); <span class="hljs-comment">//Date对象也是Object类型，因此编译器不报错</span><br>  String s2 = (String)list.get(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译不报错，因为在编译时uncheck</span><br><span class="hljs-comment">//但是在运行时就抛出异常</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>因此，对非泛型ArrayList，保证放进去对象的类型一致性变成了程序员的责任</p>
</blockquote>
</li>
</ul>
<h3 id="泛型的ArrayList"><a href="#泛型的ArrayList" class="headerlink" title="泛型的ArrayList"></a>泛型的ArrayList</h3><blockquote>
<p>尖括号里E为类型形参，以和方法参数区分开(圆括号)规定了放入ArrayList里必须是某种类型E的对象。类型形参在类体里可以用在任何其它类型可以用的地方，如成员变量类型，方法形参类型，方法返回类型。</p>
<p>注意抽象父类和实现的接口List也带了类型参数E。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, </span><br><span class="hljs-class">    <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span>&#123;<br>        ...<br>    &#125;<br></code></pre></div></td></tr></table></figure>
<p>内部结构就是一个Object数组</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">transient</span> Object[] elementData; <br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>将下标为index的元素（注意类型是Object）强制转换为E类型返回。为什么不用instanceOf检查？</p>
<p>因为add方法保证了数组里元素的类型一定是E</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>add方法参数类型是E，这就规定了加入这个集合的元素都必须是E类型，如果add类型不一致的对象，编译器一定报错</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;	<br><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>调用上面elementData方法，该方法直接返回E类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        rangeCheck(index);<span class="hljs-comment">//检查index是否越界</span><br>        <span class="hljs-keyword">return</span> elementData(index);<br>    &#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p><strong>因此，有了泛型机制，程序员的责任（保证类型一致性，例如用instanceOf检查也是程序员的责任）变成了编译器的责任。这就是引入泛型机制的优点。</strong></p>
</blockquote>
<ul>
<li><p>ArrayList<E>定义了一个带<strong>类型形参</strong>的泛型类， 类型参数<strong>E是形参</strong></E></p>
</li>
<li><p>ArrayList<String> 是一个参数化类型(<strong>实例类型</strong>)<strong>，</strong>其中String作为一个具体类型（实参）传递给形参E。 这里借用了术语”实例”，不是指对象，而是一个具体的类型</String></p>
</li>
<li><p>特别重要的时：<strong>类型实参String传递给类型形参E时发生在编译时（不是运行时）</strong>。因此，对于下面的语句，编译器会用<strong>String代替E，对代码进行类型检查</strong></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//用实例类型ArrayList&lt;String&gt; 声明引用变量list</span><br>list.add(“China”);<span class="hljs-comment">//编译器会根据类型实参String检查传入add方法的对象类型是否匹配，否则报错</span><br><br></code></pre></div></td></tr></table></figure>

<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414093844658.png" srcset="/img/loading.gif" lazyload alt="image-20210414093844658"></p>
</li>
<li><p>ArrayList<String> list = new ArrayList<String>(); </String></String></p>
</li>
<li><p>ArrayList<String> list就规定了只能往list里添加String字符串</String></p>
<p>list.add(“Hust”);     //正确，只能向list中添加字符串</p>
<p>list.add(new Integer(1)); //错误，list中只能添加字符串</p>
</li>
<li><p><strong>泛型类型的参数类型必须是引用类型</strong></p>
<p>如 ArrayList<int> list = new ArrayList<int>(); //错误</int></int></p>
<p>ArrayList<Integer> list = new ArrayList<Integer>(); //正确</Integer></Integer></p>
<p>list.add(5); //正确 <strong>自动打包（装箱）机制</strong></p>
<p>int i = list.get(0); //正确，如果元素是包装类型，如Integer,Double,Character，可以直接将这个元素赋给一个基本类型的变量。这个过程称为<strong>自动拆箱机制</strong></p>
</li>
</ul>
<h2 id="定义泛型类和接口"><a href="#定义泛型类和接口" class="headerlink" title="定义泛型类和接口"></a>定义泛型类和接口</h2><h3 id="用泛型定义栈类"><a href="#用泛型定义栈类" class="headerlink" title="用泛型定义栈类"></a>用泛型定义栈类</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414185245589.png" srcset="/img/loading.gif" lazyload alt="image-20210414185245589" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericStack</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>         <span class="hljs-keyword">private</span> ArrayList&lt;E&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;E&gt;();<br>    	<span class="hljs-comment">//判空</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>	 <span class="hljs-keyword">return</span> list.isEmpty();<br>         &#125;<br>    	<span class="hljs-comment">//获取长度</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> list.size();<br>         &#125;<br>    	<span class="hljs-comment">//取值不出栈</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>	 <span class="hljs-keyword">return</span> list.get(getSize() - <span class="hljs-number">1</span>);<br>         &#125;<br>    	<span class="hljs-comment">//出栈</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>	 E o = list.get(getSize() - <span class="hljs-number">1</span>) ;<br>	 list.remove(getSize() - <span class="hljs-number">1</span>);<br>	 <span class="hljs-keyword">return</span> o;<br>          &#125;<br>    	<span class="hljs-comment">//入栈</span><br>   		 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E o)</span> </span>&#123;<br>	 		list.add(o);<br>           &#125; <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>	 		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;stack: &quot;</span> + list.toString();<br>          &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<p>GenericStack<String>是泛型类GenericStack<E>的一个实例类型</E></String></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">GenericStack&lt;String&gt; stack1 = <span class="hljs-keyword">new</span> GenericStack&lt; String &gt;();<br>stack1.push(“Londen”);<br>stack1.push(“Paris”);<br>stack1.push(“New York”);<br></code></pre></div></td></tr></table></figure>
<p>GenericStack<Integer>是泛型类GenericStack<E>的另一个实例类型</E></Integer></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">GenericStack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>stack1.push(<span class="hljs-number">5</span>);<br>stack1.push(<span class="hljs-number">10</span>);<br>stack1.push(<span class="hljs-number">15</span>);<br></code></pre></div></td></tr></table></figure>

<ul>
<li>注意：<strong>GenericStack<E>构造函数形式是擦除参数类型后的GenericStack( ),不是GenericStack&lt;&gt;();</E></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericContainer</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">//注意泛型的构造函数不带泛型参数，连&lt;&gt;都不能有</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericContainer</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<hr>
<p>注意</p>
<ul>
<li><p>泛型类或者泛型接口的一个实力类型，可以作为其他类的父类或者类要实现的接口</p>
</li>
<li><p>如Java API中，Java.lang.String类实现Comparable接口的写法是</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-title">inplements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;</span><br><span class="hljs-class">//<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;是泛型类接口<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;类型的实例类型（接口）</span><br><span class="hljs-class"></span><br><span class="hljs-class">//<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;是一个这样接口类型：可以比较两个<span class="hljs-title">String</span>对象的大小</span><br><span class="hljs-class"></span><br><span class="hljs-class">//而<span class="hljs-title">String</span>实现了这个接口<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>这样的目的主要是避免不同类的比较，限定只能String和String比，Circle和Circle比，不能引用了Comparable的类就可以比</p>
</li>
<li><p>类似的，如果我们要定义了一个实现Comparable接口的Cricle类，就要这么写</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Cricle</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ul>
<li><p>除了可以定义泛型接口和泛型类，也可以定义泛型方法。下面的例子在一个非泛型类里定义了泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethodDemo</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer[] integers = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        String[] strings = &#123;<span class="hljs-string">&quot;Londen&quot;</span>,<span class="hljs-string">&quot;Paris&quot;</span>,<span class="hljs-string">&quot;New York&quot;</span>,<span class="hljs-string">&quot;Austin&quot;</span>&#125;;		  <br>        GenericMethodDemo.&lt;Integer&gt;print(integers);			    <br>        GenericMethodDemo.&lt;String&gt;print(strings);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(E[] list)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt;list.length; i++)&#123;<br>            System.out.print(list[i]+<span class="hljs-string">&quot; &quot;</span>);<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p><strong>调用泛型方法</strong>，将实际类型放于&lt;&gt;之中方法名之前；</p>
<p>也可以<strong>不显式指定实际类型（方法名前不加&lt;&gt;）</strong>，而直接给实参调用，如</p>
<p>print(integers); print(strings);由<strong>编译器自动发现实际类型</strong></p>
</blockquote>
<blockquote>
<p><strong>声明泛型方法</strong>，将类型参数<E>置于返回类型之前</E></p>
<p>方法的类型参数<strong>可以作为形参类型，方法返回类型，也可以用在方法体内其他类型可以用的地方</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="受限泛型"><a href="#受限泛型" class="headerlink" title="受限泛型"></a>受限泛型</h2><ul>
<li><p>在定义泛型类、泛型接口、泛型方法时，可以将类型参数指定为另外一种类型（或泛型）的子类型（用extends），这样的类型参数称之为<strong>受限的</strong>（bounded）</p>
</li>
<li><p>想实现泛型方法比较二个几何对象的面积是否相等，几何对象类型很多，都从GeometricObject派生 （E代表一种几何对象类型，如Circle，Triangel）</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoundedTypeDemo</span></span>&#123;<br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equalArea</span><span class="hljs-params">(E object1, E object2 )</span></span><br><span class="hljs-function">        </span>&#123;<br>        	<span class="hljs-keyword">return</span> object1.getArea() == object2.getArea( );<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>E extends GeometricObject规定了E必须是GeometricObject及其子类，因此E类型对象有方法getArea</p>
</blockquote>
</li>
<li><p>注意: 类型参数放置的位置，应放在<strong>方法的返回类型之前</strong>(定义泛型方法)或者<strong>类名之后</strong>（定义泛型类时）</p>
</li>
</ul>
<h2 id="原始类型和向后兼容"><a href="#原始类型和向后兼容" class="headerlink" title="原始类型和向后兼容"></a>原始类型和向后兼容</h2><ul>
<li><p>没有指定具体实现类型的泛型类和泛型接口称为原始类型（raw type）。如：</p>
<ul>
<li><p>GenericStack stack = new GenericStack( ); <strong>等价</strong>于</p>
</li>
<li><p>GenericStatck&lt;Object&gt; stack = new GenericStack&lt;Object&gt;( );</p>
<p>(JDK1.5后出现泛型，为了让新老代码兼容，出现泛型后，第一句不报错，但是警告)</p>
</li>
</ul>
</li>
<li><p><strong>这种不带类型参数的泛型类或泛型接口称为原始类型。</strong>使用原始类型可以向后兼容Java的早期版本。如Comparable类型. </p>
</li>
<li><p><strong>尽量不要用！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//从JDK1.5开始，Comparable就是泛型接口Comparable&lt;T&gt;的原始类型(raw type)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Max</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparable <span class="hljs-title">findMax</span><span class="hljs-params">(Comparable o1, Comparable o2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (o1.compareTo(o2) &gt; <span class="hljs-number">0</span>)?o1:o2;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p> 上例中，Comparable o1和Comparable o2都是原始类型声明，但是，<strong>原始类型是不安全的</strong>。如：Max.findMax(“Welcome”,123）；<strong>编译通过</strong>(都实现了Comparable)，但会<strong>引起运行时错误</strong>（类型不一致）。</p>
</blockquote>
</li>
<li><p>安全的办法是使用泛型，现在将findMax方法改成泛型方法。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Max</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="hljs-function">E <span class="hljs-title">findMax</span><span class="hljs-params">(E o1, E o2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (o1.compareTo(o2) &gt; <span class="hljs-number">0</span>)?o1:o2;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>E extends Comparable&lt;E&gt;指定类型E必须<strong>实现Comparable接口</strong>，而且接口比较<strong>对象类型必须是E</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Circle</span>&gt; </span>&#123;…&#125;<br><br>Max.findMax(<span class="hljs-keyword">new</span> Circle(),<span class="hljs-keyword">new</span> Circle(<span class="hljs-number">10.0</span>);<br><span class="hljs-comment">//编译上面这条语句时，编译器会自动发现findMax的类型实参为Circle，用Circle替换E</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>这个时候语句Max.findMax(“Welcome”,123）；会引起<strong>编译时错误</strong>，因为findMax方法要求两个参数类型必须一致，且<strong>E必须实现Comparable<E> 接口</E></strong></p>
</blockquote>
</li>
</ul>
<h2 id="通配泛型"><a href="#通配泛型" class="headerlink" title="通配泛型"></a>通配泛型</h2><h3 id="泛型集合类型没有协变性"><a href="#泛型集合类型没有协变性" class="headerlink" title="泛型集合类型没有协变性"></a><strong>泛型集合类型没有协变性</strong></h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WildCardNeedDemo</span> </span>&#123;<br>    <span class="hljs-comment">//参数类型为GenericStack&lt;Number&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(GenericStack&lt;Number&gt; stack)</span></span>&#123;<br>        <span class="hljs-keyword">double</span> max = stack.pop().doubleValue();<br>        <span class="hljs-keyword">while</span> (! stack.isEmpty())&#123;<br>            <span class="hljs-keyword">double</span> value = stack.pop().doubleValue();<br>            <span class="hljs-keyword">if</span>(value &gt; max)<br>                max = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        GenericStack&lt;Integer&gt; intStack = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>        intStack.push(<span class="hljs-number">1</span>);intStack.push(<span class="hljs-number">2</span>);intStack.push(<span class="hljs-number">3</span>);<br>   		<span class="hljs-comment">//传入的参数为insack是GenericStack&lt;Integer&gt;</span><br>        System.out.println(<span class="hljs-string">&quot;Th max value is &quot;</span> + max(intStack));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>出错，因为intStack不是GenericStack<Number>实例</Number></p>
</blockquote>
<p>Integer是Number的子类，但是</p>
<p>GenericStack<Integer>并不是GenericStack<Number>的子类。</Number></Integer></p>
<p>原因：<strong>泛型集合类型没有协变性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WildCardNeedDemo</span> </span>&#123;<br>    <span class="hljs-comment">//参数GenericStack&lt;？ extends Number&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(GenericStack&lt;？ extends Number&gt; stack)</span></span>&#123;<br>        <span class="hljs-keyword">double</span> max = stack.pop().doubleValue();<br>        <span class="hljs-keyword">while</span> (! stack.isEmpty())&#123;<br>            <span class="hljs-keyword">double</span> value = stack.pop().doubleValue();<br>            <span class="hljs-keyword">if</span>(value &gt; max)<br>                max = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p><strong>double max(GenericStack&lt;? extends Number&gt; stack)</strong></p>
<p><strong>extends表示了类型参数的范围关系。</strong> </p>
<p><strong>GenericStack&lt;? extends Number&gt;才是GenericStack<Integer>的父类，</Integer></strong>GenericStack<Number>不是GenericStack<Integer> <strong>的父类</strong></Integer></Number></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        GenericStack&lt;Integer&gt; intStack = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>        intStack.push(<span class="hljs-number">1</span>);intStack.push(<span class="hljs-number">2</span>);intStack.push(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;Th max value is &quot;</span> + max(intStack));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>如上代码就不报错了</p>
</blockquote>
<p>三种形式：</p>
<ul>
<li>？ , 非受限通配，等价于 ? extends Object，注意<ul>
<li>GenericStack&lt;?&gt;不是原始类型， GenericStack是原始类型</li>
</ul>
</li>
<li>？ extends T, 受限通配,表示T或者T的子类，上界通配符，T定义了类型上限</li>
<li>? super T，下限通配，表示T或者T的父类型，下界通配符，T定义了类型下限</li>
</ul>
<h3 id="数组有协变性"><a href="#数组有协变性" class="headerlink" title="数组有协变性"></a>数组有协变性</h3><ul>
<li>数组的协变性是指，如果类A是类B的父类，那么A[]就是B[]的父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jonathan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Apple</span></span>&#123;&#125; <span class="hljs-comment">//一种苹果</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orange</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span></span>&#123;&#125;<br></code></pre></div></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//由于数组的协变性，可以把Apple[]类型的引用赋值给Friut[]类型的引用</span><br>Fruit[] fruits = <span class="hljs-keyword">new</span> Apple[<span class="hljs-number">10</span>]; 		<br>fruits[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Apple();  <br>fruits[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Jonathan(); <span class="hljs-comment">// Jonathan是Apple的子类</span><br></code></pre></div></td></tr></table></figure>

<p>​                以上都正确，但是下面语句fruits的<strong>声明类型是Fruit</strong>因此编译通过，但<strong>运行时将Fruit转型为Apple错误</strong><br>​                数组是在<strong>运行时才去判断数组元素的类型约束</strong>；<br>​                而泛型正好相反，在<strong>运行时，泛型的类型信息是会被擦除的</strong>，编译的时候去检查类型约束</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">try</span>&#123;<br>    fruits[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Fruit();<span class="hljs-comment">//运行时抛出异常 java.lang.ArrayStoreException，这是数组协变性导致的问题</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    System.out.println(e);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="泛型容器（任何泛型类）没有协变性"><a href="#泛型容器（任何泛型类）没有协变性" class="headerlink" title="泛型容器（任何泛型类）没有协变性"></a>泛型容器（任何泛型类）没有协变性</h3><ul>
<li><p>为了解决数组协变性导致的问题，Java编译器规定泛型容器（任何泛型类）没有协变性</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;(); <span class="hljs-comment">//编译错误</span><br><span class="hljs-comment">//Type mismatch: cannot convert from ArrayList&lt;Apple&gt; to ArrayList&lt;Fruit&gt;</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>因为我们在谈论容器的类型，而不是容器持有对象的类型</p>
</li>
<li><p>A是B父类型，但泛型类（比如容器）ArrayList<A>不是ArrayList<B>的父类型，因此上面的语句报错</B></A></p>
</li>
<li><p>为什么数组有协变性而泛型没有协变性</p>
<ul>
<li>数组具有协变性，因此在运行时才会判断元素的类型约束，这将导致有时发生<strong>运行时错误</strong>，抛出异常java.lang.ArrayStoreException。这个功能在Java中是一个公认的“瑕疵”</li>
<li>泛型没有协变性：<strong>泛型设计者认为与其在运行失败，不如在编译时就失败（禁止泛型的协变性就是为了杜绝数组协变性带来的问题，即如果泛型有协变性，面临可协变的数组一样的问题）</strong>——静态类型语言（Java，C++）的全部意义再与代码运行前找出错误，Python，JavaScript之类的语言是动态类型语言（不安全）。</li>
<li>但有时希望像数组一样，一个父类型容器引用变量指向子类型同期，这时要使用通配符</li>
</ul>
</li>
</ul>
<h3 id="上界通配泛型-extends"><a href="#上界通配泛型-extends" class="headerlink" title="上界通配泛型? extends"></a>上界通配泛型? extends</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? extends Fruit&gt; list = <span class="hljs-keyword">new</span>  ArrayList&lt;Apple&gt;(); <span class="hljs-comment">//左边类型是右边类型的父类型</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>上面语句编译通过，但是这样的list不能加入任何东西，下面语句都会编译出错</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">list.add(<span class="hljs-keyword">new</span> Apple()); list.add(<span class="hljs-keyword">new</span> Fruit()); <span class="hljs-comment">//编译都报错</span><br><span class="hljs-comment">//可加入null</span><br>list.add(<span class="hljs-keyword">null</span>);<br><br><span class="hljs-comment">//但是从这个list取对象没有问题，编译时都解释成Fruit，运行时可以是具体的类型如Apple（有多态性）</span><br>Fruit f = list.get(<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure>

<ul>
<li>因为ArrayList&lt;? entends Fruit&gt;意味着该list集合中存放的都是Fruit的子类型（包括Fruit自身），Fruit的子类型可能有很多，但list只能<strong>存放其中的某一种类型</strong>，编译器<strong>只能知道元素类型的上限是Fruit，而无法知道list引用会指向什么具体的ArrayList</strong>，可以是ArrayList<Apple>,也可能是ArrayList<Jonathan>,<strong>为了安全，Java泛型只能将其设计成不能添加元素</strong>。</Jonathan></Apple></li>
<li>虽然不能添加元素，但从里面获取元素的类型都是Fruit类型（编译时）</li>
<li>因此带&lt;! extends&gt;类型通配符的泛型类<strong>不能往里存内容（不能set），只能读取（只能get）</strong></li>
<li>那这样的声明的容器类型有什么意义？它的意义是作为一个<strong>只读（只从里面取对象）的容器</strong></li>
</ul>
<blockquote>
<p>假设已经实例化好了另外一个容器，对象已经放入其中，这时用ArrayList&lt;? extends Fruit&gt; list <strong>指向这个另外的容器，那么我们可以通过list取出容器的所有对象而没有任何问题</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;();<br><span class="hljs-comment">//调用apples.add方法添加很多Apple及其子类对象</span><br><br>ArrayList&lt;? extends Fruit&gt; list = apples; <span class="hljs-comment">//现在ArrayList&lt;? extends Fruit&gt; 类型的引用指向apples</span><br><span class="hljs-keyword">for</span>（<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++）&#123;<br>    Fruit f = list.get(i)；  <span class="hljs-comment">//运行时从容器里取出的都是Apple及其子类对象，赋值给Fruit引用没问题</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p><strong>这个例子还是比较极端（纯粹是语法功能演示），实际更有意义的是作为方法参数：该方法接受一个放好对象的容器，然后在方法里只是逐个取出元素进行处理</strong></p>
</blockquote>
<p>运用上限通配泛型</p>
<ul>
<li><p>程序的其他地方，创建具体类型的容器，添加对象，ArrayList作为实参调用handle方法</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;Apple&gt; appleList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">//等价于new ArrayList&lt;Apple&gt;(); </span><br>appleList.add(<span class="hljs-keyword">new</span> Apple());<span class="hljs-comment">//ArrayList&lt;Apple&gt;是具体类型，编译器很清楚地知道类型参数是Apple这时可以add</span><br><span class="hljs-comment">//由于形参类型ArrayList&lt;? extends Fruit&gt;是实参类型ArrayList&lt;Apple&gt;的父类型，因此实参可以传给形参</span><br>handle(appleList); <br></code></pre></div></td></tr></table></figure></li>
<li><p>handle方法，参数类型设置为ArrayList&lt;? extends Fruit&gt; </p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(ArrayList&lt;? extends Fruit&gt; list)</span></span>&#123; <span class="hljs-comment">//注意方法里只能从list get元素</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++)&#123;<br>		Fruit o = list.get(i); <span class="hljs-comment">//可以确定list里面对象一定是Fruit或子类类型</span><br>        	<span class="hljs-comment">//处理对象o，注意这时调用o的实例方法时具有多态性</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>如上我们可以看到上限通配泛型可以作为只读。</p>
</li>
</ul>
<h3 id="下限通配泛型-super"><a href="#下限通配泛型-super" class="headerlink" title="下限通配泛型? super"></a>下限通配泛型? super</h3><ul>
<li><p>采用下界通配符 <strong>？****super T</strong> 的泛型类引用，可以指向所有以T及其父类型为类型参数的实例类型</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Fruit&gt;(); <span class="hljs-comment">//这时new后边的Fruit可以省略</span><br>ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;(); <span class="hljs-comment">//允许，Object是Fruit父类</span><br>ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;(); <span class="hljs-comment">//但是不能指向Fruit子类的容器</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>可以向List里面添加T及T的子类对象</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">list.add(<span class="hljs-keyword">new</span> Fruit()); 	<span class="hljs-comment">//OK</span><br>list.add(<span class="hljs-keyword">new</span> Apple()); 	<span class="hljs-comment">//OK</span><br>list.add(<span class="hljs-keyword">new</span> Jonathan()); 	<span class="hljs-comment">//OK</span><br>list.add(<span class="hljs-keyword">new</span> Orange())；	<span class="hljs-comment">//OK	</span><br><span class="hljs-comment">//list.add(new Object()); //添加Fruit父类则编译器禁止，报错</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>但从list里get数据只能被编译器解释称Object</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o1 = list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//OK</span><br>Fruit o2 = list.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">//报错，Object不能赋给Fruit，需要强制类型转换，</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>因此这种泛型类和采用？extends的泛型类正好相反：<strong>只能存数据</strong>，获取数据<strong>至少部分失效</strong>（编译器解释成Object）</p>
</li>
</ul>
<h3 id="extend和-super的理解"><a href="#extend和-super的理解" class="headerlink" title="? extend和? super的理解"></a>? extend和? super的理解</h3><blockquote>
<p>现在看看通配泛型 ？ extends，注意右边的new ArrayList的类型参数必须是Fruit的子类型</p>
<p>//? extends Fruit指定了类型上限，因此下面的都成立：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? extends Fruit&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Fruit&gt;(); <span class="hljs-comment">//=号右边，如果是Fruit，可以不写，等价于new ArrayList&lt;&gt;();</span><br>ArrayList&lt;? extends Fruit&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;();  <span class="hljs-comment">//=号右边，如果是Fruit的子类，则必须写</span><br>ArrayList&lt;? extends Fruit&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Jonathan&gt;(); <span class="hljs-comment">//=号右边，如果是Fruit的子类，则必须写</span><br>ArrayList&lt;? extends Fruit&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Orange&gt;();  <span class="hljs-comment">//=号右边，如果是Fruit的子类，则必须写</span><br></code></pre></div></td></tr></table></figure>

<ul>
<li><p>ArrayList&lt;? extends Fruit&gt; list可指向</p>
<ol>
<li>ArrayList<Fruit></Fruit></li>
<li>ArrayList<Apple></Apple></li>
<li>ArrayList<Jonathan></Jonathan></li>
<li>ArrayList<Orange>…</Orange></li>
</ol>
</li>
<li><p>一个ArrayList<Fruit>容器可以加入Fruit、Apple、Jonathan、Orange，</Fruit></p>
</li>
<li><p>一个ArrayList<Apple>容器可以加入Apple、Jonathan，</Apple></p>
</li>
<li><p>一个ArrayList<Orange>容器可以加入Orange，</Orange></p>
</li>
</ul>
<blockquote>
<p>假如当ArrayList&lt;? extends Fruit&gt; list为<strong>方法形参</strong>时，如果方法内部调list.add，</p>
<p>由于编译时，编译器无法知道ArrayList&lt;? extends Fruit&gt;类型的引用变量会<strong>指向哪一个具体容器类型</strong>，编译器<strong>无法知道该怎么处理add</strong>。</p>
</blockquote>
<blockquote>
<p>例如当add的对象类型是Orange，如果list指向ArrayList<Apple>，加不进去。但如果list指向为ArrayList<Orange>，就可以加进去。</Orange></Apple></p>
</blockquote>
<blockquote>
<p><strong>为了安全，编译器干脆禁止ArrayList&lt;? extends Fruit&gt;类型的list添加元素。</strong></p>
</blockquote>
<blockquote>
<p><strong>但从list里get元素，都解释成Fruit类型</strong></p>
</blockquote>
<hr>
<blockquote>
<p>? super Fruit指定了类型下限，因此下面二行都成立</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Fruit&gt;(); 	<span class="hljs-comment">//=号右边，这时Fruit可以省略，等价于new ArrayList&lt;&gt;();</span><br>ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;(); 	<span class="hljs-comment">//允许。=号右边，如果是Fruit的父类，必须写出类型</span><br><span class="hljs-comment">//ArrayList&lt;? super Fruit&gt; list3 = new ArrayList&lt;Apple&gt;(); 	//但是不能指向Fruit子类的容器</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>因此ArrayList&lt;? super Fruit&gt; list引用可以指向ArrayList<Fruit>以及Fruit父类型的容器如ArrayList<Object>。</Object></Fruit></p>
</blockquote>
<ul>
<li>当ArrayList&lt;? super Fruit&gt; list为方法形参时,<strong>编译器知道list指向的具体容器的类型参数至少是Fruit</strong>。当向list里add对象o时，分析几种可能的情况：<ol>
<li>o是Fruit及其子类类型，这里面又分二种情况<ol>
<li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Fruit>，可以加入</Fruit></li>
<li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Object>,可以加入</Object></li>
</ol>
</li>
<li> o是Fruit的父类型如Object，这里面又分二种情况</li>
<li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Fruit>，这时编译器不允许加入，Object不能转型为Fruit</Fruit></li>
<li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Object>，可以加入</Object></li>
</ol>
</li>
</ul>
<blockquote>
<p>综合以上四种情况，可以看到，只要对象o的类型是Fruit及其子类型，这时将对象o加入list一定是安全的（1.1, 1.2）；</p>
<p>如果对象是Fruit父类型，则不允许加入最安全（因为可能出现2.1的情况)。由于? super Fruit规定了list元素类型的下限，因此取元素时编译器只能全部解释成Object</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">list1.add(<span class="hljs-keyword">new</span> Fruit()); <br>list1.add(<span class="hljs-keyword">new</span> Apple()); <br>list1.add(<span class="hljs-keyword">new</span> Jonathan());<span class="hljs-comment">//只要加入Fruit及其子类对象都OK</span><br><span class="hljs-comment">//list1.add(new Object()); //添加Fruit父类则编译器禁止，报错</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>取对象时都必须解释成Object类型。因此我们说带&lt;? super&gt;通配符的泛型类的get方法至少是部分失效</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o1 = list.get(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//Fruit o2 = list.get(0);  //报错，Object不能赋给Fruit，需要强制类型转换，但是引入泛型就是想去掉强制类型转换</span><br></code></pre></div></td></tr></table></figure>

<h4 id="extends和-super的使用原则"><a href="#extends和-super的使用原则" class="headerlink" title="? extends和? super的使用原则"></a>? extends和? super的使用原则</h4><p>Producer Extends，Consumer Super原则（PECS）</p>
<blockquote>
<p>Producer Extends: 如果需要一个只读泛型类，用来Produce T，那么用? extends T</p>
<p>Consumer Super： 如果需要一个只写泛型类，用来Consume T，那么用? super T</p>
<p>如果需要同时读取和写入，那么久不能用通配符</p>
</blockquote>
<p>例如我们读JDK的Collections类的copy方法，可以看到一个经典使用PECS原则的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collections</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>	<span class="hljs-comment">//其中重要的代码片段为</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;srcSize; i++)<br>                dest.set(i, src.get(i)); <span class="hljs-comment">//dest:写，src：读</span><br>        &#125; <br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>看如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperWildCarDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        GenericStack&lt;String&gt; strStack= <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>	  GenericStack&lt;Object&gt; objStack = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();		<br>	  objStack.push(“Java<span class="hljs-string">&quot;);</span><br><span class="hljs-string">	  objStack.push(2); //装箱</span><br><span class="hljs-string">	  strStack.push(“Sun&quot;</span>);		<br>	  add(strStack , objStack);		<br>    &#125;<br></code></pre></div></td></tr></table></figure>

<p>方法1</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(GenericStack&lt;T&gt; stack1,</span></span><br><span class="hljs-function"><span class="hljs-params">							GenericStack&lt;? <span class="hljs-keyword">super</span> T&gt; stack2)</span></span>&#123;<br>	  <span class="hljs-keyword">while</span>(!stack1.isEmpty())<br>			stack2.push(stack1.pop()); <span class="hljs-comment">//只写</span><br>    &#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>编译时，编译器根据实参strStack的类型参数String确定类型形参T为String。GenericStack&lt;? super T&gt;stack2表示元素类型是String父类的堆栈，因此实参objStack的类型GenericStack<Object>与形参stack2的类型匹配，参数传递也没问题。<strong>注意stack2只写。</strong></Object></p>
</blockquote>
<p>方法2</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(GenericStack&lt;？extends T&gt; stack1,GenericStack&lt;T&gt; stack2)</span></span>&#123;<br>	  <span class="hljs-keyword">while</span>(!stack1.isEmpty())<br>			stack2.push(stack1.pop());<br>    &#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>add方法参数类型改为（GenericStack&lt;？extends T&gt; stack1,GenericStack<T> stack2）也没问题，这时根据第二个实参类型推断出T为Object，而第一个实参类型GenericStack<String>是GenericStack&lt;? Extends Object&gt;的子类型，因此参数传递也没问题。<strong>注意stack1只读。</strong></String></T></p>
</blockquote>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416203513322.png" srcset="/img/loading.gif" lazyload alt="image-20210416203513322"></p>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416203550072.png" srcset="/img/loading.gif" lazyload alt="image-20210416203550072"></p>
<h2 id="泛型擦除和对泛型的限制"><a href="#泛型擦除和对泛型的限制" class="headerlink" title="泛型擦除和对泛型的限制"></a>泛型擦除和对泛型的限制</h2><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><ul>
<li>泛型是用类型擦除（type erasure）方法实现的。泛型的作用就是使得编译器在编译时通过类型参数来检测代码的类型匹配性。<strong>当编译通过，意味着代码里的类型都是匹配的。因此，所有的类型参数使命完成而全部被擦除</strong>。因此，泛型信息(类型参数)在运行时是不可用的，这种方法使得泛型代码<strong>向后兼容使用原始代码的遗留代码</strong>。</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416203725935.png" srcset="/img/loading.gif" lazyload alt="image-20210416203725935"></p>
<ul>
<li><strong>泛型存在于编译时</strong>，当编译器认为泛型类型是安全的，就会将其转化为原始类型。<strong>这时(a)所示的源代码编译后变成(b)所示的代码</strong>。注意在(b)里，由于list.get(0)返回的对象运行时类型一定是String，因此<strong>强制类型转换一定是安全的。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeErasureTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        ArrayList&lt;String&gt; strList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Fruit&gt; fruitList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <br>        Class clz1 = strList.getClass(); <span class="hljs-comment">//getClass返回运行时信息</span><br>        Class clz2 = fruitList.getClass();<br>        <br>        System.out.println(clz1.getSimpleName());   <span class="hljs-comment">//ArrayList</span><br>        System.out.println(clz2.getSimpleName());   <span class="hljs-comment">//ArrayList</span><br>        System.out.println(clz1 == clz2);           <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>**所有参数化类型（实例类型）ArrayList<String> **、ArrayList<Fruit>在运行时共享同一个类型：ArrayList。</Fruit></String></p>
</blockquote>
<ul>
<li>当编译泛型类，接口和方法时，会用Object代替非首先类型参数E,<E extends object></E></li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416204338780.png" srcset="/img/loading.gif" lazyload alt="image-20210416204338780"></p>
<ul>
<li>如果一个泛型的参数类型是受限的，编译器会用该受限类型来替换它</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416204444415.png" srcset="/img/loading.gif" lazyload alt="image-20210416204444415"></p>
<hr>
<ul>
<li><p>泛型类会擦除类型参数，所有泛型的实例类型共享擦除后形成的原始类型如ArrayList</p>
<ul>
<li><p>泛型类所有实例类型在运行时共享原始类型，如：</p>
<p>ArrayList<String> list1 = new ArrayList&lt;&gt;( );</String></p>
<p>ArrayList<Integer> list2= new ArrayList&lt;&gt;( );</Integer></p>
<p>在运行时只有一个擦除参数类型后的原始ArrayList类被加载到JVM中</p>
</li>
<li><p>所以， list1 instanceOf ArrayList<String>是错误的，可用：</String></p>
<p>list1 instanceOf ArrayList</p>
<p>list2 instanceOf ArrayList</p>
<p>instanceOf是根据运行时类型进行检查</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用泛型类型的限制"><a href="#使用泛型类型的限制" class="headerlink" title="使用泛型类型的限制"></a>使用泛型类型的限制</h3><ul>
<li><p>不能使用new E( ); //只能想办法得到E的类型<strong>实参</strong>的Class信息，再newInstance(…)</p>
<p>不能用泛型的类型参数创建实例，如： E object = new E( ); //错误，泛型类型参数在运行时不可用</p>
</li>
<li><p>不能使用new E[ ]</p>
<p>不能用泛型的类型参数创建数组，如： E[ ] element = new E[cpacity]; //错误</p>
<ul>
<li><strong>new是运行是发生的，因此new 后面一定不能出现类型形参E，运行时类型参数早没了</strong></li>
</ul>
</li>
<li><p>强制类型转换可以用类型形参E，通过类型转换实现无法确保运行时类型转换是否成功</p>
<ul>
<li>E[ ] element = (E[ ])new Object[cpacity];  //编译可通过(所谓编译通过就是指编译时uncheck，至于运行时是否出错，那是程序员自己的责任</li>
</ul>
</li>
</ul>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericOneDimensionArray</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <br>    <span class="hljs-keyword">private</span> T[] elements = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//T[]类型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericOneDimensionArray</span><span class="hljs-params">(Class&lt;? extends T&gt; clz,<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>        elements = (T[])Array.newInstance(clz,size);<br>    &#125;<br>    <span class="hljs-comment">//get, put等其他方法省略</span><br><br>    <span class="hljs-keyword">public</span> T[] getElements()&#123; <span class="hljs-keyword">return</span> elements; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        GenericOneDimensionArray&lt;String&gt; stringArray = <br>                <span class="hljs-keyword">new</span> GenericOneDimensionArray(String.class,<span class="hljs-number">10</span>);<br>        String[] a = stringArray.getElements();  <span class="hljs-comment">//这里不会抛出运行时异常了</span><br><span class="hljs-comment">//        a[0] = new Fruit(); //不是String类型的对象，编译报错</span><br>        a[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>注意如下的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> T[] elements = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//T[]类型</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericOneDimensionArray</span><span class="hljs-params">(Class&lt;? extends T&gt; clz,<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>    elements = (T[])Array.newInstance(clz,size);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>这里第一个参数是Class&lt;? extends T&gt; clz，表示一个T类型及其子类的Class对象。通过Class对象，可以通过反射创建运行时类型为T[]的数组。</p>
</blockquote>
<blockquote>
<p>但是Array.newInstance方法返回的是Object，因此需要强制类型转换。但这里的强制类型转换是安全的，因为创建的数组的运行时类型就是T[]</p>
</blockquote>
<blockquote>
<p>Array.newInstance(数组元素类型的Class对象, size)</p>
<p>通过反射机制创建运行时类型为T[]的数组</p>
</blockquote>
<p>这个泛型数组实现的版本比前一个要好多了，但构造函数要多传一个<em><strong>Class</strong></em>对象，指明数组元素类型信息。举这个例子还想说明反射机制的重要性。</p>
<hr>
<ul>
<li><p>使用泛型类型的限制：不能new泛型数组（数组元素是泛型），但可以声明</p>
<ul>
<li><p>不能使用new A<E>[ ]的数组形式，因为E已经被擦除</E></p>
<p>ArrayList<String>[ ] list = new ArrayList<String>[10]；//错误</String></String></p>
</li>
</ul>
</li>
<li><p>E已经被擦除，只能用泛型的原始类型初始化数组, 必须改为new ArrayList[10]</p>
<p>ArrayList<String> [ ] list = new ArrayList[10]；</String></p>
<ul>
<li><p>为什么这里不需要强制类型转换：参数化类型与原始类型的兼容性</p>
</li>
<li><p>参数化类型对象可以被赋值为原始类型的对象，原始类型对象也可以被赋值为参数化类型对象</p>
<p> ArrayList a1 = new ArrayList(); //原始类型</p>
<p> ArrayList<String> a2 = a1; //参数化类型</String></p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>静态上下文</strong>中不允许使用泛型的类型参数。由于泛型类的所有实例类型都共享相同的运行时类，所以<strong>泛型类的静态变量和方法都被它的所有实例类型所共享</strong>。因此，在静态方法、数据域或者初始化语句中，使用泛型的参数类型是非法的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(E o1)</span></span>&#123;<span class="hljs-comment">//Illegal</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> E o1; <span class="hljs-comment">//Illegal</span><br>    <br>    <span class="hljs-keyword">static</span>&#123;<br>        E o2;<span class="hljs-comment">//Illegal</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>Test<String>和Test<Integer>这二个实例类型共享同一个运行时类型，如果静态上下文可以使用类型参数E, 会导致矛盾：</Integer></String></p>
<p>m方法的形参类型到底是String还是Integer？</p>
</blockquote>
<hr>
<ul>
<li><p>异常类不能是泛型的。泛型类不能继承java.lang.Throwable。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>非法，因为如果允许这么做，则应为MyException添加一个catch语句</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">try</span>&#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">catch</span>(MyException&lt;T&gt; ex)&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>JVM必须检查这个从try语句中抛出的异常以确定与catch语句中的异常类型匹配，但这不可能，因为运行时的类型信息是不可获得的。</p>
</li>
</ul>
<h2 id="实现带泛型参数的对象工厂（一种设计模式）"><a href="#实现带泛型参数的对象工厂（一种设计模式）" class="headerlink" title="实现带泛型参数的对象工厂（一种设计模式）"></a>实现带泛型参数的对象工厂（一种设计模式）</h2><ul>
<li><p>使用泛型类型的限制</p>
<ul>
<li>不能使用new E();//只能用newInstance(…)</li>
</ul>
</li>
<li><p>如何利用反射机制，通过newInstance()来创建对象？</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectFactory</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>	<span class="hljs-keyword">private</span> Class&lt;T&gt; type;  <span class="hljs-comment">//定义私有数据成员，保存要创建的对象的类型信息</span><br>    <br><span class="hljs-comment">//构造函数传入要创建的对象的类型信息</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObjectFactory</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.type = type;<br>	&#125;	<br><span class="hljs-comment">//对象工厂的create方法负责产生一个T类型的对象，利用newInstance</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>		T o = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			o= type.newInstance();<br>		&#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>        <span class="hljs-comment">//这里顺便说明和强调一下，一个类定义缺省构造函数（不带参数）多么重要</span><br>		<span class="hljs-keyword">return</span> o;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如下为一个实例</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;	<br>		<span class="hljs-comment">//首先创建一个负责生产Car的对象工厂，传进去需要创建对象的类的Class信息	</span><br>		ObjectFactory&lt;Car&gt; carFactory = <span class="hljs-keyword">new</span> ObjectFactory&lt;Car&gt;(Car.class);<br>		Car o = carFactory.create();  <span class="hljs-comment">//由对象工厂负责产生car对象</span><br>		System.out.println(carFactory.create().toString());	<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> String s = <span class="hljs-keyword">null</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">()</span> </span>&#123;<br>		s = <span class="hljs-string">&quot;Car&quot;</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> s;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>  以Car.class为参数去构造一个ObjectFactory<Car>类型的对象工厂，再调用对象工厂的create方法，一定会返回Car对象。</Car></p>
</blockquote>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%B3%9B%E5%9E%8B/">泛型</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/17/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java笔记——多线程和并行程序设计</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/12/Java_ArrayList/">
                        <span class="hidden-mobile">Java自学——List</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function () {
        var gitalk = new Gitalk({
          clientID: '81506d8985202387cbbd',
          clientSecret: '40c6250a001a80f7986e1ec1a375dc2d7e82f7d9',
          repo: 'Pigsty',
          owner: 'Trent-Liu',
          admin: ["Trent-Liu"],
          id: '40d5b163b3d061282599084f78de9705',
          language: 'zh-CN',
          labels: ["Gitalk"],
          perPage: 10,
          pagerDirection: 'last',
          createIssueManually: true,
          distractionFreeMode: false,
          proxy: '&lt;your own proxy&gt;/https://github.com/login/oauth/access_token'
        });
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
