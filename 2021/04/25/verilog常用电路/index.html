

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="选择器2-1选择器1234567891011121314// 2-1 选择器module mux_21(a, b, sel, out);    parameter WIDTH = 8;        input [WIDTH-1:0] a, b;    input sel;    output [WIDTH-1:0] out;        // 三元运算符    assign out = sel">
  <meta name="author" content="Trent-Liu">
  <meta name="keywords" content="分享在HUST中的一些学习经历">
  
  <title>Verilog常见电路 - Pigsty</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"trent-liu.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>





<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Pigsty</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/wallhaven-dgkmpo_3840x2160.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Verilog常见电路">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-25 18:00" pubdate>
        2021年4月25日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      48
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Verilog常见电路</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年5月11日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="2-1选择器"><a href="#2-1选择器" class="headerlink" title="2-1选择器"></a>2-1选择器</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 2-1 选择器</span><br><br><span class="hljs-keyword">module</span> mux_21(a, b, sel, out);<br>    <span class="hljs-keyword">parameter</span> WIDTH = <span class="hljs-number">8</span>;<br>    <br>    <span class="hljs-keyword">input</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a, b;<br>    <span class="hljs-keyword">input</span> sel;<br>    <span class="hljs-keyword">output</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] out;<br>    <br>    <span class="hljs-comment">// 三元运算符</span><br>    <span class="hljs-keyword">assign</span> out = sel == <span class="hljs-number">0</span> ? a : b;<br>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></div></td></tr></table></figure>

<span id="more"></span>

<h3 id="4-1选择器"><a href="#4-1选择器" class="headerlink" title="4-1选择器"></a>4-1选择器</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 4-1 1 bit 选择器设计方案I</span><br><span class="hljs-keyword">module</span> mux_41(a, b, c, d, <br>  sel, out);<br><br>  <span class="hljs-keyword">input</span> a, b, c, d;<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out;<br><br>  <span class="hljs-keyword">always</span> @(a, b, c, d, sel)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (sel == <span class="hljs-number">2&#x27;b00</span>)<br>      out = a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sel == <span class="hljs-number">2&#x27;b01</span>)<br>      out = b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sel == <span class="hljs-number">2&#x27;b10</span>)<br>      out = c;<br>    <span class="hljs-keyword">else</span> out = d;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 4-1 1 bit 选择器设计方案II</span><br><span class="hljs-keyword">module</span> mux_41(a, b, c, d, <br>  sel, out);<br><br>  <span class="hljs-keyword">input</span> a, b, c, d;<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out;<br><br>  <span class="hljs-keyword">always</span> @(a, b, c, d, sel)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(sel)<br>      <span class="hljs-number">2&#x27;b00</span>: out = a;<br>      <span class="hljs-number">2&#x27;b01</span>: out = b;<br>      <span class="hljs-number">2&#x27;b10</span>: out = c;<br>      <span class="hljs-keyword">default</span>: out = d;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 4-1 选择器设计方案 III</span><br><br><span class="hljs-keyword">module</span> mux_41(a, sel, out);<br>    <span class="hljs-keyword">parameter</span> WIDTH = <span class="hljs-number">8</span>;<br>    <br>    <span class="hljs-keyword">input</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>    <span class="hljs-keyword">output</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] out;<br>    <br>    <span class="hljs-comment">// 利用数组</span><br>    <span class="hljs-keyword">assign</span> out = a[sel];<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<h2 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h2><ul>
<li><p><strong>译码器：将具有特定含义的二进制代码转换成控制信号的器件。</strong></p>
</li>
<li><p><strong>地址译码器</strong></p>
</li>
<li><p><strong>显示译码器</strong></p>
</li>
<li><p><strong>指令译码器</strong></p>
</li>
<li><p><strong>…</strong></p>
</li>
</ul>
<p><strong>通过二进制编码来选择当前占用总线的设备。</strong></p>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210427202403937.png" srcset="/img/loading.gif" lazyload alt="image-20210427202403937"></p>
<h3 id="38译码器"><a href="#38译码器" class="headerlink" title="38译码器"></a>38译码器</h3><p>最常见的地址译码器 3比特构成8个设备的地址的地址译码器</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 3-8 译码器 行为描述方法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">要点：</span><br><span class="hljs-comment">1、输出（被赋值的对象必须被声明为寄存器类型）</span><br><span class="hljs-comment">2. 用always做关键词,后面跟@():trigger list,包含所有影响输出的变量，如果变化，就执行always</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">module</span> decoder_38(A, Y);<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] A;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] Y;<br><br>  <span class="hljs-keyword">always</span> @(A)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(A)<br>      <span class="hljs-number">3&#x27;d0</span>: Y = <span class="hljs-number">8&#x27;b1111_1110</span>;<br>      <span class="hljs-number">3&#x27;d1</span>: Y = <span class="hljs-number">8&#x27;b1111_1101</span>;<br>      <span class="hljs-number">3&#x27;d2</span>: Y = <span class="hljs-number">8&#x27;b1111_1011</span>;<br>      <span class="hljs-number">3&#x27;d3</span>: Y = <span class="hljs-number">8&#x27;b1111_0111</span>;<br>      <span class="hljs-number">3&#x27;d4</span>: Y = <span class="hljs-number">8&#x27;b1110_1111</span>;<br>      <span class="hljs-number">3&#x27;d5</span>: Y = <span class="hljs-number">8&#x27;b1101_1111</span>;<br>      <span class="hljs-number">3&#x27;d6</span>: Y = <span class="hljs-number">8&#x27;b1011_1111</span>;<br>      <span class="hljs-number">3&#x27;d7</span>: Y = <span class="hljs-number">8&#x27;b0111_1111</span>;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>常数的声明方法:</p>
<p>[宽度]‘[进制][值]</p>
<p>硬件中，不能赋没有位宽的值，没有位宽的值在硬件中通常为32位的值，通常又用不到，浪费资源。所以通常要指定位宽</p>
<p>为了更好的阅读二进制串，允许中间用_连接，verilog会自动去掉_</p>
</blockquote>
<p>负值逻辑：enable逻辑信号是为了让选中的信号有效，其他的信号无效。</p>
<p>硬件中对于enable信号通常采用负逻辑，0有效，1无效，因为负逻辑不容易被误触发。通常无效的时候是1，被干扰的可能性较小，使得设备不会被误触发。</p>
<p>通常enable，reset，控制信号写允许读允许都用负值逻辑</p>
<h2 id="分频器"><a href="#分频器" class="headerlink" title="分频器"></a>分频器</h2><p>分频是指将时钟信号的频率进行降低的时序电路，例如：如果要将频率降低为原来的1/N，就叫N分频。为便于高层模块改变分频系数N，将N定义为参数。实例化时可以把参数传递进去：  </p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> divider(clk, clk_N);<br>    <span class="hljs-keyword">input</span> clk;                      <span class="hljs-comment">// 系统时钟</span><br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> clk_N;                   <span class="hljs-comment">// 分频后的时钟</span><br>    <span class="hljs-keyword">parameter</span> N = <span class="hljs-number">100_000_000</span>;     <span class="hljs-comment">// 1Hz的时钟,N=fclk/fclk_N</span><br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] counter;             <span class="hljs-comment">/* 计数器变量，通过计数实现分频。当计数器从0计数到(N/2-1)时，输出时钟翻转，计数器清零 */</span><br><br>    <span class="hljs-keyword">initial</span><br>    <span class="hljs-keyword">begin</span>                           <span class="hljs-comment">// 赋初始值</span><br>        counter = <span class="hljs-number">0</span>;<br>        clk_N = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)           <span class="hljs-comment">// 时钟上升</span><br>    <span class="hljs-keyword">begin</span><br>        counter &lt;= counter + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (counter &gt; N / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">begin</span><br>                clk_N &lt;= ~clk_N;<br>                counter &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<p>如上，1Hz的时钟，分频后将其变成每N/2=0.5Hz，时钟翻转一次，这样就对时钟进行分频</p>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="简单加法计数器"><a href="#简单加法计数器" class="headerlink" title="简单加法计数器"></a>简单加法计数器</h3><p>时钟脉冲来的时候，就+1，四位，将记到f的时候再+1就溢出，归0</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> CNT4 (CLK,Q);<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] Q;<br>    <span class="hljs-keyword">input</span> CLK;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] Q;<br>    <span class="hljs-keyword">always</span>@(posegde CLK)<br>        Q&lt;=Q+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210427203236919.png" srcset="/img/loading.gif" lazyload alt="image-20210427203236919"></p>
<h3 id="实用加法计数器"><a href="#实用加法计数器" class="headerlink" title="实用加法计数器"></a>实用加法计数器</h3><ul>
<li><p><strong>异步复位</strong> <strong>rst_n</strong> 优先级最高</p>
</li>
<li><p><strong>使能</strong> **en ** 当使能信号有效时，加法计数器才执行加法，无效时，即使有时钟脉冲，值保持不变</p>
</li>
<li><p><strong>同步预置</strong> <strong>load/data</strong>：可以预置一个计数的初始值  通过load控制信号，和预置的数data，预置初始值。load为负值逻辑，当时钟上升沿时，检测到load信号，就把data赋到计数输出</p>
</li>
<li><p><strong>计数输出</strong> **dout ** 设定记满的上限</p>
</li>
<li><p><strong>计数溢出</strong> <strong>cout</strong>：计数满时的输出信号</p>
<h3 id="实用模10计数器"><a href="#实用模10计数器" class="headerlink" title="实用模10计数器"></a>实用模10计数器</h3></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 实用模 10 计数器</span><br><span class="hljs-keyword">module</span> cnt10(clk, rst_n, en, load_n, data, cout, dout);<br>    <span class="hljs-keyword">input</span> clk, rst_n, en, load_n;  <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] data;<br>    <span class="hljs-keyword">output</span> cout;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] dout;<br>    <br>    <span class="hljs-comment">//行为描述</span><br>    <span class="hljs-comment">//不能混合边沿和电平，所以两个边沿触发。rst_n为负值逻辑</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk, <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (!rst_n) dout &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">//优先级最高</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (en) <span class="hljs-keyword">begin</span>  <span class="hljs-comment">//使能en高于load，使能无效则load无效。</span><br>            <span class="hljs-keyword">if</span> (!load_n) dout &lt;= data;  <span class="hljs-comment">//load有效，赋值。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dout &lt; <span class="hljs-number">4&#x27;d9</span>) dout &lt;= dout + <span class="hljs-number">1</span>; <span class="hljs-comment">//没记满，则+1</span><br>            <span class="hljs-keyword">else</span> dout &lt;= <span class="hljs-number">4&#x27;d0</span>;  <span class="hljs-comment">//计数值记满（9）或大于9（预置了&gt;10的数，如此写避免了bug），复位到0</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">//计数到9，输出记满1信号，否则输出0</span><br>    <span class="hljs-keyword">assign</span> cout = (dout == <span class="hljs-number">4&#x27;d9</span>) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/newimg/image-20210429013238264.png" srcset="/img/loading.gif" lazyload alt="image-20210429013238264"></p>
<h3 id="tb的写法"><a href="#tb的写法" class="headerlink" title="tb的写法"></a>tb的写法</h3><p>对于上述较为复杂的电路，用tb验证，模拟了上述的信号</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">timescale</span> 1ns / 1ps;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">必须声明timescale，tb除了做行为仿真，还要做综合后时序仿真，因为综合后会引入器件延时和布线延时，即使在行为仿真后正确，也可能在综合仿真后产生尖峰和毛刺，导致逻辑失败。</span><br><span class="hljs-comment">因此必须考虑延时。延时要声明timescale，过大，则低频电路，器件延时被忽略，若过小，则高频电路，则器件延时布线延时不可忽略，产生不可预期的后果。</span><br><span class="hljs-comment">所以tb首先要声明实在哪一个频率点上进行仿真，不可或缺。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">module</span> cnt10_tb( );<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  输入信号赋值，来模拟信号源，观测输出信号，看是否满足输出要求，既然要赋值，则通常为initial或always，因此输入信号要为reg类型</span><br><span class="hljs-comment">  输出信号只观测，则wire型。</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">reg</span> clk,rst_n,en,load_n;<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] data;<br>  <span class="hljs-keyword">wire</span> cout;<br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] dout;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    tb的第一条语句一定是调用待检测的模块，输入信号输出信号连上模块，待检测模块的一头接信号源，另一头接示波器，第一条语句始终引入待检测模块</span><br><span class="hljs-comment">    */</span><br>  cnt10 dut(clk,rst_n,en,<br>    load_n,data,cout,dout);<br><br>  <span class="hljs-comment">// 产生 10ns 周期的时钟信号，每5ns反相一次</span><br>  <span class="hljs-keyword">initial</span> clk = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">切记，做任何仿真之前，需要对该信号进行初始化，凡是没有初始化的信号，vivado认为是个x，未知状态信号，任何操作逻辑都是未知状态。</span><br><span class="hljs-comment">对输入信号操作前，要赋初值。</span><br><span class="hljs-comment">*/</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// #100 </span><br>    rst_n = <span class="hljs-number">1</span>;<br>    en = <span class="hljs-number">1</span>;<br>    load_n = <span class="hljs-number">1</span>;<br>    data = <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// 使能为0期间，不计数</span><br>    #<span class="hljs-number">10</span> en = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">15</span> en = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 异步复位，不受时钟影响</span><br>    #<span class="hljs-number">6</span> rst_n = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">2</span> rst_n = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 预置数改变不影响计数</span><br>    #<span class="hljs-number">10</span> data = <span class="hljs-number">7</span>;<br>    <span class="hljs-comment">// 直到预置数被装载</span><br>    #<span class="hljs-number">20</span> load_n = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">10</span> load_n = <span class="hljs-number">1</span>; <br>    <span class="hljs-comment">// 大于10的预置数</span><br>    #<span class="hljs-number">30</span> data = <span class="hljs-number">11</span>;<br>    #<span class="hljs-number">30</span> load_n = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">10</span> load_n = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p><strong>总是使用</strong> <strong>timescale</strong> <strong>规定时间</strong>,对后续综合后时间仿真产生影响</p>
<p>在全局置位、复位脉冲释放之前就确保 <em><strong>时钟源</strong></em> 已经开始工作。时钟源写在最前。</p>
<p><strong>在仿真时间的</strong> <strong>0</strong> <strong>时刻，将所有的设计输入初始化位为一个确定的值；</strong></p>
<p>**在综合后和实现后的时序仿真中，会自动触发全局置位/复位脉冲（GSR），这会让所有的寄存器在仿真的前100ns **内锁定其值。因此在100ns 之后再赋值激励数据；如果对一个带复位的时序电路仿真，而且希望做综合后实现后的时序仿真，则第一条语句要写延时100ns，保证后续所有输入在100ns后输入才能得到正确的仿真结果。</p>
</blockquote>
<h2 id="触发器和锁存器"><a href="#触发器和锁存器" class="headerlink" title="触发器和锁存器"></a>触发器和锁存器</h2><ul>
<li><p>触发器（Flip-flop）和锁存器（Latch）都是具有记忆功能的二进制存储器件。</p>
</li>
<li><p>触发器和锁存器的实现形式很多，在ASIC中通常使用 D 触发器和 D 锁存器。</p>
</li>
<li><p>触发器和锁存器的功能区别：</p>
<ul>
<li>触发器由时钟信号的跳边沿触发“存储”</li>
<li>锁存器由电平信号触发“存储”</li>
</ul>
<h3 id="基本D触发器"><a href="#基本D触发器" class="headerlink" title="基本D触发器"></a>基本D触发器</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428010431170.png" srcset="/img/loading.gif" lazyload alt="image-20210428010431170" style="zoom:50%;"></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> DFF1(CLK,D,Q)<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK) <span class="hljs-comment">//时钟上升沿才会引起赋值，非阻塞式赋值（上一个时刻存储的内容赋值给当前时刻）</span><br>        Q&lt;=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<p>D触发器在时钟的边沿执行存储（写入功能），设定上升沿，每遇到上升沿，就把D的内容写入Q，随后D变化（变化中没有碰到时钟上升沿），D的变化不会写入Q。</p>
<p>输出存储了上一个时钟时候的写入，起到了存储的功能，每遇到时钟上升沿，就将D写入Q</p>
<blockquote>
<p>非阻塞式赋值：上一个时刻存储的内容赋给当前时刻</p>
<p>阻塞式赋值：执行上一次赋值后面执行出的计算出的值赋值给当前内容</p>
<p>时序电路使用非阻塞式赋值，非阻塞式赋值可以，但写法比较麻烦</p>
</blockquote>
<h3 id="含异步复位和使能的D触发器"><a href="#含异步复位和使能的D触发器" class="headerlink" title="含异步复位和使能的D触发器"></a>含异步复位和使能的D触发器</h3><ul>
<li><strong>异步</strong>复位：复位信号不受时钟控制，时钟不管是上升沿下降沿不变</li>
<li>复位信号通常都是<strong>负值逻辑</strong>的，抗干扰能力强，不容易被误触发</li>
<li>使能：使能信号有效时，触发器才工作</li>
<li>使能优先级低于复位信号</li>
</ul>
<img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428011405545.png" srcset="/img/loading.gif" lazyload alt="image-20210428011405545" style="zoom:50%;">

<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> DFF2(CLK,D,Q,RST,EN);<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D,RST,EN;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> RST)<br>        <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">if</span>(!RST) Q&lt;=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(EN) Q&lt;=D;<br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<h3 id="含同步复位的D触发器"><a href="#含同步复位的D触发器" class="headerlink" title="含同步复位的D触发器"></a>含同步复位的D触发器</h3><ul>
<li>同步复位：在时钟信号跳变沿检测复位信号</li>
</ul>
<img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428011748095.png" srcset="/img/loading.gif" lazyload alt="image-20210428011748095" style="zoom:50%;">

<p>复位信号为1时若时钟为上升沿，则复位</p>
<p>时钟上升沿时检测到复位信号。</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> DFF3(CLK,D,Q,RST);<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D,RST;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK)<br>        <span class="hljs-keyword">if</span>(RST==<span class="hljs-number">1</span>) Q=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (RST==<span class="hljs-number">0</span>) Q=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428012140989.png" srcset="/img/loading.gif" lazyload alt="image-20210428012140989"></p>
<h3 id="基本锁存器"><a href="#基本锁存器" class="headerlink" title="基本锁存器"></a>基本锁存器</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428080744342.png" srcset="/img/loading.gif" lazyload alt="image-20210428080744342" style="zoom:50%;">

<p>最大的区别在于锁存器是电平触发</p>
<p>clk=1的时候，Q随D变化，clk=0时，Q不变</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> LATCH1(CLK,D,Q);<br>    <span class="hljs-keyword">output</span> Q; <span class="hljs-keyword">input</span> CLK,D;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span> @(D oir CLK)<br>        <span class="hljs-keyword">if</span>(CLK) Q&lt;=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p><strong>CLK</strong> <strong>==</strong> <strong>1</strong> <strong>时，等于直通电路，等于写入当前状态。</strong></p>
<p><strong>CLK</strong> <strong>==</strong> <strong>0</strong> <strong>时，保持输出，等于记忆当前状态。</strong></p>
</blockquote>
<h3 id="含异步复位的锁存器"><a href="#含异步复位的锁存器" class="headerlink" title="含异步复位的锁存器"></a>含异步复位的锁存器</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428081400344.png" srcset="/img/loading.gif" lazyload alt="image-20210428081400344" style="zoom:50%;">

<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> LATCH3 (CLK,D,Q,RST);<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D,RST;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(D <span class="hljs-keyword">or</span> CLK <span class="hljs-keyword">or</span> RST)<br>        <span class="hljs-keyword">if</span>(!RST) Q&lt;=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(CLK) Q&lt;=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>复位的优先级总是最高的。</p>
<p>锁存器中，CLK往往也被称为LE（latch enable）</p>
</blockquote>
<h3 id="触发器和锁存器的比较"><a href="#触发器和锁存器的比较" class="headerlink" title="触发器和锁存器的比较"></a>触发器和锁存器的比较</h3><p><strong>Latch 对输入电平敏感，受布线延时影响大，很难保证没有毛刺的输出；而 DFF 不容易产生毛刺。</strong></p>
<p><strong>FPGA 中没有 Latch 单元，只有 FF 单元 (我们使用的 Artix-7 中，有 126,800 个 FF)，需要用多个逻辑单元来实现 Latch，因此使用 FF 更节约资源。</strong></p>
<p><strong>但是，在某些设计中，Latch 不可替代。</strong></p>
<p><strong>结论：尽可能避免 Latch 的产生。例如：一个不“完备”的条件语句（有 if 而无 else，case 没有 default）（没有完全穷举状态的时候）将会产生 Latch。</strong></p>
<p>例如3-1 bit选择器，如下只对三种状态赋值，产生锁存器</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 3-1 1 bit 选择器</span><br><br><span class="hljs-keyword">module</span> mux_31(a,b,c,sel,out);<br><br>  <span class="hljs-keyword">input</span> a, b, c;<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out;<br><br>  <span class="hljs-keyword">always</span> @(a, b, c, sel)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(sel)<br>      <span class="hljs-number">2</span>’b00: out = a;<br>      <span class="hljs-number">2</span>’b01: out = b;<br>      <span class="hljs-number">2</span>’b10: out = c;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428082140830.png" srcset="/img/loading.gif" lazyload alt="image-20210428082140830" style="zoom: 50%;">

<p>锁存器当sel=11时，锁存器将保持过去的状态不会改变</p>
<h2 id="寄存器和存储器"><a href="#寄存器和存储器" class="headerlink" title="寄存器和存储器"></a>寄存器和存储器</h2><ul>
<li><p>寄存器（register）：用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。</p>
</li>
<li><p>存储器（memory）：也是用来存放数据的区域，分为 ROM 和 RAM 两类。</p>
</li>
<li><p>寄存器与存储器的制造工艺不同：</p>
<ul>
<li><p>寄存器通常使用触发器和锁存器来实现，速度快、占用面积大</p>
</li>
<li><p>存储器通常使用 6 MOS 管（静态存储器）或 1 MOS 管（动态存储器）实现，速度慢，占用面积小</p>
</li>
<li><p>FPGA 中通常配有专门的存储单元，而不用逻辑门来实现存储。Aritx-7 上有大约 5Mbits 的可配置内存块。</p>
</li>
</ul>
</li>
</ul>
<h3 id="基本寄存器"><a href="#基本寄存器" class="headerlink" title="基本寄存器"></a>基本寄存器</h3><p>根据触发器和锁存器分析。FPGA中寄存器最好用触发器实现（占用资源少，稳定）</p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> register(clk,en,d,q);<br>    <span class="hljs-keyword">parameter</span> WHIDTH = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">input</span> clk,rst_n,en;<br>    <span class="hljs-keyword">input</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] d;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [width-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] q;<br>    <br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(!rst_n) q&lt;=<span class="hljs-number">0</span>;   <span class="hljs-comment">//复位</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(en) q&lt;=d;  <span class="hljs-comment">//能赋值</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<h3 id="双端口存储器-结构最简单"><a href="#双端口存储器-结构最简单" class="headerlink" title="双端口存储器(结构最简单)"></a>双端口存储器(结构最简单)</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ram(data,read_addr,write_addr,clk,we,q);<br>    <span class="hljs-keyword">parameter</span> DATA_WIDTH=<span class="hljs-number">8</span>; <span class="hljs-comment">//数据宽度</span><br>    <span class="hljs-keyword">parameter</span> ADDR_WIDTH=<span class="hljs-number">3</span>;  <span class="hljs-comment">//地址总线宽度</span><br>    <br>    <span class="hljs-keyword">input</span> clk,we;<br>    <span class="hljs-keyword">input</span> [DATA_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data;<br>    <span class="hljs-keyword">input</span> [ADDR_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] read_addr,write_addr;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DATA_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] q;<br>    <br>    <span class="hljs-comment">//申明存储器数组</span><br>    <span class="hljs-keyword">reg</span> [DATA_WIDTH=<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] ram[ADDR_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];  <span class="hljs-comment">//每个总线对应一个ram，每个ram是8位</span><br>    <br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (we)<br>        ram[write_addr] &lt;= data;   <span class="hljs-comment">//write_addr总线连接的存储单元赋值</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        initial begin   //对存储器初始化</span><br><span class="hljs-comment">            Sreadmemh(&quot;ram_init.txt&quot;,ram)</span><br><span class="hljs-comment">        */</span><br><br>        q &lt;= ram[read_addr];  <span class="hljs-comment">//输出一直是read——addr总选连接的存储单元</span><br>  <span class="hljs-keyword">end</span>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></div></td></tr></table></figure>

<ul>
<li><p><strong>双端口</strong> <strong>RAM</strong> <strong>读写端口完全独立</strong></p>
<ul>
<li><strong>优点：简单；快速，读写无需等待</strong></li>
<li><strong>缺点：占用资源多</strong></li>
</ul>
</li>
<li><p><strong>存储大小与地址宽度之间的关系</strong></p>
<ul>
<li><strong>size</strong> <strong>=</strong> <strong>2^addr_width</strong></li>
</ul>
</li>
<li><p><strong>实现上，使用了</strong> <strong>FPGA</strong> <strong>中的内存块单元</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428084327484.png" srcset="/img/loading.gif" lazyload alt="image-20210428084327484"></p>
<h2 id="数据通路设计"><a href="#数据通路设计" class="headerlink" title="数据通路设计"></a>数据通路设计</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210511121612132.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;">

<p>经典的计算机模型的数据处理器</p>
<ul>
<li>数据通路负责数据的操作，包括算是运算和传输数据</li>
<li>控制器负责数据的控制，通常以有限状态机方式实现，包括控制流的输入、输出，以及控制数据通路钟数据的传输顺序</li>
<li> 处理器旁通常会有哪一个存储器，可根据地址存取程序指令和数据。</li>
</ul>
<hr>
<h4 id="数据通路设计-1"><a href="#数据通路设计-1" class="headerlink" title="数据通路设计"></a>数据通路设计</h4><ul>
<li>首先实现各个单元模块，包括计算单元ALU，寄存器单元LA和LB，双端口存储器GR</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/newimg/image-20210429012206972.png" srcset="/img/loading.gif" lazyload alt="image-20210429011556719"></p>
<p>首先实现各个模块</p>
<h5 id="计算单元ALU"><a href="#计算单元ALU" class="headerlink" title="计算单元ALU"></a>计算单元ALU</h5><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> alu(a,b,op,q);<br>    <span class="hljs-keyword">parameter</span> WIDTH = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">input</span>[WIDTH-<span class="hljs-number">1</span>：<span class="hljs-number">0</span>] a,b;<br>    <span class="hljs-keyword">input</span>[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] op;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] q;<br>    <span class="hljs-keyword">always</span>@(*) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span>(op)<br>            <span class="hljs-number">2&#x27;b00</span>:q=a+b;<br>            <span class="hljs-number">2&#x27;b01</span>:q=a&amp;b;<br>            <span class="hljs-number">2&#x27;b10</span>:q=a^b;<br>            <span class="hljs-number">2&#x27;b11</span>:q=a|b;<br>            <span class="hljs-keyword">default</span>: q=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>

<h5 id="寄存器单元LA和LB以及双端口存储器GR上文已经定义"><a href="#寄存器单元LA和LB以及双端口存储器GR上文已经定义" class="headerlink" title="寄存器单元LA和LB以及双端口存储器GR上文已经定义"></a>寄存器单元LA和LB以及双端口存储器GR上文已经定义</h5><p>register(clk,rst_n,end,d,q)</p>
<p>ram(data,read_addr,write_addr,clk,we,q)</p>
<p>利用结构描述设计方法，利用以上模块实现数据通路</p>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/newimg/image-20210429011533770.png" srcset="/img/loading.gif" lazyload alt="image-20210429012206972"></p>
<figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"> <span class="hljs-keyword">module</span> datapath_top(clk,rst,lda,ldb,read_addr,write_addr,we,op);<br>    <span class="hljs-keyword">input</span> clk,rst,lda,ldb,we;<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_addr,write_addr;<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] op;<br>    <br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] gr_data,alu_data;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] la_data,lb_data;<br>    <br>    register<span class="hljs-variable">#(32) LA(clk,rst,lda,gr_data,la_data)</span><br>    register<span class="hljs-variable">#(32) LB(clk,rst,ldb,gr_data,lb_data)</span><br>    ram<span class="hljs-variable">#(32,5) GR(alu_data,read_addr,write_addr,clk,we,gr_data)</span>;<br>    alu<span class="hljs-variable">#(32) ALU(la_data,lb_data,op,alu_data)</span>;<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Verilog/">Verilog</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Verilog%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%94%B5%E8%B7%AF/">Verilog，常见电路</a>
                    
                  </div>
                
              </div>

              <!--
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
-->
<p class="note note-warning">
  <strong>本文作者: </strong><a href="/">Trent-Liu</a> <br>
  <strong>本文链接: </strong><a href="https://trent-liu.github.io/2021/04/25/verilog%E5%B8%B8%E7%94%A8%E7%94%B5%E8%B7%AF/">https://trent-liu.github.io/2021/04/25/verilog%E5%B8%B8%E7%94%A8%E7%94%B5%E8%B7%AF/</a> <br>
  <strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
     </p>
     


              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/28/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94JAVAFX/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java笔记——JavaFx</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/24/verilog%E5%85%A5%E9%97%A8/">
                        <span class="hidden-mobile">Verilog填鸭入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function () {
        var gitalk = new Gitalk({
          clientID: '81506d8985202387cbbd',
          clientSecret: '40c6250a001a80f7986e1ec1a375dc2d7e82f7d9',
          repo: 'Pigsty',
          owner: 'Trent-Liu',
          admin: ["Trent-Liu"],
          id: '0e9cfb12da662ccdde908068e72559d5',
          language: 'zh-CN',
          labels: ["Gitalk"],
          perPage: 10,
          pagerDirection: 'last',
          createIssueManually: true,
          distractionFreeMode: false,
          proxy: '&lt;your own proxy&gt;/https://github.com/login/oauth/access_token'
        });
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


<div class="text-center py-1">  
  <div>
    <span id="timeDate1">载入天数...</span>
    <span id="times1">载入时分秒...</span>
    <script>
    var now1 = new Date();
    function createtime1(){
        var grt1= new Date("07/21/2018 23:00");//此处修改你的建站时间或者网站上线时间
        now1.setTime(now1.getTime()+250);
        days1 = (now1 - grt1 ) / 1000 / 60 / 60 / 24;
        dnum1 = Math.floor(days1);
        hours1 = (now1 - grt1 ) / 1000 / 60 / 60 - (24 * dnum1);
        hnum1 = Math.floor(hours1);
        if(String(hnum1).length ==1 ){
            hnum1 = "0" + hnum1;
        }
        minutes1 = (now1 - grt1 ) / 1000 /60 - (24 * 60 * dnum1) - (60 * hnum1);
        mnum1 = Math.floor(minutes1);
        if(String(mnum1).length ==1 ){
                  mnum1 = "0" + mnum1;
        }
        
        document.getElementById("timeDate1").innerHTML = "💓 ysm&lyk&nbsp"+dnum1+"&nbspdays";  //此次自定义显示内容
        document.getElementById("times1").innerHTML = hnum1 + "&nbsphr&nbsp" + mnum1 + "&nbspmin&nbsp";
    }  //此次自定义显示内容
    setInterval("createtime1()",250);
    </script>
  </div>

<div class="text-center py-1">  
<div>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("03/20/2021 17:25:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      /*
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      */
      document.getElementById("timeDate").innerHTML = "🏡pigsty for&nbsp"+dnum+"&nbspdays";  //此次自定义显示内容
      document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" /*+ snum + "&nbspsec"*/;
  }  //此次自定义显示内容
  setInterval("createtime()",250);
  </script>
</div>

<div class="text-center py-1">   
  <div>
    <span>Copyright © 2021</span></a>
    <a href="https://erenspace.cool/" target="_blank" rel="nofollow noopener">
     <span>Trent-Liu‘s Pigsty</span></a>    <br>
  </div>


<!--
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
-->

  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>

<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>