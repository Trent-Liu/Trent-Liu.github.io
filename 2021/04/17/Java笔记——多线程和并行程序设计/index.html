

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="程序、进程和线程“程序”代表一个静态的对象，是内含指令和数据的文件，存储在磁盘或其他存储设备中
“进程”代表一个动态的对象，是程序的一个执行过程，存在于系统的内存中，一个进程对应于一个程序
“进程”是运行于某个进程中，用于完成某个具体任务的顺序控制流程，有时被成为轻型进程
">
  <meta name="author" content="Trent-Liu">
  <meta name="keywords" content="分享在HUST中的一些学习经历">
  
  <title>Java笔记——多线程和并行程序设计 - Pigsty</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/a11y-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"trent-liu.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>





<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Pigsty</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/Java.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java笔记——多线程和并行程序设计">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-17 18:00" pubdate>
        2021年4月17日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      120
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java笔记——多线程和并行程序设计</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年5月13日 中午
                
              </p>
            
            <div class="markdown-body">
              <h2 id="程序、进程和线程"><a href="#程序、进程和线程" class="headerlink" title="程序、进程和线程"></a>程序、进程和线程</h2><p>“程序”代表一个静态的对象，是内含指令和数据的文件，存储在磁盘或其他存储设备中</p>
<p>“进程”代表一个动态的对象，是程序的一个执行过程，存在于系统的内存中，一个进程对应于一个程序</p>
<p>“进程”是运行于某个进程中，用于完成某个具体任务的顺序控制流程，有时被成为轻型进程</p>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210417081121324.png" srcset="/img/loading.gif" lazyload alt="image-20210417081121324"></p>
<span id="more"></span>

<p>多线程的执行次序完全随机，运行结果随机</p>
<p>理论上来讲，16G的机器，每个进程有单独的内存空间，都是16G，若多进程不够用，内存和硬盘不断交换</p>
<ul>
<li>当一个进程被创建，自动地创建了一个主线程。因此，一个进程至少有一个主线程。</li>
<li>线程：程序中完成一个任务地有始有终地<strong>执行流</strong>，都有一个执行的起点，经过一系列指令后到达终点。</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210417081330380.png" srcset="/img/loading.gif" lazyload alt="image-20210417081330380"></p>
<ul>
<li>现代OS都将线程作为最小调度单位，进程作为资源分配的最小单位。分配给进程的资源（如文件，外设）可以被进程里的线程使用。</li>
</ul>
<h2 id="线程的作用"><a href="#线程的作用" class="headerlink" title="线程的作用"></a>线程的作用</h2><ul>
<li><p>一个进程的多个子线程可以并发运行</p>
</li>
<li><p>多线程可以使程序反应更快、交互性更强、执行效率更高。</p>
</li>
<li><p>特别是Server端的程序，都是需要启动多个线程来处理大量来自客户端的请求</p>
</li>
<li><p>一个典型的GUI程序分为</p>
<ul>
<li>GUI线程：处理UI消息循环，如鼠标消息、键盘消息</li>
<li>Worker线程：后台的数据处理工作，比如打印文件，大数据量的运算</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Runuable接口和线程类Thread"><a href="#Runuable接口和线程类Thread" class="headerlink" title="Runuable接口和线程类Thread"></a>Runuable接口和线程类Thread</h2><h4 id="通过实现Runnable接口创建线程"><a href="#通过实现Runnable接口创建线程" class="headerlink" title="通过实现Runnable接口创建线程"></a>通过实现Runnable接口创建线程</h4><ul>
<li>实现Runnable接口，需要实现唯一的接口方法run<ul>
<li>void run()</li>
<li><strong>该方法定义了线程执行的功能</strong></li>
</ul>
</li>
<li>创建实现Runnable接口的类的对象</li>
<li>利用Thread类的构造函数创建线程对象<ul>
<li>public Thread(Runnable target)</li>
<li>new Thread对象时需要传入Runnable接口实例</li>
</ul>
</li>
<li>通过线程对象的start()方法启动线程</li>
</ul>
   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Client Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>   ...<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">(...)</span> </span>&#123;<br>   ...  <br>   <span class="hljs-comment">// Create an instance of TaskClass</span><br>   <span class="hljs-comment">//创建实现Runnable接口的对象</span><br>   Runnable task = <span class="hljs-keyword">new</span> TaskClass(...);<br> <br>   <span class="hljs-comment">// Create a thread</span><br>   <span class="hljs-comment">//以实现Runnable接口的对象为参数创建Thread对象</span><br>   Thread thread = <span class="hljs-keyword">new</span> Thread(task);<br> <br>   <span class="hljs-comment">// Start a thread</span><br>   <span class="hljs-comment">//Thread.start()开始线程</span><br>   thread.start(); <span class="hljs-comment">// 启动后自动执行task.run</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>通过线程任务类(TaskClass)创建任务对象(task),task为实现Runnable接口的对象</li>
<li>以任务对象task为参数new Thread对象。Thread对象代表一个线程，线程的执行内容由任务对象task定义。</li>
<li>通过线程对象Thread启动线程thread.start(),任何线程只能启动一次，多次调用产生IllegalThreadStateException异常</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Custom task class</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<span class="hljs-comment">//Java.lang.Runnable</span><br>   ... <span class="hljs-comment">//可以有自己的数据成员</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TaskClass</span><span class="hljs-params">(...)</span> </span>&#123;<br>      ...<br>   &#125;<br> <br>   <span class="hljs-comment">//Implement the run method in Runnable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//Tell system how to run custom thread</span><br>      ...<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="通过实现Runnable接口创建线程的例子"><a href="#通过实现Runnable接口创建线程的例子" class="headerlink" title="通过实现Runnable接口创建线程的例子"></a>通过实现Runnable接口创建线程的例子</h3><ul>
<li><p>程序创建并运行两个线程，第一个线程打印100次字母a，第二个线程打印100次字母b</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintChar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> //实现<span class="hljs-title">Runnable</span>接口</span><br><span class="hljs-class"></span>&#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> charToPrint;  <span class="hljs-comment">// The character to print</span><br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> times;  <span class="hljs-comment">// The times to repeat</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> t)</span></span>&#123;  charToPrint = c;  times = t; &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//实现Runnable中声明的run方法</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt; times; i++) System.out.print(charToPrint);<br>      &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>new Thread对象时需要传入Runnable接口实例</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableDemo</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//以PrintChar对象实例为参数构造Thread对象 </span><br>        Thread printA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>));<br>        Thread printB = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>));<br>        printA.start();<br>        printB.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="通过继承Thread类创建线程"><a href="#通过继承Thread类创建线程" class="headerlink" title="通过继承Thread类创建线程"></a>通过继承Thread类创建线程</h4><ul>
<li>线程和线程任务混在一起，不建议使用。</li>
<li>Java不支持多继承，CustomThread继承了Thread类，不能再继承其他类。</li>
</ul>
   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">// Custom thread class</span><br><span class="hljs-comment">//Thread类的拓展类</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>  <span class="hljs-comment">//数据成员</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomThread</span><span class="hljs-params">(...)</span> </span>&#123;<br>    ...<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Tell system how to perform this task</span><br>    ...<br>  &#125;<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ol>
<li>定义Thread类的扩展类（CustomThread）</li>
<li>通过扩展类（CustonThread）创建线程对象（thead）</li>
<li>通过线程对象thrad启动线程thread.start()</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Client class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// Create a thread</span><br>    Thread thread1 = <span class="hljs-keyword">new</span> CustomThread();<br>    <span class="hljs-comment">// Start thread</span><br>    thread1.start( ); <span class="hljs-comment">//激活thread1对象的run</span><br>    <br>    <span class="hljs-comment">// Create a thread</span><br>    Thread thread2 = <span class="hljs-keyword">new</span> CustomThread( );<br>    <span class="hljs-comment">// Start thread</span><br>    thread2.start(); <span class="hljs-comment">//激活thread2对象的run</span><br>  &#125;<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="通过继承Thread类创建线程的实例"><a href="#通过继承Thread类创建线程的实例" class="headerlink" title="通过继承Thread类创建线程的实例"></a>通过继承Thread类创建线程的实例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintChar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> //继承<span class="hljs-title">Thread</span>类</span><br><span class="hljs-class"></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> charToPrint;  <span class="hljs-comment">//要打印的字符</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> times;  <span class="hljs-comment">//打印的次数</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> t)</span></span>&#123; charToPrint = c; times = t; &#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//覆盖run方法，定义线程要完成的功能</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt; times; i++)<br>			System.out.print(charToPrint);<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	    Thread printA = <span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>); <span class="hljs-comment">//创建二个线程对象</span><br>	    Thread printB = <span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>);<br>	    printA.start(); <span class="hljs-comment">//启动线程</span><br>	    printB.start();	<span class="hljs-comment">//启动另外一个线程</span><br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="线程的状态切换"><a href="#线程的状态切换" class="headerlink" title="线程的状态切换"></a>线程的状态切换</h3><ul>
<li>就绪：万事俱备，等待CPU调度</li>
<li>运行：线程获得了CPU的所有权并在上面运行</li>
<li>消亡：当run()执行完毕后，线程就消亡</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421184045450.png" srcset="/img/loading.gif" lazyload alt="image-20210421184045450"></p>
<ul>
<li>下面一些情况导致线程从<strong>运行状态转到阻塞状态</strong>：<ol>
<li>调用了sleep</li>
<li>调用了Object wait()方法，条件对象的await方法，Thread的join方法以及等待其他线程，或者等待资源锁</li>
<li>发出了阻塞式IO操作请求，并等待IO操作结束(如等待阻塞式Socket的数据到来)</li>
</ol>
</li>
<li>线程由<strong>阻塞状态被唤醒后，回到就绪态</strong>。唤醒的原因<ol>
<li>sleep时间到</li>
<li>调用wait(await)的线程被其他线程notify，调用join方法的线程等到了其他线程完成，线程拿到了资源锁</li>
<li>阻塞IO完成</li>
</ol>
</li>
</ul>
<blockquote>
<p>Object类定义了wait/notify/notifyAll方法</p>
<p>Thread类定义了sleep/yield/join方法</p>
</blockquote>
<h3 id="Runnable接口和线程类Thread"><a href="#Runnable接口和线程类Thread" class="headerlink" title="Runnable接口和线程类Thread"></a>Runnable接口和线程类Thread</h3><ul>
<li><p>java.lang.Runnable</p>
<p>Runnable接口实例定义了线程任务，即线程要执行的逻辑。一个线程任务必须通过线程对象来执行</p>
<img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421184504711.png" srcset="/img/loading.gif" lazyload alt="image-20210421184504711" style="zoom: 50%;">

<p>Thread()                                    创建一个空的线程</p>
<p>Thread(task:Runnable)          为指定的任务创建一个线程</p>
<p>start():void                                开始一个线程，进入Ready状态，如无其它线程等待，可立即Run进入running状态</p>
<p>isAlive():boolean                      测试线程当前是否在运行</p>
<p>setPriority(p:int):void             为该线程指定优先值p（1~10）</p>
<p>join():void                                   等待线程结束</p>
<p>sleep(millis:long):void             让当前线程休眠若干ms，监视器自动恢复其运行</p>
<p>yield():void                                  将线程从running变为ready，允许其他线程执行（自己也可能立即执行）</p>
<p>interrupt():void                            中断该线程</p>
</li>
</ul>
<h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><ul>
<li><p>n线程优先级范围从1－10，数字越高越能被优先执行。但优先级高并不代表能独自占用执行时间片，可能是<strong>优先级高得到越多的执行时间片</strong>，反之，<strong>优先级低的分到的执行时间少但不会分配不到执行时间</strong></p>
</li>
<li><p>每个线程创建时赋予默认的优先级Thread.NORM_PRIORITY. </p>
</li>
<li><p>通过setPriority(int priority)为线程指定优先级. </p>
</li>
<li><p>用getPriority()方法获取线程的优先级.</p>
</li>
<li><p>JAVA定义的优先级：1～10</p>
</li>
<li><p>Thread类有int 类型的常量：</p>
<ul>
<li><p>Thread.MIN_PRIORITY（1）</p>
</li>
<li><p>Thread.MAX_PRIORITY（10）</p>
</li>
<li><p>Thread.NORM_PRIORITY（5）</p>
</li>
</ul>
</li>
<li><p>多个线程只能是“宏观上并行，微观上串行”</p>
</li>
<li><p>在有限个CPU的系统中确定多个线程的执行顺序称为线程的调度</p>
</li>
<li><p>Java的线程调度是抢占式的，这表示调度机制会<strong>周期性地中断线程</strong>，将上下文切换到另一个线程；从而为每个线程都提供时间片</p>
</li>
<li><p>自私的线程</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">run() &#123;<br>			<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>			&#125;<br>		&#125;<br><br></code></pre></div></td></tr></table></figure>

<p>应适当地在run()里sleep或yield一下，让其他线程由更多机会被运行。</p>
<p><em><strong>不要编写依赖于线程优先级的程序</strong></em></p>
</li>
</ul>
<h3 id="线程类Thread的yield，sleep方法"><a href="#线程类Thread的yield，sleep方法" class="headerlink" title="线程类Thread的yield，sleep方法"></a>线程类Thread的yield，sleep方法</h3><h4 id="使用yield-方法为其他线程让出CPU时间"><a href="#使用yield-方法为其他线程让出CPU时间" class="headerlink" title="使用yield()方法为其他线程让出CPU时间"></a>使用yield()方法为其他线程让出CPU时间</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; times; i++) &#123;<br>        System.out.print(charToPrint);<br>        Thread.yield();  <span class="hljs-comment">//挂起进入ready，给其它进程调度机会</span><br>     &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>将线程从running变为ready，允许其他线程执行（自己也可能立即执行）</p>
</blockquote>
<h4 id="sleep-long-mills-方法将线程设置为休眠状态，确保其他线程执行："><a href="#sleep-long-mills-方法将线程设置为休眠状态，确保其他线程执行：" class="headerlink" title="sleep(long mills)方法将线程设置为休眠状态，确保其他线程执行："></a>sleep(long mills)方法将线程设置为休眠状态，确保其他线程执行：</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//循环中使用sleep方法，循环放在try-catch块中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; times; i++) &#123;<br>            System.out.print(charToPrint);<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">50</span>) Thread.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 必检异常：其它线程调当前线程（正在休眠）interupt方法会抛出该异常</span><br>    <span class="hljs-keyword">catch</span> (InterruptedException ex &#123; &#125;<br>&#125;<span class="hljs-comment">//处于阻塞状态（如在睡眠，在wait，在执行阻塞式IO）的线程，如果被其他线程打断（即处于阻塞的线程的interupt方法被其它线程调用），会抛出InterruptedException</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、1.5中的condition.await、以及可中断的通道上的 I/O 操作方法后可进入阻塞状态）</p>
<p>则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法（sleep、join、wait、1.5中的condition.await及可中断的通道上的 I/O 操作方法）调用处抛出InterruptedException异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为false。</p>
<p>抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求。</p>
</blockquote>
<h4 id="线程类Thread的join方法"><a href="#线程类Thread的join方法" class="headerlink" title="线程类Thread的join方法"></a>线程类Thread的join方法</h4><p>Runnable接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintChar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> //实现<span class="hljs-title">Runnable</span>接口</span><br><span class="hljs-class"></span>&#123;<br>  	<span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> charToPrint;  <span class="hljs-comment">// The character to print</span><br> 	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> times;  <span class="hljs-comment">// The times to repeat</span><br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> t)</span></span>&#123;  charToPrint = c;  times = t; &#125;<br>  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//实现Runnable中声明的run方法</span><br>   		 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt; times; i++) <br>    			System.out.print(charToPrint);<br>  	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>执行多线程</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>   		 Thread printA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>));<br>   		 Thread printB = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>));<br>   		 printA.start();<br>    		 printB.start();<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421190447197.png" srcset="/img/loading.gif" lazyload alt="image-20210421190447197"></p>
<blockquote>
<p>可以看到屏幕上<strong>无规律的交替输出ab</strong>。这是多线程程序的特点，<strong>每次运行输出结果可能是不一样的</strong>。如果希望把所有a先打印完再打印b，怎么做？</p>
</blockquote>
<p>修改代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        Thread printA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>));<br>        Thread printB = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>));<br>        printA.start();  <span class="hljs-comment">//在主线程里首先启动printA线程</span><br>        printA.join(); <span class="hljs-comment">//主线程被阻塞，等待printA执行完</span><br>        printB.start(); <span class="hljs-comment">//主线程被唤醒，启动printB线程</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421190613062.png" srcset="/img/loading.gif" lazyload alt="image-20210421190613062"></p>
<blockquote>
<p>join方法的作用：在A线程中调用了B线程（对象）的join()方法时，表示A线程放弃控制权（被阻塞了），只有<strong>当B线程执行完毕时，A线程才被唤醒继续执行。</strong></p>
<p>程序在main线程中调用printA线程（对象）的join方法时，<strong>main线程放弃cpu控制权（被阻塞），直到线程printA执行完毕</strong>，main线程被唤醒执行printB.start();</p>
<p>运行结果是全部a打印完才开始打印b</p>
</blockquote>
<p>定义一个新的线程任务类</p>
<blockquote>
<p>在线程任务对象print100的run中启动新线程Thread4，并调用Thread4 的join( ) 方法，，等待Thread4结束:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNum</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123; <span class="hljs-comment">//实现新的线程任务类，打印数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> lastNum;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123; lastNum = n; &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>       Thread thread4=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">4000</span>));<br>        thread4.start();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;lastNum;i++)&#123;<br>                System.out.print(<span class="hljs-string">&quot; &quot;</span> + i);<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">50</span>) thread4.join(); <span class="hljs-comment">//join方法可以给参数指定至多等若干毫秒</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(InterruptedException e)&#123; &#125; <span class="hljs-comment">//join方法可能会抛出这个异常</span><br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>启动tPrint100线程：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Runnable print100 = <span class="hljs-keyword">new</span> PrintNum(<span class="hljs-number">100</span>); <span class="hljs-comment">//线程任务对象</span><br>Thread tPrint100 = <span class="hljs-keyword">new</span> Thread(print100); <span class="hljs-comment">//线程对象</span><br>tPrint100.start();<br></code></pre></div></td></tr></table></figure>

<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192003612.png" srcset="/img/loading.gif" lazyload alt="image-20210421192003612"></p>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192306057.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到，thread4打印c一直在执行，同时tPrint100也一直在打印数字，当打印到50的时候，调用了thread4.join()，之后停止tPrint100进程，让thread4打印c，当所有c打印完后，再继续打印数字</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li><p>由于要为每一个线程任务创建一个线程（Thread对象），对于有<strong>大量线程任务的场景就不够高效</strong></p>
<p>（当线程任务执行完毕，即run方法结束后，Thread对象就消亡，然后又为新的线程任务去new新的线程对象…, <strong>当有大量的线程任务时，就不断的new Thread对象，Thread对象消亡，再new Thread对象…</strong>）</p>
</li>
<li><p>线程池适合<strong>大量线程任务的并发执行</strong>。线程池通过有效管理线程、“复用” 线程来提高性能. </p>
</li>
<li><p>从JDK 1.5 开始使用Executor接口（执行器）来执行线程池中的任务，Executor的<strong>子接口ExecutorService管理和控制任务</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192655047.png" srcset="/img/loading.gif" lazyload alt="image-20210421192655047"></p>
<ul>
<li>使用Executors的类方法创建一个线程池，Eecutors由Object派生</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192841546.png" srcset="/img/loading.gif" lazyload alt="image-20210421192841546"></p>
<blockquote>
<p>Executors还支持其它类型的线程池的创建方法如：newScheduledThreadPool、newSingleThreadPool</p>
</blockquote>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExecutorDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// Create a fixed thread pool with maximum three threads</span><br>    ExecutorService es= Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br> <br>    <span class="hljs-comment">// Submit runnable tasks to the executor</span><br> 	es.execute(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">100</span>));<br> 	es.execute(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">100</span>));<br> 	es.execute(<span class="hljs-keyword">new</span> PrintNum(<span class="hljs-number">100</span>));<br> <br>    <span class="hljs-comment">// Shut down 关闭，不接受新的线程任务，现有的任务将继续执行直到完成</span><br><br>    es.shutdown();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="进一步讨论：区分任务和线程"><a href="#进一步讨论：区分任务和线程" class="headerlink" title="进一步讨论：区分任务和线程"></a>进一步讨论：区分任务和线程</h3><ul>
<li><p>任务</p>
<ul>
<li>任务是实现了Runnable接口的类的实例</li>
<li>这个任务的逻辑由run方法实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-comment">//数据成员和其它方法... </span><br>    <br>   <span class="hljs-comment">//Implement the run method in Runnable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//task logic...</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>线程</p>
<ul>
<li>线程是Thread类的实例，是任务的运行载体</li>
<li>任务必须通过线程来运行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>        Runnable task = <span class="hljs-keyword">new</span> Task(...); <span class="hljs-comment">// Create an instance of Task</span><br>        <br>        Thread thread = <span class="hljs-keyword">new</span> Thread(task); <span class="hljs-comment">// Create a thread   </span><br>        thread.start(); <span class="hljs-comment">// Start a thread</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421194556081.png" srcset="/img/loading.gif" lazyload alt="image-20210421194556081" style="zoom:67%;">

<blockquote>
<p>如果这样直接new一个线程，线程启动后，执行任务的run方法，当任务的run方法执行完毕，线程对象使命就结束，被JVM回收。</p>
<p>如果有大量的任务要运行，会导致频繁创建新线程，销毁线程。</p>
<p>线程池维护多个创建好的线程，同时可以让多个任务“复用”线程，避免了线程的重复创建和销毁。</p>
</blockquote>
<p><strong>但是一个线程任务被线程执行完后，线程就自动消亡。那么如何复用一个线程（即让线程去执行新的任务）？这个问题大家下去思考。</strong>（待解决）</p>
<h2 id="线程同步-程序清单30-4"><a href="#线程同步-程序清单30-4" class="headerlink" title="线程同步-程序清单30-4"></a>线程同步-程序清单30-4</h2><ul>
<li><p>如果一个共享资源（比如一个对象）被多个线程<strong>同时访问</strong>，如果不对访问进行控制，会造成<strong>不可预期</strong>的结果。这是需要对线程实施同步控制</p>
</li>
<li><p>Account是账户类，其数据成员balance为当前余额，deposit方法往账户存钱，getBalance方法读取账户余额</p>
</li>
<li><p>AddPennyTask为任务，每次往账户里存一个便士</p>
</li>
<li><p>启动100个线程同时执行AddPennyTask任务</p>
</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421195919991.png" srcset="/img/loading.gif" lazyload alt="image-20210421195919991"></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountWithoutSync</span></span>&#123;<br>    <br>    <span class="hljs-comment">//内部静态类Account</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>&#123;<br>		<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;<br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>			<span class="hljs-keyword">return</span> balance;  <br>		&#125;	<br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span></span>&#123;<br>			<span class="hljs-keyword">int</span> newBalance = balance + amount;   <span class="hljs-comment">//读取balance			</span><br>			<span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">//休眠是为了放大数据不一致的可能性</span><br>               &#125;<br>			<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;	&#125;<br>			balance = newBalance;		<span class="hljs-comment">//写balance</span><br>		&#125;	<br>	&#125;<br>    <br>    <span class="hljs-comment">//内部静态类AddPennyTask是线程任务类，实现Runnable接口，调用account对象的deposit方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddPennyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  account.deposit(<span class="hljs-number">1</span>); &#125;<br>    &#125;<br>    <br>     <span class="hljs-comment">//account对象被100个线程访问：每个线程的run方法都调用accoun.deposit方法   </span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Account account = <span class="hljs-keyword">new</span> Account();<br>&#125;<br></code></pre></div></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> ch30;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountWithoutSync</span> </span>&#123;<br>    <br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//newCachedThreadPool()创建一个线程池，会再必要的时候创建新的线程。但是如果以前已经创建好的线程可用，则先宠用之前创建好的线程。</span><br>        ExecutorService executor = Executors.newCachedThreadPool();<br>        <br>        <span class="hljs-comment">//通过线程池启动100个线程，执行AddPenyTask类型的任</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;<br>            executor.execute(<span class="hljs-keyword">new</span> AddPennyTask());<br>        &#125;<br>        <br>        <span class="hljs-comment">//关闭线程池</span><br>        executor.shutdown();<br>        <br>        <span class="hljs-comment">//等待线程池里线程全部结束，线程池中都执行完后，返回true</span><br>        <span class="hljs-keyword">while</span>(!executor.isTerminated())&#123;  &#125;<br>            System.out.println(<span class="hljs-string">&quot;What is balance?&quot;</span> + account.getBalance());<br>        &#125;	<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>按理说，结果应该得到100，但是实际上结果如下（每次得到的值都是不同的）</p>
<img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421202408116.png" srcset="/img/loading.gif" lazyload alt="image-20210421202408116" style="zoom: 67%;">

<p><strong>原因：多个线程访问一个对象，没有同步</strong></p>
<p>多个线程同时访问公共资源，会导致<strong>竞争状态（同时去修改公共资源）</strong>。为了避免竞争状态，应该<strong>防止多个线程同时进入程序的某一特定部分</strong>，这样的部分叫临界区。<strong>Account类的deposit方法就是临界区</strong>。可<strong>用synchronized关键字来同步</strong>，保证<strong>一次只有一个线程可以访问这个方法</strong>。当一个方法被synchronized修饰，这个方法就是<strong>原子的（一个线程开始执行这个方法，就不可中断）</strong></p>
<blockquote>
<p><strong>注意deposit里面每条语句都不是原子的（对应着一堆汇编指令），因此每条(汇编)语句执行时，是随时可能被中断，切换到另外一个线程</strong></p>
</blockquote>
<ul>
<li>task1和task2同时进入account对象的deposit方法</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421203255031.png" srcset="/img/loading.gif" lazyload alt="image-20210421203255031"></p>
<blockquote>
<p>task1还没有对balance进行修改，没执行到blance=newBalance的汇编语句，task2就开始任务，此时task2读取的balance就是0</p>
</blockquote>
<hr>
<ul>
<li><p>线程同步用于协调<strong>多个线程访问公共资源</strong></p>
<p>公共资源被多个线程同时访问，可能会遭到破坏</p>
<p>（程序清单30-4：AccountWithoutSync.java）</p>
</li>
<li><p>临界区（critical region）可能被多个线程同时进入的程序的一部分区域</p>
<ul>
<li>所以需要对临界区同步，<strong>保证任何时候只能有1个线程进入临界区</strong></li>
</ul>
</li>
<li><p>可以用synchronized关键词来同步临界区</p>
<ul>
<li>临界区可以是方法，包括静态方法和实例方法，那么被<strong>synchronized关键字修饰的方法叫同步方法</strong></li>
<li>临界区也可以是语句块，也可以用synchronized关键字来同步语句块：如synchronized(this){…}</li>
</ul>
</li>
<li><p>除了用synchronized关键字，还可以<strong>利用加锁同步临界区</strong></p>
</li>
</ul>
<h3 id="线程同步-synchronized"><a href="#线程同步-synchronized" class="headerlink" title="线程同步-synchronized"></a>线程同步-synchronized</h3><ul>
<li><p>synchronized可用于<strong>同步方法</strong></p>
</li>
<li><p>使用关键字synchronized来修饰方法</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span></span><br></code></pre></div></td></tr></table></figure></li>
<li><p>一次<strong>只有一个线程</strong>可以进入这个同步方法</p>
</li>
<li><p>synchronized关键字是如何做到方法同步的？</p>
<p>通过<strong>加锁</strong>：一个线程要进入同步方法，首先拿到锁，进入方法后立刻上锁，导致<strong>其它要进入这个方法的线程被阻塞</strong>（等待锁）</p>
<ul>
<li>锁是一种实现资源排他使用的机制</li>
<li>对于<strong>synchronized</strong>实例方法，是对调用该方法的<strong>对象(this对象)加锁</strong></li>
<li>对于<strong>synchronized</strong>静态方法，是对拥有这个静态方法的<strong>类加锁</strong></li>
</ul>
</li>
<li><p>当进入方法的线程执行完方法后，锁被释放，会唤醒等待这把锁的其他进程。</p>
</li>
</ul>
<hr>
<p><strong>同步对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span></span><br></code></pre></div></td></tr></table></figure>

<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421204754330.png" srcset="/img/loading.gif" lazyload alt="image-20210421204754330"></p>
<p><strong>同步语句块</strong></p>
<ul>
<li>被synchronized关键字同步的语句块称为同步块(synchronized Block)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">synchronized</span> (expr) &#123;   statements;  &#125;  	，<br></code></pre></div></td></tr></table></figure>

<ul>
<li><p>表达式<strong>expr求值结果必须是一个对象的引用</strong>，因此可以通过对任何对象加锁来同步语句块</p>
<ul>
<li>如果expr指向的对象<strong>没有被加锁</strong>，则<strong>第一个执行到同步块的线程对该对象加锁</strong>，线程执行该语句块，然后解锁；</li>
<li>如果expr指向的对象<strong>已经加了锁</strong>，则执行到同步块的其它线程将<strong>被阻塞</strong></li>
<li>expr指向的对象解锁后，所有等待该对象锁的线程都被唤醒</li>
</ul>
</li>
<li><p>同步语句块允许同步方法中的<strong>部分代码</strong>，而不必是整个方法，增强了程序的并发能力</p>
</li>
<li><p>任何同步的<strong>实例方法</strong>都可以转换为同步语句块。</p>
</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421205701082.png" srcset="/img/loading.gif" lazyload alt="image-20210421205701082"></p>
<hr>
<h4 id="前面的例子中的如下几种解决方案"><a href="#前面的例子中的如下几种解决方案" class="headerlink" title="前面的例子中的如下几种解决方案"></a>前面的例子中的如下几种解决方案</h4><ol>
<li>deposit方法改为同步的</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> balance;<br>	&#125;<br>		<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span></span>&#123;<br>		<span class="hljs-keyword">int</span> newBalance = balance + amount;			<br>		<span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;<br>		<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;	&#125;<br>		balance = newBalance;<br>	&#125;		<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>sleep方法调用之后，并没有释放锁。使得线程仍然可以同步控制。sleep不会让出系统资源；</p>
<p>凡是在上了锁的临界区里，sleep方法不会释放锁</p>
</blockquote>
<ol start="2">
<li>修改共享资源Account类，在deposit方法内部加同步块</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> balance;<br>	&#125;		<br>	<span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span></span>&#123;<br>		<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>			<span class="hljs-keyword">int</span> newBalance = balance + amount;			<br>			<span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;<br>			<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;	&#125;<br>			balance = newBalance;<br>		&#125;		<br>	&#125;		<br>&#125; <br></code></pre></div></td></tr></table></figure>

<ol start="3">
<li>修改线程任务类AddPennyTask，在run方法里加同步块</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddPennyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">synchronized</span>(account)&#123;<br>			account.deposit(<span class="hljs-number">1</span>);	<br>		&#125;	<br>	&#125;	<br>&#125; <br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>注意：是对account对象加锁。不能对this对象加锁，即**synchronized(this)**是错误的</p>
<p>因为this是AddPennyTask对象（此处，而前两处就是account对象），100个线程任务对象各不相同，因此synchronized(this)是对100个线程任务对象分别加锁，根本没起到同步的作用。100个线程任务对象同时访问的是共享资源account对象，需要加锁同步的是account对象。</p>
</blockquote>
<h3 id="线程同步-加锁同步"><a href="#线程同步-加锁同步" class="headerlink" title="线程同步-加锁同步"></a>线程同步-加锁同步</h3><ul>
<li><p>采用synchronized关键字的同步要<strong>隐式地</strong>在对<strong>象实例或类上加锁</strong>，粒度较大影响性能</p>
</li>
<li><p>JDK1.5可以显式地加锁，能够在更小地粒度上进行线程同步</p>
</li>
<li><p>一个锁是一个Lock接口的实例</p>
</li>
<li><p>类ReentrantLock是Lock的一个具体实现：可重入的锁</p>
</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421210848626.png" srcset="/img/loading.gif" lazyload alt="image-20210421210848626"></p>
<ul>
<li>可重入性锁描述这样的一个问题：一个线程在<strong>持有一个锁的时候</strong>，它能否<strong>再次（多次）申请该锁</strong>。如果一个线程已经获得了锁，它还可以再次获取该锁而不会死锁，那么我们就称该锁为可重入锁。通过以下伪代码说明：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>&#123;    <br>	lock.lock(); <span class="hljs-comment">// 获取锁    </span><br>	methodB();    <br>	lock.unlock() <span class="hljs-comment">// 释放锁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span></span>&#123;    <br>	lock.lock(); <span class="hljs-comment">// 再次获取该锁   </span><br>	 <span class="hljs-comment">// 其他业务    </span><br>	lock.unlock();<span class="hljs-comment">// 释放锁</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>Java关键字synchronized隐式支持重入性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountWithSyncUsingLock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Account account = <span class="hljs-keyword">new</span> Account();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executor = Executors.newCachedThreadPool();<br>        <br>        <span class="hljs-comment">// Create and launch 100 threads</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;executor.execute(<span class="hljs-keyword">new</span> AddPennyTask());&#125;<br>        executor.shutdown();<br>        <br>        <span class="hljs-comment">// Wait until all tasks are finished</span><br>        <span class="hljs-keyword">while</span> (!executor.isTerminated()) &#123; &#125;<br>        System.out.println(<span class="hljs-string">&quot;What is balance ? &quot;</span> + account.getBalance());<br>    &#125;<br>    <br>    <span class="hljs-comment">// A thread for adding a penny to the account</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddAPennyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;account.deposit(<span class="hljs-number">1</span>); &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure>

<p>加锁同步</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-comment">// An inner class for account，主要变化在账户类</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(); <br>        <span class="hljs-comment">// 注意这里是静态的，被所有Account实例共享</span><br>        <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;   <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> balance;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>            <br>            <br>            <span class="hljs-comment">//在这里加锁（临界区开始）</span><br>            <span class="hljs-comment">//第一个进入这个方法的线程获得锁，把deposite方法锁住。</span><br>            <span class="hljs-comment">//其他进入方法的线程必须等待这把锁，因为进入阻塞状态</span><br>            lock.lock( ); <span class="hljs-comment">// Acquire the lock</span><br>            <br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">int</span> newBalance = balance + amount;<br>                Thread.sleep(<span class="hljs-number">5</span>);<br>                balance = newBalance;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;   &#125;<br>            <br>            <span class="hljs-comment">//在finally块里释放锁，其它等待这把锁的线程被唤醒</span><br>            <span class="hljs-comment">//第一个获得锁的线程可以进入该方法了，进去后又对deposite上锁…</span><br>            <span class="hljs-keyword">finally</span> &#123; lock.unlock(); <span class="hljs-comment">// Release the lock，在finally中进行锁的释放。&#125;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<hr>
<h4 id="线程同步-场景1"><a href="#线程同步-场景1" class="headerlink" title="线程同步-场景1"></a>线程同步-场景1</h4><ul>
<li>假设一个类有多个用<strong>synchronized修饰的</strong>同步实例方法，如果多个线程访问这个类的<strong>同一个对象</strong>，当一个线程获得了该对象锁进入到其中一个同步方法时，这把锁<strong>会锁住这个对象所有的同步实例方法</strong></li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421211526607.png" srcset="/img/loading.gif" lazyload alt="image-20210421211526607"></p>
<p>设置如下共享资源类，这个类的实例被多个线程访问</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resource</span></span>&#123; <br>    <br>    <span class="hljs-comment">//多个线程会对value读写，因此需要同步控制。</span><br>    <span class="hljs-comment">//value就是竞争性资源。Resource对象也因此成为竞争性资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;   <span class="hljs-comment">//多个线程会同时对这个数据成员读写</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span>  value;&#125;<br>    <br>    <span class="hljs-comment">//inc方法把value值增加，增加量为amount</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span>  </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入inc: &quot;</span>);<br>        <span class="hljs-keyword">int</span> newValue = value + amount;<br>        <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;  <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;	&#125;<br>        value = newValue;<br>        System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开inc.&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//dec方法把value减少，减少量为amount</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span>  </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入dec: &quot;</span>);<br>        <span class="hljs-keyword">int</span> newValue = value - amount;<br>        <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">2</span>); &#125; <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;	&#125;<br>        value = newValue;<br>        System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开dec.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>inc,dec两个方法都是synchronized的，两个同步的实例方法</p>
</blockquote>
<p><strong>设置如下的两个循环创建线程任务的类</strong></p>
<ul>
<li><p>IncTask是线程任务，会循环调用资源对象r.inc方法，loops是循环次数。</p>
<p>IncTask的构造函数会传入要访问的对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Resource r = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//要访问的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次增加量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IncTask</span><span class="hljs-params">(Resource r,<span class="hljs-keyword">int</span> amount,<span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r; <span class="hljs-keyword">this</span>.amount = amount; <span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123; r.inc(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><p>DecTask是线程任务，会循环调用资源对象r.dec方法，loops是循环次数。</p>
<p>DecTask的构造函数会传入要访问的对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Resource r = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//要访问的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次减少量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecTask</span><span class="hljs-params">(Resource r, <span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r;<span class="hljs-keyword">this</span>.amount = amount;<span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;  r.dec(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>运行</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//每次增加量为10，每次减少量为5，循环次数100</span><br>    	<span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>;<br>    	<span class="hljs-keyword">int</span> decAmount = <span class="hljs-number">5</span>;<br>    	<span class="hljs-keyword">int</span> loops = <span class="hljs-number">100</span>;<br><br>    	<span class="hljs-comment">//创建资源对象r</span><br>        Resource r = <span class="hljs-keyword">new</span> Resource();<br>    <br>    	<span class="hljs-comment">//构造线程任务incTask，注意传入的第一个参数为对象r，</span><br>		<span class="hljs-comment">//构造线程任务decTask，注意传入的第一个参数也为对象r，</span><br>		<span class="hljs-comment">//意味着这二个线程任务一旦执行，对应的二个线程调用的是同一个对象的方法，</span><br>    	<span class="hljs-comment">//一个线程(t1)调用r.inc, 另外一个线程(t2)调用r.dec</span><br>        Runnable incTask = <span class="hljs-keyword">new</span> IncTask( r, incAmount, loops );<br>        Runnable decTask = <span class="hljs-keyword">new</span> DecTask( r, decAmount, loops );<br><br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask); es.execute(decTask);<br>        es.shutdown();<br>        <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br><br>    	<span class="hljs-comment">//计算出正确的value值</span><br>		<span class="hljs-comment">//显示实际的计算值和正确的值，验证同步是否正确</span><br>        <span class="hljs-keyword">int</span> correctValue = (incAmount - decAmount)  * loops;<br>        System.out.println(<span class="hljs-string">&quot;\nThe value: &quot;</span> +  r.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + correctValue);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>运行结果如下</p>
<blockquote>
<p><strong>Thread 13</strong> <strong>进入inc: –&gt;Thread 13</strong> <strong>离开inc.</strong></p>
<p><strong>…</strong></p>
<p><strong>Thread 13进入inc: –&gt;Thread 13</strong> 离开inc.</p>
<p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p>
<p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p>
<p>**Thread 14进入inc: –&gt;Thread 14 **离开inc.</p>
<p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p>
<p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p>
<p>**Thread 13进入inc: –&gt;Thread 13 <strong>离开inc.</strong></p>
<p><strong>…</strong></p>
<p><strong>The value: 500, correct value: 500</strong></p>
</blockquote>
<blockquote>
<p>可以看到线程13进入inc，对象被加锁，线程14必须等待线程13退出inc后，才能进入dec。所以输出结果里线程13和14的控制台输出没有乱。</p>
<p>最下面的输出的value值也是正确的</p>
</blockquote>
<blockquote>
<p><strong>这个例子说明，二个线程访问同一个对象时， 只要一个线程拿到对象锁，这个对象的所有同步实例方法都被锁</strong></p>
<p>即incTask对应线程进入inc是，decTask的线程不能进入dec</p>
</blockquote>
<h4 id="线程同步-场景2"><a href="#线程同步-场景2" class="headerlink" title="线程同步-场景2"></a>线程同步-场景2</h4><ul>
<li>假设一个类有多个用<strong>synchronized修饰的</strong>同步实例方法，如果多个线程访问这个类的<strong>不同对象</strong>，那么<strong>不同对象的synchronized锁不一样</strong>，<strong>每个对象的锁只能对访问该对象的线程同步</strong></li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421212622864.png" srcset="/img/loading.gif" lazyload alt="image-20210421212622864"></p>
<p><strong>如下示例创建两个对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>,decAmount = <span class="hljs-number">5</span>, loops = <span class="hljs-number">3</span>;<br><br>    	<span class="hljs-comment">//注意，和场景1不同，现在创建二个资源对象r1和r2</span><br>        Resource r1 = <span class="hljs-keyword">new</span> Resource();<br>        Resource r2 = <span class="hljs-keyword">new</span> Resource();<br>    <br>    <br>    	<span class="hljs-comment">//incTask1和decTask1访问对象r1; 它们的运行线程被r1的对象锁同步；</span><br>		<span class="hljs-comment">//incTask2和decTask2访问对象r2;它们的运行线程被r2的对象锁同步；</span><br>		<span class="hljs-comment">//但是这二对线程之间没有同步约束，例如incTask1和incTask2的运行线程不会被同步</span><br>        Runnable incTask1 = <span class="hljs-keyword">new</span> IncTask(r1,incAmount,loops);      Runnable decTask1 = <span class="hljs-keyword">new</span> DecTask(r1,decAmount,loops);<br>        Runnable incTask2 = <span class="hljs-keyword">new</span> IncTask(r2,incAmount,loops);     Runnable decTask2 = <span class="hljs-keyword">new</span> DecTask(r2,decAmount,loops);<br><br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask1);es.execute(decTask1);<br>        es.execute(incTask2);es.execute(decTask2);<br>        es.shutdown();<br>        <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br>        <span class="hljs-keyword">int</span> r1CorrectValue = (incAmount - decAmount)  * loops ;	<span class="hljs-keyword">int</span> r2CorrectValue = (incAmount - decAmount)  * loops;<br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r1: &quot;</span> + r1.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r1CorrectValue);<br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r2: &quot;</span> + r2.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r2CorrectValue);<br> &#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>4个线程访问两个不同的对象，不同的对象锁不一样，incTask1进入对象r1的inc，和incTask2是否可以进入对象r2的inc无关</p>
</blockquote>
<p>结果如下</p>
<blockquote>
<p><strong>Thread 13 进入inc:</strong> </p>
<p><strong>Thread 15 进入inc</strong>: –&gt;Thread 13 离开inc.</p>
<p><strong>Thread 13  进入inc</strong>: –&gt;Thread 15 离开inc.</p>
<p><strong>Thread 15 进入inc</strong>: –&gt;Thread 13 离开inc.</p>
<p><strong>Thread 13  进入inc</strong>: –&gt;Thread 15 离开inc.</p>
<p><strong>Thread 15进入inc</strong>: –&gt;<strong>Thread 15 离开inc.</strong>–&gt;<strong>Thread 13 离开inc.</strong></p>
<p><strong>Thread 14 进入dec:</strong> </p>
<p><strong>Thread 16进入dec</strong>: –&gt;<strong>Thread 14离开dec.</strong></p>
<p><strong>Thread 14 进入dec:</strong> –&gt;<strong>Thread 16 离开dec.</strong></p>
<p><strong>Thread 16进入dec</strong>: –&gt;<strong>Thread 14离开dec.</strong></p>
<p><strong>Thread 14 进入dec:</strong> –&gt;<strong>Thread 16 离开dec.</strong></p>
<p><strong>Thread 16进入dec</strong>: –&gt;<strong>Thread 16离开dec.</strong>–&gt;<strong>Thread 14离开dec.</strong></p>
<p><strong>The value of r1: 15, correct value: 15</strong></p>
<p><strong>The value of r2: 15, correct value: 15</strong></p>
</blockquote>
<blockquote>
<p>计算结果正确。</p>
<p>13和15分别访问二个对象的inc，没有同步约束，因此它们的System.out.println输出是乱的；14和16也是如此。但</p>
<p>是13和14是同步的，15和16也是同步的。如果只看13和14的输出，就没有乱。</p>
</blockquote>
<h4 id="线程同步-场景3"><a href="#线程同步-场景3" class="headerlink" title="线程同步-场景3"></a>线程同步-场景3</h4><ul>
<li>n如果采用Lock锁进行同步，一旦Lock锁被一个线程获得，那么被这把锁控制的所有临界区都被上锁，这时所有其他访问这些临界区的线程都被阻塞。</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421213850843.png" srcset="/img/loading.gif" lazyload alt="image-20210421213850843"></p>
<p><strong>ResourceWithLock采用Lock对临界区上锁，而不是用synchronized关键字</strong></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceWithLock</span> </span>&#123; <span class="hljs-comment">//重新定义资源类，采用Lock锁</span><br>    <span class="hljs-keyword">private</span>  Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();  <span class="hljs-comment">//创建Lock锁对象，注意是实例变量 </span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;   <span class="hljs-comment">//多个线程会同时对这个数据成员读写</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span>  value; &#125;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span>   </span>&#123;<br>        <span class="hljs-comment">//inc方法在这加Lock锁（临界区开始）</span><br>        lock.lock( ); <span class="hljs-comment">// Acquire the lock</span><br>        <br>        <span class="hljs-keyword">try</span>&#123; System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入inc: &quot;</span>);<br>            <span class="hljs-keyword">int</span> newValue = value + amount;  <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;  <span class="hljs-keyword">catch</span>(InterruptedException e)&#123; &#125;<br>            value = newValue; System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开inc.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span>&#123; lock.unlock(); &#125;<span class="hljs-comment">//inc退出方法前解Lock锁，退出临界区</span><br><br>    &#125;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">//dec方法用同一把Lock锁。</span><br>        lock.lock( ); <span class="hljs-comment">// Acquire the lock</span><br>        <br>        <span class="hljs-keyword">try</span>&#123; System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入dec: &quot;</span>);<br>            <span class="hljs-keyword">int</span> newValue = value - amount; <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">2</span>); &#125;  <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;	&#125;<br>            value = newValue; System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开dec.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123; lock.unlock(); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p><strong>Inc，dec方法用同一把Lock锁。因此如果调用lock.lock(); 加锁，这个锁同时锁住inc和dec方法。</strong></p>
</blockquote>
<p>与场景一相同的两个类,但是<strong>访问类型不同</strong>了</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncTaskWithLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> ResourceWithLock r = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IncTaskWithLock</span><span class="hljs-params">(ResourceWithLock r,<span class="hljs-keyword">int</span> amount,<span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r; <span class="hljs-keyword">this</span>.amount = amount; <span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123; r.inc(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>IncTask是线程任务，会循环调用资源对象r.inc方法，loops是循环次数。</p>
<p>线程任务现在要访问的资源类型是<strong>ResourceWithLock</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecTaskWithLock</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> ResourceWithLock r = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecTaskWithLock</span><span class="hljs-params">(ResourceWithLock r, <span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r; <span class="hljs-keyword">this</span>.amount = amount; <span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123; r.dec(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>DecTask是线程任务，会循环调用资源对象r.dec方法，loops是循环次数。</p>
<p>线程任务现在要访问的资源类型是<strong>ResourceWithLock</strong></p>
</blockquote>
<p>如下运行</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> decAmount = <span class="hljs-number">5</span>; <span class="hljs-keyword">int</span> loops = <span class="hljs-number">50</span>;<br>		<span class="hljs-comment">//创建资源对象r，注意资源类型是ResourceWithLock</span><br>        ResourceWithLock r = <span class="hljs-keyword">new</span> ResourceWithLock();<br>    <br>    	<span class="hljs-comment">//构造线程任务incTask，decTask</span><br>    	<span class="hljs-comment">//注意:二个任务的线程访问的是同一个ResourceWithLock对象，用的是同一把Lock锁。</span><br>    	<span class="hljs-comment">//这时只要一个线程拿到锁，所有被这个锁控制的临界区都被锁住。</span><br>   		<span class="hljs-comment">//即incTask的线程进入inc时，decTask的线程不能进入dec</span><br>        Runnable incTask = <span class="hljs-keyword">new</span> IncTaskWithLock( r ,incAmount,loops);<br>        Runnable decTask = <span class="hljs-keyword">new</span> DecTaskWithLock( r ,decAmount,loops);<br><br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask); es.execute(decTask);<br>        es.shutdown(); <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br><br>        <span class="hljs-keyword">int</span> correctValue = (incAmount - decAmount)  * loops;<br>        System.out.println(<span class="hljs-string">&quot;\nThe value: &quot;</span> + r.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + correctValue);<br>    &#125;<br></code></pre></div></td></tr></table></figure>

<p>结果如下</p>
<blockquote>
<p><strong>Thread 13 进入inc: –&gt;Thread 13 离开inc.</strong></p>
<p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p>
<p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p>
<p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p>
<p><strong>…</strong></p>
<p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p>
<p><strong>Thread 13 进入inc: –&gt;Thread 13 离开inc.</strong></p>
<p><strong>Thread 13 进入inc: –&gt;Thread 13 离开inc.</strong></p>
<p><strong>…</strong></p>
<p><strong>The value: 250, correct value: 250</strong></p>
</blockquote>
<blockquote>
<p>可以看到线程13进入inc，临界区inc和dec都被加锁，线程14必须等待线程13退出inc后，才能进入dec。所以输出结果里线程13和14的控制台输出没有乱.</p>
<p>最下面的输出的value值也是正确的</p>
</blockquote>
<h4 id="线程同步-场景4"><a href="#线程同步-场景4" class="headerlink" title="线程同步-场景4"></a>线程同步-场景4</h4><ul>
<li>如果一个类采用Lock锁对临界区上锁，而且这个Lock锁也是该类的实例成员（见ResourceWithLock的里的lock对象定义），那么<strong>这个类的二个实例的Lock锁就是不同的锁</strong>，下面的动画演示了这种场景：对象o1的Lock锁和对象o2的Lock锁是不同的锁对象。</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421214552381.png" srcset="/img/loading.gif" lazyload alt="image-20210421214552381"></p>
<blockquote>
<p><strong>注意，和场景3不同，现在创建二个资源对象r1和r2.注意资源类型是ResourceWithLock</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>, decAmount = <span class="hljs-number">5</span>,loops = <span class="hljs-number">20</span>; <br>    <br>    <span class="hljs-comment">//两个ResourceWithLock对象</span><br>    ResourceWithLock r1 = <span class="hljs-keyword">new</span> ResourceWithLock();  <br>    ResourceWithLock r2 = <span class="hljs-keyword">new</span> ResourceWithLock();<br><br>    <span class="hljs-comment">/*四个线程访问二个不同对象</span><br><span class="hljs-comment">     *incTask1，decTask1的执行线程访问同一个对象r1，它们之间同步</span><br><span class="hljs-comment">     * incTask2，decTask2的执行线程访问同一个对象r2，它们之间同步</span><br><span class="hljs-comment">     * incTask1执行线程进入对象r1的inc，和incTask2执行线程是否可以进入对象r2的inc无关，因为锁不一样</span><br><span class="hljs-comment">*/</span><br>        <span class="hljs-comment">//incTask1，decTask1访问同一个对象r1，它们之间同步</span><br>        Runnable incTask1 = <span class="hljs-keyword">new</span> IncTaskWithLock(r1,incAmount,loops);<br>        Runnable decTask1 = <span class="hljs-keyword">new</span> DecTaskWithLock(r1,decAmount,loops);<br>        <span class="hljs-comment">//incTask2，decTask2访问同一个对象r2，它们之间同步</span><br>        Runnable incTask2 = <span class="hljs-keyword">new</span> IncTaskWithLock(r2,incAmount,loops);<br>        Runnable decTask2 = <span class="hljs-keyword">new</span> DecTaskWithLock(r2,decAmount,loops);<br><br>    <br>    <br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask1); es.execute(decTask1); es.execute(incTask2); es.execute(decTask2);<br>        es.shutdown();<br>        <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br>        <span class="hljs-keyword">int</span> r1CorrectValue = (incAmount - decAmount)  * loops ; <span class="hljs-keyword">int</span> r2CorrectValue = (incAmount - decAmount)  * loops;          <br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r1: &quot;</span> + r1.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r1CorrectValue);<br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r2: &quot;</span> + r2.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r2CorrectValue);<br>    &#125;<br><br></code></pre></div></td></tr></table></figure>

<p>输出结果</p>
<blockquote>
<p><strong>Thread 13 进入inc:</strong></p>
<p><strong>Thread 15 进入inc: –&gt;Thread 15 离开inc.</strong></p>
<p><strong>Thread 16 进入dec: –&gt;Thread 13 离开inc.</strong></p>
<p><strong>Thread 14 进入dec: –&gt;Thread 16 离开dec.</strong></p>
<p><strong>Thread 16 进入dec: –&gt;Thread 14 离开dec.</strong></p>
<p><strong>Thread 14 进入dec: –&gt;Thread 16 离开dec.</strong></p>
<p><strong>Thread 16 进入dec: –&gt;Thread 14 离开dec.</strong></p>
<p><strong>Thread 14 进入dec: –&gt;Thread 16 离开dec.</strong></p>
<p><strong>Thread 15 进入inc: –&gt;Thread 14 离开dec.</strong></p>
<p><strong>Thread 13 进入inc: –&gt;Thread 15 离开inc.</strong></p>
<p><strong>Thread 15 进入inc: –&gt;Thread 13 离开inc.</strong></p>
<p><strong>Thread 13 进入inc: –&gt;Thread 15 离开inc.–&gt;Thread 13 离开inc.</strong></p>
<p><strong>The value of r1: 15, correct value: 15</strong></p>
<p><strong>The value of r2: 15, correct value: 15</strong></p>
</blockquote>
<blockquote>
<p>计算结果正确。</p>
<p>13和15分别访问二个对象的inc，没有同步约束，因此它们的输出是乱的；14和16也是如此。但是13和14是同步的，15和16也是同步的。如果只看13和14的输出，就没有乱。</p>
</blockquote>
<h3 id="线程同步-总结和思考"><a href="#线程同步-总结和思考" class="headerlink" title="线程同步-总结和思考"></a>线程同步-总结和思考</h3><ul>
<li><p>如果采用synchronized关键字对类 A的实例方法进行同步控制，这时等价于synchronized(this){ }</p>
<ul>
<li>一旦一个线程进入类A的对象o的synchronized实例方法，<strong>对象o被加锁，对象o所有的synchronized实例方法都被锁住</strong>，从而阻塞了要访问对象o的synchronized实例方法的线程，<strong>但是与访问A类其它对象的线程无关</strong></li>
</ul>
</li>
<li><p>如果采用synchronized关键字对类 A的静态方法进行同步控制，这时等价于synchronized(A.class){ }。一旦一个线程进入A的一个静态同步方法，A所有的静态同步方法都被锁（这个锁是类级别的锁），<strong>这个锁对所有访问该类静态同步方法的线程有效，不管这些线程是通过类名访问静态同步方法还是通过不同的对象访问静态同步方法。</strong></p>
</li>
<li><p>如果通过Lock对象进行同步，首先看Lock对象对哪些临界区上锁，一旦Lock锁被一个线程获得，那么被这把锁控制的所有临界区都被上锁（如场景3）；另外要区分Lock对象本身是否是不同的：不同的Lock对象能阻塞的线程是不一样的（如场景4）。</p>
</li>
</ul>
<h3 id="线程同步-线程协作"><a href="#线程同步-线程协作" class="headerlink" title="线程同步-线程协作"></a>线程同步-线程协作</h3><ul>
<li><p>线程之间有资源竞争，<strong>synchronized和Lock锁这些同步机制解决的是资源竞争问题</strong></p>
</li>
<li><p>线程之间还有相互协作的问题</p>
</li>
<li><p>假设创建并启动两个任务线程：</p>
<ul>
<li><p>存款线程用来向账户中存款</p>
</li>
<li><p>提款线程从同一账户中提款</p>
</li>
<li><p>当提款的数额大于账户的当前余额时，提款线程必须等待存款线程往账户里存钱</p>
</li>
<li><p>如果存款线程存入一笔资金，必须通知提款线程重新尝试提款，如果余额仍未达到提款的数额，提款线程必须继续等待新的存款 </p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421215036540.png" srcset="/img/loading.gif" lazyload alt="image-20210421215036540"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
                    
                  </div>
                
              </div>

              <!--
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
-->
<p class="note note-warning">
  <strong>本文作者: </strong><a href="/">Trent-Liu</a> <br>
  <strong>本文链接: </strong><a href="https://trent-liu.github.io/2021/04/17/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">https://trent-liu.github.io/2021/04/17/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</a> <br>
  <strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
     </p>
     


              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/22/Java%E6%B5%81/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java流，文件，IO</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/12/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/">
                        <span class="hidden-mobile">Java笔记——泛型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#valine",
          app_id: "kln923ignpAig6tMBYCNQLi4-gzGzoHsz",
          app_key: "rxzdxPz6ABf8lCQH2OOo6WH9",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


<div class="text-center py-1">  
  <div>
    <span id="timeDate1">载入天数...</span>
    <span id="times1">载入时分秒...</span>
    <script>
    var now1 = new Date();
    function createtime1(){
        var grt1= new Date("07/21/2018 23:00");//此处修改你的建站时间或者网站上线时间
        now1.setTime(now1.getTime()+250);
        days1 = (now1 - grt1 ) / 1000 / 60 / 60 / 24;
        dnum1 = Math.floor(days1);
        hours1 = (now1 - grt1 ) / 1000 / 60 / 60 - (24 * dnum1);
        hnum1 = Math.floor(hours1);
        if(String(hnum1).length ==1 ){
            hnum1 = "0" + hnum1;
        }
        minutes1 = (now1 - grt1 ) / 1000 /60 - (24 * 60 * dnum1) - (60 * hnum1);
        mnum1 = Math.floor(minutes1);
        if(String(mnum1).length ==1 ){
                  mnum1 = "0" + mnum1;
        }
        
        document.getElementById("timeDate1").innerHTML = "💓 ysm&lyk&nbsp"+dnum1+"&nbspdays";  //此次自定义显示内容
        document.getElementById("times1").innerHTML = hnum1 + "&nbsphr&nbsp" + mnum1 + "&nbspmin&nbsp";
    }  //此次自定义显示内容
    setInterval("createtime1()",250);
    </script>
  </div>

<div class="text-center py-1">  
<div>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("03/20/2021 17:25:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      /*
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      */
      document.getElementById("timeDate").innerHTML = "🏡pigsty for&nbsp"+dnum+"&nbspdays";  //此次自定义显示内容
      document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" /*+ snum + "&nbspsec"*/;
  }  //此次自定义显示内容
  setInterval("createtime()",250);
  </script>
</div>

<div class="text-center py-1">   
  <div>
    <span>Copyright © 2021</span></a>
    <a href="https://erenspace.cool/" target="_blank" rel="nofollow noopener">
     <span>Trent-Liu‘s Pigsty</span></a>    <br>
  </div>


<!--
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
-->

  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>

<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>