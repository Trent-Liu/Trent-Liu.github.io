

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="实例方法覆盖
如果子类重新定义了从父类中继承的实例方法，称为方法覆盖(method override)。
仅当父类方法在子类里是可访问的，该实例方法才能被子类覆盖，即父类私有实例方法不能被子类覆盖，父类实例私有方法自动视为final的。
静态方法不能被覆盖，如果静态方法在子类中重新定义，那么父类方法将被隐藏。
覆盖特性：一旦父类中的实例方法被子类覆盖，同时用父类型的引用变量引用了子类对象，这时不能">
  <meta name="author" content="Trent-Liu">
  <meta name="keywords" content="分享在HUST中的一些学习经历">
  
  <title>Java笔记——继承和多态下 - Pigsty</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"trent-liu.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>





<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Pigsty</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/wallhaven-e781gr_1920x1080.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java笔记——继承和多态下">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-26 23:00" pubdate>
        2021年3月26日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      67
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java笔记——继承和多态下</h1>
            
            <div class="markdown-body">
              <h2 id="实例方法覆盖"><a href="#实例方法覆盖" class="headerlink" title="实例方法覆盖"></a>实例方法覆盖</h2><ul>
<li>如果子类<strong>重新定义</strong>了从父类中继承的实例方法，称为方法覆盖(method override)。<ul>
<li>仅当父类方法在子类里是<strong>可访问的</strong>，该实例方法<strong>才能被子类覆盖</strong>，即父类<strong>私有</strong>实例方法不能被子类覆盖，父类实例私有方法自动视为final的。</li>
<li>静态方法不能被覆盖，如果静态方法在子类中重新定义，那么父类方法将被<strong>隐藏</strong>。</li>
<li><strong>覆盖特性</strong>：一旦父类中的实例方法被子类覆盖，同时用父类型的引用变量引用了子类对象，这时不能通过这个父类型引用变量去访问被覆盖的父类方法(即这时被覆盖的父类方法不可再被发现)。因为实例方法具有多态性（晚期绑定）<ul>
<li>在子类类体函数中可以使用super调用被覆盖的父类方法。</li>
</ul>
</li>
<li>隐藏特性：指父类的变量（实例变量、静态变量）和静态方法在子类被重新定义，但由于<strong>类的变量和静态方法没有多态性</strong>，因此通过<strong>父类型引用变量访问的一定是父类变量、静态方法</strong>(即被隐藏的可再发现)。</li>
<li>方法覆盖的哲学涵义：子对象当然可以修改父类的行为（生物进化除了遗传，还有变异）  </li>
</ul>
</li>
</ul>
<p>例子：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;               <span class="hljs-comment">//父类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A&#x27;s m&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A&#x27;s s&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-comment">//子类</span><br>    <span class="hljs-comment">//覆盖父类实例方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B&#x27;s m&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//隐藏父类静态方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B&#x27;s s&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OverrideDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A o = <span class="hljs-keyword">new</span> B();  <span class="hljs-comment">//父类型变量引用子类对象</span><br>        o.m();  <span class="hljs-comment">//由于父类实例方法m被子类覆盖，o运行时指向B类对象，由于多态性，执行的是B的m</span><br>        o.s();    <span class="hljs-comment">//由于s是静态方法，没有多态性，编译器编译时对象o的声明类型是A，所以执行的是A的s</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>父类型变量o引用了子类对象，通过o调用被覆盖的实例方法m时，调用的一定是子类方法，这时不可能调用到父类的方法m(父类函数不能被发现），因为多态特性。<strong>多态性使得根据new 后面的类型决定调用哪个m</strong>，new后是谁，实例方法就是谁的  </p>
</blockquote>
<blockquote>
<p>静态方法和成员变量没有多态性，因此要<strong>根据声明类型决定调用哪个s</strong>，声明是谁，静态方法就是谁。</p>
</blockquote>
<p>因此上面的结果为</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">B<span class="hljs-string">&#x27;s m</span><br><span class="hljs-string">A&#x27;</span>s s<br></code></pre></div></td></tr></table></figure>
<p>A o = new B();<br>o的实例方法是B的，静态方法是A的</p>
<blockquote>
<p>引用变量o有二个类型：声明类型A，实际运行时类型B  </p>
</blockquote>
<blockquote>
<p>判断o.s()执行的是哪个函数按照o的<strong>声明类型</strong>，因为静态函数s<strong>没有多态性</strong>，<br>函数入口地址在<strong>编译时</strong>就确定（早期绑定），而编译时所有变量的类型都按声明类型。  </p>
</blockquote>
<blockquote>
<p>判断o.m()执行的是哪个函数按照o的<strong>实际运行类型</strong>，在<strong>运行时</strong>按照o指向<br>的实际类型B来<strong>重新计算函数入口地址</strong>（晚期绑定。多态性），因此调用的是B的m</p>
</blockquote>
<blockquote>
<p>因此一旦引用变量o指向了B类型对象（A o = new B()），o.m()调用的永远是B的m，再也无法通过o调用A的m，哪怕强制转换都不行： ((A)o).m();调用的还是B的m这就是前面PPT所说的不能再发现。</p>
</blockquote>
<p>对上面AB两个类，如果这样</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"> B o = <span class="hljs-keyword">new</span> B();<br> o.s(); <span class="hljs-comment">//调用B的s，将父类A的s隐藏，即通过B类型的引用变量o是不可能调用A的s</span><br>((A)o).s(); <span class="hljs-comment">//通过强制类型转换，可以调用A的s，可以找回。也可以通过类名调用来找回:A.s( );</span><br></code></pre></div></td></tr></table></figure>
<p>这就是被隐藏的变量和静态方法可以再发现</p>
<p>实例方法覆盖的一个应用：在子类里覆盖父类方法  (父类的toString可以打印颜色，填充等)</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A circle &quot;</span> + <span class="hljs-keyword">super</span>.toString() <br>        + <span class="hljs-string">&quot;\n\tradius: &quot;</span> + radius;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>这样做的好处是Circle对象的基本属性,如color，filled，dateCreated由父类方法打印，Circle对象只负责打印新的属性值  </p>
</blockquote>
<h2 id="Object中的方法"><a href="#Object中的方法" class="headerlink" title="Object中的方法"></a>Object中的方法</h2><blockquote>
<p>任何类在设计时应考虑覆盖祖先类Object的如下函数： equal，clone，toString等。</p>
</blockquote>
<ul>
<li>java.lang.Object类是<strong>所有类的祖先类</strong>。如果一个类在声明时没有指定父类，那么这个类的<strong>父类是Object类</strong>。<ul>
<li>它提供方法如<strong>toString</strong>、<strong>equals</strong>、<strong>getClass</strong>、<em>clone</em>、<em>finalize</em>。前3个为公有，后2个为保护。getClass为final（用于泛型和反射机制，禁止覆盖）。</li>
<li>equals方法:用于测试两个对象是否相等。<strong>Object类的默认实现是比较两个对象引用是否引用同一个对象。</strong> 只是比较引用是否相同，不能真正判断是否相同，引用相同一定相同，但是相同不一定是引用相同， 在很多子类中要覆盖。</li>
<li>toString方法：返回代表这个对象的字符串。<strong>Object类的默认实现是返回由类名、@和hashCode组成。</strong><br>Circle circle = new Circle();<br>circle.toString();//Circle@15037e5，如果Circle没有覆盖toString<br>Object的toString方法提供的信息不是很有用。因此<strong>通常子类应该覆盖该方法，提供更有意义的信息</strong></li>
</ul>
</li>
</ul>
<h3 id="equals的覆盖"><a href="#equals的覆盖" class="headerlink" title="equals的覆盖"></a>equals的覆盖</h3><ul>
<li>equals用于判断一个对象同另一个对象的所有成员内容是否相等。覆盖时应考虑：<ul>
<li>对<strong>基本类型数值</strong>成员。直接使用==判断即可。</li>
<li>对<strong>引用类型变量</strong>成员。则需要对这些变量成员调用equals判断，不能用==。</li>
</ul>
</li>
<li>覆盖equals函数，最好<strong>同时覆盖hashCode()方法</strong>，该方法返回对象的hashCode值。<ul>
<li>需要对比的时候，<strong>首先用hashCode去对比</strong>，如果hashCode不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,<strong>如果hashCode相同，此时再用equals()比，如果equals()也相同</strong>，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</li>
</ul>
</li>
<li>覆盖equals函数，首先用instanceof检查参数的类型是否和当前对象的类型一样。<br>instanceof和加减乘除一样，当作运算符。<br>例如在Circle类中覆盖<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>&#123;   <span class="hljs-comment">//父类的参数就为Object，覆盖参数必须与父类一致</span><br>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Circle)	<span class="hljs-comment">//应先检查另一对象o的类型 检查参数o的类型是否与当前对象的类型一样。</span><br>            <span class="hljs-keyword">return</span>  radius==((Circle)o).radius;  <span class="hljs-comment">//o中无radius这个变量，需要强制类型转换</span><br>        <span class="hljs-comment">//上面的式子，radius也可以写成this.radius,是c1的radius</span><br>        <span class="hljs-comment">//o是c2传进equals时被转换为的Object，需要强制类型转换。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br>Circle c1= ...;<br>Circle c2= ...;<br>c1.equals(c2);<br><span class="hljs-comment">//c1为Circle，为this引用，在对象中就是Circle</span><br><span class="hljs-comment">//c2在进入函数后被转换为Object类，相当于 Object o=c2； 实际上在函数中，o还是有Circle类的各种实例</span><br><span class="hljs-comment">//只不过由于在进入equals时转换成Object，在上文中需要再强制转换为Circle再与this.radius比较</span><br></code></pre></div></td></tr></table></figure></li>
</ul>
<blockquote>
<p>hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？<br> <br>     因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？<br> <br>           因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：<br> <br>         1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。<br>         2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。<br> <br>所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！  </p>
</blockquote>
<h3 id="clone的覆盖"><a href="#clone的覆盖" class="headerlink" title="clone的覆盖"></a>clone的覆盖</h3><ul>
<li>要实现一个类的clone方法，首先这个类需要实现Cloneable接口，否则会抛出CloneNotSupportedException异常</li>
<li>Cloneable接口其实就是一个标记接口，里面没有定义任何接口方法，只是用来<strong>标记</strong>一个类是否支持克隆：没有实现该接口的类不能克隆</li>
<li>还要公有覆盖clone方法，即Object类里clone方法是保护的，<strong>子类覆盖这个方法时应该提升为public</strong></li>
<li>方法里应实现<strong>深拷贝</strong>clone，Object的clone实现是<strong>浅拷贝</strong>。<ul>
<li>浅拷贝指所有类型都直接赋值=，这就导致数值类型没问题，但是引用类型就不是拷贝，而是指向同一个值<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    String j;<br>&#125;<br><br>A o1=...;<br>A <span class="hljs-number">02</span>;<br>o2.i=o1.i; <span class="hljs-comment">//值类型可以</span><br><span class="hljs-number">02.</span>j=o1.j; <span class="hljs-comment">//引用类型不可以，因为这会导致o2.j指向o1.j，而不是拷贝。</span><br></code></pre></div></td></tr></table></figure></li>
</ul>
</li>
<li>克隆的深度：要克隆的对象可能包含基本类型数值成员或引用类型变量成员，对于基本类型数值成员使用=赋值即可，对于引用类型成员则需要<strong>进一步嵌套调用该成员的克隆方法</strong>进行赋值。  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">o2.j=o1.j  <span class="hljs-comment">//错误，引用类型</span><br>o2.j=o1.j.clone();  <span class="hljs-comment">//实现该成员的克隆方法后</span><br></code></pre></div></td></tr></table></figure></li>
</ul>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//首先必须实现Cloneable接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] values = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE]; <span class="hljs-comment">//A的values成员是数组</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getValues()&#123;<br>        <span class="hljs-keyword">return</span> values;<br>    &#125;<br>    <span class="hljs-comment">//覆盖clone方法，提升为public，只是调用Object的的clone，</span><br>    <span class="hljs-comment">//不修改行为</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<span class="hljs-comment">//Clone方法不带参数，返回Object，同时可能会抛出CloneNotSupportedException异常</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<span class="hljs-comment">//调用Object的clone</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        A o1 = <span class="hljs-keyword">new</span> A();<br>        A o2 = (A)(o1.clone()); <span class="hljs-comment">//clone返回Object，因此要强制类型转换</span><br>        System.out.println(o1 == o2); <span class="hljs-comment">//false，说明clone返回的是新的引用</span><br>        System.out.println(o1.getValues() == o2.getValues()); <span class="hljs-comment">//true 但为浅拷贝克隆</span><br>    &#125;				<span class="hljs-comment">//因为o1和o2内部values引用指向了内存里同一个数组					</span><br>    <span class="hljs-comment">//说明A的clone方法里，所调用的super.clone()是浅拷贝</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>如上，A实现Cloneable接口，表示A支持克隆，然后A中的clone覆盖父类Object中的clone，直接调用了父类clone，得到的结果表示父类clone为浅拷贝。  </p>
</blockquote>
<p>为此，若要实现类A的深拷贝，如下  </p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] values = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE];<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getValues()&#123; <span class="hljs-keyword">return</span> values; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValues</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] newValues)</span> </span>&#123;<span class="hljs-comment">//添加setValues方法，设置内部数组内容</span><br>	<span class="hljs-keyword">this</span>.values = newValues;<br>    &#125;<br>    <br>    <span class="hljs-comment">//覆盖equals方法，比较二个A类型对象内容是否一样</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> A)&#123;<br>            A o = (A)obj;<br>            <span class="hljs-keyword">return</span> java.util.Arrays.equals(<span class="hljs-keyword">this</span>.getValues(),o.getValues());<br>        &#125;<span class="hljs-comment">//Attays中已完备的equals</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//覆盖clone方法，提升为public，重新实现为深拷贝</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        A newObj = <span class="hljs-keyword">new</span> A(); <span class="hljs-comment">//new一个新对象，不好的选择</span><br>  建议：  上一行语句换为 A newObj=(A)<span class="hljs-keyword">super</span>.clone();<br>	newObj.values = <span class="hljs-keyword">this</span>.values.clone(); <span class="hljs-comment">//数组的clone是深拷贝，如果去掉clone，则是浅拷贝</span><br>	<span class="hljs-keyword">return</span> newObj;<br>    &#125;<br><br>    <span class="hljs-comment">//覆盖toString方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuffer buf = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v : values)&#123;<br>            buf.append(v + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> buf.toString().trim(); <span class="hljs-comment">//去掉最后多余的空格</span><br>    &#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        A o1 = <span class="hljs-keyword">new</span> A();<br>        o1.setValues(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;);<br>        A o2 = (A)(o1.clone());<br>        System.out.println(o1 == o2); <span class="hljs-comment">//false</span><br>        System.out.println(o1.getValues() == o2.getValues()); <span class="hljs-comment">//false 说明不是浅拷贝克隆</span><br>        System.out.println(o1.equals(o2)); <span class="hljs-comment">//true,二个对象的内容相等， 说明是深拷贝克隆          </span><br>        System.out.println(o2.toString()); <span class="hljs-comment">//显示 1 2 3 4 5 6 7 8 9 10</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<ul>
<li>如果B类里包含了A类型成员，只要A实现了深拷贝克隆，则B可以很方便地实现深拷贝克隆。如C类里包含了B类型成员，D类型里包含了C类型成员…,以此类推，只要每个类型都实现了深拷贝克隆，那么<strong>最外层的包装类可以非常方便的实现深拷贝克隆</strong>。这就是第37页PPT里讲到的<strong>克隆的深度问题</strong><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    A a;    <span class="hljs-comment">//引用类型成员</span><br>    <span class="hljs-keyword">int</span> i;  <span class="hljs-comment">//值类型</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        B newObj = <span class="hljs-keyword">new</span> B();<br>        newObj.i = <span class="hljs-keyword">this</span>.i;   <span class="hljs-comment">//值类型成员直接=赋值</span><br>        newObj.a = (A)(<span class="hljs-keyword">this</span>.a.clone()); <span class="hljs-comment">//引用类型的成员不能直接赋值，必须调用clone方法，深拷贝</span><br>        <span class="hljs-keyword">return</span> newObj;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h2 id="多态性、动态绑定和对象的强制类型转换"><a href="#多态性、动态绑定和对象的强制类型转换" class="headerlink" title="多态性、动态绑定和对象的强制类型转换"></a>多态性、动态绑定和对象的强制类型转换</h2><ul>
<li>继承关系使一个子类可以继承父类的特征(属性和方法），并附加新特征</li>
<li>子类是父类的具体化（沿着继承链从祖先类到后代类，特征越来越具体；反过来，从后代类往祖先类回溯，越来越抽象）</li>
<li>每个<strong>子类的实例都是父类的实例</strong>（<strong>子类对象ISA父类</strong>），但反过来不成立  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class Student extends Person&#123; …&#125;<br>Person p = <span class="hljs-keyword">new</span> Student();<span class="hljs-comment">//OK 父类引用可直接指向子类对象</span><br>Student s = <span class="hljs-keyword">new</span> Person();<span class="hljs-comment">//error  子类引用不能指向父类对象</span><br></code></pre></div></td></tr></table></figure></li>
<li>这个特性是多态的重要基础  <blockquote>
<p>多态：通过引用变量调用实例函数时，根据所引用的实际对象的类型，执行该类型的相应实例方法，从而表现出不同的行为称为多态。通过<strong>继承</strong>时<strong>覆盖父类的实例方法实现多态</strong>。多态实现的原理：在<strong>运行时</strong>根据引用变量指向对象的实际类型，<strong>重新计算调用方法的入口地址（晚期绑定）。</strong></p>
</blockquote>
</li>
</ul>
<p>先看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-comment">//父类</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Greeting</span><span class="hljs-params">()</span></span>&#123; <br>        System.out.println(<span class="hljs-string">&quot;Best wish from a person!&quot;</span>); <br>        &#125; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;	 <span class="hljs-comment">//子类</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Greeting</span><span class="hljs-params">( )</span></span>&#123; <br>        System.out.println(<span class="hljs-string">&quot;Best wish from a employee!&quot;</span>);<br>        &#125; <br>    &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;   <span class="hljs-comment">//子类的子类</span><br>		<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Greeting</span><span class="hljs-params">( )</span></span>&#123; <br>            System.out.println(<span class="hljs-string">&quot;Best wish from a manager!&quot;</span>);<br>            &#125; <br>        &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingTest1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>       <span class="hljs-comment">//父类引用变量可以引用本类和子类对象，p1,p2,p3的声明类型都是Person(父类型），p2,p3执行子类对象</span><br>       Person p1= <span class="hljs-keyword">new</span> Person( ),p2= <span class="hljs-keyword">new</span> Employee( ),p3= <span class="hljs-keyword">new</span> Manager( );      <br>	p1.Greeting( ); <span class="hljs-comment">//调用Person的Greeting()    ，由于实际指向对象类型是Person</span><br> 	p2.Greeting( ); <span class="hljs-comment">//调用Employee的Greeting()  ，由于实际指向对象类型是Employee</span><br> 	p3.Greeting( ); <span class="hljs-comment">//调用Manager的Greeting()   ，由于实际指向对象类型是Manager</span><br>	<br>    &#125;<br>&#125;<br><span class="hljs-comment">//根据实际指向的类型，执行实际的实例方法</span><br></code></pre></div></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingSender</span></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span> <span class="hljs-params">(Person p)</span></span>&#123; <br>        p.Greeting(); <span class="hljs-comment">//编译时应该是Person的Greeing</span><br>        &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingTest1</span></span>&#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>	GreetingSender g = <span class="hljs-keyword">new</span> GreetingSender();<br>       	g.newYearGreeting(<span class="hljs-keyword">new</span> Person()); 	<span class="hljs-comment">//调用Person的Greeting()</span><br>       	g.newYearGreeting(<span class="hljs-keyword">new</span> Employee());	<span class="hljs-comment">//调用Employee的Greeting()</span><br>       	g.newYearGreeting(<span class="hljs-keyword">new</span> Manager());	<span class="hljs-comment">//调用Manager的Greeting()</span><br>      &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<p>以最后一条语句为例来解释多态特性：<br>当<strong>实参new Manager()传给形参Person p</strong>时，<strong>等价于Person p = new Manager()</strong>, 因此执行p.Greeting()语句时根据形参p指向的对象的<strong>实际类型动态计算</strong>Greeting方法的入口地址，调用了Manager的Greeting()</p>
<ul>
<li><p>这段程序的微妙之处在于：</p>
<ul>
<li>GreetingSender类的newYearGreeting方法的参数是Person类型，那么<br>newYearGreeting的行为应该是Person对象的行为。</li>
<li>但是在实际运行时我们看到<strong>随着实参对象类型的变化</strong>， newYearGreeting<br>方法却表现出了多种不同的行为，这种机制称为多态</li>
</ul>
</li>
<li><p>仔细观察程序，可以发现产生多态的三个重要因素：</p>
</li>
</ul>
<ol>
<li>不同类之间有继承链</li>
<li>newYearGreeting方法的<strong>参数</strong>类型用的<strong>父类类型</strong></li>
<li>newYearGreeting调用的Greeting方法都被<strong>子类</strong>用自己的行为<strong>覆盖</strong><br>满足了这三个条件，用继承链中不同子类的对象做为方法的实参去调用方法会使该方法表现出不同的行为。由于子类的实例也是父类的实例，所以用子类对象作为实参传给方法中的父类型的形参是没有问题的。</li>
</ol>
<ul>
<li>多态条件：<strong>父类变量可引用本类和子类对象</strong>，子类对象isA父类对象</li>
<li>当调用<strong>实例方法</strong>时，由Java虚拟机动态地决定所调用的方法，称为动态绑定(dynamic binding)或者晚期绑定或者延迟绑定(lazy binding)或者多态。<br>假定对象o是类C1的实例，C1是C2的子类，C2是C3的子类，…，Cn-1是Cn的子类。也就是说，Cn是最一般的类，C1是最具体的类。在Java中，Cn是Object类。<br>如果调用继承链里子类型C1对象o的方法p，Java虚拟机按照C1、C2、…、Cn的顺序依次查找方法p的实现。一旦找到一个实现，将停止查找，并执行找到的第一个实现(覆盖的实例函数)。<br><img src="https://raw.githubusercontent.com/Trent-Liu/picture/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-03-29%20231337.png" srcset="/img/loading.gif" lazyload alt="haha">  </li>
</ul>
<p>上例中，若p3指向Manager类的对象。当通过newYearGreeting(p3)方法去调用p3.Greeting()方法时，Java虚拟机会沿着继承链，从Manager类到父类查找Greeting的实现，结果找到Manager自己的实现<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-03-29%20231740.png?raw=true" srcset="/img/loading.gif" lazyload alt="haha">  </p>
<p>若Employee覆盖了Greeting，而Manager没有覆盖，那么p3.Greeting()调用的是Employeede的  </p>
<h3 id="通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用"><a href="#通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用" class="headerlink" title="通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用"></a>通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用</h3><ul>
<li>由于父类变量可以引用子类对象，针对父类型设计的任何代码都可以<strong>应用于子类对象</strong>。  <ul>
<li>newYearGreeting(Person p){p.Greeting()}这段代码可以应用于所有Person子类型对象</li>
<li>多态性允许方法使用更通用的类作为参数类型。</li>
<li>如果方法参数是父类，那么这个参数可以接受任何子类对象作为实参。当调用这对象的方法时，将动态绑定方法的实现。<ul>
<li>newYearGreeting(Person p):该方法能接受从Person类型开始所有子类型对象作为实参</li>
<li>newYearGreeting(Manager p):该方法只能能接受从Manager类型开始所有子类型对象作为实参  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>哪个更好？<br>显然前者通用性更强。  </p>
<p>如果没有多态机制，针对Person，Employee及Manager类，我们必须写出三个重载版本的newYearGreeting函数</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingSender</span></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span><span class="hljs-params">(Person p)</span></span>&#123; p.Greeting(); &#125; 	 	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span><span class="hljs-params">(Employee e)</span></span>&#123; e.Greeting(); &#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span><span class="hljs-params">(Manager m)</span></span>&#123; m.Greeting(); &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>假如我们新增加一个从Manager派生的CEO类，也实现了Greeting方法，我们需要增加一个新的newYearGreeing的重载版本。</li>
<li>更为糟糕的是，我们需要重新编译GreetingSender类。</li>
<li>回到第44页实现的多态版的GreetingSender类，可以适用于任何Person子类型，哪怕GreetingSender类作为商业类已经卖出去了，对后来新派生的CEO类型都可以不用重新编译地很好地工作</li>
</ul>
<hr>
<ul>
<li><p>父类变量引用子类对象，可视为将子类对象转换为父类（不需强制类型转换）。</p>
</li>
<li><p>类型转换(type casting)可以将一个对象的类型转换成继承链中的另一种类型。</p>
<ul>
<li>从子类到父类的转换是合法的，称为隐式转换。<br><code>Person p=new Manager();//将子类对象转换为父类对象</code></li>
<li>从父类到子类必须显式（强制）转换。<br><code>Manager m = p; //编译错 ，p是Person父类型，Person不一定是Manager</code><br><code>Manager m = (Manager)p;//ok，但转换前没有检查 </code>  </li>
<li>从父类到子类转换必须显式转换，转换前应进行检查更安全。<br><code>Manager m = null;</code><br><code>if(p instanceof Manager) m= (Manager)p; //安全：转换前检查 </code>  </li>
</ul>
</li>
<li><p>为什么从父类到子类转换必须强制类型转换？</p>
</li>
<li><p>首先要理解类型检查（type checking）发生在编译时</p>
</li>
<li><p>然后要理解Person p = new Manager()的真正涵义<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-03-29%20232726.png?raw=true" srcset="/img/loading.gif" lazyload alt="haha">  </p>
</li>
<li><p>但是创建Manager对象并由p来引用是在运行时发生</p>
</li>
<li><p>因为程序还没运行，编译器无法知道p会指向什么对象，<strong>编译器在编译时只能根据变量p的声明类型（Person）来类型检查</strong></p>
</li>
<li><p>当编译器检查到 Manager m = p；编译器认为Person类型引用p要赋值给类型为Manager类型引用，扩展内存可能引起麻烦且不安全，因此，编译器认为类型不匹配，会报错。</p>
</li>
<li><p>加上强制转换 Manager m = (<strong>Manager</strong>)p；意思是强烈要求编译器，把p解释成Manager类型，风险我来承担。这个时候编译器就按Manager类型来解释p</p>
</li>
<li><p>因此，强制类型转换意味着你自己承担风险，编译器不会再做类型检查。</p>
</li>
<li><p>强制类型转换的风险是：运行时如果p指向的对象不是Manager的实例时程序会出错。</p>
</li>
<li><p>为了避免风险，最好用instanceof来做实例类型检查。</p>
</li>
</ul>
<h4 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h4><ul>
<li>可以用instanceof操作符判断一个引用指向的对象是否是一个类的实例。表达式返回boolean值。</li>
<li>语法  <div class="hljs code-wrapper"><pre><code>`referenceVariable  instanceof  TypeName`  
</code></pre></div>
</li>
<li>所以上面的例子安全的写法为： <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Person p = <span class="hljs-keyword">new</span> Manager()<br><span class="hljs-keyword">if</span>（p <span class="hljs-keyword">instanceof</span> Manager）<br>	Manager m = （Manager）p;<br></code></pre></div></td></tr></table></figure></li>
<li>意思是如果p指向的对象真的是Manager实例，再强制转换类型</li>
</ul>
<hr>
<ul>
<li>重载发生在编译时(Compile time)，编译时编译器根据实参比对重载方法的形参找到最合适的方法。</li>
<li>多态发生在运行(Run time)时，运行时JVM根据变量所引用的对象的真正类型来找到最合适的实例方法。</li>
<li>有的书上把重载叫做“编译时多态”，或者叫“早期绑定”(早期指编译时)。</li>
<li>多态是晚期绑定(晚期指运行时)</li>
<li>绑定是指找到函数的入口地址的过程。</li>
</ul>
<hr>
<ul>
<li>编写程序，创建两个几何对象：圆和矩形。调用displayObject来显示结果。<ul>
<li>如果对象是圆，显示半径和面积</li>
<li>如果对象是矩形，显示面积</li>
<li>警告: 对象访问运算符(.)优先于类型转换运算符。使用括号保证在(.)运算符之前转换<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">((Circle)object).getArea() <span class="hljs-comment">//OK</span><br>(Circle)object.getArea(); <span class="hljs-comment">//错误</span><br></code></pre></div></td></tr></table></figure></li>
</ul>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96/">实例方法覆盖</a>
                    
                      <a class="hover-with-bg" href="/tags/Object%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/">Object中的方法</a>
                    
                      <a class="hover-with-bg" href="/tags/clone%E7%9A%84%E8%A6%86%E7%9B%96/">clone的覆盖</a>
                    
                      <a class="hover-with-bg" href="/tags/equals%E7%9A%84%E8%A6%86%E7%9B%96/">equals的覆盖</a>
                    
                      <a class="hover-with-bg" href="/tags/%EF%BC%81%E5%A4%9A%E6%80%81/">！多态</a>
                    
                  </div>
                
              </div>

              <!--
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
-->
<p class="note note-warning">
  <strong>本文作者: </strong><a href="/">Trent-Liu</a> <br>
  <strong>本文链接: </strong><a href="https://trent-liu.github.io/2021/03/26/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E4%B8%8B/">https://trent-liu.github.io/2021/03/26/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E4%B8%8B/</a> <br>
  <strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
     </p>
     


              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/03/28/Java%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java的常用包</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/26/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/">
                        <span class="hidden-mobile">Java笔记——继承和多态上</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function () {
        var gitalk = new Gitalk({
          clientID: '81506d8985202387cbbd',
          clientSecret: '40c6250a001a80f7986e1ec1a375dc2d7e82f7d9',
          repo: 'Pigsty',
          owner: 'Trent-Liu',
          admin: ["Trent-Liu"],
          id: '905267e4f6c0577e853ddf91752ecbd2',
          language: 'zh-CN',
          labels: ["Gitalk"],
          perPage: 10,
          pagerDirection: 'last',
          createIssueManually: true,
          distractionFreeMode: false,
          proxy: '&lt;your own proxy&gt;/https://github.com/login/oauth/access_token'
        });
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<div class="text-center py-1">  
<div>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("03/20/2021 17:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "🚀 for&nbsp"+dnum+"&nbspdays";  //此次自定义显示内容
      document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" + snum + "&nbspsec";
  }  //此次自定义显示内容
  setInterval("createtime()",250);
  </script>
</div>

<div class="text-center py-1">   
  <div>
    <span>Copyright © 2021</span></a>
    <a href="https://erenspace.cool/" target="_blank" rel="nofollow noopener">
     <span>Trent-Liu‘s Pigsty</span></a>    <br>
  </div>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>

<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>