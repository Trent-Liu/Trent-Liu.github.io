

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="个人博客">
  <meta name="author" content="Trent-Liu">
  <meta name="keywords" content="分享在HUST中的一些学习经历">
  
  <title>C++剑指offer2 - Pigsty</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/a11y-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"trentliu.cn","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>





<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Pigsty</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/TreeHole/">
                <i class="iconfont icon-wechat-fill"></i>
                TreeHole
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/wallhaven-dgkmpo_3840x2160.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++剑指offer2">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Trent-Liu
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-03 08:00" pubdate>
        2022年3月3日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      14k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      217
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++剑指offer2</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月11日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h5 id="剑指offer-001-整数除法"><a href="#剑指offer-001-整数除法" class="headerlink" title="剑指offer 001 整数除法"></a>剑指offer 001 整数除法</h5><p>要点在于掌握int型数据的存储</p>
<p>正负数的边界不同，0x8000 0000表示最小的负数-2^-31，不存在对应的正数，而其他的负数均存在对应的正数，因此可以先单独处理结果为2^31，即那个不存在的最大正数的情况，被除数应该是INI_MIN，除数应该是-1，结果应返回INT_MAX</p>
<p>除此之外，由于负数的范围比正数大1，因此可以先将正数转化为负数，对两个负数进行除法，最后再进行符号的调整。</p>
<p>由于题目中不可以使用*，/，%，我们考虑使用减法来实现除法，即不断减去二的倍数。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-comment">//第一种情况，首先排除结果为2^31，即int型无法表示的最大正数的情况</span><br>        <span class="hljs-keyword">if</span> (a == INT_MIN &amp;&amp; b== <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> INT_MAX;<br>        &#125;<br>        <span class="hljs-comment">//保存最终结果的符号，只有当一正一负，最终结果是负数</span><br>        <span class="hljs-keyword">int</span> flag = (a &gt; <span class="hljs-number">0</span>) ^ (b &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//再将正数的被除数或者除数转化为正数</span><br>        <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>) &#123;<br>            a = -a;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>            b = -b;<br>        &#125;<br><br>        <span class="hljs-comment">//这里设置res的类型为unsigned是必须的，考虑下面商绝对值的结果是2^31的情况</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//只要被除数仍然小于等于除数（负数），则还可以继续除</span><br>        <span class="hljs-keyword">while</span> (a &lt;= b) &#123;<br>            <span class="hljs-comment">//计算本轮，被除数剩下的部分等于2的多少倍的除数</span><br>            <span class="hljs-keyword">int</span> value = b;<br>            <span class="hljs-keyword">int</span> quotient = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//这里限定每轮value的值大于等于0xc0000 0000 是必要的，如果小于，且仍大于被除数，则这一轮value+value就会越界。</span><br>            <span class="hljs-keyword">while</span> (value &gt; <span class="hljs-number">0xc0000000</span> &amp;&amp; a &lt;= value + value) &#123;<br>                quotient += quotient;<br>                value += value;<br>            &#125;<br>            res += quotient;<br>            a -= value;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> flag == <span class="hljs-number">1</span> ? res : -res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<h5 id="剑指offer-002-二进制加法"><a href="#剑指offer-002-二进制加法" class="headerlink" title="剑指offer 002 二进制加法"></a>剑指offer 002 二进制加法</h5><p>最朴素的思想，从字符串最末端，即表示的二进制的第0位开始进行运算，记录进位端以及每次运算的结果</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">addBinary</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b)</span> </span>&#123;<br>        <span class="hljs-built_in">string</span> res;<br>        <span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>;   <span class="hljs-comment">//二进制串a的末端开始</span><br>        <span class="hljs-keyword">int</span> j = b.size() - <span class="hljs-number">1</span>;   <span class="hljs-comment">//二进制串b的末端开始</span><br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;      <span class="hljs-comment">//进位端</span><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry !=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//当二进制串a没有运算完，计算当前位是1还是0，否则为0</span><br>            <span class="hljs-keyword">int</span> tempa = i &gt;=<span class="hljs-number">0</span> ? a[i--] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//二进制串b同理</span><br>            <span class="hljs-keyword">int</span> tempb = j &gt;=<span class="hljs-number">0</span> ? b[j--] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">char</span> temp_result = tempa + tempb + carry;<br>            carry =  temp_result / <span class="hljs-number">2</span>;<br>            res += to_string(temp_result%<span class="hljs-number">2</span>);<br><br>        &#125;<br>        reverse(res.begin(), res.end());<br>        <span class="hljs-keyword">return</span> res;<br>        <br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>to_string() 将数字量转化为字符串</p>
<p>res.append(stirng) 等价于 res += string</p>
<p>字符串中push_back(char)的参数是char型的</p>
<h5 id="剑指offer-003-前n个数字二进制中1的个数-动态规划"><a href="#剑指offer-003-前n个数字二进制中1的个数-动态规划" class="headerlink" title="剑指offer 003 前n个数字二进制中1的个数 动态规划"></a>剑指offer 003 前n个数字二进制中1的个数 动态规划</h5><p>可以很轻松的看出这道题可以通过动态规划解决，将所有2的倍数为界限，按区域划分即可，比如4的二进制表示为0100，8的二进制表示为1000，对于4到8之间的数，比如7，只需要7-4=3，3的二进制表示为0011，7的二进制表示为0111，7二进制中1的个数就是4的个数加（7-4）的个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">int</span> boundary = <span class="hljs-number">1</span>;<br>        res[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == boundary * <span class="hljs-number">2</span>) &#123;<br>                res[i] = <span class="hljs-number">1</span>;<br>                boundary *= <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res[i] = <span class="hljs-number">1</span> + res[i - boundary];<br>            &#125;<br><br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-004-只出现一次的数字"><a href="#剑指offer-004-只出现一次的数字" class="headerlink" title="剑指offer 004 只出现一次的数字"></a>剑指offer 004 只出现一次的数字</h5><p>方法1： 哈希表，很容易想到，只需要统计每个数字出现的次数，从中找到只出现1次的数字就可以</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num: nums) &#123;<br>            ++<span class="hljs-built_in">map</span>[num];<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> freq : <span class="hljs-built_in">map</span>) &#123;<br>            <span class="hljs-keyword">if</span> (freq.second == <span class="hljs-number">1</span>) &#123;<br>                ans = freq.first;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。</p>
<p>方法2</p>
<p>由于除了需要寻找的那个数字，其他数字均出现三次，因此我们可以按位求出所要的结果</p>
<p>为求结果的某一位，将所有数字的这一位相加，除了答案的数字，其他数字的这一位均出现3此，相加值为0或者3，因此一定是3的倍数，只需要将最终结果%3，就可以只剩下所要求结果的那一位。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> tmp_ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> tmp_tool = <span class="hljs-number">1</span> &lt;&lt; i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>                tmp_ans += (num &amp; tmp_tool) &gt;&gt; i;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tmp_ans % <span class="hljs-number">3</span>) &#123;<br>                ans |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-005-单词长度的最大乘积"><a href="#剑指offer-005-单词长度的最大乘积" class="headerlink" title="剑指offer 005 单词长度的最大乘积"></a>剑指offer 005 单词长度的最大乘积</h5><p>要找到两个不包含相同字符的字符串，最直接的想法是对于每一个字符串进行循环比较，然而这种方法的时间复杂度过于复杂，很不适合。</p>
<p>考虑到只需要比较是否存在相同字符，我们可以采用二进制存储的方法，当某个字符串中出现某个字符，就保存在某一位，最后比较两个字符串是否有公共字符，只需要进行与操作即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; b_words;<br>        <span class="hljs-comment">//构建出一个数组，存放每个字符串的字符存在情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> word : words) &#123;<br>            <span class="hljs-keyword">int</span> b_tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word) &#123;<br>                b_tmp |= <span class="hljs-number">1</span> &lt;&lt; (c-<span class="hljs-string">&#x27;a&#x27;</span>);<br>            &#125;<br>            b_words.push_back(b_tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.size(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; words.size(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (b_words[i] &amp; b_words[j]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">int</span> tmp = words[i].size() * words[j].size();<br>                    res = res &gt; tmp ? res : tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-006-排序数组中的两个数字之和"><a href="#剑指offer-006-排序数组中的两个数字之和" class="headerlink" title="剑指offer 006 排序数组中的两个数字之和"></a>剑指offer 006 排序数组中的两个数字之和</h5><p>给定的数组已经完成排序，因此思路很容易得到，使用双指针法，从左右两端进行比较</p>
<p>如果当前数字和大于target，右指针向左移动，如果当前数字和小于target，左指针向右移动。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = numbers.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] == target) &#123;<br>                <span class="hljs-keyword">return</span> &#123;left,right&#125;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] &gt; target) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-007-数组中和为0的三个数"><a href="#剑指offer-007-数组中和为0的三个数" class="headerlink" title="剑指offer 007 数组中和为0的三个数"></a>剑指offer 007 数组中和为0的三个数</h5><p>这道题看上去复杂，实际上和上一道题有很大的相似度</p>
<p>可以先对数组进行排序，然后固定一个元素nums[i]，将之后的元素按照双指针法，寻找两数和为-nums[i]的位置即可，但是这道题没有上一道题不存在重复元素的限制，因此为了提高效率，可以进行一定的去重处理，其实只要遇见与上一个数字重复的数字，直接跳过即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; threeSum(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">if</span> (nums.size() &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        <span class="hljs-comment">//排序</span><br>        sort(nums.begin(), nums.end());<br><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">//首先要确定第一个值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size()<span class="hljs-number">-2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//接下来只需要用双指针法找结果为target的组合</span><br>            <span class="hljs-keyword">int</span> target = -nums[i];<br>            <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>, right = nums.size() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span> (nums[left] + nums[right] == target) &#123;<br>                    res.push_back(&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-comment">//当遇见重复时需要跳过</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[++left]);<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[--right]);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] + nums[right] &gt; target) &#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    left++;<br>                &#125;<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-008-和大于等于target的最短子数组"><a href="#剑指offer-008-和大于等于target的最短子数组" class="headerlink" title="剑指offer 008 和大于等于target的最短子数组"></a>剑指offer 008 和大于等于target的最短子数组</h5><p>方法一可以使用双指针——滑动窗口法，逐渐后移，求出每个以当前尾指针为末尾的最短的符合条件的子数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = nums.size();<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = INT_MAX;<br>        <span class="hljs-keyword">while</span> (end &lt; length) &#123;<br>            <span class="hljs-comment">//尾指针后移，同时sum增加尾指针对应的新元素</span><br>            sum += nums[end];<br>            <span class="hljs-comment">//当此时的子数组已经满足条件，则逐渐回缩头指针，直到找到以当前尾指针为末尾的子数组的最短长度</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                ans = min(ans, end - start + <span class="hljs-number">1</span>);<br>                sum -= nums[start];<br>                start++;<br>            &#125;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == INT_MAX ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-009-乘积小于K的子数组"><a href="#剑指offer-009-乘积小于K的子数组" class="headerlink" title="剑指offer 009 乘积小于K的子数组"></a>剑指offer 009 乘积小于K的子数组</h5><p>上一道题要求出的是最短子数组，而这道题要求出成绩小于K的所有子数组，我们还是使用双指针法，求出每个以当前尾指针为末尾的那个最大的符合条件的子数组，然后只需要增加当前尾指针为末尾的新增的子数组数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSubarrayProductLessThanK</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = nums.size();<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; length) &#123;<br>            sum *= nums[end];<br>            <span class="hljs-comment">//这里start &lt;= end是必要的，因为可能存在k为0的情况，此时若不加此限制条件，start将一直增加，直到越界。</span><br>            <span class="hljs-keyword">while</span> (start &lt;= end &amp;&amp; sum &gt;= k) &#123;<br>                sum /= nums[start];<br>                start++;<br>            &#125;<br>            <span class="hljs-comment">//找到以end为尾指针的最长子数组，则只需要增加以end为末尾的所有满足条件的子数组数量，共end - start + 1 个</span><br>            ans += end - start + <span class="hljs-number">1</span>;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-010-和为k的子数组"><a href="#剑指offer-010-和为k的子数组" class="headerlink" title="剑指offer 010 和为k的子数组"></a>剑指offer 010 和为k的子数组</h5><p>同样是求连续的子数组，但是数组中出现了负数，则这种情况不能使用滑动窗口</p>
<p>滑动窗口的条件是while窗口内元素超过或者不满足条件时，进行移动，如果数组存在了负数，则我们无法决定左移动还是右移动。</p>
<p>一种场景存在多种可能，就使用数组中另一种常用的算法——前缀和。</p>
<p>前缀和的思想是，申请一个哈希表，遍历数组，对于遍历到的每个元素，存入这个元素之前所有元素的和，并且查找此时哈希表中有没有当前前缀和-目标的值，若存在，说明中间存在这一段满足要求。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;<br>        <span class="hljs-built_in">map</span>.insert(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历所有的前缀和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            sum += num;<br>            <span class="hljs-comment">//查看此时哈希表中之前有没有存入前缀和为sum-k的情况，如果有，就存在子数组的和为k</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.count(sum - k)) &#123;<br>                res += <span class="hljs-built_in">map</span>[sum - k];<br>            &#125;<br>            <span class="hljs-comment">//存入当前位置前缀和的值</span><br>            <span class="hljs-built_in">map</span>[sum]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>map::count()是C++ STL中的内置函数，如果在映射容器中存在带有键K的元素，则该函数返回1。如果容器中不存在键为K的元素，则返回0。</p>
<h5 id="剑指offer-011-0和1个数相同的子数组"><a href="#剑指offer-011-0和1个数相同的子数组" class="headerlink" title="剑指offer 011 0和1个数相同的子数组"></a>剑指offer 011 0和1个数相同的子数组</h5><p>一个思路是既然要求0和1个数相同的子数组，不妨将0看成-1，问题就转化为求和为0的子数组</p>
<p>采用上题的思路，对于这种前缀和问题仍然需要补充一个起始点，</p>
<p>求最长前缀和，对于每种出现的和的情况，只需要保存最早出现的那个。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxLength</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;<br>        <span class="hljs-comment">//初始边界</span><br>        <span class="hljs-built_in">map</span>.insert(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-comment">//计算前缀和，0当成-1</span><br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count--;<br>            &#125;<br>            <span class="hljs-comment">//若之前保存的前缀和中存在这个和，则计算当前最大长度</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.count(count)) &#123;<br>                res = max(res, i - <span class="hljs-built_in">map</span>[count] + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//每种前缀和只需要保存最早出现的</span><br>                <span class="hljs-built_in">map</span>.insert(&#123;count, i+<span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>







<h5 id="剑指offer-012-左右两边子数组的和相等"><a href="#剑指offer-012-左右两边子数组的和相等" class="headerlink" title="剑指offer 012  左右两边子数组的和相等"></a>剑指offer 012  左右两边子数组的和相等</h5><p>求一个中心下标，即这个下标的左右两侧的元素的和相等，我们想到的思路是</p>
<p>首先计算所有元素的和，只需要进行一次遍历，找到某个位置，这个位置左边元素和的两倍等于所有元素和减去当前位置的值</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//计算总和</span><br>        <span class="hljs-keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> cursum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-comment">//当前位置的前一个位置的所有和的两倍是否等于综合减当前位置。</span><br>            <span class="hljs-keyword">if</span> (cursum * <span class="hljs-number">2</span> == sum - nums[i]) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            cursum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>accumulate函数将一段数字从头到尾累加起来，或者使用指定的运算符进行运算<br> accumulate函数的前两个参数指定累加的范围，第三个参数为累加的初值，第四个参数为进行的操作，默认为累加<br> 使用accumulate要添加<code>#include&lt;numeric&gt;</code></p>
<h5 id="剑指offer-013-二维子矩阵的和"><a href="#剑指offer-013-二维子矩阵的和" class="headerlink" title="剑指offer 013 二维子矩阵的和"></a>剑指offer 013 二维子矩阵的和</h5><p>很无聊，左上角和右下角的标度不一样是实在没想到</p>
<p>Matrix.resize(m+1, vector<int>(n+1));</int></p>
<p>vector&lt;vector&lt;int&gt;&gt;的重新设置大小</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    NumMatrix(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix) &#123;<br>        <span class="hljs-keyword">int</span> m = matrix.size();<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">if</span> (m != <span class="hljs-number">0</span>) &#123;<br>            n = matrix[<span class="hljs-number">0</span>].size();<br>            Matrix.resize(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                Matrix[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Matrix[i+<span class="hljs-number">1</span>][j] + Matrix[i][j+<span class="hljs-number">1</span>] + matrix[i][j] - Matrix[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Matrix[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>] -Matrix[row2+<span class="hljs-number">1</span>][col1] - Matrix[row1][col2+<span class="hljs-number">1</span>] + Matrix[row1][col1];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; Matrix;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-014-字符串中的变位词"><a href="#剑指offer-014-字符串中的变位词" class="headerlink" title="剑指offer 014 字符串中的变位词"></a>剑指offer 014 字符串中的变位词</h5><p>双指针法，没有弄明白</p>
<p>滑动窗口</p>
<p>思路是创建两个哈希表，里面的元素个数与第一个字符串相同，首先记录s1中各个字符出现的次数，以及s2中前s1.size()个字符出现的次数，接着就可以保持s1.size()的窗口，沿着s2滑动，每次循环比较此时两个哈希表是否相等，若不相等，则窗口向后滑动，同时更新s2的哈希表。</p>
<p>若两个哈希表相等的适合，则找到想要的结果</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> s1_length = s1.size(), s2_length = s2.size();<br>        <span class="hljs-keyword">if</span> (s1_length &gt; s2_length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; table1;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; table2;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s1_length; i++) &#123;<br>            table1[s1[i]]++;<br>            table2[s2[i]]++;<br><br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = s1_length;<br>        <span class="hljs-keyword">for</span> (left,right; right &lt;= s2_length; left++,right++) &#123;<br>            <br>            <span class="hljs-keyword">bool</span> f = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; c++)&#123;<br>                <span class="hljs-keyword">if</span>(table1[c] != table2[c])&#123;<br>                    f = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(f)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (right == s2_length) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//第二个字符串每次以s1.size()的长度向右移一个位置，</span><br>            table2[s2[left]]--;<br>            table2[s2[right]]++;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-015-字符串中的所有变位词"><a href="#剑指offer-015-字符串中的所有变位词" class="headerlink" title="剑指offer 015 字符串中的所有变位词"></a>剑指offer 015 字符串中的所有变位词</h5><p>该题思路和上一题完全一致，简简单单变化一下即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> p_length = p.size(), s_length = s.size();<br>        <span class="hljs-keyword">if</span> (p_length &gt; s_length) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; table1;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; table2;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p_length; i++) &#123;<br>            table1[p[i]]++;<br>            table2[s[i]]++;<br><br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = p_length;<br>        <span class="hljs-keyword">for</span> (left,right; right &lt;= s_length; left++,right++) &#123;<br>            <br>            <span class="hljs-keyword">bool</span> f = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; c++)&#123;<br>                <span class="hljs-keyword">if</span>(table1[c] != table2[c])&#123;<br>                    f = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(f)<br>                res.push_back(left);<br>            <span class="hljs-keyword">if</span> (right == s_length) &#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            <span class="hljs-comment">//第二个字符串每次以s1.size()的长度向右移一个位置，</span><br>            table2[s[left]]--;<br>            table2[s[right]]++;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-016-不含重复字符的最长子字符串"><a href="#剑指offer-016-不含重复字符的最长子字符串" class="headerlink" title="剑指offer 016 不含重复字符的最长子字符串"></a>剑指offer 016 不含重复字符的最长子字符串</h5><p>可以使用滑动窗口的思想，窗口先向右扩展，每次扩展都要检查新加入的字符是否和窗口内已存在的字符重复，如果重复，则窗口左端向右缩，直到新加入的字符不与窗口内已存在字符重复。</p>
<p>每次右扩展窗口，直到满足条件时，就要记录当前长度，与当前最长长度比较，并更新最长长度。</p>
<p>每轮结束时，记录的是以当前右侧字符为末尾的符合条件的字串的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> max_length = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mp;<br><br>        <span class="hljs-comment">//窗口右侧为记录对象，右侧不断扩展</span><br>        <span class="hljs-keyword">for</span> (right; right &lt; s.size(); right++) &#123;<br>            mp[s[right]]++;<br><br>            <span class="hljs-comment">//当右侧新加入的字符与窗口内已存在字符产生冲突</span><br>            <span class="hljs-comment">//就要回缩左侧的字符，直到没有冲突，此时就记录了已当前右字符为末尾的符合条件的最长字符。</span><br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; mp[s[right]] &gt;= <span class="hljs-number">2</span>) &#123;<br>                mp[s[left]]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//更新最长长度</span><br>            max_length = max(max_length, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_length;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-017-含有所有字符的最短字符串"><a href="#剑指offer-017-含有所有字符的最短字符串" class="headerlink" title="剑指offer 017 含有所有字符的最短字符串"></a>剑指offer 017 含有所有字符的最短字符串</h5><p>仍然采用滑动窗口思想，但是要注意一些问题。</p>
<p>根据我的总结，滑动窗口思想一般都是，确保当前滑动窗口内的子串或者子数组是满足条件的，更新最右侧范围后，再回缩左侧范围，但要确保回缩不影响当前字串的正确性。</p>
<p>每次遍历，最终得到的都是以当前的最右侧字符为末尾的，最优的子串。</p>
<p>这道题思想同样是这样。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">minWindow</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mpt, mps;<br>        <span class="hljs-keyword">int</span> res_left = <span class="hljs-number">0</span>, min_length = INT_MAX;<br>        <span class="hljs-comment">//记录t中各字符出现次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c: t) &#123;<br>            mpt[c]++;<br>        &#125;<br>        <span class="hljs-comment">//记录此时的滑动窗口中，包含的t中的字符的数量</span><br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历窗口</span><br>        <span class="hljs-keyword">for</span> (; right &lt; s.size(); right++) &#123;<br>            <span class="hljs-comment">//窗口每次向右移动</span><br>            mps[s[right]]++;<br>            <span class="hljs-comment">//当窗口内新增一个尚且没有的t中字符，则窗口内的包含t的字符数量加一</span><br>            <span class="hljs-keyword">if</span> (mps[s[right]] &lt;= mpt[s[right]]) &#123;<br>                cnt++;<br>            &#125;<br>            <span class="hljs-comment">//当窗口左侧的字符在窗口中的数量，已经超过t中该字符的数量时，就可以向右移动，减去这个多余的字符</span><br>            <span class="hljs-comment">//循环，直到左侧字符数量与t中一致，也就是说不可以再向右移动，再移动，窗口将不满足包含t中所有字符</span><br>            <span class="hljs-keyword">while</span> (mps[s[left]] &gt; mpt[s[left]]) &#123;<br>                mps[s[left]]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//当窗口中包含所有的t中字符时，就更新，事实上只要第一次满足，后面每一次移动窗口右侧，肯定会满足</span><br>            <span class="hljs-comment">//因为我们在移动左侧窗口的时候，一定不会让条件不满足</span><br>            <span class="hljs-comment">//意思是每次遍历，窗口都表示：以当前最右侧字符为末尾的，所有s中子串中符合条件的最短字符串。</span><br>            <span class="hljs-keyword">if</span> (cnt == t.size()) &#123;<br>                <span class="hljs-keyword">if</span> (min_length &gt; right - left + <span class="hljs-number">1</span>) &#123;<br>                    min_length = right - left + <span class="hljs-number">1</span>;<br>                    res_left = left;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min_length == INT_MAX) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-built_in">string</span> res = s.substr(res_left, min_length);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>str.substr(1, 3);   <em>//要创建新的变量接收获取的子符串           两个参数一个起始位置 一个截取长度</em></p>
<h5 id="剑指offer-018-有效的回文"><a href="#剑指offer-018-有效的回文" class="headerlink" title="剑指offer 018 有效的回文"></a>剑指offer 018 有效的回文</h5><p>思路很简单，只需要使用爽指针，一个开头一个末尾，向中间移动，判断左右对称位置的字符是否相等即可。</p>
<p>但是这道题给出的输入字符串并不是标准的纯小写字符字符串，需要进行一定的操作</p>
<p>学习一些string的函数</p>
<p>isalpha ：判断一个字符是否为字母，如果是则返回true，否则返回false；<br>isdigit : 判断一个字符是否表示数字，如果是则返回true，否则返回false；<br>isalnum : 判断一个字符是否表示数字或者字母，如果是则返回true，否则返回false;<br>islower : 判断一个字符是否为小写字母，如果是则返回true，否则返回false;<br>isupper : 判断一个字符是否为大写字母，如果是则返回true，否则返回false；<br>tolower : 若字符为字母则转化为小写字母；<br>toupper : 若字符为字母则转化为大写字母；</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = s.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">//如果当前left位置的字符不是字母，就向后移动一位</span><br>            <span class="hljs-keyword">while</span> (left &lt; s.size() &amp;&amp; !<span class="hljs-built_in">isalnum</span>(s[left])) &#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//right位置同理</span><br>            <span class="hljs-keyword">while</span> (right &gt;= <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-built_in">isalnum</span>(s[right])) &#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left &lt;= right &amp;&amp; <span class="hljs-built_in">tolower</span>(s[left]) != <span class="hljs-built_in">tolower</span>(s[right])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指019-最多删除一个字符得到回文"><a href="#剑指019-最多删除一个字符得到回文" class="headerlink" title="剑指019 最多删除一个字符得到回文"></a>剑指019 最多删除一个字符得到回文</h5><p>一定要注意看题，是最多删除一个字符，而不是必须删除一个字符，因此正常的回文字符串应该也返回true。</p>
<p>这道题我们可以仍然按部就班判断是否为回文，当遇到第一个不相等的对称位置时，就跳过此位置，分别检验跳过左或者跳过右的剩余字符串部分是否为回文即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = s.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (s[left] != s[right]) &#123;<br>                <span class="hljs-keyword">return</span> isPalindrome(s, left+<span class="hljs-number">1</span>, right) || isPalindrome(s, left, right<span class="hljs-number">-1</span>);<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (s[left++] != s[right--]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-020"><a href="#剑指offer-020" class="headerlink" title="剑指offer 020"></a>剑指offer 020</h5><p>除了暴力枚举也可以使用动态规划的算法</p>
<p>遍历从1到length的所有长度，显然subLen为1时，是回文子串，subLen为2时，只要当前子串的两个字符相等即为回文子串，当subLen大于2时，若s[i] == s[i+subLen-1]，只要看内层的子串dp[i+1][i+subLen-2]是否相等即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = s.size();<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(length, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(length,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//子串长度为1时肯定为回文</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>            res++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> subLen = <span class="hljs-number">2</span>;subLen &lt;= length; subLen++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + subLen - <span class="hljs-number">1</span> &lt; length; i++) &#123;<br>                <span class="hljs-comment">//子串长度为2且字符相等，为回文</span><br>                <span class="hljs-keyword">if</span> (subLen == <span class="hljs-number">2</span> &amp;&amp; s[i] == s[i+<span class="hljs-number">1</span>]) &#123;<br>                    dp[i][i+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>                    res++;<br>                &#125;<br>                <span class="hljs-comment">//子串长度大于2，只需要看它内层长度减2的那个子串是否为回文。</span><br>                <span class="hljs-keyword">if</span> (subLen &gt; <span class="hljs-number">2</span> &amp;&amp; s[i] == s[i+subLen<span class="hljs-number">-1</span>]) &#123;<br>                    dp[i][i+subLen<span class="hljs-number">-1</span>] = dp[i+<span class="hljs-number">1</span>][i+subLen<span class="hljs-number">-2</span>];<br>                    res += dp[i][i+subLen<span class="hljs-number">-1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>





<h5 id="剑指offer-021-删除链表的倒数第n个结点"><a href="#剑指offer-021-删除链表的倒数第n个结点" class="headerlink" title="剑指offer 021 删除链表的倒数第n个结点"></a>剑指offer 021 删除链表的倒数第n个结点</h5><p>快慢指针法即可完成，让快指针先向后移动n个结点，之后快指针和慢指针一起移动，直到快指针为nullptr的时候，慢指针就到了将要删除的结点的位置</p>
<p>为了考虑只有一个结点的情况，特别定义一个哨兵结点，就可以解决删除头结点的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);<br>        ListNode* fast = head;<br>        ListNode* slow = dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span>) &#123;<br>            fast = fast -&gt; next;<br>            slow = slow -&gt; next;<br>        &#125;<br><br>        ListNode* tmp = slow -&gt; next;<br>        slow -&gt; next = tmp -&gt; next;<br>        <span class="hljs-keyword">delete</span> tmp;<br><br>        <span class="hljs-keyword">return</span> dummy -&gt; next;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-022-链表中环的入口结点"><a href="#剑指offer-022-链表中环的入口结点" class="headerlink" title="剑指offer 022 链表中环的入口结点"></a>剑指offer 022 链表中环的入口结点</h5><p>方法1 可以使用哈希表的方法，记录每个结点是否被访问过，遇到的第一个被访问过的结点，就是环的入口结点</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_set</span>&lt;ListNode *&gt; visited;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (visited.count(head)) &#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            visited.insert(head);<br>            head = head -&gt; next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>方法2 快慢指针</p>
<p>使用两个指针fast和slow，都从链表头出发，slow每次移动一个位置，而fast每次移动两个位置，由于存在移动差，这两个指针一定在环中再次相遇。</p>
<p>相遇后</p>
<p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220303163744281.png" srcset="/img/loading.gif" lazyload alt="image-20220303163744281"></p>
<p>slow走过的距离是a+b</p>
<p>而fast走过的距离是a + n(b+c) + b</p>
<p>fast走过的距离又是slow的两倍</p>
<p>因此有关系 a + n(b+c) + b = 2(a+b)</p>
<p>得到<em>a</em>=<em>c</em>+(<em>n</em>−1)(<em>b</em>+<em>c</em>)</p>
<p>因此到相遇点的距离等于c加上n-1倍的圈长，此时我们再设置一个指针从头出发，以每次移动一个结点的速度和slow一起，当新指针走过a的距离到入口时，slow也到入口。</p>
<p>注意判断是否存在环，即会不会走到nullptr</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* slow = head, *fast = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span>) &#123;<br>            slow = slow -&gt; next;<br>            <span class="hljs-keyword">if</span> (fast -&gt; next ==<span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            fast = fast-&gt; next -&gt; next;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                ListNode* tmp = head;<br>                <span class="hljs-keyword">while</span> (slow != tmp) &#123;<br>                    slow = slow -&gt; next;<br>                    tmp = tmp -&gt; next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-024-翻转链表"><a href="#剑指offer-024-翻转链表" class="headerlink" title="剑指offer 024 翻转链表"></a>剑指offer 024 翻转链表</h5><p>1.递归</p>
<p>当递归到最后一个结点，即head-&gt;next = nullptr时，应当返回自身，称为新的头节点。</p>
<p>递归过程中，我们的思想是当前的结点方向改变，即他指向的结点指向他，他自身指向nullptr</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* new_head = reverseList(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> new_head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>2.迭代</p>
<p>迭代的思路很容易，就是不断将当前结点指向前一个结点，同时保留后一个结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++\">class Solution &#123;<br>public:<br>    ListNode* reverseList(ListNode* head) &#123;<br>        ListNode * cur &#x3D; head;<br>        ListNode * pre &#x3D; nullptr;<br>        while (cur) &#123;<br>            ListNode * next &#x3D; cur -&gt; next;<br>            cur -&gt; next &#x3D; pre;<br>            pre &#x3D; cur;<br>            cur &#x3D; next;<br>        &#125;<br>        return pre;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-025-链表中的两数相加"><a href="#剑指offer-025-链表中的两数相加" class="headerlink" title="剑指offer 025 链表中的两数相加"></a>剑指offer 025 链表中的两数相加</h5><p>可以考虑翻转链表，使得从地位开始进位相加</p>
<p>也可以使用栈，将两个链表的所有元素分别全部压栈，再依次出栈相加</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s1, s2;<br>        ListNode* res = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (l1) &#123;<br>            s1.push(l1-&gt;val);<br>            l1 = l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (l2) &#123;<br>            s2.push(l2-&gt;val);<br>            l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!s1.empty() || !s2.empty() || carry != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (!s1.empty()) &#123;<br>                sum += s1.top();<br>                s1.pop();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!s2.empty()) &#123;<br>                sum += s2.top();<br>                s2.pop();<br>            &#125;<br>            sum += carry;<br>            carry = sum/<span class="hljs-number">10</span>;<br>            sum = sum%<span class="hljs-number">10</span>;<br>            ListNode* tmp_node = <span class="hljs-keyword">new</span> ListNode(sum);<br>            tmp_node -&gt; next = res;<br>            res = tmp_node;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h4 id="剑指offer-026-重排链表"><a href="#剑指offer-026-重排链表" class="headerlink" title="剑指offer 026 重排链表"></a>剑指offer 026 重排链表</h4><p>最开始的思路是想，将后1/2的链表翻转，求出中点的结点，再将两端链表根据规则插入排序</p>
<p>这种指定排序规律的链表可以使用哈希表的方法，存储结点指针，直接随机访问下标进行排序，难度大大降低。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;ListNode*&gt; table;<br>        ListNode* res = head;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            table.push_back(head);<br>            head = head-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = table.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <br>            table[i]-&gt;next = table[j];<br>            table[j]-&gt;next = table[i+<span class="hljs-number">1</span>];<br>            i++;<br>            j--;<br>        &#125;<br>        table[(table.size())/<span class="hljs-number">2</span>]-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h6 id="剑指offer-027-回文链表"><a href="#剑指offer-027-回文链表" class="headerlink" title="剑指offer 027 回文链表"></a>剑指offer 027 回文链表</h6><ol>
<li><p>可以考虑使用数组将链表中的所有结点的值按序保存，之后可以随机访问的形式，双指针一前一后遍历，判断数组是否回文即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; list_val;<br>        <span class="hljs-keyword">while</span> (head) &#123;<br>            list_val.push_back(head -&gt; val);<br>            head = head-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = list_val.size() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (list_val[left] != list_val[right]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure></li>
<li><p>递归</p>
<p>递归的思想是一直递归到链表末端，保存一个与之对称的指针指向头，当指向末端后，就可以逐个比较，当值相同时，头指针后移，同时回到上一层递归，递归中的指针前移。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    ListNode * frontPointer;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">recursivelyCheck</span><span class="hljs-params">(ListNode* curPointer)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (curPointer!= <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (recursivelyCheck(curPointer-&gt;next) == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (curPointer-&gt;val != frontPointer-&gt;val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            frontPointer = frontPointer-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        frontPointer = head;<br>        <span class="hljs-keyword">return</span> recursivelyCheck(head);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure></li>
</ol>
<h5 id="剑指offer-028-展平多级双向链表"><a href="#剑指offer-028-展平多级双向链表" class="headerlink" title="剑指offer 028 展平多级双向链表"></a>剑指offer 028 展平多级双向链表</h5><p>思路一是类比二叉树，二叉树的结构就是一个结点有左右孩子，而多级双向链表中，child可以看作左孩子，next可以看作右孩子，因此我们可以考虑使用先序遍历的方法，即中-左-右的遍历顺序遍历该链表，即可得到所需要的结构</p>
<p>将遍历结果存储在数组中，最后对数组中的每一个结点前后相连即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* prev;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* child;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;Node*&gt; res;<br>    <span class="hljs-function">Node* <span class="hljs-title">flatten</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-comment">//先序遍历得到所要顺序的数组</span><br>            dfs(head);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        Node* new_head = head;<br>        head-&gt;child = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; res.size(); i++) &#123;<br>            new_head-&gt;next = res[i];<br>            res[i]-&gt;prev = new_head;<br>            new_head = new_head-&gt;next;<br>            new_head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            new_head-&gt;child = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;        <br>    &#125;<br>    <span class="hljs-comment">//先序遍历递归写法</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node* cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            res.push_back(cur);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(cur-&gt;child);<br>        dfs(cur-&gt;next);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-029-排序的循环链表"><a href="#剑指offer-029-排序的循环链表" class="headerlink" title="剑指offer 029 排序的循环链表"></a>剑指offer 029 排序的循环链表</h5><p>将插入情况理顺清楚即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _next) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = _next;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">insert</span><span class="hljs-params">(Node* head, <span class="hljs-keyword">int</span> insertVal)</span> </span>&#123;<br>        Node *new_node = <span class="hljs-keyword">new</span> Node(insertVal);<br>        <span class="hljs-comment">//空结点的情况，直接插入</span><br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            head = new_node;<br>            new_node-&gt;next = new_node;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">//设置一前一后两个指针，根据不同情况进行选择</span><br>        Node* front = head-&gt;next;<br>        Node* behind = head;<br>        <span class="hljs-comment">//绕环遍历一周</span><br>        <span class="hljs-keyword">while</span> (front != head) &#123;<br>            <span class="hljs-comment">//临界情况</span><br>            <span class="hljs-keyword">if</span> (behind-&gt;val &gt; front-&gt;val) &#123;<br>                <span class="hljs-comment">//比两个都大或者都小</span><br>                <span class="hljs-keyword">if</span> (front-&gt;val &gt;= insertVal) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (behind-&gt;val &lt;= insertVal) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//普通情况</span><br>            <span class="hljs-keyword">if</span> (behind-&gt;val &lt;= insertVal &amp;&amp; front-&gt;val &gt;= insertVal) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            front = front-&gt;next;<br>            behind = behind-&gt;next;<br>        &#125;<br>        behind-&gt;next = new_node;<br>        new_node-&gt;next = front;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-030-插入、删除和随机访问都是O-1-的容器"><a href="#剑指offer-030-插入、删除和随机访问都是O-1-的容器" class="headerlink" title="剑指offer 030 插入、删除和随机访问都是O(1)的容器"></a>剑指offer 030 插入、删除和随机访问都是O(1)的容器</h5><p>哈希表</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomizedSet</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; numToLocation;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;<br><span class="hljs-keyword">public</span>:<br>    RandomizedSet() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (numToLocation.count(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        numToLocation[val] = nums.size();<br>        nums.push_back(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!numToLocation.count(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;    <br>        <span class="hljs-keyword">int</span> location = numToLocation[val];<br>        numToLocation[nums.back()] = location;<br>        numToLocation.erase(val);<br>        nums[location] = nums.back();<br>        nums.pop_back();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nums[rand() % nums.size()];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RandomizedSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RandomizedSet* obj = new RandomizedSet();</span><br><span class="hljs-comment"> * bool param_1 = obj-&gt;insert(val);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;remove(val);</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;getRandom();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-031-最近最少使用缓存"><a href="#剑指offer-031-最近最少使用缓存" class="headerlink" title="剑指offer 031 最近最少使用缓存"></a>剑指offer 031 最近最少使用缓存</h5><p>同时使用哈希表和双向链表</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>        <span class="hljs-keyword">int</span> key = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;<br>        Node * next;<br>        Node * prev;<br>        Node() &#123;&#125;;<br>        Node(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val):key(key), val(val) &#123;&#125;;<br>    &#125;;<br>    Node * dummy;<br>    Node * tail; <br>    <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> curnum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, Node*&gt; hashtable;<br><span class="hljs-keyword">public</span>:<br>    LRUCache(<span class="hljs-keyword">int</span> capacity) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;capacity = capacity; <br>        dummy = <span class="hljs-keyword">new</span> Node();<br>        tail = <span class="hljs-keyword">new</span> Node();<br>        dummy-&gt;next = tail;<br>        tail-&gt;prev = dummy;<br>        tail-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hashtable.count(key)) &#123;<br>            movetotail(key);<br>            <span class="hljs-keyword">return</span> hashtable[key]-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hashtable.count(key)) &#123;<br>            hashtable[key]-&gt;val = value;<br>            movetotail(key);<br>            <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (curnum &lt; capacity) &#123;<br>                addtotail(key,value);<br>                curnum++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                deletefront();<br>                addtotail(key,value);<br>                hashtable[key]-&gt;val = value;<br>                hashtable[key]-&gt;key = key;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">movetotail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        Node* cur = hashtable[key];<br>        <span class="hljs-keyword">if</span> (cur == tail) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur-&gt;prev-&gt;next = cur-&gt;next;<br>            cur-&gt;next-&gt;prev = cur-&gt;prev;<br>            tail-&gt;prev-&gt;next = cur;<br>            cur-&gt;prev = tail-&gt;prev;<br>            cur-&gt;next = tail;<br>            tail-&gt;prev = cur;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addtotail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        Node * tmp = <span class="hljs-keyword">new</span> Node(key,value);<br>        tail-&gt;prev-&gt;next = tmp;<br>        tmp-&gt;prev = tail-&gt;prev;<br>        tmp-&gt;next = tail;<br>        tail-&gt;prev = tmp;<br>        hashtable[key] = tmp;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deletefront</span> <span class="hljs-params">()</span> </span>&#123;<br>        hashtable.erase(dummy-&gt;next-&gt;key);<br>        Node * tmp = dummy-&gt;next;<br>        dummy-&gt;next = dummy-&gt;next-&gt;next;<br>        dummy-&gt;next-&gt;prev = dummy;<br><br>        <span class="hljs-keyword">delete</span> tmp;<br><br>    &#125;<br><br>    <br><br><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>





<h5 id="剑指offer-032-有效的变位词"><a href="#剑指offer-032-有效的变位词" class="headerlink" title="剑指offer 032 有效的变位词"></a>剑指offer 032 有效的变位词</h5><p>哈希表即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == t) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> table[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s) &#123;<br>            table[c-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) &#123;<br>            table[c-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (table[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-033-变位词组"><a href="#剑指offer-033-变位词组" class="headerlink" title="剑指offer 033 变位词组"></a>剑指offer 033 变位词组</h5><p>注意变位词组的特点是字符串中各字符的数量一致，因此我们对变位词排序，得到的新单词一定相同，因此我们可以考虑对于每个字符串排序，根据得到的排序后字符串归类</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; groupAnagrams(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs) &#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> s : strs) &#123;<br>            <span class="hljs-built_in">string</span> tmp = s;<br>            sort(tmp.begin(), tmp.end());<br>            mp[tmp].push_back(s);<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mp.begin(); it != mp.end(); it++) &#123;<br>            res.push_back(it-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-034-外星语言是否排序"><a href="#剑指offer-034-外星语言是否排序" class="headerlink" title="剑指offer 034 外星语言是否排序"></a>剑指offer 034 外星语言是否排序</h5><p>将字母表顺序根据顺序号存在哈希表中，比较两个单词时比较每个字母的顺序大小即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAlienSorted</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">string</span> order)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            mp[order[i]] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.size()<span class="hljs-number">-1</span>; i++) &#123;<br>            <span class="hljs-built_in">string</span> front = words[i];<br>            <span class="hljs-built_in">string</span> behind = words[i+<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">bool</span> res = compare(front, behind);<br>            <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = min(s1.size(), s2.size());<br>        <span class="hljs-keyword">bool</span> sub_equal = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp[s1[i]] &lt; mp[s2[i]]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mp[s1[i]] &gt; mp[s2[i]]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s1[i] != s2[i]) &#123;<br>                sub_equal = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sub_equal == <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">return</span> s1.size() &lt;= s2.size() ? <span class="hljs-literal">true</span>: <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>





<h5 id="剑指offer-035-最小时间差"><a href="#剑指offer-035-最小时间差" class="headerlink" title="剑指offer 035 最小时间差"></a>剑指offer 035 最小时间差</h5><p>首先将所有时间都转化为分钟，存入vector中，当然如果存在重复的值，直接返回0。</p>
<p>对其排序，排序后逐个比较前后元素的差，返回最小的。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++\">class Solution &#123;<br>public:<br>    int findMinDifference(vector&lt;string&gt;&amp; timePoints) &#123;<br>        vector&lt;int&gt; vec;<br>        for (string tmp : timePoints) &#123;<br>            int curtime &#x3D; (tmp[0] - &#39;0&#39;) * 10 * 60 + (tmp[1] - &#39;0&#39;) * 60 + (tmp[3] - &#39;0&#39;) * 10 + (tmp[4] - &#39;0&#39;);<br>            auto iter&#x3D;find(vec.begin(), vec.end(), curtime);<br>            if (iter !&#x3D; vec.end()) &#123;<br>                return 0;<br>            &#125; else &#123;<br>                vec.push_back(curtime);<br>            &#125;<br>        &#125;<br>        sort(vec.begin(), vec.end());<br>        int res &#x3D; 1440;<br>        for (int i &#x3D; 0; i &lt; vec.size()-1; i++) &#123;<br>            res &#x3D; min(res, vec[i+1] - vec[i]);<br>        &#125;<br>        res &#x3D; min(res, (vec[0] + 1440 - vec[vec.size()-1]));<br><br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>





<h5 id="剑指offer-036-后缀表达式"><a href="#剑指offer-036-后缀表达式" class="headerlink" title="剑指offer 036 后缀表达式"></a>剑指offer 036 后缀表达式</h5><p>经典栈问题</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> s : tokens) &#123;<br>            <span class="hljs-keyword">if</span> (isDegital(s)) &#123;<br>                st.push(atoi(s.c_str()));<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">char</span> c = s[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> tmp1 = st.top();<br>                st.pop();<br>                <span class="hljs-keyword">int</span> tmp2 = st.top();<br>                st.pop();<br>                <br>                <span class="hljs-keyword">switch</span> (c) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    result = tmp1 + tmp2;<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    result = tmp2 - tmp1;<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    result = tmp1 * tmp2;<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                    result  = tmp2 / tmp1;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                st.push(result);<br><br>            &#125;<br>        &#125;<br>        result = st.top();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDegital</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; str.size();i++) &#123;<br>            <span class="hljs-keyword">if</span> (str.at(i) == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; str.size() &gt; <span class="hljs-number">1</span>)  <span class="hljs-comment">// 有可能出现负数</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (str.at(i) &gt; <span class="hljs-string">&#x27;9&#x27;</span> || str.at(i) &lt; <span class="hljs-string">&#x27;0&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>判断C++中的字符串是否为整数</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDegital</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; str.size();i++) &#123;<br>        <span class="hljs-keyword">if</span> (str.at(i) == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; str.size() &gt; <span class="hljs-number">1</span>)  <span class="hljs-comment">// 有可能出现负数</span><br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (str.at(i) &gt; <span class="hljs-string">&#x27;9&#x27;</span> || str.at(i) &lt; <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>将string类型的整数转换为数字</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt; // 包含头文件</span></span><br><br><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;54321&quot;</span>;<br><span class="hljs-built_in">stringstream</span> ss;<br>ss&lt;&lt;str;<br><span class="hljs-keyword">int</span> temp;<br>ss&gt;&gt;temp;<br></code></pre></div></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;54231&quot;</span>;<br><span class="hljs-keyword">int</span> result = atoi(str.c_str());<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-037-小行星碰撞"><a href="#剑指offer-037-小行星碰撞" class="headerlink" title="剑指offer 037 小行星碰撞"></a>剑指offer 037 小行星碰撞</h5><p>自己的版本，不够优化，没有充分利用栈的思想</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">asteroidCollision</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; asteroids)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-comment">//先将所有的行星压栈</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : asteroids) &#123;<br>            st.push(i);<br>        &#125;<br><br>        <span class="hljs-comment">//当栈中存在两个及以上行星的时候</span><br>        <span class="hljs-keyword">while</span> (st.size() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> tmp1 = st.top();<br>            st.pop();<br>            <span class="hljs-keyword">int</span> tmp2 = st.top();<br>            st.pop();<br>            <span class="hljs-comment">//相撞的情况</span><br>            <span class="hljs-keyword">if</span> (tmp1 &lt; <span class="hljs-number">0</span> &amp;&amp; tmp2 &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">int</span> tmp_res;<br>                <span class="hljs-comment">//质量相同的行星湮灭</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(tmp1) != <span class="hljs-built_in">abs</span>(tmp2)) &#123;<br>                    <span class="hljs-comment">//质量大的行星存活</span><br>                    tmp_res = <span class="hljs-built_in">abs</span>(tmp1) &gt; <span class="hljs-built_in">abs</span>(tmp2) ? tmp1 : tmp2;<br>                    st.push(tmp_res); <br>                &#125; <br>                <span class="hljs-comment">//这里要取回之前已经存放安全的行星，因为左边的行星可能会被更左边的行星撞碎</span><br>                <span class="hljs-keyword">if</span> (!res.empty()) &#123;<br>                    <span class="hljs-keyword">int</span> tmp = res.back();<br>                st.push(tmp);<br>                res.pop_back();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//同方向的行星，一颗放入存活集</span><br>                res.push_back(tmp1);<br>                st.push(tmp2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将最后一颗存活的行星放入存活集</span><br>        <span class="hljs-keyword">if</span> (!st.empty()) &#123;<br>            <span class="hljs-keyword">int</span> tmp = st.top();<br>            st.pop();<br>            res.push_back(tmp);<br>        &#125;<br>        <br><br>        reverse(res.begin(), res.end());<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>可以直接在入栈和入存活集的时候进行判断</p>
<p>当然若左边只剩下负数行星的时候肯定会存活，因此如果栈中最后只剩负数行星，就入存活集</p>
<p>最后将所有剩余的正数行星入存活集</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">asteroidCollision</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; asteroids)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : asteroids) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) st.push(i);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>                    <span class="hljs-keyword">int</span> j = st.top();<br>                    <span class="hljs-keyword">if</span> (j &gt; -i) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; -i)&#123;<br>                        st.pop();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        st.pop();<br>                        i = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> &amp;&amp; st.empty()) ans.push_back(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            tmp.push(st.top());<br>            st.pop();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!tmp.empty()) &#123;<br>            ans.push_back(tmp.top());<br>            tmp.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-038-每日温度"><a href="#剑指offer-038-每日温度" class="headerlink" title="剑指offer 038 每日温度"></a>剑指offer 038 每日温度</h5><p>这道题可以使用两个栈解决，温度栈入栈的是新的一天的温度一定要比前一天低，天数栈入栈的是温度栈对应温度是第几天。</p>
<p>让每天的温度与温度栈中的数据进行比对，如果新一天的温度高于温度栈顶的温度，那么就出栈，并记录温度栈顶那天等待的天数。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-comment">//单调栈，栈中存放的只能是递减的数据</span><br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-comment">//记录单调栈中存放的温度是第几天</span><br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; wait_day;<br>        <span class="hljs-comment">//保存等待结果</span><br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (!st.empty())  &#123;<br>                <span class="hljs-comment">//新的一天的温度比之前的温度高</span><br>                <span class="hljs-keyword">while</span>(!st.empty() &amp;&amp; st.top() &lt; temperatures[i]) &#123;<br>                    st.pop();<br>                    <span class="hljs-comment">//则单调栈中的天已经等待了当前天减去单调栈中存放的温度那天</span><br>                    res[wait_day.top()] = i - wait_day.top();<br>                    wait_day.pop();<br>                &#125;   <br>            &#125;<br>            res[i] = <span class="hljs-number">0</span>;<br>            st.push(temperatures[i]);<br>            wait_day.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-039-直方图最大矩形面积"><a href="#剑指offer-039-直方图最大矩形面积" class="headerlink" title="剑指offer 039 直方图最大矩形面积"></a>剑指offer 039 直方图最大矩形面积</h5><p>设置一个单调栈</p>
<p>当目前元素大于栈顶元素，直接存入目前元素的位置，当目前元素小于栈顶元素，就先将栈顶位置出栈，得到目前栈顶位置的高度，再用当前位置i - st.top() -1 ，得到的是以当前出栈位置为高度的最大矩形的面积，因为单调栈特性是高度递增，遇到不递增的高度出栈，因此出栈元素的前一个栈中元素和当前要入栈元素的位置，就是当前出栈元素高度两侧延申，左右遇到的第一个比出栈元素低的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max_area = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        st.push(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.size(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (st.size() &gt; <span class="hljs-number">1</span> &amp;&amp; heights[i] &lt; heights[st.top()]) &#123;<br>                <span class="hljs-keyword">int</span> cur_pos = st.top();<br>                <span class="hljs-keyword">int</span> cur_height = heights[cur_pos];<br>                st.pop();<br>                max_area = max(max_area, cur_height*(i-st.top()<span class="hljs-number">-1</span>));<br>            &#125;<br>            st.push(i);<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = heights.size();<br>        <span class="hljs-keyword">while</span> (st.top() != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">int</span> cur_pos = st.top();<br>            <span class="hljs-keyword">int</span> cur_height = heights[cur_pos];<br>            st.pop();<br>            max_area = max(max_area, cur_height*(i-st.top()<span class="hljs-number">-1</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_area;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-040-矩阵中的最大矩形"><a href="#剑指offer-040-矩阵中的最大矩形" class="headerlink" title="剑指offer 040 矩阵中的最大矩形"></a>剑指offer 040 矩阵中的最大矩形</h5><p>将矩阵按行转化为直方图即可，当一行中出现0，则这行的这个位置清零，若为1则加上入一次的直方图中。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = matrix.size();<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">histogram</span><span class="hljs-params">(matrix[<span class="hljs-number">0</span>].size(),<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            getHistogram(histogram, matrix[i]);<br><br>            res = max(res, getMaxRectangle(histogram));<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getHistogram</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;prehistogram, <span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                prehistogram[i] += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prehistogram[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMaxRectangle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; heights)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        st.push(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">int</span> max_area = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.size(); i++) &#123;<br>            <span class="hljs-keyword">while</span>(st.top() != <span class="hljs-number">-1</span> &amp;&amp; heights[st.top()] &gt; heights[i]) &#123;<br>                <span class="hljs-keyword">int</span> curheight = heights[st.top()];<br>                st.pop();<br>                max_area = max(max_area, curheight * (i-st.top()<span class="hljs-number">-1</span>));<br>            &#125;<br>            st.push(i);<br>        &#125;<br>        <span class="hljs-keyword">int</span> i =  heights.size();<br>        <span class="hljs-keyword">while</span> (st.top() != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">int</span> curheight = heights[st.top()];<br>            st.pop();<br>            max_area = max(max_area, curheight * (i-st.top()<span class="hljs-number">-1</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_area;<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-041-滑动窗口的平均值"><a href="#剑指offer-041-滑动窗口的平均值" class="headerlink" title="剑指offer 041 滑动窗口的平均值"></a>剑指offer 041 滑动窗口的平均值</h5><p>简单的队列问题</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovingAverage</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">int</span> max_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; que;<br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;<br>    MovingAverage(<span class="hljs-keyword">int</span> size) &#123;<br>        max_size = size;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (que.size() &lt; max_size) &#123;<br>            sum += val;<br>            que.push(val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!que.empty()) &#123;<br>                sum -= que.front();<br>                que.pop();<br>            &#125;<br>            que.push(val);<br>            sum += val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum / que.size();<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MovingAverage object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MovingAverage* obj = new MovingAverage(size);</span><br><span class="hljs-comment"> * double param_1 = obj-&gt;next(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-042-最近请求次数"><a href="#剑指offer-042-最近请求次数" class="headerlink" title="剑指offer 042 最近请求次数"></a>剑指offer 042 最近请求次数</h5><p>设置一个队列，每次将小于当前时间-3000的所有数从队列中清除即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecentCounter</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; que;<br>    <span class="hljs-keyword">int</span> time_width;<br>    RecentCounter() &#123;<br>        time_width = <span class="hljs-number">3000</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ping</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> earlytime = t - <span class="hljs-number">3000</span>;<br>        <span class="hljs-keyword">while</span> (!que.empty() &amp;&amp; que.front() &lt; earlytime) &#123;<br>            que.pop();<br>        &#125;<br>        que.push(t);<br>        <span class="hljs-keyword">return</span>  que.size();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RecentCounter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RecentCounter* obj = new RecentCounter();</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;ping(t);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>





<h5 id="剑指offer-043-往完全二叉树添加节点"><a href="#剑指offer-043-往完全二叉树添加节点" class="headerlink" title="剑指offer 043 往完全二叉树添加节点"></a>剑指offer 043 往完全二叉树添加节点</h5><p>二叉树层序遍历！</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CBTInserter</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">queue</span> &lt;TreeNode*&gt; que;<br>    TreeNode * root;<br>    CBTInserter(TreeNode* root) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;root = root;<br>        que.push(root);<br>        <span class="hljs-keyword">while</span> (que.front()-&gt;left &amp;&amp; que.front()-&gt;right) &#123;<br>            que.push(que.front()-&gt;left);<br>            que.push(que.front()-&gt;right);<br>            que.pop();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (que.front()-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            que.push(que.front()-&gt;left);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        TreeNode *tmp = <span class="hljs-keyword">new</span> TreeNode(v);<br>        TreeNode *tmpfather = que.front();<br>        <span class="hljs-keyword">if</span> (tmpfather-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            tmpfather-&gt;right = tmp;<br>            que.pop();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmpfather-&gt;left = tmp;<br>        &#125;<br>        que.push(tmp);<br>        <br>        <span class="hljs-keyword">return</span> tmpfather-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">get_root</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CBTInserter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CBTInserter* obj = new CBTInserter(root);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;insert(v);</span><br><span class="hljs-comment"> * TreeNode* param_2 = obj-&gt;get_root();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>





<h5 id="剑指offer-044-二叉树每层的最大值"><a href="#剑指offer-044-二叉树每层的最大值" class="headerlink" title="剑指offer 044 二叉树每层的最大值"></a>剑指offer 044 二叉树每层的最大值</h5><p>队列 层序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">int</span> cur_size;<br>        <span class="hljs-keyword">int</span> cur_max;<br>        que.push(root);<br><br>        <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>            cur_size = que.size();<br>            cur_max = INT_MIN;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_size; i++) &#123;<br>                TreeNode* node = que.front();<br>                cur_max = max(cur_max, node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    que.push(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    que.push(node-&gt;right);<br>                &#125;<br>                que.pop();<br>            &#125;<br>            res.push_back(cur_max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>





<h5 id="剑指offer-045-二叉树最底层最左边的值"><a href="#剑指offer-045-二叉树最底层最左边的值" class="headerlink" title="剑指offer 045 二叉树最底层最左边的值"></a>剑指offer 045 二叉树最底层最左边的值</h5><p>仍然是层序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode *&gt; que;<br>        <span class="hljs-keyword">int</span> res;<br>        que.push(root);<br>        <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>            <span class="hljs-keyword">int</span> cur_length = que.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_length; i++) &#123;<br>                TreeNode* node = que.front();<br><br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                    res = node-&gt;val;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    que.push(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    que.push(node-&gt;right);<br>                &#125;<br>                que.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-046-二叉树的右侧视图"><a href="#剑指offer-046-二叉树的右侧视图" class="headerlink" title="剑指offer 046 二叉树的右侧视图"></a>剑指offer 046 二叉树的右侧视图</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        que.push(root);<br><br>        <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>            <span class="hljs-keyword">int</span> cur_length = que.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_length; i++) &#123;<br>                TreeNode * node = que.front();<br>                <span class="hljs-keyword">if</span> (i == cur_length<span class="hljs-number">-1</span>) &#123;<br>                    res.push_back(node-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    que.push(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    que.push(node-&gt;right);<br>                &#125;<br>                que.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>





<h5 id="二叉树的三种遍历"><a href="#二叉树的三种遍历" class="headerlink" title="二叉树的三种遍历"></a>二叉树的三种遍历</h5><p>统一写法 后序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.push(root);<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            TreeNode *node = st.top();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.pop();<br>                st.push(node);<br>                st.push(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.push(node-&gt;right);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.push(node-&gt;left);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.pop();<br>                node = st.top();<br>                st.pop();<br>                result.push_back(node-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>





<h5 id="剑指offer-047-二叉树剪纸"><a href="#剑指offer-047-二叉树剪纸" class="headerlink" title="剑指offer 047 二叉树剪纸"></a>剑指offer 047 二叉树剪纸</h5><p>考虑到当孩子节点都是0的时候，该节点也是0，意思是左子树和右子树都是0的时候，自己也为0，因此应先遍历左右子节点，左右子节点的值影响父节点的值。</p>
<p>因此应使用后续遍历，当左右孩子为0的时候，将父节点也设为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        root-&gt;left = pruneTree(root-&gt;left);<br>        root-&gt;right = pruneTree(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (root-&gt;val == <span class="hljs-number">0</span> &amp;&amp; root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>





<h5 id="剑指offer-048-序列化与反序列化二叉树"><a href="#剑指offer-048-序列化与反序列化二叉树" class="headerlink" title="剑指offer 048 序列化与反序列化二叉树"></a>剑指offer 048 序列化与反序列化二叉树</h5><p>将一个二叉树保存为一个string类型，再用string还原一个二叉树</p>
<p>先序遍历 </p>
<p>多看代码</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br>        &#125;<br>        <span class="hljs-built_in">string</span> leftstr = serialize(root-&gt;left);<br>        <span class="hljs-built_in">string</span> rightstr = serialize(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> to_string(root-&gt;val) + <span class="hljs-string">&quot;,&quot;</span> + leftstr + <span class="hljs-string">&quot;,&quot;</span> + rightstr;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-built_in">string</span> data)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; dataArray&#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : data) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>                dataArray.push_back(<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dataArray.back().push_back(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dfs(dataArray, i);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; &amp;dataArray, <span class="hljs-keyword">int</span> &amp;i)</span> </span>&#123;<br>        <span class="hljs-built_in">string</span> str = dataArray[i];<br>        i++;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br><br>        TreeNode * node = <span class="hljs-keyword">new</span> TreeNode(stoi(str));<br>        node-&gt;left = dfs(dataArray, i);<br>        node-&gt;right = dfs(dataArray,i);<br>        <span class="hljs-keyword">return</span> node;<br>                  <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec ser, deser;</span><br><span class="hljs-comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span><br></code></pre></div></td></tr></table></figure>





<h5 id="049-从根节点到叶节点的路径数字之和"><a href="#049-从根节点到叶节点的路径数字之和" class="headerlink" title="049 从根节点到叶节点的路径数字之和"></a>049 从根节点到叶节点的路径数字之和</h5><p>先序遍历递归版本</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> prevsum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> sum = prevsum * <span class="hljs-number">10</span> + root-&gt;val;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> dfs(root-&gt;left, sum) + dfs(root-&gt;right, sum);<br>        &#125;<br>    &#125;<br><br><br><br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>层序遍历队列版本</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que_node;<br>        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; que_num;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        que_node.push(root);<br>        que_num.push(root-&gt;val);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que_node.empty()) &#123;<br>            <span class="hljs-keyword">int</span> cur_length = que_node.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_length; i++) &#123;<br>                TreeNode * tmpnode = que_node.front(); <br>                <span class="hljs-keyword">int</span> tmpnum = que_num.front();<br>                <span class="hljs-keyword">if</span> (tmpnode-&gt;left) &#123;<br>                    que_node.push(tmpnode-&gt;left);<br>                    que_num.push(tmpnum*<span class="hljs-number">10</span> + tmpnode-&gt;left-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (tmpnode-&gt;right) &#123;<br>                    que_node.push(tmpnode-&gt;right);<br>                    que_num.push(tmpnum*<span class="hljs-number">10</span> + tmpnode-&gt;right-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (tmpnode-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; tmpnode-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                    sum += tmpnum;<br>                &#125;<br>                que_node.pop();<br>                que_num.pop();<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure>





<h5 id="050-向下的路径节点之和"><a href="#050-向下的路径节点之和" class="headerlink" title="050 向下的路径节点之和"></a>050 向下的路径节点之和</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rootSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val == targetSum) &#123;<br>            ret++;<br>        &#125; <br><br>        ret += rootSum(root-&gt;left, targetSum - root-&gt;val);<br>        ret += rootSum(root-&gt;right, targetSum - root-&gt;val);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> ret = rootSum(root, targetSum);<br>        ret += pathSum(root-&gt;left, targetSum);<br>        ret += pathSum(root-&gt;right, targetSum);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br></code></pre></div></td></tr></table></figure>

<h5 id="节点之和最大的路径"><a href="#节点之和最大的路径" class="headerlink" title="节点之和最大的路径"></a>节点之和最大的路径</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> ans = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//获取左右两支的最大值</span><br>        <span class="hljs-keyword">int</span> sumleft = dfs(root-&gt;left);<br>        <span class="hljs-keyword">int</span> sumright = dfs(root-&gt;right);<br><br>        <span class="hljs-comment">//检测当前的^,是点最大，一支最大，还是^最大</span><br>        ans = max(ans, root-&gt;val);<br>        ans = max(ans, root-&gt;val + max(sumright, sumleft));<br>        ans = max(ans, root-&gt;val + sumleft +sumright);<br><br>        <span class="hljs-comment">//向上一层返回，返回的一定是一条线，而不是一个^，因此取左右分支最大的一支返回</span><br>        <span class="hljs-keyword">return</span> max(root-&gt;val, root-&gt;val + max(sumright, sumleft));<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-052-展平二叉搜索树"><a href="#剑指offer-052-展平二叉搜索树" class="headerlink" title="剑指offer 052 展平二叉搜索树"></a>剑指offer 052 展平二叉搜索树</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; res;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        st.push(root);<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            TreeNode * node = st.top();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.push(node-&gt;right);<br>                &#125;<br>                st.push(node);<br>                st.push(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.push(node-&gt;left);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.pop();<br>                node = st.top();<br>                res.push_back(node);<br>                st.pop();<br>            &#125;<br>        &#125;<br><br>        <br>        TreeNode * tmp = res[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size()<span class="hljs-number">-1</span>; i++) &#123;<br>            tmp-&gt;right = res[i+<span class="hljs-number">1</span>];<br>            tmp-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            tmp = tmp-&gt;right;<br>        &#125;<br>        tmp-&gt;right = <span class="hljs-literal">nullptr</span>;<br>        tmp-&gt;left = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer053-二叉搜索树中的中序后继"><a href="#剑指offer053-二叉搜索树中的中序后继" class="headerlink" title="剑指offer053 二叉搜索树中的中序后继"></a>剑指offer053 二叉搜索树中的中序后继</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode* root, TreeNode* p)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">bool</span> next = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        st.push(root);<br>        <span class="hljs-keyword">while</span>(!st.empty()) &#123;<br>            TreeNode* node = st.top();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.push(node-&gt;right);<br>                &#125;<br>                st.push(node);<br>                st.push(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.push(node-&gt;left);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.pop();<br>                node = st.top();<br>                <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">return</span> node;<br>                &#125;<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (node == p) &#123;<br>                    next = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-054-所有大于等于节点的值之和"><a href="#剑指offer-054-所有大于等于节点的值之和" class="headerlink" title="剑指offer 054 所有大于等于节点的值之和"></a>剑指offer 054 所有大于等于节点的值之和</h5><p>既然树是有序的，而且要将每个节点的值替换成树种大于或者等于该节点值得所有节点之和，不妨直接由中序遍历，变成逆中序遍历，按照右中左的顺序，从大到小遍历，并将数值依次相加保存。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        convertBST(root-&gt;right);<br>        sum += root-&gt;val;<br>        root-&gt;val = sum;<br>        convertBST(root-&gt;left);<br><br>        <span class="hljs-keyword">return</span> root; <br><br>    &#125; <br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-055-二叉搜索树迭代器"><a href="#剑指offer-055-二叉搜索树迭代器" class="headerlink" title="剑指offer 055 二叉搜索树迭代器"></a>剑指offer 055 二叉搜索树迭代器</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; result;<br>    <span class="hljs-keyword">int</span> curnode;<br>    <span class="hljs-keyword">int</span> nodesize;<br><span class="hljs-keyword">public</span>:<br><br>    BSTIterator(TreeNode* root) &#123;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.push(root);<br>            <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>                TreeNode* node = st.top();<br>                <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                    st.pop();<br>                    <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                        st.push(node-&gt;right);<br>                    &#125;<br>                    st.push(node);<br>                    st.push(<span class="hljs-literal">nullptr</span>);<br>                    <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                        st.push(node-&gt;left);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    st.pop();<br>                    node = st.top();<br>                    st.pop();<br>                    result.push_back(node);<br>                &#125;<br>            &#125;<br>        &#125;<br>        curnode = <span class="hljs-number">0</span>;<br>        nodesize = result.size();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> result[curnode++]-&gt;val;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (curnode &lt; nodesize) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * BSTIterator* obj = new BSTIterator(root);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;next();</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;hasNext();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer-056-二叉搜索树中两个节点之和"><a href="#剑指offer-056-二叉搜索树中两个节点之和" class="headerlink" title="剑指offer 056 二叉搜索树中两个节点之和"></a>剑指offer 056 二叉搜索树中两个节点之和</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        st.push(root);<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            TreeNode* node = st.top();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.push(node-&gt;right);<br>                &#125;<br>                st.push(node);<br>                st.push(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.push(node-&gt;left);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.pop();<br>                node = st.top();<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (mp.count(k - node-&gt;val)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                mp[node-&gt;val] = <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>





<h5 id="剑指offer-057-值和下标只差都在给定的范围内"><a href="#剑指offer-057-值和下标只差都在给定的范围内" class="headerlink" title="剑指offer 057 值和下标只差都在给定的范围内"></a>剑指offer 057 值和下标只差都在给定的范围内</h5><p>滑动窗口 + 桶思想</p>
<p>滑动窗口负责淘汰数据，桶帮助简化比较过程</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-keyword">int</span> tmpID = getID(nums[i], t+<span class="hljs-number">1ll</span>);<br>            <span class="hljs-keyword">if</span> (mp.count(tmpID)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mp.count(tmpID<span class="hljs-number">-1</span>) &amp;&amp; <span class="hljs-built_in">abs</span>((<span class="hljs-keyword">long</span>)mp[tmpID<span class="hljs-number">-1</span>] - nums[i]) &lt;= t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mp.count(tmpID+<span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">abs</span>((<span class="hljs-keyword">long</span>)mp[tmpID+<span class="hljs-number">1</span>] - nums[i]) &lt;= t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            mp[tmpID] = nums[i];<br>            <span class="hljs-keyword">if</span> (i &gt;= k) &#123;<br>                mp.erase(getID(nums[i - k], t + <span class="hljs-number">1ll</span>));<br>            &#125;<br>            <br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getID</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">long</span> range)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ID;<br>        <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">0</span>) &#123;<br>            ID = num/range;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;<br>            ID = (num + <span class="hljs-number">1</span>) / range - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ID;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>



<h5 id="剑指offer058-日程表"><a href="#剑指offer058-日程表" class="headerlink" title="剑指offer058 日程表"></a>剑指offer058 日程表</h5><p>利用map，first和second都可以存数</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCalendar</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//由小到大的有序对</span><br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>    MyCalendar() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> iter = mp.lower_bound(start);<br>        <span class="hljs-comment">//第一个结束时间比end晚的，比较它的开始时间是否比end早</span><br>        <span class="hljs-keyword">if</span> (iter != mp.end() &amp;&amp; iter-&gt;first &lt; end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//第一个结束时间比end早的，比较它的开始时间是否比start晚</span><br>        <span class="hljs-keyword">if</span> (iter != mp.begin() &amp;&amp; (--iter)-&gt;second &gt; start) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        mp[start] = end;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyCalendar object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyCalendar* obj = new MyCalendar();</span><br><span class="hljs-comment"> * bool param_1 = obj-&gt;book(start,end);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>







<h5 id="剑指offer-059-数据流的第K大数值"><a href="#剑指offer-059-数据流的第K大数值" class="headerlink" title="剑指offer 059 数据流的第K大数值"></a>剑指offer 059 数据流的第K大数值</h5><p>priority_queue</p>
<p>priority_queue 模板有 3 个参数，其中两个有默认的参数；第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象，它定义了一个用来决定元素顺序的断言。因此模板类型是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Container=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;, <span class="hljs-keyword">typename</span> Compare=<span class="hljs-built_in">std</span>::less&lt;T&gt;&gt; class <span class="hljs-built_in">priority_queue</span><br></code></pre></div></td></tr></table></figure>

<p>如你所见，priority_queue 实例默认有一个 vector 容器。函数对象类型 less<T> 是一个默认的排序断言，定义在头文件 function 中，决定了容器中最大的元素会排在队列前面。fonction 中定义了 greater<T>，用来作为模板的最后一个参数对元素排序，最小元素会排在队列前面。当然，如果指定模板的最巵一个参数，就必须提供另外的两个模板类型参数。</T></T></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KthLargest</span> &#123;</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; heap;<br>    <span class="hljs-keyword">int</span> size;<br><span class="hljs-keyword">public</span>:<br>    KthLargest(<span class="hljs-keyword">int</span> k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        size = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : nums) &#123;<br>            heap.push(i);<br>            <span class="hljs-keyword">if</span> (heap.size() &gt; size) &#123;<br>                heap.pop();<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (heap.size() &lt; size) &#123;<br>            heap.push(val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (heap.top() &lt; val) &#123;<br>                heap.pop();<br>                heap.push(val);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> heap.top();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * KthLargest* obj = new KthLargest(k, nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;add(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/C/">C++</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                  </div>
                
              </div>

              <!--
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
-->
<p class="note note-warning">
  <strong>本文作者: </strong><a href="/">Trent-Liu</a> <br>
  <strong>本文链接: </strong><a href="https://trentliu.cn/2022/03/03/C++%E5%89%91%E6%8C%87offer2/">https://trentliu.cn/2022/03/03/C++%E5%89%91%E6%8C%87offer2/</a> <br>
  <strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
     </p>
     


              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/07/CodeTop/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CodeTop</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/20/C++%20%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/">
                        <span class="hidden-mobile">C++几种排序方式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#valine",
          app_id: "kln923ignpAig6tMBYCNQLi4-gzGzoHsz",
          app_key: "rxzdxPz6ABf8lCQH2OOo6WH9",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


<div class="text-center py-1">  
  <div>
    <span id="timeDate1">载入天数...</span>
    <span id="times1">载入时分秒...</span>
    <script>
    var now1 = new Date();
    function createtime1(){
        var grt1= new Date("07/21/2018 23:00");//此处修改你的建站时间或者网站上线时间
        now1.setTime(now1.getTime()+250);
        days1 = (now1 - grt1 ) / 1000 / 60 / 60 / 24;
        dnum1 = Math.floor(days1);
        hours1 = (now1 - grt1 ) / 1000 / 60 / 60 - (24 * dnum1);
        hnum1 = Math.floor(hours1);
        if(String(hnum1).length ==1 ){
            hnum1 = "0" + hnum1;
        }
        minutes1 = (now1 - grt1 ) / 1000 /60 - (24 * 60 * dnum1) - (60 * hnum1);
        mnum1 = Math.floor(minutes1);
        if(String(mnum1).length ==1 ){
                  mnum1 = "0" + mnum1;
        }
        
        document.getElementById("timeDate1").innerHTML = "💓 ysm&lyk&nbsp"+dnum1+"&nbspdays";  //此次自定义显示内容
        document.getElementById("times1").innerHTML = hnum1 + "&nbsphr&nbsp" + mnum1 + "&nbspmin&nbsp";
    }  //此次自定义显示内容
    setInterval("createtime1()",250);
    </script>
  </div>

<div class="text-center py-1">  
<div>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("03/20/2021 17:25:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      /*
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      */
      document.getElementById("timeDate").innerHTML = "🏡pigsty for&nbsp"+dnum+"&nbspdays";  //此次自定义显示内容
      document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" /*+ snum + "&nbspsec"*/;
  }  //此次自定义显示内容
  setInterval("createtime()",250);
  </script>
</div>

<div class="text-center py-1">   
  <div>
    <span>Copyright © 2021</span></a>
    <a href="https://erenspace.cool/" target="_blank" rel="nofollow noopener">
     <span>Trent-Liu‘s Pigsty</span></a>    <br>
  </div>


<!--
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
-->

  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>

<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>