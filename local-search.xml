<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Verilog一些简单电路</title>
    <link href="/2021/05/11/verilog%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%94%B5%E8%B7%AF/"/>
    <url>/2021/05/11/verilog%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="七段数码管"><a href="#七段数码管" class="headerlink" title="七段数码管"></a>七段数码管</h2><p>模块定义</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> <span class="hljs-number">_7</span>Seg_Driver_Decode(SW, SEG, AN, LED);<br><span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] SW;   <span class="hljs-comment">// 16位拨动开关</span><br><span class="hljs-keyword">output</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] SEG;  <span class="hljs-comment">// 7段数码管驱动，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;<span class="hljs-comment">// 7段数码管片选信号，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] LED;   <span class="hljs-comment">// 16位LED显示</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="直接驱动7段数码管（7-SegDisplay）"><a href="#直接驱动7段数码管（7-SegDisplay）" class="headerlink" title="直接驱动7段数码管（7-SegDisplay）"></a>直接驱动7段数码管（7-SegDisplay）</h3><p>使用“数据流描述”设计“7段数码管直接驱动”模块。</p><ul><li><p>用SW[7:0]直接驱动7段数码管的CA-CG、DP显示单元。</p></li><li><p>用SW[15:8]选择被驱动的7段数码管。</p></li><li><p>用LED[15:0]显示SW的状态。</p></li></ul><p>拨动开关与7-SegDisplay对应关系</p><table><thead><tr><th><strong>拨动开关编号</strong></th><th><strong>7-SegDisplay</strong></th></tr></thead><tbody><tr><td>SW7</td><td>CA</td></tr><tr><td>SW6</td><td>CB</td></tr><tr><td>SW5</td><td>CC</td></tr><tr><td>SW4</td><td>CD</td></tr><tr><td>SW3</td><td>CE</td></tr><tr><td>SW2</td><td>CF</td></tr><tr><td>SW1</td><td>CG</td></tr><tr><td>SW0</td><td>DP</td></tr></tbody></table><p>代码如下</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> <span class="hljs-number">_7</span>Seg_Driver_Direct(SW, CA, CB, CC, CD, CE, CF, CG, DP, AN, LED);<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] SW;                          <span class="hljs-comment">// 16位拨动开关</span><br><span class="hljs-keyword">output</span> CA, CB, CC, CD, CE, CF, CG, DP;    <span class="hljs-comment">// 7段数码管驱动，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;                          <span class="hljs-comment">// 7段数码管片选信号，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] LED;                        <span class="hljs-comment">// 16位LED显示，高电平有效</span><br><br><span class="hljs-keyword">assign</span> &#123;CA, CB, CC, CD, CE, CF, CG, DP&#125; = SW[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> AN[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = SW[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br><span class="hljs-keyword">assign</span> LED[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] = SW[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="译码驱动七段数码管"><a href="#译码驱动七段数码管" class="headerlink" title="译码驱动七段数码管"></a>译码驱动七段数码管</h3><ul><li><p>添加<strong>译码器</strong>，<strong>用SW[3:0]输入待显示的单个数字</strong>,转换成对应的数码管应该亮的位置，而不是之前通过[7:0] SEG直接控制LED亮。</p></li><li><p>输入数字与显示对应表如表3-2。</p></li><li><p>用SW[15:8]选择被驱动的7段数码管。</p></li><li><p>用LED[15:0]显示SW的状态。</p></li></ul><p>输入与7-SegDisplay对应关系及显示码</p><table><thead><tr><th><strong>输入数字</strong></th><th><strong>7-SegDisplay</strong></th><th><strong>显示码</strong></th></tr></thead><tbody><tr><td>0000</td><td>0</td><td>11000000</td></tr><tr><td>0001</td><td>1</td><td>11111001</td></tr><tr><td>0010</td><td>2</td><td>10100100</td></tr><tr><td>0011</td><td>3</td><td>10110000</td></tr><tr><td>0100</td><td>4</td><td>10011001</td></tr><tr><td>0101</td><td>5</td><td>10010010</td></tr><tr><td>0110</td><td>6</td><td>10000010</td></tr><tr><td>0111</td><td>7</td><td>11111000</td></tr><tr><td>1000</td><td>8</td><td>10000000</td></tr><tr><td>1001</td><td>9</td><td>10011000</td></tr><tr><td>1010</td><td>A</td><td>10001000</td></tr><tr><td>1011</td><td>b</td><td>10000011</td></tr><tr><td>1100</td><td>C</td><td>11000110</td></tr><tr><td>1101</td><td>d</td><td>10100001</td></tr><tr><td>1110</td><td>E</td><td>10000110</td></tr><tr><td>1111</td><td>F</td><td>10001110</td></tr></tbody></table><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210511112315620.png" style="zoom: 50%;"><h4 id="四位转16位译码器"><a href="#四位转16位译码器" class="headerlink" title="四位转16位译码器"></a>四位转16位译码器</h4><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> decoder_4to16(in, out);<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] in;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out;<br><br>    <span class="hljs-keyword">always</span>@(in)<br>        <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">case</span>(in)<br>                <span class="hljs-number">4&#x27;b0000</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11000000</span>;<br>                <span class="hljs-number">4&#x27;b0001</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11111001</span>;<br>                <span class="hljs-number">4&#x27;b0010</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10100100</span>;<br>                <span class="hljs-number">4&#x27;b0011</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10110000</span>;<br>                <span class="hljs-number">4&#x27;b0100</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10011001</span>;<br>                <span class="hljs-number">4&#x27;b0101</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10010010</span>;<br>                <span class="hljs-number">4&#x27;b0110</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10000010</span>;<br>                <span class="hljs-number">4&#x27;b0111</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11111000</span>;<br>                <span class="hljs-number">4&#x27;b1000</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10000000</span>;<br>                <span class="hljs-number">4&#x27;b1001</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10011000</span>;<br>                <span class="hljs-number">4&#x27;b1010</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10001000</span>;<br>                <span class="hljs-number">4&#x27;b1011</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10000011</span>;<br>                <span class="hljs-number">4&#x27;b1100</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11000110</span>;<br>                <span class="hljs-number">4&#x27;b1101</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10100001</span>;<br>                <span class="hljs-number">4&#x27;b1110</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10000110</span>;<br>                <span class="hljs-keyword">default</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10001110</span>;<br>            <span class="hljs-keyword">endcase</span><br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p>译码驱动七段数码管</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> <span class="hljs-number">_7</span>Seg_Driver_Decode(SW, SEG, AN, LED);<br><span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] SW;           <span class="hljs-comment">// 16位拨动开关</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] SEG;      <span class="hljs-comment">// 7段数码管驱动，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;           <span class="hljs-comment">// 7段数码管片选信号，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] LED;         <span class="hljs-comment">// 16位LED显示</span><br><br>decoder_4to16(<span class="hljs-variable">.in</span>(SW[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.out</span>(SEG[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]));<br>    <br>    <span class="hljs-keyword">assign</span> AN[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]   = SW[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">assign</span> LED[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] = SW[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="译码选择7段数码管"><a href="#译码选择7段数码管" class="headerlink" title="译码选择7段数码管"></a>译码选择7段数码管</h3><p>不仅数码管显示的数字直接通过译码器显示，对于哪个数码管亮的选择，采用选择器，三位的开关选择8个数码管谁亮。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210511113303265.png" style="zoom:50%;"><h4 id="三转八选择器"><a href="#三转八选择器" class="headerlink" title="三转八选择器"></a>三转八选择器</h4><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> selector_3to8(in, out);<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] in;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out;<br>    <br>    <span class="hljs-keyword">always</span>@(in)  <br>        <span class="hljs-keyword">case</span>(in)  <br>            <span class="hljs-number">3&#x27;b000</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11111110</span>;<br>            <span class="hljs-number">3&#x27;b001</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11111101</span>;<br>            <span class="hljs-number">3&#x27;b010</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11111011</span>;<br>            <span class="hljs-number">3&#x27;b011</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11110111</span>;<br>            <span class="hljs-number">3&#x27;b100</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11101111</span>;<br>            <span class="hljs-number">3&#x27;b101</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11011111</span>;<br>            <span class="hljs-number">3&#x27;b110</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10111111</span>;<br>            <span class="hljs-keyword">default</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b01111111</span>;<br>        <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p>用译码器和选择器组成的译码选择七段数码管</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> <span class="hljs-number">_7</span>Seg_Driver_Choice(SW, SEG, AN, LED);<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] SW;       <span class="hljs-comment">// 16位拨动开关</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] SEG;      <span class="hljs-comment">// 7段数码管驱动，低电平有效</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;       <span class="hljs-comment">// 7段数码管片选信号，低电平有效</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] LED;     <span class="hljs-comment">// 16位LED显示</span><br><br>    selector_3to8(<span class="hljs-variable">.in</span>(SW[<span class="hljs-number">15</span>:<span class="hljs-number">13</span>]), <span class="hljs-variable">.out</span>(AN[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]));<br>    decoder_4to16(<span class="hljs-variable">.in</span>(SW[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.out</span>(SEG[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]));<br>    <br>    <span class="hljs-keyword">assign</span> LED[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] = SW[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="简单时序电路-数码管动态显示"><a href="#简单时序电路-数码管动态显示" class="headerlink" title="简单时序电路 数码管动态显示"></a>简单时序电路 数码管动态显示</h3><h4 id="分频器"><a href="#分频器" class="headerlink" title="分频器"></a>分频器</h4><ul><li><p>nexys4ddr实验板的系统时钟信号由E3引脚提供，频率100MHz，周期10ns。</p></li><li><p>设计一个频率为1Hz（周期为1s）的分频器divider，可在模块中用parameter定义一个参数delay，值为50,000,000，同时定义一个变量cnt对系统时钟clk的上升沿进行计数。每当cnt计数到delay（50,000,000×10ns=500,000,000ns=0.5s）时，将分频时钟信号CK的电平反转，即可得到周期为1s的分频时钟信号。在上层模块中实例化divider模块时，可传递新的参数来调整delay的值，得到合适频率的分频时钟信号。</p></li><li><p>设计上层模块lab3_1，实例化分频器模块divider，用分频器模块的输出信号控制led[0]闪亮。</p></li><li><p>在上层模块中修改分频器模块的参数delay，观察led[0]闪亮快慢的变化。</p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> divider(clk, clk_N);<br>    <span class="hljs-keyword">input</span> clk;                      <span class="hljs-comment">// 系统时钟</span><br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> clk_N;                   <span class="hljs-comment">// 分频后的时钟</span><br>    <span class="hljs-keyword">parameter</span> N = <span class="hljs-number">50_000_000</span>;     <span class="hljs-comment">// 1Hz的时钟,N=fclk/fclk_N</span><br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] counter;             <span class="hljs-comment">/* 计数器变量，通过计数实现分频。当计数器从0计数到50_000_000时，输出时钟翻转，计数器清零 */</span><br><br>    <span class="hljs-keyword">initial</span><br>    <span class="hljs-keyword">begin</span>                           <span class="hljs-comment">// 赋初始值</span><br>        counter = <span class="hljs-number">0</span>;<br>        clk_N = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)           <span class="hljs-comment">// 时钟上升</span><br>    <span class="hljs-keyword">begin</span><br>        counter &lt;= counter + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (counter &gt; N )   <span class="hljs-comment">//每次初始时钟记满50_000_000次后，即每0.5s，新的时钟信号翻转一次，就得到了周期为1s的时钟。</span><br>            <span class="hljs-keyword">begin</span><br>                clk_N &lt;= ~clk_N;<br>                counter &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h4 id="三位计数器"><a href="#三位计数器" class="headerlink" title="三位计数器"></a>三位计数器</h4><ul><li>所谓计数器就是在时钟信号沿的控制下能够进行自动加或减（通常是+1或-1）的时序电路。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> counter(clk, out);<br>    <span class="hljs-keyword">input</span> clk;                    <span class="hljs-comment">// 计数时钟</span><br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] out;         <span class="hljs-comment">// 计数值</span><br><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)         <span class="hljs-comment">// 在时钟上升沿计数器加1</span><br>    <span class="hljs-keyword">begin</span><br>        out &lt;= out + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h4 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h4><ul><li>设计一个容量为8单元的4位只读存储器，里面存放待显示数字0、2、4、6、8、A、C、E 的4位二进制编码，可在initial语句中对存储器进行初始化。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> rom8x4(addr, data);<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] addr;               <span class="hljs-comment">// 地址</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] data;              <span class="hljs-comment">// 地址addr处存储的数据 </span><br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>: <span class="hljs-number">0</span>] mem [<span class="hljs-number">7</span>: <span class="hljs-number">0</span>];          <span class="hljs-comment">//  8个4位的存储器</span><br><br>    <span class="hljs-keyword">initial</span>                         <span class="hljs-comment">// 初始化存储器</span><br>        <span class="hljs-keyword">begin</span><br>            mem[<span class="hljs-number">0</span>]=<span class="hljs-number">4&#x27;b0000</span>;<br>            mem[<span class="hljs-number">1</span>]=<span class="hljs-number">4&#x27;b0010</span>;<br>            mem[<span class="hljs-number">2</span>]=<span class="hljs-number">4&#x27;b0100</span>;<br>            mem[<span class="hljs-number">3</span>]=<span class="hljs-number">4&#x27;b0110</span>;<br>            mem[<span class="hljs-number">4</span>]=<span class="hljs-number">4&#x27;b1000</span>;<br>            mem[<span class="hljs-number">5</span>]=<span class="hljs-number">4&#x27;b1010</span>;<br>            mem[<span class="hljs-number">6</span>]=<span class="hljs-number">4&#x27;b1100</span>;<br>            mem[<span class="hljs-number">7</span>]=<span class="hljs-number">4&#x27;b1110</span>;<br>        <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">assign</span> data[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] = mem[addr];   <span class="hljs-comment">// 读取addr单元的值输出</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h4 id="数码管动态显示"><a href="#数码管动态显示" class="headerlink" title="数码管动态显示"></a>数码管动态显示</h4><p>顶层模块</p><p>实现八个数码管从右至左“分时”显示存储器中的数据，即mem[0]值在AN0显示，mem[1]值在AN1显示，……</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> dynamic <span class="hljs-number">_</span>scan(clk,  SEG, AN);<br><span class="hljs-keyword">input</span> clk;              <span class="hljs-comment">// 系统时钟</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] SEG;  <span class="hljs-comment">// 分别对应CA、CB、CC、CD、CE、CF、CG和DP</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;        <span class="hljs-comment">// 8位数码管片选信号</span><br><br>┋                      <span class="hljs-comment">// 功能实现</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210511120547376.png" style="zoom: 33%;"><p>信号进来以后，先通过分频器得到人眼可以识别的信号频率</p><p>新的信号频率通过计数器得到八位不同状态</p><p>计数器得到的数据分别用来选择数码管和显示数字</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> dynamic_scan(clk, SEG, AN);<br>    <span class="hljs-keyword">input</span> clk;              <span class="hljs-comment">// 系统时钟</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] SEG;  <span class="hljs-comment">// 分别对应CA、CB、CC、CD、CE、CF、CG和DP</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;        <span class="hljs-comment">// 8位数码管片选信</span><br>    <span class="hljs-keyword">wire</span> clk_tmp;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] num;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] code;<br><br>    divider d1(<span class="hljs-variable">.clk</span>(clk), <span class="hljs-variable">.clk_N</span>(clk_tmp));<br>    counter c1(<span class="hljs-variable">.clk</span>(clk_tmp), <span class="hljs-variable">.out</span>(num[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]));<br>    selector_3to8(<span class="hljs-variable">.in</span>(num[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.out</span>(AN[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]));<br>    rom8x4(<span class="hljs-variable">.addr</span>(num[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.data</span>(code[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]));<br>    decoder_4to16(<span class="hljs-variable">.in</span>(code[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.out</span>(SEG[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]));<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>常见电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10常用快捷键</title>
    <link href="/2021/05/08/win10%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/05/08/win10%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="win10常用快捷键"><a href="#win10常用快捷键" class="headerlink" title="win10常用快捷键"></a>win10常用快捷键</h3><p>作为一名鼠标重度依赖者，没有鼠标的时候感觉做什么都很别扭</p><p>实际上触控板和键盘快捷键用熟练之后还是很方便的（主要是很装b</p><p>整理一些win10常用的快捷键。</p><span id="more"></span><ul><li><p><strong>win+D</strong> 切换到桌面，显示桌面，速成老板键，摸鱼专用</p></li><li><p><strong>win+E</strong> 打开快速访问，当然如果想要打开的是我的电脑，可以设置</p><hr><p>点击<strong>查看</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210508173836402.png" style="zoom:33%;"><p>点击选项</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/20210508174058.png" alt="image-20210508174035591" style="zoom:33%;"><p>将快速访问改为此电脑。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/20210508175332.png" style="zoom:33%;"><hr></li><li><p><strong>win+I</strong> 打开设置界面（系统、设备等）</p></li><li><p><strong>win+L</strong> 快速锁屏，相当于默认的睡眠</p></li><li><p><strong>win+M</strong> 最小化所有窗口</p></li><li><p><strong>win+shift+M</strong> 还原最小化的窗口</p></li><li><p><strong>win+R</strong> 打开电脑的运行，输入指令，文末附常用的指令</p></li><li><p><strong>win+V</strong> 多重剪切板，即记录之前所有的复制记录</p></li><li><p><strong>win+W</strong> 打开ink工作区，非常好用</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/20210508175219.png" alt="image-20210508175105242" style="zoom:33%;"></li><li><p><strong>win+方向</strong>，电脑分屏，二分三分四分，很常用。</p></li><li><p><strong>win+tab</strong>，新建一个虚拟桌面，可以在不同的虚拟桌面中打开不同的程序。一个用来办公，一个用来游戏等等。</p></li><li><p><strong>win+数字</strong>，打开任务栏的第N个程序（装b用，没什么太大的作用）</p></li><li><p><strong>win+ +/-</strong>  缩放屏幕，没什么用</p></li><li><p><strong>win+ctrl+方向左右</strong> 切换虚拟桌面</p></li></ul><ul><li><strong>ctrl+X</strong> 剪切</li><li><strong>ctrl+C</strong> 复制</li><li><strong>ctrl+V</strong> 粘贴</li><li><strong>ctrl+Z</strong> 撤销</li><li><strong>ctrl+Y</strong> 恢复</li><li><strong>ctrl+shift+T</strong> 恢复被关闭的网页</li><li><strong>ctrl+N</strong> 创建同级界面，即若当前界面为word，ctrl+N就新建一个word</li><li><strong>ctrl+shift+N</strong> 新建文件夹</li><li><strong>ctrl+W</strong> 关闭当前界面</li><li><strong>ctrl+shift+esc</strong> 打开任务管理器</li><li><strong>ctrl+shift+F</strong> 切换到繁体输入</li></ul><ul><li><strong>shift+delete</strong> 永久删除文件，即包括回收站也无法留存。</li><li><strong>Alt+鼠标双击/Enter</strong> 查看文件的属性</li><li><strong>Alt+Tab</strong> 切换应用窗口 很常用</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>win10快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——JavaFx</title>
    <link href="/2021/04/28/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94JAVAFX/"/>
    <url>/2021/04/28/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94JAVAFX/</url>
    
    <content type="html"><![CDATA[<h2 id="JAVA-UI编程经历的三个阶段"><a href="#JAVA-UI编程经历的三个阶段" class="headerlink" title="JAVA UI编程经历的三个阶段"></a>JAVA UI编程经历的三个阶段</h2><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428001620727.png" alt="image-20210428001620727"></p><span id="more"></span><h2 id="JavaFx程序的基本结构"><a href="#JavaFx程序的基本结构" class="headerlink" title="JavaFx程序的基本结构"></a>JavaFx程序的基本结构</h2><p><strong>Java FX工程结构图如下所示</strong></p><p><strong>Java FX采用MVC（Model-View-Control）设计模式：</strong></p><p><strong>降低了界面展现、应用逻辑、用户对视图的操作控制三部分的耦合度。</strong></p><p>（UI的程序都是基于事件驱动，用户点击按钮，触发事件，事件处理函数中写逻辑。如果不采用MVC，导致逻辑被写进事件处理函数，界面展示和应用逻辑搅在一起，可维护性很差）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428001634383.png" alt="image-20210428001634383" style="zoom: 67%;"><ol><li>不管播放器的UI怎么设计，先设计一个Model，里面有状态、数据、方法。</li><li>专门负责界面展现 视图</li><li>控制器</li></ol><p>以上三部分相对独立，用户对视图的操作转到控制器，控制器解读操作含义，来操作模型。如操作player，控制器向模型请求player模型放歌，模型告诉视图状态已经改变，视图显示位用户更新。</p><p>使用IDEA创建工程，工程要选择Java FX，就产生如下的工程文件</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428002247404.png" alt="image-20210428002247404"></p><p>设计一个网页的时候，网页的视图就是html描述，如上xml与网页联系起来。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>要实现如下页面，一个编辑框和一个按钮</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428003306682.png" alt="image-20210428003306682"></p><p>对应的配置文件：语法基于xml，可扩展的标记语言。JavaFx UI的开发和设计网页是完全一致，设计网页用html，html实际上是xml的一个实例，开发方式与web开发统一起来。</p><p>如下为sample.fxml</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428003543633.png" alt="image-20210428003543633"></p><blockquote><p> pane为根节点，第二行fx:controller是很重要的属性，指定了视图的控制器，引入类名</p><p>里面两个组件Button和TextField，如果需要在Java程序里访问空间，需要在xml里指定控件的fx:id属性</p></blockquote><p>Java中通过如下语句加载</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">// Main.java里加载sample.fxml</span><br>FXMLLoader loader = <span class="hljs-keyword">new</span> FXMLLoader(getClass().getResource(“sample.fxml<span class="hljs-string">&quot;));</span><br><span class="hljs-string">Pane root = loader.load(); //返回一个对象，对象的类型就是根节点的类型Pane，将整个视图加载进来</span><br></code></pre></div></td></tr></table></figure><h3 id="Main类的实现"><a href="#Main类的实现" class="headerlink" title="Main类的实现"></a>Main类的实现</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Main必须继承Application(JavaFx定义好的),并覆盖start方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br><span class="hljs-meta">@Override</span>  <span class="hljs-comment">//覆盖Application中的start方法</span><br>    <span class="hljs-comment">//Stage就是舞台（窗体），可以随时切换场景</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Stage primaryStage)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.加载sample.fxml</span><br>FXMLLoader loader = <span class="hljs-keyword">new</span> FXMLLoader(getClass().getResource(“sample.fxml<span class="hljs-string">&quot;));</span><br><span class="hljs-string">                                                                         //2.加载视图的根节点（fxml里根节点），自动加载根节点下面所有的UI控件</span><br><span class="hljs-string">Pane root = loader.load();</span><br><span class="hljs-string"></span><br><span class="hljs-string">//3.得到控制器实例</span><br><span class="hljs-string">Controller controller = loader.getController();</span><br><span class="hljs-string"></span><br><span class="hljs-string">            //4.将Main对象传进控制器，这样控制器就可以访问Main对象的成员</span><br><span class="hljs-string">            controller.setMyApp(this);</span><br><span class="hljs-string"></span><br><span class="hljs-string">//5.Scene构造函数第一个参数指定了场景里的根节点对象root（前面已加载）</span><br><span class="hljs-string">//root是视图的根结点，将整个视图加载进scene中了</span><br><span class="hljs-string">Scene scene = new Scene(root,400,600);</span><br><span class="hljs-string">                                                                      //6.切换了舞台的场景</span><br><span class="hljs-string">primaryStage.setScene(scene);</span><br><span class="hljs-string">primaryStage.show();</span><br><span class="hljs-string">&#125; catch(Exception e) &#123;</span><br><span class="hljs-string">e.printStackTrace();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">public static void main(String[] args) &#123;</span><br><span class="hljs-string">//静态方法，Application里已经定义好了</span><br><span class="hljs-string">        launch(args);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></div></td></tr></table></figure><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controller</span> </span>&#123;<br><span class="hljs-meta">@FXML</span>    <br>    <span class="hljs-keyword">private</span> TextField text;<br><br>    <span class="hljs-comment">//Main对象引用，引用Main的实例，这样控制器就可以访问Main对象的成员</span><br><span class="hljs-keyword">private</span> Main myApp;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyApp</span><span class="hljs-params">(Main myApp)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.myApp = myApp;<br>&#125;<br><br><span class="hljs-meta">@FXML</span>    <span class="hljs-comment">//ActionEvent e用户点击按钮的事件处理函数</span><br>    <span class="hljs-comment">//@FXML标注将onClick函数与xml中定义的onAction=“#onClick” 绑定</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;<br>text.setText(<span class="hljs-string">&quot;Button Cliked&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>@FXML标注很重要，将实例变量名与xml中fx:id属性值相同的控件绑定起来，</p><p>在Java程序里通过text引用，可以控制TextField对象（读写），比如onClick方法里的text.setText方法</p></blockquote><hr><p>视图 控制器 model Main(仅仅是启动类)如何关联</p><p>@FXML标注，controller就可以得到视图文件中任何一个UI组件的实例</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428003543633.png" alt="image-20210428003543633"></p><p>如下，控制器中的</p><p>private TextField text    对应fxml中的TextField fx:id=”text”</p><p>public void onclick(ActionEvent e){}   对应onAction=”#onClick”</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@FXML</span>    <br>    <span class="hljs-keyword">private</span> TextField text;<br><span class="hljs-meta">@FXML</span>    <br><span class="hljs-comment">//@FXML标注将onClick函数与xml中定义的onAction=“#onClick” 绑定</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;<br>text.setText(<span class="hljs-string">&quot;Button Cliked&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><p>controller和main联系起来，如下属性和方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Main对象引用，引用Main的实例，这样控制器就可以访问Main对象的成员</span><br><span class="hljs-keyword">private</span> Main myApp;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyApp</span><span class="hljs-params">(Main myApp)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.myApp = myApp;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>我们讨论了Controller（控制器）、fxml配置文件（视图）。那么Model呢？Main不要作为模型类，应该在工程里添加Model类。Main只是JavaFX应用的启动类。控制器如何拿到Model的对象？定义一个类似于setMyApp的方法，例如：</p><p>  public void setModel(Model model)。</p><p>然后在Main类里实例化Model对象，通过拿到的Controller实例（Main类中），controller调用setModel方法。Model就传到Controller里</p></blockquote><h3 id="也可以完全用Java程序创建UI"><a href="#也可以完全用Java程序创建UI" class="headerlink" title="也可以完全用Java程序创建UI"></a>也可以完全用Java程序创建UI</h3><p>start中直接new了Button，再创建scene，将btOK入scene第一个参数，就是UI的根结点，scene中只有一个button，占满整个scene。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> javafx.application.Application ;<br><span class="hljs-keyword">import</span> javafx.scene.Scene;<br><span class="hljs-keyword">import</span> javafx.scene.control .Button;<br><span class="hljs-keyword">import</span> javafx.stage.Stage;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJavaFX</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Stage primaryStage)</span> </span>&#123;<br>    Button btOK = <span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;OK&quot;</span>);<br>    Scene scene = <span class="hljs-keyword">new</span> Scene(btOK, <span class="hljs-number">200</span>, <span class="hljs-number">250</span>);<br>    primaryStage.setTitle(<span class="hljs-string">&quot;MyJavaFX&quot;</span>); <br>    primaryStage.setScene(scene); <br>    primaryStage.show(); <br>  &#125;<span class="hljs-comment">//注意按钮占满了了整个场景  </span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Application.launch(args);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>需从Application类派生</strong></p><p><strong>重写start方法：用于启动主窗体(Stage类型)。</strong></p></blockquote><blockquote><p><strong>如果想启动两个窗体（Stage），可在start中创建新的Stage对象。</strong></p></blockquote><blockquote><p><strong>Stage就像一个舞台，由场景Scene组成。场景可以切换（Stage的setScene方法）</strong></p></blockquote><blockquote><p><strong>launch 方法是一个定义在Application 类中的静态方法，用于启动一个独立的JavaFX 应用：激活start方法。</strong></p></blockquote><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428010018119.png" alt="image-20210428010018119"></p><p><strong>注意也可以完全脱离fxml，完全在Java程序里定义视图的内容，这个例子就是如此。但不推荐这样做，用fxml定义视图，可以将代码与视图定义分离。有的同学担心fxml写起来太麻烦，不用担心。利用UI设计工具SceneBuilder，用拖拽控件的方式设计好UI后，会自动产生fxml配置文件。</strong></p><h2 id="面板、UI组件以及形状"><a href="#面板、UI组件以及形状" class="headerlink" title="面板、UI组件以及形状"></a>面板、UI组件以及形状</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210429002126467.png" style="zoom:67%;"><blockquote><p> 一个Stage就是一个窗口，在<strong>Stage中包含了多个Scene</strong>，Stage可以通过setScene切换场景</p></blockquote><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210429003434137.png" style="zoom:50%;"><blockquote><p><strong>Scene包含多个Parent</strong>（Pane或者Control），但其中只<strong>有一个根节点root，根节点的类型可以是Parent，Pane，Control</strong>(Parent或其子类，但Scene里不能包含Shape，ImageView，因为这两个不是Parent的子类，不能直接放在Scene)，根节点里面可以有很多UI的具体组件，UI组件都是Node类型，Node是所有可视化组件的祖先类</p></blockquote><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210429003704742.png" style="zoom:33%;"><blockquote><p>Node有多个子类， </p><ul><li><p>其中第一个子类Parant，凡是Parant派生的，都有子节点。其两个子类</p><ol><li><p>Control：子类为各种UI组件</p></li><li><p>面板Pane，子类为许多具体面板。</p></li></ol></li><li><p>Node可以直接派生子类</p><div class="hljs code-wrapper"><pre><code>  1. Shape：各种形状，  2. ImageView：图像。</code></pre></div><p>  Node直接派生的，而不是Parant派生的，这些类没有子节点，这些类的对象只能加载到Parant。</p></li></ul></blockquote><blockquote><p>面板Pane</p><p>通常是作为一个容器，面板Pane里面可以包含很多Node，Node是所有可视化UI组件的祖先类，因此Pane里还可以嵌套Pane，也可以放UI组件。面板的主要作用是布局。</p></blockquote><p>界面元素的包含关系</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210429003347993.png" style="zoom: 67%;"><blockquote><p>注意:</p><p>(1)派生：Node-&gt;Parent-&gt;Pane，</p><p>  故Pane可包含Node的任何子类。</p><p>(2)Pane由Node构成-&gt;故可由Pane构成，</p><p>  故Pane可包含多个Pane。</p><p>(3)Scene可包含Control或Pane, 但不能</p><p>  包含Shape和ImageView。</p></blockquote><hr><p>通过最开始的例子进行解释</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210429005012890.png"></p><blockquote><p>注意Pane作为容器，负责里面UI组件的布局(Layout). Pane可以相互嵌套，实现任意复杂的布局。</p></blockquote><blockquote><p>如果需要在Pane里加入更多UI组件</p><p>在fxml文件的Pane节点里添加子节点</p></blockquote><hr><p>可以通过Java程序动态地向UI界面添加新的UI组件</p><p><strong>pane.getChi1dren().add(构造好的UI组件对象);是将一个UI组件加入面板的方法。</strong></p><p>这个代码<strong>不需要fxml文件可以运行</strong>。因此，我们可以不依赖于fxml，直接在程序里创建UI并布局（当然比较麻烦）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"> <span class="hljs-keyword">import</span> javafx.application.Application;<br> <span class="hljs-keyword">import</span> javafx.scene.Scene;<br> <span class="hljs-keyword">import</span> javafx.scene.control.Button;<br> <span class="hljs-keyword">import</span> javafx.stage.Stage;<br> <span class="hljs-keyword">import</span> javafx.scene.1ayout.StackPane;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ButtonlnPane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Stage primaryStage)</span></span>&#123;<br> <span class="hljs-comment">/*StackPane：Pane的子类，</span><br><span class="hljs-comment"> 它实现的布局方式是：控件在同一中央位置堆叠存放，</span><br><span class="hljs-comment"> 一个控件可能覆盖其它控件。</span><br><span class="hljs-comment">*/</span><br>        StackPane pane = <span class="hljs-keyword">new</span> StackPane();<br><span class="hljs-comment">/*程序将Button控件加入StackPane。</span><br><span class="hljs-comment">getChildren返回javafx.collections.ObservableList 的一个实例。子节点列表</span><br><span class="hljs-comment">*/</span><br>        <span class="hljs-comment">/*ObservableList类似于ArrayList, 用于存储元素集合。</span><br><span class="hljs-comment">        调用add(e)可将一个元素加入集合的列表。</span><br><span class="hljs-comment">*/</span><br>        pane.getChildren().add(<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;OK&quot;</span>));<br><br>        Scene scene = <span class="hljs-keyword">new</span> Scene(pane, <span class="hljs-number">200</span>,<span class="hljs-number">50</span>);<br><br>        primaryStage.setTitle(<span class="hljs-string">&quot;Button in a pane&quot;</span>); <br><br>        primaryStage.setScene(scene);     <br><br>        primaryStage.show(); <span class="hljs-comment">// Display the stage</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>JavaFx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JavaFx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog常见电路</title>
    <link href="/2021/04/25/verilog%E5%B8%B8%E7%94%A8%E7%94%B5%E8%B7%AF/"/>
    <url>/2021/04/25/verilog%E5%B8%B8%E7%94%A8%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="2-1选择器"><a href="#2-1选择器" class="headerlink" title="2-1选择器"></a>2-1选择器</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 2-1 选择器</span><br><br><span class="hljs-keyword">module</span> mux_21(a, b, sel, out);<br>    <span class="hljs-keyword">parameter</span> WIDTH = <span class="hljs-number">8</span>;<br>    <br>    <span class="hljs-keyword">input</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a, b;<br>    <span class="hljs-keyword">input</span> sel;<br>    <span class="hljs-keyword">output</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] out;<br>    <br>    <span class="hljs-comment">// 三元运算符</span><br>    <span class="hljs-keyword">assign</span> out = sel == <span class="hljs-number">0</span> ? a : b;<br>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></div></td></tr></table></figure><span id="more"></span><h3 id="4-1选择器"><a href="#4-1选择器" class="headerlink" title="4-1选择器"></a>4-1选择器</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 4-1 1 bit 选择器设计方案I</span><br><span class="hljs-keyword">module</span> mux_41(a, b, c, d, <br>  sel, out);<br><br>  <span class="hljs-keyword">input</span> a, b, c, d;<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out;<br><br>  <span class="hljs-keyword">always</span> @(a, b, c, d, sel)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (sel == <span class="hljs-number">2&#x27;b00</span>)<br>      out = a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sel == <span class="hljs-number">2&#x27;b01</span>)<br>      out = b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sel == <span class="hljs-number">2&#x27;b10</span>)<br>      out = c;<br>    <span class="hljs-keyword">else</span> out = d;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 4-1 1 bit 选择器设计方案II</span><br><span class="hljs-keyword">module</span> mux_41(a, b, c, d, <br>  sel, out);<br><br>  <span class="hljs-keyword">input</span> a, b, c, d;<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out;<br><br>  <span class="hljs-keyword">always</span> @(a, b, c, d, sel)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(sel)<br>      <span class="hljs-number">2&#x27;b00</span>: out = a;<br>      <span class="hljs-number">2&#x27;b01</span>: out = b;<br>      <span class="hljs-number">2&#x27;b10</span>: out = c;<br>      <span class="hljs-keyword">default</span>: out = d;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 4-1 选择器设计方案 III</span><br><br><span class="hljs-keyword">module</span> mux_41(a, sel, out);<br>    <span class="hljs-keyword">parameter</span> WIDTH = <span class="hljs-number">8</span>;<br>    <br>    <span class="hljs-keyword">input</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>    <span class="hljs-keyword">output</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] out;<br>    <br>    <span class="hljs-comment">// 利用数组</span><br>    <span class="hljs-keyword">assign</span> out = a[sel];<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h2 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h2><ul><li><p><strong>译码器：将具有特定含义的二进制代码转换成控制信号的器件。</strong></p></li><li><p><strong>地址译码器</strong></p></li><li><p><strong>显示译码器</strong></p></li><li><p><strong>指令译码器</strong></p></li><li><p><strong>…</strong></p></li></ul><p><strong>通过二进制编码来选择当前占用总线的设备。</strong></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210427202403937.png" alt="image-20210427202403937"></p><h3 id="38译码器"><a href="#38译码器" class="headerlink" title="38译码器"></a>38译码器</h3><p>最常见的地址译码器 3比特构成8个设备的地址的地址译码器</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 3-8 译码器 行为描述方法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">要点：</span><br><span class="hljs-comment">1、输出（被赋值的对象必须被声明为寄存器类型）</span><br><span class="hljs-comment">2. 用always做关键词,后面跟@():trigger list,包含所有影响输出的变量，如果变化，就执行always</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">module</span> decoder_38(A, Y);<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] A;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] Y;<br><br>  <span class="hljs-keyword">always</span> @(A)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(A)<br>      <span class="hljs-number">3&#x27;d0</span>: Y = <span class="hljs-number">8&#x27;b1111_1110</span>;<br>      <span class="hljs-number">3&#x27;d1</span>: Y = <span class="hljs-number">8&#x27;b1111_1101</span>;<br>      <span class="hljs-number">3&#x27;d2</span>: Y = <span class="hljs-number">8&#x27;b1111_1011</span>;<br>      <span class="hljs-number">3&#x27;d3</span>: Y = <span class="hljs-number">8&#x27;b1111_0111</span>;<br>      <span class="hljs-number">3&#x27;d4</span>: Y = <span class="hljs-number">8&#x27;b1110_1111</span>;<br>      <span class="hljs-number">3&#x27;d5</span>: Y = <span class="hljs-number">8&#x27;b1101_1111</span>;<br>      <span class="hljs-number">3&#x27;d6</span>: Y = <span class="hljs-number">8&#x27;b1011_1111</span>;<br>      <span class="hljs-number">3&#x27;d7</span>: Y = <span class="hljs-number">8&#x27;b0111_1111</span>;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><blockquote><p>常数的声明方法:</p><p>[宽度]‘[进制][值]</p><p>硬件中，不能赋没有位宽的值，没有位宽的值在硬件中通常为32位的值，通常又用不到，浪费资源。所以通常要指定位宽</p><p>为了更好的阅读二进制串，允许中间用_连接，verilog会自动去掉_</p></blockquote><p>负值逻辑：enable逻辑信号是为了让选中的信号有效，其他的信号无效。</p><p>硬件中对于enable信号通常采用负逻辑，0有效，1无效，因为负逻辑不容易被误触发。通常无效的时候是1，被干扰的可能性较小，使得设备不会被误触发。</p><p>通常enable，reset，控制信号写允许读允许都用负值逻辑</p><h2 id="分频器"><a href="#分频器" class="headerlink" title="分频器"></a>分频器</h2><p>分频是指将时钟信号的频率进行降低的时序电路，例如：如果要将频率降低为原来的1/N，就叫N分频。为便于高层模块改变分频系数N，将N定义为参数。实例化时可以把参数传递进去：  </p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> divider(clk, clk_N);<br>    <span class="hljs-keyword">input</span> clk;                      <span class="hljs-comment">// 系统时钟</span><br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> clk_N;                   <span class="hljs-comment">// 分频后的时钟</span><br>    <span class="hljs-keyword">parameter</span> N = <span class="hljs-number">100_000_000</span>;     <span class="hljs-comment">// 1Hz的时钟,N=fclk/fclk_N</span><br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] counter;             <span class="hljs-comment">/* 计数器变量，通过计数实现分频。当计数器从0计数到(N/2-1)时，输出时钟翻转，计数器清零 */</span><br><br>    <span class="hljs-keyword">initial</span><br>    <span class="hljs-keyword">begin</span>                           <span class="hljs-comment">// 赋初始值</span><br>        counter = <span class="hljs-number">0</span>;<br>        clk_N = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)           <span class="hljs-comment">// 时钟上升</span><br>    <span class="hljs-keyword">begin</span><br>        counter &lt;= counter + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (counter &gt; N / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">begin</span><br>                clk_N &lt;= ~clk_N;<br>                counter &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p>如上，1Hz的时钟，分频后将其变成每N/2=0.5Hz，时钟翻转一次，这样就对时钟进行分频</p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="简单加法计数器"><a href="#简单加法计数器" class="headerlink" title="简单加法计数器"></a>简单加法计数器</h3><p>时钟脉冲来的时候，就+1，四位，将记到f的时候再+1就溢出，归0</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> CNT4 (CLK,Q);<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] Q;<br>    <span class="hljs-keyword">input</span> CLK;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] Q;<br>    <span class="hljs-keyword">always</span>@(posegde CLK)<br>        Q&lt;=Q+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210427203236919.png" alt="image-20210427203236919"></p><h3 id="实用加法计数器"><a href="#实用加法计数器" class="headerlink" title="实用加法计数器"></a>实用加法计数器</h3><ul><li><p><strong>异步复位</strong> <strong>rst_n</strong> 优先级最高</p></li><li><p><strong>使能</strong> **en ** 当使能信号有效时，加法计数器才执行加法，无效时，即使有时钟脉冲，值保持不变</p></li><li><p><strong>同步预置</strong> <strong>load/data</strong>：可以预置一个计数的初始值  通过load控制信号，和预置的数data，预置初始值。load为负值逻辑，当时钟上升沿时，检测到load信号，就把data赋到计数输出</p></li><li><p><strong>计数输出</strong> **dout ** 设定记满的上限</p></li><li><p><strong>计数溢出</strong> <strong>cout</strong>：计数满时的输出信号</p><h3 id="实用模10计数器"><a href="#实用模10计数器" class="headerlink" title="实用模10计数器"></a>实用模10计数器</h3></li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 实用模 10 计数器</span><br><span class="hljs-keyword">module</span> cnt10(clk, rst_n, en, load_n, data, cout, dout);<br>    <span class="hljs-keyword">input</span> clk, rst_n, en, load_n;  <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] data;<br>    <span class="hljs-keyword">output</span> cout;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] dout;<br>    <br>    <span class="hljs-comment">//行为描述</span><br>    <span class="hljs-comment">//不能混合边沿和电平，所以两个边沿触发。rst_n为负值逻辑</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk, <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (!rst_n) dout &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">//优先级最高</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (en) <span class="hljs-keyword">begin</span>  <span class="hljs-comment">//使能en高于load，使能无效则load无效。</span><br>            <span class="hljs-keyword">if</span> (!load_n) dout &lt;= data;  <span class="hljs-comment">//load有效，赋值。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dout &lt; <span class="hljs-number">4&#x27;d9</span>) dout &lt;= dout + <span class="hljs-number">1</span>; <span class="hljs-comment">//没记满，则+1</span><br>            <span class="hljs-keyword">else</span> dout &lt;= <span class="hljs-number">4&#x27;d0</span>;  <span class="hljs-comment">//计数值记满（9）或大于9（预置了&gt;10的数，如此写避免了bug），复位到0</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">//计数到9，输出记满1信号，否则输出0</span><br>    <span class="hljs-keyword">assign</span> cout = (dout == <span class="hljs-number">4&#x27;d9</span>) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/newimg/image-20210429013238264.png" alt="image-20210429013238264"></p><h3 id="tb的写法"><a href="#tb的写法" class="headerlink" title="tb的写法"></a>tb的写法</h3><p>对于上述较为复杂的电路，用tb验证，模拟了上述的信号</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">timescale</span> 1ns / 1ps;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">必须声明timescale，tb除了做行为仿真，还要做综合后时序仿真，因为综合后会引入器件延时和布线延时，即使在行为仿真后正确，也可能在综合仿真后产生尖峰和毛刺，导致逻辑失败。</span><br><span class="hljs-comment">因此必须考虑延时。延时要声明timescale，过大，则低频电路，器件延时被忽略，若过小，则高频电路，则器件延时布线延时不可忽略，产生不可预期的后果。</span><br><span class="hljs-comment">所以tb首先要声明实在哪一个频率点上进行仿真，不可或缺。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">module</span> cnt10_tb( );<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  输入信号赋值，来模拟信号源，观测输出信号，看是否满足输出要求，既然要赋值，则通常为initial或always，因此输入信号要为reg类型</span><br><span class="hljs-comment">  输出信号只观测，则wire型。</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">reg</span> clk,rst_n,en,load_n;<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] data;<br>  <span class="hljs-keyword">wire</span> cout;<br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] dout;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    tb的第一条语句一定是调用待检测的模块，输入信号输出信号连上模块，待检测模块的一头接信号源，另一头接示波器，第一条语句始终引入待检测模块</span><br><span class="hljs-comment">    */</span><br>  cnt10 dut(clk,rst_n,en,<br>    load_n,data,cout,dout);<br><br>  <span class="hljs-comment">// 产生 10ns 周期的时钟信号，每5ns反相一次</span><br>  <span class="hljs-keyword">initial</span> clk = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">切记，做任何仿真之前，需要对该信号进行初始化，凡是没有初始化的信号，vivado认为是个x，未知状态信号，任何操作逻辑都是未知状态。</span><br><span class="hljs-comment">对输入信号操作前，要赋初值。</span><br><span class="hljs-comment">*/</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// #100 </span><br>    rst_n = <span class="hljs-number">1</span>;<br>    en = <span class="hljs-number">1</span>;<br>    load_n = <span class="hljs-number">1</span>;<br>    data = <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// 使能为0期间，不计数</span><br>    #<span class="hljs-number">10</span> en = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">15</span> en = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 异步复位，不受时钟影响</span><br>    #<span class="hljs-number">6</span> rst_n = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">2</span> rst_n = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 预置数改变不影响计数</span><br>    #<span class="hljs-number">10</span> data = <span class="hljs-number">7</span>;<br>    <span class="hljs-comment">// 直到预置数被装载</span><br>    #<span class="hljs-number">20</span> load_n = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">10</span> load_n = <span class="hljs-number">1</span>; <br>    <span class="hljs-comment">// 大于10的预置数</span><br>    #<span class="hljs-number">30</span> data = <span class="hljs-number">11</span>;<br>    #<span class="hljs-number">30</span> load_n = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">10</span> load_n = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>总是使用</strong> <strong>timescale</strong> <strong>规定时间</strong>,对后续综合后时间仿真产生影响</p><p>在全局置位、复位脉冲释放之前就确保 <em><strong>时钟源</strong></em> 已经开始工作。时钟源写在最前。</p><p><strong>在仿真时间的</strong> <strong>0</strong> <strong>时刻，将所有的设计输入初始化位为一个确定的值；</strong></p><p>**在综合后和实现后的时序仿真中，会自动触发全局置位/复位脉冲（GSR），这会让所有的寄存器在仿真的前100ns **内锁定其值。因此在100ns 之后再赋值激励数据；如果对一个带复位的时序电路仿真，而且希望做综合后实现后的时序仿真，则第一条语句要写延时100ns，保证后续所有输入在100ns后输入才能得到正确的仿真结果。</p></blockquote><h2 id="触发器和锁存器"><a href="#触发器和锁存器" class="headerlink" title="触发器和锁存器"></a>触发器和锁存器</h2><ul><li><p>触发器（Flip-flop）和锁存器（Latch）都是具有记忆功能的二进制存储器件。</p></li><li><p>触发器和锁存器的实现形式很多，在ASIC中通常使用 D 触发器和 D 锁存器。</p></li><li><p>触发器和锁存器的功能区别：</p><ul><li>触发器由时钟信号的跳边沿触发“存储”</li><li>锁存器由电平信号触发“存储”</li></ul><h3 id="基本D触发器"><a href="#基本D触发器" class="headerlink" title="基本D触发器"></a>基本D触发器</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428010431170.png" alt="image-20210428010431170" style="zoom:50%;"></li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> DFF1(CLK,D,Q)<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK) <span class="hljs-comment">//时钟上升沿才会引起赋值，非阻塞式赋值（上一个时刻存储的内容赋值给当前时刻）</span><br>        Q&lt;=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p>D触发器在时钟的边沿执行存储（写入功能），设定上升沿，每遇到上升沿，就把D的内容写入Q，随后D变化（变化中没有碰到时钟上升沿），D的变化不会写入Q。</p><p>输出存储了上一个时钟时候的写入，起到了存储的功能，每遇到时钟上升沿，就将D写入Q</p><blockquote><p>非阻塞式赋值：上一个时刻存储的内容赋给当前时刻</p><p>阻塞式赋值：执行上一次赋值后面执行出的计算出的值赋值给当前内容</p><p>时序电路使用非阻塞式赋值，非阻塞式赋值可以，但写法比较麻烦</p></blockquote><h3 id="含异步复位和使能的D触发器"><a href="#含异步复位和使能的D触发器" class="headerlink" title="含异步复位和使能的D触发器"></a>含异步复位和使能的D触发器</h3><ul><li><strong>异步</strong>复位：复位信号不受时钟控制，时钟不管是上升沿下降沿不变</li><li>复位信号通常都是<strong>负值逻辑</strong>的，抗干扰能力强，不容易被误触发</li><li>使能：使能信号有效时，触发器才工作</li><li>使能优先级低于复位信号</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428011405545.png" alt="image-20210428011405545" style="zoom:50%;"><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> DFF2(CLK,D,Q,RST,EN);<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D,RST,EN;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> RST)<br>        <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">if</span>(!RST) Q&lt;=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(EN) Q&lt;=D;<br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="含同步复位的D触发器"><a href="#含同步复位的D触发器" class="headerlink" title="含同步复位的D触发器"></a>含同步复位的D触发器</h3><ul><li>同步复位：在时钟信号跳变沿检测复位信号</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428011748095.png" alt="image-20210428011748095" style="zoom:50%;"><p>复位信号为1时若时钟为上升沿，则复位</p><p>时钟上升沿时检测到复位信号。</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> DFF3(CLK,D,Q,RST);<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D,RST;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK)<br>        <span class="hljs-keyword">if</span>(RST==<span class="hljs-number">1</span>) Q=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (RST==<span class="hljs-number">0</span>) Q=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428012140989.png" alt="image-20210428012140989"></p><h3 id="基本锁存器"><a href="#基本锁存器" class="headerlink" title="基本锁存器"></a>基本锁存器</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428080744342.png" alt="image-20210428080744342" style="zoom:50%;"><p>最大的区别在于锁存器是电平触发</p><p>clk=1的时候，Q随D变化，clk=0时，Q不变</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> LATCH1(CLK,D,Q);<br>    <span class="hljs-keyword">output</span> Q; <span class="hljs-keyword">input</span> CLK,D;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span> @(D oir CLK)<br>        <span class="hljs-keyword">if</span>(CLK) Q&lt;=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>CLK</strong> <strong>==</strong> <strong>1</strong> <strong>时，等于直通电路，等于写入当前状态。</strong></p><p><strong>CLK</strong> <strong>==</strong> <strong>0</strong> <strong>时，保持输出，等于记忆当前状态。</strong></p></blockquote><h3 id="含异步复位的锁存器"><a href="#含异步复位的锁存器" class="headerlink" title="含异步复位的锁存器"></a>含异步复位的锁存器</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428081400344.png" alt="image-20210428081400344" style="zoom:50%;"><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> LATCH3 (CLK,D,Q,RST);<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D,RST;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(D <span class="hljs-keyword">or</span> CLK <span class="hljs-keyword">or</span> RST)<br>        <span class="hljs-keyword">if</span>(!RST) Q&lt;=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(CLK) Q&lt;=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><blockquote><p>复位的优先级总是最高的。</p><p>锁存器中，CLK往往也被称为LE（latch enable）</p></blockquote><h3 id="触发器和锁存器的比较"><a href="#触发器和锁存器的比较" class="headerlink" title="触发器和锁存器的比较"></a>触发器和锁存器的比较</h3><p><strong>Latch 对输入电平敏感，受布线延时影响大，很难保证没有毛刺的输出；而 DFF 不容易产生毛刺。</strong></p><p><strong>FPGA 中没有 Latch 单元，只有 FF 单元 (我们使用的 Artix-7 中，有 126,800 个 FF)，需要用多个逻辑单元来实现 Latch，因此使用 FF 更节约资源。</strong></p><p><strong>但是，在某些设计中，Latch 不可替代。</strong></p><p><strong>结论：尽可能避免 Latch 的产生。例如：一个不“完备”的条件语句（有 if 而无 else，case 没有 default）（没有完全穷举状态的时候）将会产生 Latch。</strong></p><p>例如3-1 bit选择器，如下只对三种状态赋值，产生锁存器</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 3-1 1 bit 选择器</span><br><br><span class="hljs-keyword">module</span> mux_31(a,b,c,sel,out);<br><br>  <span class="hljs-keyword">input</span> a, b, c;<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out;<br><br>  <span class="hljs-keyword">always</span> @(a, b, c, sel)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(sel)<br>      <span class="hljs-number">2</span>’b00: out = a;<br>      <span class="hljs-number">2</span>’b01: out = b;<br>      <span class="hljs-number">2</span>’b10: out = c;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428082140830.png" alt="image-20210428082140830" style="zoom: 50%;"><p>锁存器当sel=11时，锁存器将保持过去的状态不会改变</p><h2 id="寄存器和存储器"><a href="#寄存器和存储器" class="headerlink" title="寄存器和存储器"></a>寄存器和存储器</h2><ul><li><p>寄存器（register）：用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。</p></li><li><p>存储器（memory）：也是用来存放数据的区域，分为 ROM 和 RAM 两类。</p></li><li><p>寄存器与存储器的制造工艺不同：</p><ul><li><p>寄存器通常使用触发器和锁存器来实现，速度快、占用面积大</p></li><li><p>存储器通常使用 6 MOS 管（静态存储器）或 1 MOS 管（动态存储器）实现，速度慢，占用面积小</p></li><li><p>FPGA 中通常配有专门的存储单元，而不用逻辑门来实现存储。Aritx-7 上有大约 5Mbits 的可配置内存块。</p></li></ul></li></ul><h3 id="基本寄存器"><a href="#基本寄存器" class="headerlink" title="基本寄存器"></a>基本寄存器</h3><p>根据触发器和锁存器分析。FPGA中寄存器最好用触发器实现（占用资源少，稳定）</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> register(clk,en,d,q);<br>    <span class="hljs-keyword">parameter</span> WHIDTH = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">input</span> clk,rst_n,en;<br>    <span class="hljs-keyword">input</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] d;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [width-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] q;<br>    <br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(!rst_n) q&lt;=<span class="hljs-number">0</span>;   <span class="hljs-comment">//复位</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(en) q&lt;=d;  <span class="hljs-comment">//能赋值</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="双端口存储器-结构最简单"><a href="#双端口存储器-结构最简单" class="headerlink" title="双端口存储器(结构最简单)"></a>双端口存储器(结构最简单)</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ram(data,read_addr,write_addr,clk,we,q);<br>    <span class="hljs-keyword">parameter</span> DATA_WIDTH=<span class="hljs-number">8</span>; <span class="hljs-comment">//数据宽度</span><br>    <span class="hljs-keyword">parameter</span> ADDR_WIDTH=<span class="hljs-number">3</span>;  <span class="hljs-comment">//地址总线宽度</span><br>    <br>    <span class="hljs-keyword">input</span> clk,we;<br>    <span class="hljs-keyword">input</span> [DATA_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data;<br>    <span class="hljs-keyword">input</span> [ADDR_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] read_addr,write_addr;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DATA_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] q;<br>    <br>    <span class="hljs-comment">//申明存储器数组</span><br>    <span class="hljs-keyword">reg</span> [DATA_WIDTH=<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] ram[ADDR_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];  <span class="hljs-comment">//每个总线对应一个ram，每个ram是8位</span><br>    <br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (we)<br>        ram[write_addr] &lt;= data;   <span class="hljs-comment">//write_addr总线连接的存储单元赋值</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        initial begin   //对存储器初始化</span><br><span class="hljs-comment">            Sreadmemh(&quot;ram_init.txt&quot;,ram)</span><br><span class="hljs-comment">        */</span><br><br>        q &lt;= ram[read_addr];  <span class="hljs-comment">//输出一直是read——addr总选连接的存储单元</span><br>  <span class="hljs-keyword">end</span>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></div></td></tr></table></figure><ul><li><p><strong>双端口</strong> <strong>RAM</strong> <strong>读写端口完全独立</strong></p><ul><li><strong>优点：简单；快速，读写无需等待</strong></li><li><strong>缺点：占用资源多</strong></li></ul></li><li><p><strong>存储大小与地址宽度之间的关系</strong></p><ul><li><strong>size</strong> <strong>=</strong> <strong>2^addr_width</strong></li></ul></li><li><p><strong>实现上，使用了</strong> <strong>FPGA</strong> <strong>中的内存块单元</strong></p></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428084327484.png" alt="image-20210428084327484"></p><h2 id="数据通路设计"><a href="#数据通路设计" class="headerlink" title="数据通路设计"></a>数据通路设计</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210511121612132.png" style="zoom: 50%;"><p>经典的计算机模型的数据处理器</p><ul><li>数据通路负责数据的操作，包括算是运算和传输数据</li><li>控制器负责数据的控制，通常以有限状态机方式实现，包括控制流的输入、输出，以及控制数据通路钟数据的传输顺序</li><li> 处理器旁通常会有哪一个存储器，可根据地址存取程序指令和数据。</li></ul><hr><h4 id="数据通路设计-1"><a href="#数据通路设计-1" class="headerlink" title="数据通路设计"></a>数据通路设计</h4><ul><li>首先实现各个单元模块，包括计算单元ALU，寄存器单元LA和LB，双端口存储器GR</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/newimg/image-20210429012206972.png" alt="image-20210429011556719"></p><p>首先实现各个模块</p><h5 id="计算单元ALU"><a href="#计算单元ALU" class="headerlink" title="计算单元ALU"></a>计算单元ALU</h5><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> alu(a,b,op,q);<br>    <span class="hljs-keyword">parameter</span> WIDTH = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">input</span>[WIDTH-<span class="hljs-number">1</span>：<span class="hljs-number">0</span>] a,b;<br>    <span class="hljs-keyword">input</span>[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] op;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] q;<br>    <span class="hljs-keyword">always</span>@(*) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span>(op)<br>            <span class="hljs-number">2&#x27;b00</span>:q=a+b;<br>            <span class="hljs-number">2&#x27;b01</span>:q=a&amp;b;<br>            <span class="hljs-number">2&#x27;b10</span>:q=a^b;<br>            <span class="hljs-number">2&#x27;b11</span>:q=a|b;<br>            <span class="hljs-keyword">default</span>: q=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h5 id="寄存器单元LA和LB以及双端口存储器GR上文已经定义"><a href="#寄存器单元LA和LB以及双端口存储器GR上文已经定义" class="headerlink" title="寄存器单元LA和LB以及双端口存储器GR上文已经定义"></a>寄存器单元LA和LB以及双端口存储器GR上文已经定义</h5><p>register(clk,rst_n,end,d,q)</p><p>ram(data,read_addr,write_addr,clk,we,q)</p><p>利用结构描述设计方法，利用以上模块实现数据通路</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/newimg/image-20210429011533770.png" alt="image-20210429012206972"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"> <span class="hljs-keyword">module</span> datapath_top(clk,rst,lda,ldb,read_addr,write_addr,we,op);<br>    <span class="hljs-keyword">input</span> clk,rst,lda,ldb,we;<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_addr,write_addr;<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] op;<br>    <br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] gr_data,alu_data;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] la_data,lb_data;<br>    <br>    register<span class="hljs-variable">#(32) LA(clk,rst,lda,gr_data,la_data)</span><br>    register<span class="hljs-variable">#(32) LB(clk,rst,ldb,gr_data,lb_data)</span><br>    ram<span class="hljs-variable">#(32,5) GR(alu_data,read_addr,write_addr,clk,we,gr_data)</span>;<br>    alu<span class="hljs-variable">#(32) ALU(la_data,lb_data,op,alu_data)</span>;<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog，常见电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog填鸭入门</title>
    <link href="/2021/04/24/verilog%E5%85%A5%E9%97%A8/"/>
    <url>/2021/04/24/verilog%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="三种描述方式"><a href="#三种描述方式" class="headerlink" title="三种描述方式"></a>三种描述方式</h2><p>Verilog的<strong>基本设计单元为模块</strong></p><p><strong>结构描述</strong>（侧重于模块内部结构实现的描述方式，实例化语句进行描述）</p><span id="more"></span><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424142401321.png" alt="image-20210424142401321" style="zoom: 33%;"><p><strong>数据流描述</strong>（侧重于数据流动和处理过程的描述方式，简洁，描述输入输出信号的逻辑关系）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424142642643.png" alt="image-20210424142642643" style="zoom:33%;"><p><strong>连续赋值语句：assign</strong>，表述输入端只要有变化，表达式的值就会改变，输出改变。</p><p><strong>行为描述</strong>（侧重于行为方式）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424142849768.png" alt="image-20210424142849768" style="zoom: 33%;"><p>使用<strong>always@语句，表示会不停的运行</strong>，与实际电路一致，后面带有事件控制，一般所有的输入要列在括号中，表示输入有变化就运行后续语句</p><p>一般混合使用</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424142935445.png" alt="image-20210424142935445" style="zoom:33%;"><blockquote><p>上图半加器采用了行为描述，全加器采用了结构描述和数据流描述</p><p>verilog中的语句是<strong>同时进行</strong>的，不具有先后关系，与C语言不同。</p></blockquote><h2 id="原语（软件自带的基本的门，与或非等）"><a href="#原语（软件自带的基本的门，与或非等）" class="headerlink" title="原语（软件自带的基本的门，与或非等）"></a>原语（软件自带的基本的门，与或非等）</h2><ul><li><p>不用声明，直接实例化</p></li><li><p>输出端口在前，输入端口在后  最前的Z为输出，ABC为输入</p></li><li><p>实例名和延时可选  #10 输入输出之间延时10个时间单位</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424143347961.png" alt="image-20210424143347961"></p></li></ul><p>时延仅仅在仿真的时候可以用，综合的时候会被忽略。因为实际电路与你的元器件和材料等有关系，在实际电路不可控。</p><p><strong>结构描述</strong>：<strong>完成最顶层的设计</strong>，定义好所有小模块后连接起来。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424143709319.png" alt="image-20210424143709319" style="zoom: 33%;"><p><strong>wire线网型变量，可以表示电路中的连线</strong></p><p>上图中设计的元件的输入如何对应</p><ol><li><strong>端口位置关联</strong>，直接一一对应，怎么设计的，就直接对应上。</li><li>如果端口位置太多，可采用<strong>端口名称关联</strong>。</li></ol><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424144244364.png" alt="image-20210424144244364" style="zoom:33%;"><p>有的时候有些管脚没有用到，采用空白处理，<strong>空端口</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424144439833.png" alt="image-20210424144439833" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424144625856.png" alt="image-20210424144625856" style="zoom: 50%;"><p>里面的<strong>“，”不能省略</strong>，如果是端口名称关联则**()里不写东西**。</p><p>输入端口如果是空，表示为z高阻态</p><p>输出端口如果是空，表示没有用到。</p><p>但是<strong>要保证输入端口不悬空</strong>，输入端口悬空会产生干扰，噪音</p><p>输出端口无所围，悬空就表示不使用</p><p>给定电路图，通过实例化语句描述电路</p><p>四位加法器</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424144845335.png" alt="image-20210424144845335" style="zoom:33%;"><ol><li><p>声明对外的接口，端口名在模块名后的括号（）中，模块中指明端口类型和宽度</p></li><li><p>声明内部的连线</p></li><li><p>实例化模块</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424145209009.png" alt="image-20210424145209009" style="zoom: 50%;"></li></ol><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424145239870.png" alt="image-20210424145239870" style="zoom:33%;"><p>从上到下的设计顺序。</p><h2 id="层次化与源文件"><a href="#层次化与源文件" class="headerlink" title="层次化与源文件"></a>层次化与源文件</h2><ul><li>多个module是放在同一个文件还是分开放？</li><li>可以放在同一个文件中<ul><li>模块次序自由</li><li>适合小设计</li><li>不太适合模块重用（剪切粘贴）</li></ul></li><li>可以将模块分解成多个文件<ul><li>良好习惯：每个文件只包含一个module</li><li>便于找到一个模块</li><li>有利于模块重用（将文件添加到项目种）</li></ul></li></ul><h2 id="数据流描述的使用要点"><a href="#数据流描述的使用要点" class="headerlink" title="数据流描述的使用要点"></a>数据流描述的使用要点</h2><ul><li><p>最主要机制就是连续赋值语句</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424145807542.png" alt="image-20210424145807542"></p></li></ul><blockquote><p> 关键字assign  +  时延（可选）  +  <strong>线网型变量</strong>  =  赋值表达式</p></blockquote><p>连续赋值：只要右边表达式有变化，左边的变量值就变化。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424150127603.png" alt="image-20210424150127603" style="zoom:33%;"><p>上图种sum，src1，src2都是32位，在下面的加法算式中自动对齐，每位相加，得到结果后赋值给左边。</p><p>{}是连接运算符，将c_out与sum连接合并成了一个33位的变量。</p><h2 id="verilog运算符"><a href="#verilog运算符" class="headerlink" title="verilog运算符"></a>verilog运算符</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424150349910.png" alt="image-20210424150349910" style="zoom: 33%;"><p>与C语言几乎一致，只做少量变化。</p><h2 id="行为描述功能最强大，用法最多"><a href="#行为描述功能最强大，用法最多" class="headerlink" title="行为描述功能最强大，用法最多"></a>行为描述功能最强大，用法最多</h2><ul><li>行为建模的基础是initial和always：</li><li>所有其他的行为语句包含在这两个语句中</li><li>initial和always块不能嵌套，且左边变量必须是reg类型</li></ul><h3 id="仿真测试块Initial语句"><a href="#仿真测试块Initial语句" class="headerlink" title="仿真测试块Initial语句"></a>仿真测试块Initial语句</h3><ol><li><p>initial语句从0时刻开始执行且只执行一次</p><ul><li>如果有多个initial块，它们都从0时刻开始并行独立执行，独立完成执行</li><li>initial语句一般用来仿真，被综合工具忽略，不能综合。但是用来读取初始化存储文件时能够被综合<img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424152347342.png" alt="image-20210424152347342" style="zoom: 50%;"></li></ul><p>仿真模块名后一般加_tb表示这是testbeach文件</p></li></ol><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424152044221.png" alt="image-20210424152044221" style="zoom: 67%;"><p>全加器的测试模块，测试模块没有对外的端口。</p><p>首先要包含测试模块内部的信号，stim连接被测块的输入接口，s，c连接输出端。</p><p>凡是在initial和always语句中左侧的变量必须是寄存器类型（reg）</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424152333370.png" alt="image-20210424152333370"></p><p>stim从0一直赋值到&lt;8，每个值维持5个时间单位，输入变化，输出c，s就有变化。</p><p>仿真时通过波形可以看到值的变化</p><p>或者测试块中通过调用系统输出的任务将变量值输出观察。monitor监控函数，与printf用法差不多，一旦启动后就不断地监控。</p><p>所有的系统任务都是$开头。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424152715002.png" alt="image-20210424152715002" style="zoom: 50%;"><p>延时50个单位</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424153600378.png" alt="image-20210424153600378" style="zoom:33%;"><p>这三个initial语句同时从0时刻启动，无顺序关系</p><p>begin end相当于C中的{}，如果只有一条语句，可以不用begin end</p><h3 id="always语句"><a href="#always语句" class="headerlink" title="always语句"></a>always语句</h3><ul><li>从0时刻开始不断循环执行</li><li>可以使用触发/敏感时间列表来控制操作；@(a or b or c)</li><li>没有触发时间，将在0时刻无限循环执行</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424154001006.png" alt="image-20210424154001006" style="zoom:50%;"><p>如过不加@，敏感事件触发，会不停的执行下面的语句</p><p>always块中赋值左侧的类型一定是reg，下图中的module()中要声明是reg，因为如果不写reg会自动默认为wire型。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424161038637.png" alt="image-20210424161038637"></p><h3 id="always的事件控制方式"><a href="#always的事件控制方式" class="headerlink" title="always的事件控制方式"></a>always的事件控制方式</h3><ul><li>always是基于事件执行，有两种类型的事件控制方式<ul><li>边沿触发事件控制：用来描述时序逻辑电路</li><li>电平敏感事件控制：用来描述组合逻辑电路</li></ul></li></ul><p>时序逻辑电路边沿触发</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)  <span class="hljs-comment">//clk从低电平-&gt;高电平（正沿）</span><br>    cur_state=next_state  <span class="hljs-comment">//就执行赋值语句</span><br>    <br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">negedge</span> reset)  <span class="hljs-comment">//reset从高-&gt;低（负沿）</span><br>    count=<span class="hljs-number">0</span><br>        <br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clear <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> reset)<br></code></pre></div></td></tr></table></figure><p>posedge表示上升沿</p><p>negedge表示下降沿</p><p>不可以同时包括同一个信号的上升沿和下降沿</p><p>组合逻辑电路电平敏感</p> <figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(X1 <span class="hljs-keyword">or</span> X2 <span class="hljs-keyword">or</span> X3)<br><span class="hljs-comment">//or等价于，</span><br><span class="hljs-keyword">always</span>@(X1,X2,X3)<br><span class="hljs-comment">//*表示所有输入信号防止遗漏</span><br><span class="hljs-keyword">always</span>@(*)<br></code></pre></div></td></tr></table></figure><p>不可以同时包括电平敏感事件和边沿敏感事件</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424162156315.png" alt="image-20210424162156315" style="zoom: 33%;"><h2 id="if-else（放在always中）"><a href="#if-else（放在always中）" class="headerlink" title="if else（放在always中）"></a>if else（放在always中）</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424162314753.png" alt="image-20210424162314753" style="zoom:33%;"><p>和C唯一的不同就是{}改用begin end</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424162630348.png" alt="image-20210424162630348"></p><p>综合之后肯定会有选择器。实际的运算是，实现了运算所有可能的值，只不过最后输出的时候<strong>通过选择器输出某个值。</strong></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424162815974.png" alt="image-20210424162815974"></p><p>无else语句，不能覆盖所有可能的结果</p><p>语句不完整即有某些情况的输入对输出无任何影响，根据锁存器的特征，反映到硬件电路即会产生锁存器。</p><p><strong>if语句后要加上else，以防止锁存器的发生。</strong></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424165345023.png" alt="image-20210424165345023"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424182710316.png" alt="image-20210424182710316" style="zoom:50%;"><p>上升沿触发，当if中的reset为1时，才会清零，同步清零。</p><p>同样的set为1时，才会置1。</p><p>当reset和set都为1时，verilog的if else有优先级，第一个if先执行，依次类推。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424183422772.png" alt="image-20210424183422772"></p><p>case的末尾要加default </p><ul><li>Verilog有三种形式的case语句：case，casex，casez</li><li>表达式按顺序与各分支项值按位匹配<ul><li>两者位宽相同</li></ul></li><li>case：是一种全等比较</li><li>casez: 比较双方有一方的某些位的值是z，那么这些位的比较就不予考虑，而只关注其他位的比较结果</li><li>casex：比较双方有一方的某些位的值是x和z，就不予考虑</li><li>?可用来代替z，表示无关位</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424184241426.png" alt="image-20210424184241426" style="zoom: 33%;"><p>若真的要表示出不关心哪一位，上述的case改成casex</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while和for与C完全相同"><a href="#while和for与C完全相同" class="headerlink" title="while和for与C完全相同"></a>while和for与C完全相同</h3><h3 id="repeat循环"><a href="#repeat循环" class="headerlink" title="repeat循环"></a>repeat循环</h3><p>执行指定的循环次数</p><ul><li><p>repeat的循环次数可以是一个变量，但</p><ul><li>其值在开始循环时得到计算，从而得以事先确定循环次数</li><li>如果其值在循环执行期间发生更改，也不会更改迭代次数</li></ul></li><li><p>在teatbench，常与@(posedge)事件控制一起使用，用来等待固定数量的时钟。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424184642168.png" alt="image-20210424184642168"></p></li></ul><h3 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h3><ul><li>无限循环，常用于产生周期性的波形，用来作为仿真测试信号，它与always的不同之处是不能独立在程序中，必须写在initial块中</li><li><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424185022459.png" alt="image-20210424185022459"></li><li>经常用于产生周期性波形</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424204254143.png" alt="image-20210424204254143" style="zoom: 33%;"><p>循环几次，电路规模就扩大几倍</p><p>若循环次数已知，电路可以综合。</p><p>但是若是循环结束条件是变量，这种就无法综合。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424204410159.png"></p><p>上述电路中的语句没有用assign，是过程赋值语句</p><h3 id="过程赋值语句"><a href="#过程赋值语句" class="headerlink" title="过程赋值语句"></a>过程赋值语句</h3><ul><li><p>阻塞型过程赋值： =</p><p>前一条语句没有完成赋值过程之前，后面的语句不能被执行</p></li><li><p>非阻塞型过程赋值： &lt;=</p><p>一条非阻塞赋值语句的执行，不会影响块中其他语句的执行（意思是同时执行）</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424205106772.png" alt="image-20210424205106772"></p></li></ul><h3 id="阻塞性赋值"><a href="#阻塞性赋值" class="headerlink" title="阻塞性赋值"></a>阻塞性赋值</h3><p>当前的赋值语句阻断了其后的语句，即后面的语句必须等到当前的赋值语句执行完毕后才能执行</p><p>用于<strong>组合逻辑</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424205252988.png" alt="image-20210424205252988" style="zoom:33%;"><h3 id="非阻塞性赋值"><a href="#非阻塞性赋值" class="headerlink" title="非阻塞性赋值"></a>非阻塞性赋值</h3><p>如果没有定时控制，则同时计算RHS和更新LHS</p><p>用于<strong>时序逻辑</strong></p><p>只能用在initial和always中</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424205452445.png" alt="image-20210424205452445" style="zoom:33%;"><p>上图中out0&lt;=out1;out1&lt;=out0，时序逻辑交换变量不需要中间变量，直接赋值。</p><p>组合逻辑就需要<strong>中间变量</strong>来交换。 </p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424205715952.png" alt="image-20210424205715952" style="zoom:33%;"><p>如果上述的电路没有用=，而是用&lt;=,使得三条语句同时执行，不能实现现有的交换</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424210013817.png" alt="image-20210424210013817" style="zoom:33%;"><p>上图电路有误，无法实现交换变量的功能</p><p>同样，若在时序电路中没有用&lt;=，而是用=</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424210157890.png" alt="image-20210424210157890"></p><p>上述q1=d;q2=d1;q=q2;最终就相当于q=d，只有一个触发器（自动优化）</p><p>若上述代码改为&lt;=</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424210503238.png" alt="image-20210424210503238" style="zoom:33%;"><p>每次这三个变量都传递一次，需要三次传递，d才能到q，触发器链</p><p>下列代码中，z就不能正确表示出当前abcd的与或关系，而是上一次的</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424210654928.png" alt="image-20210424210654928" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424210801792.png" alt="image-20210424210801792" style="zoom:33%;"><p>若把temp1和temp2放入敏感列表中，当作触发事件，就可以触发了。</p><p>上述方法可行，但效率不高。一个always块需要多次传递才能得到想要的值，降低了性能。不如采用阻塞赋值，一次传递就能解决。</p><h2 id="任务和函数"><a href="#任务和函数" class="headerlink" title="任务和函数"></a>任务和函数</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424211002819.png" alt="image-20210424211002819" style="zoom:33%;"><p>函数是有返回值的，任务则没有。</p><p>function中的位宽说明就表示了返回值的位宽。对函数来说，只有input参数，无output参数。且至少有一个input</p><p>task中input和output的数量无限制，output就作为返回值返回。</p><ul><li>任务可以含有时序控制，而函数则没有。</li><li>任务可以有输入和输出函数，而函数至少一个输入参数，没有输出参数。</li><li>任务的调用是通过调用语句，而函数调用出现在表达式中。</li></ul><h3 id="函数functions"><a href="#函数functions" class="headerlink" title="函数functions"></a>函数functions</h3><ul><li>函数的定义和调用都包括在一个module内<ul><li>函数调用在表达式中（RHS）</li></ul></li><li>用于实现组合逻辑<ul><li>不能包含任何时延，时序，事件控制</li><li>可以调用其他函数，不能调用任务</li><li>只是用阻塞赋值，行为语句</li></ul></li><li>输入输出<ul><li>至少一个输入函数，不能有输出或者双向inout参数</li><li>返回一个值，与函数同名的寄存器变量在函数中被隐式地声明，通过对该寄存器赋值来返回函数值，可以指定返回值地宽度（缺省1bit）</li></ul></li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424211612718.png" alt="image-20210424211612718" style="zoom:33%;"><p>函数有返回值，调用一定在表达式中</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424211630655.png" alt="image-20210424211630655" style="zoom: 50%;"><p>函数名前为output参数，后为input参数</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424211840370.png" alt="image-20210424211840370" style="zoom: 33%;"><hr><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424211943887.png" alt="image-20210424211943887"></p><p>任务应用的更加广泛。</p><p>任务调用</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212358393.png" alt="image-20210424212358393" style="zoom: 67%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212116741.png" alt="image-20210424212116741" style="zoom:33%;"><p>任务所带地参数可以两种声明方式</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212251638.png" alt="image-20210424212251638" style="zoom:33%;"><p>任务调用的时候输入参数与参数类型一定要对应 </p><p>输出一定为reg类型</p><h3 id="时序控制"><a href="#时序控制" class="headerlink" title="时序控制"></a>时序控制</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212532877.png" alt="image-20210424212532877" style="zoom:33%;"><h3 id="命名程序块"><a href="#命名程序块" class="headerlink" title="命名程序块"></a>命名程序块</h3><ul><li><p>命名块中可以声明局部变量</p></li><li><p>命名块中声明地变量可以通过层次名引用进行访问</p></li><li><p>命名块可以被禁用（例如停止其执行）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212755355.png" alt="image-20210424212755355" style="zoom:33%;"></li></ul><h3 id="禁止语句"><a href="#禁止语句" class="headerlink" title="禁止语句"></a>禁止语句</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212914240.png" alt="image-20210424212914240" style="zoom:33%;"><p>disable continue停止continue块地执行，上文中是结束当此循环，和C中的continue一致</p><p>disable break是停止break块地执行，上文中是结束循环，和C中的break一致</p><h3 id="文件IO操作"><a href="#文件IO操作" class="headerlink" title="文件IO操作"></a>文件IO操作</h3><p>打开文件，独写，关闭</p><p>与C基本一致</p><p>打开 $fopen(“filename”);</p><p>关闭 $fclose(fd);</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424213221575.png" alt="image-20210424213221575"></p><p>与fprintf差不多</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>快速入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的触发器</title>
    <link href="/2021/04/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2021/04/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="基本RS触发器"><a href="#基本RS触发器" class="headerlink" title="基本RS触发器"></a>基本RS触发器</h2><p>基本R-S触发器是直接复位（Reset）-置位（Set）触发器的简称。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173646020.png" alt="image-20210422173646020"></p><span id="more"></span><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173706121.png" alt="image-20210422173706121" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173714969.png" alt="image-20210422173714969" style="zoom:50%;"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173754088.png" alt="image-20210422173754088" style="zoom: 50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173804535.png" alt="image-20210422173804535" style="zoom: 50%;"></p><p>次态方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173844473.png" alt="image-20210422173844473"></p><p>约束方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173856943.png" alt="image-20210422173856943"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173910649.png" alt="image-20210422173910649" style="zoom:50%;"><p>当输入端S连续出现多个置1信号，或者输入端R连续出现多个清0信号，仅第一个信号使粗发起翻转</p><p>也就是说如果波形图中一条线不变，另一条线出现连续的凹陷，只在第一个凹陷的下降沿引起状态改变。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174038087.png" alt="image-20210422174038087"></p><p>可以利用这一特点消除机械开关震动引起的尖脉冲信号</p><h2 id="或非门构成的基本RS触发器"><a href="#或非门构成的基本RS触发器" class="headerlink" title="或非门构成的基本RS触发器"></a>或非门构成的基本RS触发器</h2><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174123861.png" alt="image-20210422174123861"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174134049.png" alt="image-20210422174134049"></p><p>与与非门差不多，只是结果正好相反。</p><h2 id="简单结构的时钟控制触发器"><a href="#简单结构的时钟控制触发器" class="headerlink" title="简单结构的时钟控制触发器"></a>简单结构的时钟控制触发器</h2><p>基本R-S触发器的特点是触发器状态直接受输入信号R、S控制，一旦输入信号变化，触发器的状态随之变化</p><p>实际应用中，要求触发器按一定的时间节拍动作，让输入信号的作用收到时钟脉冲CP的控制。</p><p>时钟脉冲确定触发器状态转换的时刻（何时转换），输入信号确定触发器状态转换的方向。</p><p>时钟脉冲（CP）作用前的状态称为现态，而把时钟脉冲（CP）作用后的状态称为次态</p><h3 id="钟控RS触发器"><a href="#钟控RS触发器" class="headerlink" title="钟控RS触发器"></a>钟控RS触发器</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174224432.png" alt="image-20210422174224432" style="zoom: 67%;"><p>时钟脉冲为0时，触发器状态不变</p><p>时钟脉冲为1时，输入端RS的值可以通过控制门作用于上面的基本RS触发器</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174242225.png" alt="image-20210422174242225"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174255603.png" alt="image-20210422174255603" style="zoom: 50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174303608.png" alt="image-20210422174303608" style="zoom:50%;"><p>(1)时钟RS触发器的时钟为<strong>电平控制</strong>，在CP=1期间接收输入信号，CP=0时状态保持不变，与基本RS触发器相比，对触发器状态的转变增加了时间控制</p><p>(2)RS之间有约束，不能允许出现R和S同时为1的情况，否则会使触发器处于不确定的状态。</p><img src="https://gitee.com/trent-liuy/blogimage/raw/4fc78eeba0dd8b5ac6fac30b38b151f06a944371/img/image-20210429104508234.png" alt="image-20210422174224432" style="zoom: 67%;"><p>次态方程和约束方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174328549.png" alt="image-20210422174328549"></p><h3 id="钟控D触发器（D锁存器）"><a href="#钟控D触发器（D锁存器）" class="headerlink" title="钟控D触发器（D锁存器）"></a>钟控D触发器（D锁存器）</h3><p>钟控D触发器只有一个输入端，是由钟控R-S触发器的控制电路稍加修改后形成的。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174346174.png" alt="image-20210422174346174"></p><p>无时钟脉冲作用（CP=0）时，触发器状态保持不变</p><p>有时钟时，D为什么，触发器状态就被置为什么</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174359032.png" alt="image-20210422174359032"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174404779.png" alt="image-20210422174404779"></p><p>次态方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174519952.png" alt="image-20210422174519952"></p><img src="https://gitee.com/trent-liuy/blogimage/raw/f8f5c1456211149da510583f12d401ac97ac0e34/newimg/image-20210429111510959.png" alt="image-20210429111510959" style="zoom:50%;"><p>如上图，是<strong>电平触发</strong>。</p><p>在数字电路中，凡在CP时钟脉冲控制下，根据输入信号D情况的不同，具有置0，置1功能的电路，都称为D触发器</p><h3 id="钟控J-K触发器"><a href="#钟控J-K触发器" class="headerlink" title="钟控J-K触发器"></a>钟控J-K触发器</h3><p>R-S触发器不可以使两个输入同时为1</p><p>钟控J-K触发器利用触发器两个输出端信号始终互补的特点，有效地解决了在时钟脉冲作用期间两个输入同时为1将导致触发器状态不确定的问题</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174445698.png" alt="image-20210422174445698"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174454539.png" alt="image-20210422174454539"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174503062.png" alt="image-20210422174503062"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174535904.png" alt="image-20210422174535904" style="zoom:50%;"><p>次态方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174552805.png" alt="image-20210422174552805"></p><p><img src="https://gitee.com/trent-liuy/blogimage/raw/a0bfae900bc920021e7d6fa553e79fccb8b79ef4/newimg/image-20210429112546859.png" alt="image-20210429112546859"></p><p>如图，仍是<strong>电平触发</strong></p><p>在数字电路中，凡在CP时钟脉冲控制下，根据输入信号JK情况的不同，具有置0、置1、保持和翻转功能的电路，都称为JK触发器。</p><h3 id="钟控T触发器"><a href="#钟控T触发器" class="headerlink" title="钟控T触发器"></a>钟控T触发器</h3><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174615265.png" alt="image-20210422174615265"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174626772.png" alt="image-20210422174626772"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174632210.png" alt="image-20210422174632210"></p><p>次态方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174649126.png" alt="image-20210422174649126"></p><hr><p>上述简单结构钟控触发器的共同特点是，当时钟控制信号为低电平时（CP=0）时，触发器保持原来状态不变；当时钟控制信号为高电平（CP=1）时，触发器在输入信号作用下发生状态变化。</p><p>换而言之，触发器状态转移是被控制在一个约定的时间间隔内，而不是控制在某一时刻进行。触发器的这种钟控方式被称作电位触发方式。</p><p>电位触发方式的钟控触发器存在一个共同的问题，就是可能出现“空翻”现象。</p><p>空翻：同一个时钟脉冲作用期间触发器状态发生两次或者两次以上变化的现象。引起空翻的原因是在时钟脉冲为高电平期间，输入信号的变化直接控制着触发器状态的变化。</p><p>当CP=1时，如果输入信号发生变化，则触发器状态会跟着发生变化。从而使得一个时钟脉冲作用期间引起多次翻转（电平触发），“空翻”将造成状态的不确定和系统工作的混乱，这是不允许的。如果要使这种触发器在每个时钟脉冲作用期间仅发生一个翻转，则对时钟信号的控制电平宽度要求极其苛刻。这一不足，使这种触发器的应用受到一定限制。</p><h2 id="其他结构的钟控触发器"><a href="#其他结构的钟控触发器" class="headerlink" title="其他结构的钟控触发器"></a>其他结构的钟控触发器</h2><p>克服触发器存在的空翻现象，对控制电路的结构进行改进，将触发器的翻转控制在某一时刻完成。</p><h3 id="主从钟控触发器"><a href="#主从钟控触发器" class="headerlink" title="主从钟控触发器"></a>主从钟控触发器</h3><p>采用具有存储功能的控制电路，避免了空翻现象</p><h3 id="主从R-S触发器"><a href="#主从R-S触发器" class="headerlink" title="主从R-S触发器"></a>主从R-S触发器</h3><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174720714.png" alt="image-20210422174720714"></p><p>主从两个触发器的时钟脉冲是反相的，时钟脉冲CP（1）作为主触发器的控制信号，反相（0）作为从触发器的控制信号</p><p>主触发器的状态Q’与~Q’为从触发器的输入</p><p>从触发器的输出Q与~Q作为整个主从触发器的状态输出</p><p>工作原理：</p><p>CP=1时，主触发器的值取决于RS，与R-S触发器完全相同</p><p>此时从触发器的时钟信号为0，控制门被封锁，从触发器的状态不受主触发器状态变化的影响。整个触发器的状态不变</p><p>CP由1变为0，主触发器被封锁，状态不变，从触发器被打开，从触发器的状态与主触发器相同，总而言之，CP1变0时，将主触发器状态转为整个主从触发器的状态。</p><ul><li><p>触发器状态的变化发生在时钟脉冲CP由1变为0的时刻，因为在CP=0期间主触发器被封锁，其状态不再受输入RS的影响，因此不会引起触发器状态发生两次以上的翻转，从未克服了空翻现象。</p></li><li><p>触发器的状态取决于CP由1变成0时刻主触发器的状态，二主触发器的状态在CP=1期间是随输入RS变化的，所以触发器的状态实际上取决于CP由1变为0之前输入RS的值</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210429122410875.png"></p></li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422175311253.png" alt="image-20210422175311253" style="zoom:67%;"><p>主从R-S触发器状态的变化发生在时钟脉冲CP的下降沿时刻，故通常称为下降沿触发。</p><h3 id="主从J-K触发器"><a href="#主从J-K触发器" class="headerlink" title="主从J-K触发器"></a>主从J-K触发器</h3><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174748592.png" alt="image-20210422174748592"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210429123707381.png" style="zoom:67%;"><p>克服了空翻现象，但是存在一次翻转现象。</p><p>一次翻转：在时钟脉冲作用（CP=1）期间，主触发器的状态只能根据输入信号的变化改变一次。即主触发器在接受输入信号发生一次翻转后，其状态保持不变，不再受输入JK变化的影响。</p><h3 id="维持阻塞钟控触发器"><a href="#维持阻塞钟控触发器" class="headerlink" title="维持阻塞钟控触发器"></a>维持阻塞钟控触发器</h3><p>既克服简单结构钟控触发器的空翻现象，又提高触发器的抗干扰能力，引出了边沿触发器。边沿触发器仅在时钟脉冲CP的上升沿或者下降沿时刻响应输入信号。</p><p>维持-阻塞D触发器</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210429130144954.png" style="zoom:67%;"><ul><li><p>时钟脉冲CP=0，触发器状态保持不变。</p><p>此时接受输入信号，A=~D，B=D</p></li><li><p>时钟脉冲CP=1时，触发器的结果状态与D相同</p></li></ul><p>由于维持-阻塞线路的作用，触发器在时钟脉冲的上升沿将D输入端的数据可靠地转换成触发器状态，而在上升沿过后的时钟脉冲期间，不论D的值如何变化，触发器的状态始终以时钟脉冲上升沿时所采样的值为准。</p><p>时钟脉冲的上升边沿采样D输入端的数据，所以要求输入D在时钟脉冲CP由0变为1之前将数据准备好。在CP＝1期间始终有Qm=D</p><p>CP下降沿的时候，主触发器所存的D的值，Qm=D送入从触发器，Q=D，<del>Q=</del>D</p><p>下降沿过后，从触发器的状态也将保持不变。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210429131222263.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>数电</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
      <tag>触发器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java自学——Map</title>
    <link href="/2021/04/22/Java_Map/"/>
    <url>/2021/04/22/Java_Map/</url>
    
    <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map接口时一种<strong>键——值对（key-value）集合</strong>，Map集合中的每一个元素都包含一个键对象和一个值对象。</p><p>键对象不允许重复，值对象可以重复，而且值对象还可以是Map类型的，就像数组中的元素还可以是数组一样。</p><p>它主要有两个实现类：HashMap 类和 TreeMap 类。</p><p>HashMap按哈希算法来存取键对象，而TreeMap类可以对键对象进行排序</p><span id="more"></span><hr><ul><li>可以通过键来访问对应的值</li><li>当访问的值不存在的时候，方法会抛出一个NoSuchElementException异常</li><li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常。</li><li>当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常。</li><li>当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常。</li></ul><hr><p>常用方法</p><table><thead><tr><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>初始化Map</td><td>Map&lt;String, String&gt; map = ``new<code> </code>HashMap&lt;String, String&gt;();</td></tr><tr><td>添加键值对</td><td>map.put(<code>&quot;key1&quot;</code>, <code>&quot;value1&quot;</code>);返回 key 以前对应的 value，如果没有， 则返回 null</td></tr><tr><td>移除键值对</td><td>map.remove(<code>&quot;key1&quot;</code>);返回 key 对应的 value，如果没有，则返回null</td></tr><tr><td>获取值</td><td>map.get(<code>&quot;key1&quot;</code>)</td></tr><tr><td>清空Map</td><td>map.clear();</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——多线程和并行程序设计</title>
    <link href="/2021/04/17/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/04/17/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="程序、进程和线程"><a href="#程序、进程和线程" class="headerlink" title="程序、进程和线程"></a>程序、进程和线程</h2><p>“程序”代表一个静态的对象，是内含指令和数据的文件，存储在磁盘或其他存储设备中</p><p>“进程”代表一个动态的对象，是程序的一个执行过程，存在于系统的内存中，一个进程对应于一个程序</p><p>“进程”是运行于某个进程中，用于完成某个具体任务的顺序控制流程，有时被成为轻型进程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210417081121324.png" alt="image-20210417081121324"></p><span id="more"></span><p>多线程的执行次序完全随机，运行结果随机</p><p>理论上来讲，16G的机器，每个进程有单独的内存空间，都是16G，若多进程不够用，内存和硬盘不断交换</p><ul><li>当一个进程被创建，自动地创建了一个主线程。因此，一个进程至少有一个主线程。</li><li>线程：程序中完成一个任务地有始有终地<strong>执行流</strong>，都有一个执行的起点，经过一系列指令后到达终点。</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210417081330380.png" alt="image-20210417081330380"></p><ul><li>现代OS都将线程作为最小调度单位，进程作为资源分配的最小单位。分配给进程的资源（如文件，外设）可以被进程里的线程使用。</li></ul><h2 id="线程的作用"><a href="#线程的作用" class="headerlink" title="线程的作用"></a>线程的作用</h2><ul><li><p>一个进程的多个子线程可以并发运行</p></li><li><p>多线程可以使程序反应更快、交互性更强、执行效率更高。</p></li><li><p>特别是Server端的程序，都是需要启动多个线程来处理大量来自客户端的请求</p></li><li><p>一个典型的GUI程序分为</p><ul><li>GUI线程：处理UI消息循环，如鼠标消息、键盘消息</li><li>Worker线程：后台的数据处理工作，比如打印文件，大数据量的运算</li></ul></li></ul><hr><h2 id="Runuable接口和线程类Thread"><a href="#Runuable接口和线程类Thread" class="headerlink" title="Runuable接口和线程类Thread"></a>Runuable接口和线程类Thread</h2><h4 id="通过实现Runnable接口创建线程"><a href="#通过实现Runnable接口创建线程" class="headerlink" title="通过实现Runnable接口创建线程"></a>通过实现Runnable接口创建线程</h4><ul><li>实现Runnable接口，需要实现唯一的接口方法run<ul><li>void run()</li><li><strong>该方法定义了线程执行的功能</strong></li></ul></li><li>创建实现Runnable接口的类的对象</li><li>利用Thread类的构造函数创建线程对象<ul><li>public Thread(Runnable target)</li><li>new Thread对象时需要传入Runnable接口实例</li></ul></li><li>通过线程对象的start()方法启动线程</li></ul>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Client Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>   ...<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">(...)</span> </span>&#123;<br>   ...  <br>   <span class="hljs-comment">// Create an instance of TaskClass</span><br>   <span class="hljs-comment">//创建实现Runnable接口的对象</span><br>   Runnable task = <span class="hljs-keyword">new</span> TaskClass(...);<br> <br>   <span class="hljs-comment">// Create a thread</span><br>   <span class="hljs-comment">//以实现Runnable接口的对象为参数创建Thread对象</span><br>   Thread thread = <span class="hljs-keyword">new</span> Thread(task);<br> <br>   <span class="hljs-comment">// Start a thread</span><br>   <span class="hljs-comment">//Thread.start()开始线程</span><br>   thread.start(); <span class="hljs-comment">// 启动后自动执行task.run</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>通过线程任务类(TaskClass)创建任务对象(task),task为实现Runnable接口的对象</li><li>以任务对象task为参数new Thread对象。Thread对象代表一个线程，线程的执行内容由任务对象task定义。</li><li>通过线程对象Thread启动线程thread.start(),任何线程只能启动一次，多次调用产生IllegalThreadStateException异常</li></ol>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Custom task class</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<span class="hljs-comment">//Java.lang.Runnable</span><br>   ... <span class="hljs-comment">//可以有自己的数据成员</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TaskClass</span><span class="hljs-params">(...)</span> </span>&#123;<br>      ...<br>   &#125;<br> <br>   <span class="hljs-comment">//Implement the run method in Runnable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//Tell system how to run custom thread</span><br>      ...<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="通过实现Runnable接口创建线程的例子"><a href="#通过实现Runnable接口创建线程的例子" class="headerlink" title="通过实现Runnable接口创建线程的例子"></a>通过实现Runnable接口创建线程的例子</h3><ul><li><p>程序创建并运行两个线程，第一个线程打印100次字母a，第二个线程打印100次字母b</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintChar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> //实现<span class="hljs-title">Runnable</span>接口</span><br><span class="hljs-class"></span>&#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> charToPrint;  <span class="hljs-comment">// The character to print</span><br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> times;  <span class="hljs-comment">// The times to repeat</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> t)</span></span>&#123;  charToPrint = c;  times = t; &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//实现Runnable中声明的run方法</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt; times; i++) System.out.print(charToPrint);<br>      &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>new Thread对象时需要传入Runnable接口实例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableDemo</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//以PrintChar对象实例为参数构造Thread对象 </span><br>        Thread printA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>));<br>        Thread printB = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>));<br>        printA.start();<br>        printB.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><hr><h4 id="通过继承Thread类创建线程"><a href="#通过继承Thread类创建线程" class="headerlink" title="通过继承Thread类创建线程"></a>通过继承Thread类创建线程</h4><ul><li>线程和线程任务混在一起，不建议使用。</li><li>Java不支持多继承，CustomThread继承了Thread类，不能再继承其他类。</li></ul>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">// Custom thread class</span><br><span class="hljs-comment">//Thread类的拓展类</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>  <span class="hljs-comment">//数据成员</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomThread</span><span class="hljs-params">(...)</span> </span>&#123;<br>    ...<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Tell system how to perform this task</span><br>    ...<br>  &#125;<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>定义Thread类的扩展类（CustomThread）</li><li>通过扩展类（CustonThread）创建线程对象（thead）</li><li>通过线程对象thrad启动线程thread.start()</li></ol>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Client class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// Create a thread</span><br>    Thread thread1 = <span class="hljs-keyword">new</span> CustomThread();<br>    <span class="hljs-comment">// Start thread</span><br>    thread1.start( ); <span class="hljs-comment">//激活thread1对象的run</span><br>    <br>    <span class="hljs-comment">// Create a thread</span><br>    Thread thread2 = <span class="hljs-keyword">new</span> CustomThread( );<br>    <span class="hljs-comment">// Start thread</span><br>    thread2.start(); <span class="hljs-comment">//激活thread2对象的run</span><br>  &#125;<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="通过继承Thread类创建线程的实例"><a href="#通过继承Thread类创建线程的实例" class="headerlink" title="通过继承Thread类创建线程的实例"></a>通过继承Thread类创建线程的实例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintChar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> //继承<span class="hljs-title">Thread</span>类</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> charToPrint;  <span class="hljs-comment">//要打印的字符</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> times;  <span class="hljs-comment">//打印的次数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> t)</span></span>&#123; charToPrint = c; times = t; &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//覆盖run方法，定义线程要完成的功能</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt; times; i++)<br>System.out.print(charToPrint);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread printA = <span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>); <span class="hljs-comment">//创建二个线程对象</span><br>    Thread printB = <span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>);<br>    printA.start(); <span class="hljs-comment">//启动线程</span><br>    printB.start();<span class="hljs-comment">//启动另外一个线程</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="线程的状态切换"><a href="#线程的状态切换" class="headerlink" title="线程的状态切换"></a>线程的状态切换</h3><ul><li>就绪：万事俱备，等待CPU调度</li><li>运行：线程获得了CPU的所有权并在上面运行</li><li>消亡：当run()执行完毕后，线程就消亡</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421184045450.png" alt="image-20210421184045450"></p><ul><li>下面一些情况导致线程从<strong>运行状态转到阻塞状态</strong>：<ol><li>调用了sleep</li><li>调用了Object wait()方法，条件对象的await方法，Thread的join方法以及等待其他线程，或者等待资源锁</li><li>发出了阻塞式IO操作请求，并等待IO操作结束(如等待阻塞式Socket的数据到来)</li></ol></li><li>线程由<strong>阻塞状态被唤醒后，回到就绪态</strong>。唤醒的原因<ol><li>sleep时间到</li><li>调用wait(await)的线程被其他线程notify，调用join方法的线程等到了其他线程完成，线程拿到了资源锁</li><li>阻塞IO完成</li></ol></li></ul><blockquote><p>Object类定义了wait/notify/notifyAll方法</p><p>Thread类定义了sleep/yield/join方法</p></blockquote><h3 id="Runnable接口和线程类Thread"><a href="#Runnable接口和线程类Thread" class="headerlink" title="Runnable接口和线程类Thread"></a>Runnable接口和线程类Thread</h3><ul><li><p>java.lang.Runnable</p><p>Runnable接口实例定义了线程任务，即线程要执行的逻辑。一个线程任务必须通过线程对象来执行</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421184504711.png" alt="image-20210421184504711" style="zoom: 50%;"><p>Thread()                                    创建一个空的线程</p><p>Thread(task:Runnable)          为指定的任务创建一个线程</p><p>start():void                                开始一个线程，进入Ready状态，如无其它线程等待，可立即Run进入running状态</p><p>isAlive():boolean                      测试线程当前是否在运行</p><p>setPriority(p:int):void             为该线程指定优先值p（1~10）</p><p>join():void                                   等待线程结束</p><p>sleep(millis:long):void             让当前线程休眠若干ms，监视器自动恢复其运行</p><p>yield():void                                  将线程从running变为ready，允许其他线程执行（自己也可能立即执行）</p><p>interrupt():void                            中断该线程</p></li></ul><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><ul><li><p>n线程优先级范围从1－10，数字越高越能被优先执行。但优先级高并不代表能独自占用执行时间片，可能是<strong>优先级高得到越多的执行时间片</strong>，反之，<strong>优先级低的分到的执行时间少但不会分配不到执行时间</strong></p></li><li><p>每个线程创建时赋予默认的优先级Thread.NORM_PRIORITY. </p></li><li><p>通过setPriority(int priority)为线程指定优先级. </p></li><li><p>用getPriority()方法获取线程的优先级.</p></li><li><p>JAVA定义的优先级：1～10</p></li><li><p>Thread类有int 类型的常量：</p><ul><li><p>Thread.MIN_PRIORITY（1）</p></li><li><p>Thread.MAX_PRIORITY（10）</p></li><li><p>Thread.NORM_PRIORITY（5）</p></li></ul></li><li><p>多个线程只能是“宏观上并行，微观上串行”</p></li><li><p>在有限个CPU的系统中确定多个线程的执行顺序称为线程的调度</p></li><li><p>Java的线程调度是抢占式的，这表示调度机制会<strong>周期性地中断线程</strong>，将上下文切换到另一个线程；从而为每个线程都提供时间片</p></li><li><p>自私的线程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">run() &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>应适当地在run()里sleep或yield一下，让其他线程由更多机会被运行。</p><p><em><strong>不要编写依赖于线程优先级的程序</strong></em></p></li></ul><h3 id="线程类Thread的yield，sleep方法"><a href="#线程类Thread的yield，sleep方法" class="headerlink" title="线程类Thread的yield，sleep方法"></a>线程类Thread的yield，sleep方法</h3><h4 id="使用yield-方法为其他线程让出CPU时间"><a href="#使用yield-方法为其他线程让出CPU时间" class="headerlink" title="使用yield()方法为其他线程让出CPU时间"></a>使用yield()方法为其他线程让出CPU时间</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; times; i++) &#123;<br>        System.out.print(charToPrint);<br>        Thread.yield();  <span class="hljs-comment">//挂起进入ready，给其它进程调度机会</span><br>     &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>将线程从running变为ready，允许其他线程执行（自己也可能立即执行）</p></blockquote><h4 id="sleep-long-mills-方法将线程设置为休眠状态，确保其他线程执行："><a href="#sleep-long-mills-方法将线程设置为休眠状态，确保其他线程执行：" class="headerlink" title="sleep(long mills)方法将线程设置为休眠状态，确保其他线程执行："></a>sleep(long mills)方法将线程设置为休眠状态，确保其他线程执行：</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//循环中使用sleep方法，循环放在try-catch块中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; times; i++) &#123;<br>            System.out.print(charToPrint);<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">50</span>) Thread.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 必检异常：其它线程调当前线程（正在休眠）interupt方法会抛出该异常</span><br>    <span class="hljs-keyword">catch</span> (InterruptedException ex &#123; &#125;<br>&#125;<span class="hljs-comment">//处于阻塞状态（如在睡眠，在wait，在执行阻塞式IO）的线程，如果被其他线程打断（即处于阻塞的线程的interupt方法被其它线程调用），会抛出InterruptedException</span><br></code></pre></div></td></tr></table></figure><blockquote><p>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、1.5中的condition.await、以及可中断的通道上的 I/O 操作方法后可进入阻塞状态）</p><p>则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法（sleep、join、wait、1.5中的condition.await及可中断的通道上的 I/O 操作方法）调用处抛出InterruptedException异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为false。</p><p>抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求。</p></blockquote><h4 id="线程类Thread的join方法"><a href="#线程类Thread的join方法" class="headerlink" title="线程类Thread的join方法"></a>线程类Thread的join方法</h4><p>Runnable接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintChar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> //实现<span class="hljs-title">Runnable</span>接口</span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> charToPrint;  <span class="hljs-comment">// The character to print</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> times;  <span class="hljs-comment">// The times to repeat</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> t)</span></span>&#123;  charToPrint = c;  times = t; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//实现Runnable中声明的run方法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt; times; i++) <br>    System.out.print(charToPrint);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行多线程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>    Thread printA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>));<br>    Thread printB = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>));<br>    printA.start();<br>     printB.start();<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421190447197.png" alt="image-20210421190447197"></p><blockquote><p>可以看到屏幕上<strong>无规律的交替输出ab</strong>。这是多线程程序的特点，<strong>每次运行输出结果可能是不一样的</strong>。如果希望把所有a先打印完再打印b，怎么做？</p></blockquote><p>修改代码如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        Thread printA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>));<br>        Thread printB = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>));<br>        printA.start();  <span class="hljs-comment">//在主线程里首先启动printA线程</span><br>        printA.join(); <span class="hljs-comment">//主线程被阻塞，等待printA执行完</span><br>        printB.start(); <span class="hljs-comment">//主线程被唤醒，启动printB线程</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421190613062.png" alt="image-20210421190613062"></p><blockquote><p>join方法的作用：在A线程中调用了B线程（对象）的join()方法时，表示A线程放弃控制权（被阻塞了），只有<strong>当B线程执行完毕时，A线程才被唤醒继续执行。</strong></p><p>程序在main线程中调用printA线程（对象）的join方法时，<strong>main线程放弃cpu控制权（被阻塞），直到线程printA执行完毕</strong>，main线程被唤醒执行printB.start();</p><p>运行结果是全部a打印完才开始打印b</p></blockquote><p>定义一个新的线程任务类</p><blockquote><p>在线程任务对象print100的run中启动新线程Thread4，并调用Thread4 的join( ) 方法，，等待Thread4结束:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNum</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123; <span class="hljs-comment">//实现新的线程任务类，打印数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> lastNum;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123; lastNum = n; &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>       Thread thread4=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">4000</span>));<br>        thread4.start();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;lastNum;i++)&#123;<br>                System.out.print(<span class="hljs-string">&quot; &quot;</span> + i);<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">50</span>) thread4.join(); <span class="hljs-comment">//join方法可以给参数指定至多等若干毫秒</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(InterruptedException e)&#123; &#125; <span class="hljs-comment">//join方法可能会抛出这个异常</span><br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>启动tPrint100线程：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Runnable print100 = <span class="hljs-keyword">new</span> PrintNum(<span class="hljs-number">100</span>); <span class="hljs-comment">//线程任务对象</span><br>Thread tPrint100 = <span class="hljs-keyword">new</span> Thread(print100); <span class="hljs-comment">//线程对象</span><br>tPrint100.start();<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192003612.png" alt="image-20210421192003612"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192306057.png"></p><p>可以看到，thread4打印c一直在执行，同时tPrint100也一直在打印数字，当打印到50的时候，调用了thread4.join()，之后停止tPrint100进程，让thread4打印c，当所有c打印完后，再继续打印数字</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li><p>由于要为每一个线程任务创建一个线程（Thread对象），对于有<strong>大量线程任务的场景就不够高效</strong></p><p>（当线程任务执行完毕，即run方法结束后，Thread对象就消亡，然后又为新的线程任务去new新的线程对象…, <strong>当有大量的线程任务时，就不断的new Thread对象，Thread对象消亡，再new Thread对象…</strong>）</p></li><li><p>线程池适合<strong>大量线程任务的并发执行</strong>。线程池通过有效管理线程、“复用” 线程来提高性能. </p></li><li><p>从JDK 1.5 开始使用Executor接口（执行器）来执行线程池中的任务，Executor的<strong>子接口ExecutorService管理和控制任务</strong></p></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192655047.png" alt="image-20210421192655047"></p><ul><li>使用Executors的类方法创建一个线程池，Eecutors由Object派生</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192841546.png" alt="image-20210421192841546"></p><blockquote><p>Executors还支持其它类型的线程池的创建方法如：newScheduledThreadPool、newSingleThreadPool</p></blockquote><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExecutorDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// Create a fixed thread pool with maximum three threads</span><br>    ExecutorService es= Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br> <br>    <span class="hljs-comment">// Submit runnable tasks to the executor</span><br> es.execute(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">100</span>));<br> es.execute(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">100</span>));<br> es.execute(<span class="hljs-keyword">new</span> PrintNum(<span class="hljs-number">100</span>));<br> <br>    <span class="hljs-comment">// Shut down 关闭，不接受新的线程任务，现有的任务将继续执行直到完成</span><br><br>    es.shutdown();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="进一步讨论：区分任务和线程"><a href="#进一步讨论：区分任务和线程" class="headerlink" title="进一步讨论：区分任务和线程"></a>进一步讨论：区分任务和线程</h3><ul><li><p>任务</p><ul><li>任务是实现了Runnable接口的类的实例</li><li>这个任务的逻辑由run方法实现</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-comment">//数据成员和其它方法... </span><br>    <br>   <span class="hljs-comment">//Implement the run method in Runnable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//task logic...</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>线程</p><ul><li>线程是Thread类的实例，是任务的运行载体</li><li>任务必须通过线程来运行</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>        Runnable task = <span class="hljs-keyword">new</span> Task(...); <span class="hljs-comment">// Create an instance of Task</span><br>        <br>        Thread thread = <span class="hljs-keyword">new</span> Thread(task); <span class="hljs-comment">// Create a thread   </span><br>        thread.start(); <span class="hljs-comment">// Start a thread</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421194556081.png" alt="image-20210421194556081" style="zoom:67%;"><blockquote><p>如果这样直接new一个线程，线程启动后，执行任务的run方法，当任务的run方法执行完毕，线程对象使命就结束，被JVM回收。</p><p>如果有大量的任务要运行，会导致频繁创建新线程，销毁线程。</p><p>线程池维护多个创建好的线程，同时可以让多个任务“复用”线程，避免了线程的重复创建和销毁。</p></blockquote><p><strong>但是一个线程任务被线程执行完后，线程就自动消亡。那么如何复用一个线程（即让线程去执行新的任务）？这个问题大家下去思考。</strong>（待解决）</p><h2 id="线程同步-程序清单30-4"><a href="#线程同步-程序清单30-4" class="headerlink" title="线程同步-程序清单30-4"></a>线程同步-程序清单30-4</h2><ul><li><p>如果一个共享资源（比如一个对象）被多个线程<strong>同时访问</strong>，如果不对访问进行控制，会造成<strong>不可预期</strong>的结果。这是需要对线程实施同步控制</p></li><li><p>Account是账户类，其数据成员balance为当前余额，deposit方法往账户存钱，getBalance方法读取账户余额</p></li><li><p>AddPennyTask为任务，每次往账户里存一个便士</p></li><li><p>启动100个线程同时执行AddPennyTask任务</p></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421195919991.png" alt="image-20210421195919991"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountWithoutSync</span></span>&#123;<br>    <br>    <span class="hljs-comment">//内部静态类Account</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> balance;  <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span></span>&#123;<br><span class="hljs-keyword">int</span> newBalance = balance + amount;   <span class="hljs-comment">//读取balance</span><br><span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">//休眠是为了放大数据不一致的可能性</span><br>               &#125;<br><span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>balance = newBalance;<span class="hljs-comment">//写balance</span><br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">//内部静态类AddPennyTask是线程任务类，实现Runnable接口，调用account对象的deposit方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddPennyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  account.deposit(<span class="hljs-number">1</span>); &#125;<br>    &#125;<br>    <br>     <span class="hljs-comment">//account对象被100个线程访问：每个线程的run方法都调用accoun.deposit方法   </span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Account account = <span class="hljs-keyword">new</span> Account();<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> ch30;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountWithoutSync</span> </span>&#123;<br>    <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//newCachedThreadPool()创建一个线程池，会再必要的时候创建新的线程。但是如果以前已经创建好的线程可用，则先宠用之前创建好的线程。</span><br>        ExecutorService executor = Executors.newCachedThreadPool();<br>        <br>        <span class="hljs-comment">//通过线程池启动100个线程，执行AddPenyTask类型的任</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;<br>            executor.execute(<span class="hljs-keyword">new</span> AddPennyTask());<br>        &#125;<br>        <br>        <span class="hljs-comment">//关闭线程池</span><br>        executor.shutdown();<br>        <br>        <span class="hljs-comment">//等待线程池里线程全部结束，线程池中都执行完后，返回true</span><br>        <span class="hljs-keyword">while</span>(!executor.isTerminated())&#123;  &#125;<br>            System.out.println(<span class="hljs-string">&quot;What is balance?&quot;</span> + account.getBalance());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>按理说，结果应该得到100，但是实际上结果如下（每次得到的值都是不同的）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421202408116.png" alt="image-20210421202408116" style="zoom: 67%;"><p><strong>原因：多个线程访问一个对象，没有同步</strong></p><p>多个线程同时访问公共资源，会导致<strong>竞争状态（同时去修改公共资源）</strong>。为了避免竞争状态，应该<strong>防止多个线程同时进入程序的某一特定部分</strong>，这样的部分叫临界区。<strong>Account类的deposit方法就是临界区</strong>。可<strong>用synchronized关键字来同步</strong>，保证<strong>一次只有一个线程可以访问这个方法</strong>。当一个方法被synchronized修饰，这个方法就是<strong>原子的（一个线程开始执行这个方法，就不可中断）</strong></p><blockquote><p><strong>注意deposit里面每条语句都不是原子的（对应着一堆汇编指令），因此每条(汇编)语句执行时，是随时可能被中断，切换到另外一个线程</strong></p></blockquote><ul><li>task1和task2同时进入account对象的deposit方法</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421203255031.png" alt="image-20210421203255031"></p><blockquote><p>task1还没有对balance进行修改，没执行到blance=newBalance的汇编语句，task2就开始任务，此时task2读取的balance就是0</p></blockquote><hr><ul><li><p>线程同步用于协调<strong>多个线程访问公共资源</strong></p><p>公共资源被多个线程同时访问，可能会遭到破坏</p><p>（程序清单30-4：AccountWithoutSync.java）</p></li><li><p>临界区（critical region）可能被多个线程同时进入的程序的一部分区域</p><ul><li>所以需要对临界区同步，<strong>保证任何时候只能有1个线程进入临界区</strong></li></ul></li><li><p>可以用synchronized关键词来同步临界区</p><ul><li>临界区可以是方法，包括静态方法和实例方法，那么被<strong>synchronized关键字修饰的方法叫同步方法</strong></li><li>临界区也可以是语句块，也可以用synchronized关键字来同步语句块：如synchronized(this){…}</li></ul></li><li><p>除了用synchronized关键字，还可以<strong>利用加锁同步临界区</strong></p></li></ul><h3 id="线程同步-synchronized"><a href="#线程同步-synchronized" class="headerlink" title="线程同步-synchronized"></a>线程同步-synchronized</h3><ul><li><p>synchronized可用于<strong>同步方法</strong></p></li><li><p>使用关键字synchronized来修饰方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span></span><br></code></pre></div></td></tr></table></figure></li><li><p>一次<strong>只有一个线程</strong>可以进入这个同步方法</p></li><li><p>synchronized关键字是如何做到方法同步的？</p><p>通过<strong>加锁</strong>：一个线程要进入同步方法，首先拿到锁，进入方法后立刻上锁，导致<strong>其它要进入这个方法的线程被阻塞</strong>（等待锁）</p><ul><li>锁是一种实现资源排他使用的机制</li><li>对于<strong>synchronized</strong>实例方法，是对调用该方法的<strong>对象(this对象)加锁</strong></li><li>对于<strong>synchronized</strong>静态方法，是对拥有这个静态方法的<strong>类加锁</strong></li></ul></li><li><p>当进入方法的线程执行完方法后，锁被释放，会唤醒等待这把锁的其他进程。</p></li></ul><hr><p><strong>同步对象</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421204754330.png" alt="image-20210421204754330"></p><p><strong>同步语句块</strong></p><ul><li>被synchronized关键字同步的语句块称为同步块(synchronized Block)</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">synchronized</span> (expr) &#123;   statements;  &#125;  ，<br></code></pre></div></td></tr></table></figure><ul><li><p>表达式<strong>expr求值结果必须是一个对象的引用</strong>，因此可以通过对任何对象加锁来同步语句块</p><ul><li>如果expr指向的对象<strong>没有被加锁</strong>，则<strong>第一个执行到同步块的线程对该对象加锁</strong>，线程执行该语句块，然后解锁；</li><li>如果expr指向的对象<strong>已经加了锁</strong>，则执行到同步块的其它线程将<strong>被阻塞</strong></li><li>expr指向的对象解锁后，所有等待该对象锁的线程都被唤醒</li></ul></li><li><p>同步语句块允许同步方法中的<strong>部分代码</strong>，而不必是整个方法，增强了程序的并发能力</p></li><li><p>任何同步的<strong>实例方法</strong>都可以转换为同步语句块。</p></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421205701082.png" alt="image-20210421205701082"></p><hr><h4 id="前面的例子中的如下几种解决方案"><a href="#前面的例子中的如下几种解决方案" class="headerlink" title="前面的例子中的如下几种解决方案"></a>前面的例子中的如下几种解决方案</h4><ol><li>deposit方法改为同步的</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> balance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span></span>&#123;<br><span class="hljs-keyword">int</span> newBalance = balance + amount;<br><span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;<br><span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>balance = newBalance;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>sleep方法调用之后，并没有释放锁。使得线程仍然可以同步控制。sleep不会让出系统资源；</p><p>凡是在上了锁的临界区里，sleep方法不会释放锁</p></blockquote><ol start="2"><li>修改共享资源Account类，在deposit方法内部加同步块</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> balance;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span></span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br><span class="hljs-keyword">int</span> newBalance = balance + amount;<br><span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;<br><span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>balance = newBalance;<br>&#125;<br>&#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><ol start="3"><li>修改线程任务类AddPennyTask，在run方法里加同步块</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddPennyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(account)&#123;<br>account.deposit(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><blockquote><p>注意：是对account对象加锁。不能对this对象加锁，即**synchronized(this)**是错误的</p><p>因为this是AddPennyTask对象（此处，而前两处就是account对象），100个线程任务对象各不相同，因此synchronized(this)是对100个线程任务对象分别加锁，根本没起到同步的作用。100个线程任务对象同时访问的是共享资源account对象，需要加锁同步的是account对象。</p></blockquote><h3 id="线程同步-加锁同步"><a href="#线程同步-加锁同步" class="headerlink" title="线程同步-加锁同步"></a>线程同步-加锁同步</h3><ul><li><p>采用synchronized关键字的同步要<strong>隐式地</strong>在对<strong>象实例或类上加锁</strong>，粒度较大影响性能</p></li><li><p>JDK1.5可以显式地加锁，能够在更小地粒度上进行线程同步</p></li><li><p>一个锁是一个Lock接口的实例</p></li><li><p>类ReentrantLock是Lock的一个具体实现：可重入的锁</p></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421210848626.png" alt="image-20210421210848626"></p><ul><li>可重入性锁描述这样的一个问题：一个线程在<strong>持有一个锁的时候</strong>，它能否<strong>再次（多次）申请该锁</strong>。如果一个线程已经获得了锁，它还可以再次获取该锁而不会死锁，那么我们就称该锁为可重入锁。通过以下伪代码说明：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>&#123;    <br>lock.lock(); <span class="hljs-comment">// 获取锁    </span><br>methodB();    <br>lock.unlock() <span class="hljs-comment">// 释放锁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span></span>&#123;    <br>lock.lock(); <span class="hljs-comment">// 再次获取该锁   </span><br> <span class="hljs-comment">// 其他业务    </span><br>lock.unlock();<span class="hljs-comment">// 释放锁</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>Java关键字synchronized隐式支持重入性</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountWithSyncUsingLock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Account account = <span class="hljs-keyword">new</span> Account();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executor = Executors.newCachedThreadPool();<br>        <br>        <span class="hljs-comment">// Create and launch 100 threads</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;executor.execute(<span class="hljs-keyword">new</span> AddPennyTask());&#125;<br>        executor.shutdown();<br>        <br>        <span class="hljs-comment">// Wait until all tasks are finished</span><br>        <span class="hljs-keyword">while</span> (!executor.isTerminated()) &#123; &#125;<br>        System.out.println(<span class="hljs-string">&quot;What is balance ? &quot;</span> + account.getBalance());<br>    &#125;<br>    <br>    <span class="hljs-comment">// A thread for adding a penny to the account</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddAPennyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;account.deposit(<span class="hljs-number">1</span>); &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>加锁同步</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-comment">// An inner class for account，主要变化在账户类</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(); <br>        <span class="hljs-comment">// 注意这里是静态的，被所有Account实例共享</span><br>        <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;   <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> balance;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>            <br>            <br>            <span class="hljs-comment">//在这里加锁（临界区开始）</span><br>            <span class="hljs-comment">//第一个进入这个方法的线程获得锁，把deposite方法锁住。</span><br>            <span class="hljs-comment">//其他进入方法的线程必须等待这把锁，因为进入阻塞状态</span><br>            lock.lock( ); <span class="hljs-comment">// Acquire the lock</span><br>            <br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">int</span> newBalance = balance + amount;<br>                Thread.sleep(<span class="hljs-number">5</span>);<br>                balance = newBalance;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;   &#125;<br>            <br>            <span class="hljs-comment">//在finally块里释放锁，其它等待这把锁的线程被唤醒</span><br>            <span class="hljs-comment">//第一个获得锁的线程可以进入该方法了，进去后又对deposite上锁…</span><br>            <span class="hljs-keyword">finally</span> &#123; lock.unlock(); <span class="hljs-comment">// Release the lock，在finally中进行锁的释放。&#125;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><h4 id="线程同步-场景1"><a href="#线程同步-场景1" class="headerlink" title="线程同步-场景1"></a>线程同步-场景1</h4><ul><li>假设一个类有多个用<strong>synchronized修饰的</strong>同步实例方法，如果多个线程访问这个类的<strong>同一个对象</strong>，当一个线程获得了该对象锁进入到其中一个同步方法时，这把锁<strong>会锁住这个对象所有的同步实例方法</strong></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421211526607.png" alt="image-20210421211526607"></p><p>设置如下共享资源类，这个类的实例被多个线程访问</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resource</span></span>&#123; <br>    <br>    <span class="hljs-comment">//多个线程会对value读写，因此需要同步控制。</span><br>    <span class="hljs-comment">//value就是竞争性资源。Resource对象也因此成为竞争性资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;   <span class="hljs-comment">//多个线程会同时对这个数据成员读写</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span>  value;&#125;<br>    <br>    <span class="hljs-comment">//inc方法把value值增加，增加量为amount</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span>  </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入inc: &quot;</span>);<br>        <span class="hljs-keyword">int</span> newValue = value + amount;<br>        <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;  <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>        value = newValue;<br>        System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开inc.&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//dec方法把value减少，减少量为amount</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span>  </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入dec: &quot;</span>);<br>        <span class="hljs-keyword">int</span> newValue = value - amount;<br>        <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">2</span>); &#125; <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>        value = newValue;<br>        System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开dec.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>inc,dec两个方法都是synchronized的，两个同步的实例方法</p></blockquote><p><strong>设置如下的两个循环创建线程任务的类</strong></p><ul><li><p>IncTask是线程任务，会循环调用资源对象r.inc方法，loops是循环次数。</p><p>IncTask的构造函数会传入要访问的对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Resource r = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//要访问的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次增加量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IncTask</span><span class="hljs-params">(Resource r,<span class="hljs-keyword">int</span> amount,<span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r; <span class="hljs-keyword">this</span>.amount = amount; <span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123; r.inc(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>DecTask是线程任务，会循环调用资源对象r.dec方法，loops是循环次数。</p><p>DecTask的构造函数会传入要访问的对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Resource r = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//要访问的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次减少量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecTask</span><span class="hljs-params">(Resource r, <span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r;<span class="hljs-keyword">this</span>.amount = amount;<span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;  r.dec(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//每次增加量为10，每次减少量为5，循环次数100</span><br>    <span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> decAmount = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> loops = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-comment">//创建资源对象r</span><br>        Resource r = <span class="hljs-keyword">new</span> Resource();<br>    <br>    <span class="hljs-comment">//构造线程任务incTask，注意传入的第一个参数为对象r，</span><br><span class="hljs-comment">//构造线程任务decTask，注意传入的第一个参数也为对象r，</span><br><span class="hljs-comment">//意味着这二个线程任务一旦执行，对应的二个线程调用的是同一个对象的方法，</span><br>    <span class="hljs-comment">//一个线程(t1)调用r.inc, 另外一个线程(t2)调用r.dec</span><br>        Runnable incTask = <span class="hljs-keyword">new</span> IncTask( r, incAmount, loops );<br>        Runnable decTask = <span class="hljs-keyword">new</span> DecTask( r, decAmount, loops );<br><br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask); es.execute(decTask);<br>        es.shutdown();<br>        <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br><br>    <span class="hljs-comment">//计算出正确的value值</span><br><span class="hljs-comment">//显示实际的计算值和正确的值，验证同步是否正确</span><br>        <span class="hljs-keyword">int</span> correctValue = (incAmount - decAmount)  * loops;<br>        System.out.println(<span class="hljs-string">&quot;\nThe value: &quot;</span> +  r.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + correctValue);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下</p><blockquote><p><strong>Thread 13</strong> <strong>进入inc: –&gt;Thread 13</strong> <strong>离开inc.</strong></p><p><strong>…</strong></p><p><strong>Thread 13进入inc: –&gt;Thread 13</strong> 离开inc.</p><p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p><p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p><p>**Thread 14进入inc: –&gt;Thread 14 **离开inc.</p><p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p><p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p><p>**Thread 13进入inc: –&gt;Thread 13 <strong>离开inc.</strong></p><p><strong>…</strong></p><p><strong>The value: 500, correct value: 500</strong></p></blockquote><blockquote><p>可以看到线程13进入inc，对象被加锁，线程14必须等待线程13退出inc后，才能进入dec。所以输出结果里线程13和14的控制台输出没有乱。</p><p>最下面的输出的value值也是正确的</p></blockquote><blockquote><p><strong>这个例子说明，二个线程访问同一个对象时， 只要一个线程拿到对象锁，这个对象的所有同步实例方法都被锁</strong></p><p>即incTask对应线程进入inc是，decTask的线程不能进入dec</p></blockquote><h4 id="线程同步-场景2"><a href="#线程同步-场景2" class="headerlink" title="线程同步-场景2"></a>线程同步-场景2</h4><ul><li>假设一个类有多个用<strong>synchronized修饰的</strong>同步实例方法，如果多个线程访问这个类的<strong>不同对象</strong>，那么<strong>不同对象的synchronized锁不一样</strong>，<strong>每个对象的锁只能对访问该对象的线程同步</strong></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421212622864.png" alt="image-20210421212622864"></p><p><strong>如下示例创建两个对象</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>,decAmount = <span class="hljs-number">5</span>, loops = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">//注意，和场景1不同，现在创建二个资源对象r1和r2</span><br>        Resource r1 = <span class="hljs-keyword">new</span> Resource();<br>        Resource r2 = <span class="hljs-keyword">new</span> Resource();<br>    <br>    <br>    <span class="hljs-comment">//incTask1和decTask1访问对象r1; 它们的运行线程被r1的对象锁同步；</span><br><span class="hljs-comment">//incTask2和decTask2访问对象r2;它们的运行线程被r2的对象锁同步；</span><br><span class="hljs-comment">//但是这二对线程之间没有同步约束，例如incTask1和incTask2的运行线程不会被同步</span><br>        Runnable incTask1 = <span class="hljs-keyword">new</span> IncTask(r1,incAmount,loops);      Runnable decTask1 = <span class="hljs-keyword">new</span> DecTask(r1,decAmount,loops);<br>        Runnable incTask2 = <span class="hljs-keyword">new</span> IncTask(r2,incAmount,loops);     Runnable decTask2 = <span class="hljs-keyword">new</span> DecTask(r2,decAmount,loops);<br><br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask1);es.execute(decTask1);<br>        es.execute(incTask2);es.execute(decTask2);<br>        es.shutdown();<br>        <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br>        <span class="hljs-keyword">int</span> r1CorrectValue = (incAmount - decAmount)  * loops ;<span class="hljs-keyword">int</span> r2CorrectValue = (incAmount - decAmount)  * loops;<br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r1: &quot;</span> + r1.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r1CorrectValue);<br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r2: &quot;</span> + r2.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r2CorrectValue);<br> &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>4个线程访问两个不同的对象，不同的对象锁不一样，incTask1进入对象r1的inc，和incTask2是否可以进入对象r2的inc无关</p></blockquote><p>结果如下</p><blockquote><p><strong>Thread 13 进入inc:</strong> </p><p><strong>Thread 15 进入inc</strong>: –&gt;Thread 13 离开inc.</p><p><strong>Thread 13  进入inc</strong>: –&gt;Thread 15 离开inc.</p><p><strong>Thread 15 进入inc</strong>: –&gt;Thread 13 离开inc.</p><p><strong>Thread 13  进入inc</strong>: –&gt;Thread 15 离开inc.</p><p><strong>Thread 15进入inc</strong>: –&gt;<strong>Thread 15 离开inc.</strong>–&gt;<strong>Thread 13 离开inc.</strong></p><p><strong>Thread 14 进入dec:</strong> </p><p><strong>Thread 16进入dec</strong>: –&gt;<strong>Thread 14离开dec.</strong></p><p><strong>Thread 14 进入dec:</strong> –&gt;<strong>Thread 16 离开dec.</strong></p><p><strong>Thread 16进入dec</strong>: –&gt;<strong>Thread 14离开dec.</strong></p><p><strong>Thread 14 进入dec:</strong> –&gt;<strong>Thread 16 离开dec.</strong></p><p><strong>Thread 16进入dec</strong>: –&gt;<strong>Thread 16离开dec.</strong>–&gt;<strong>Thread 14离开dec.</strong></p><p><strong>The value of r1: 15, correct value: 15</strong></p><p><strong>The value of r2: 15, correct value: 15</strong></p></blockquote><blockquote><p>计算结果正确。</p><p>13和15分别访问二个对象的inc，没有同步约束，因此它们的System.out.println输出是乱的；14和16也是如此。但</p><p>是13和14是同步的，15和16也是同步的。如果只看13和14的输出，就没有乱。</p></blockquote><h4 id="线程同步-场景3"><a href="#线程同步-场景3" class="headerlink" title="线程同步-场景3"></a>线程同步-场景3</h4><ul><li>n如果采用Lock锁进行同步，一旦Lock锁被一个线程获得，那么被这把锁控制的所有临界区都被上锁，这时所有其他访问这些临界区的线程都被阻塞。</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421213850843.png" alt="image-20210421213850843"></p><p><strong>ResourceWithLock采用Lock对临界区上锁，而不是用synchronized关键字</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceWithLock</span> </span>&#123; <span class="hljs-comment">//重新定义资源类，采用Lock锁</span><br>    <span class="hljs-keyword">private</span>  Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();  <span class="hljs-comment">//创建Lock锁对象，注意是实例变量 </span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;   <span class="hljs-comment">//多个线程会同时对这个数据成员读写</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span>  value; &#125;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span>   </span>&#123;<br>        <span class="hljs-comment">//inc方法在这加Lock锁（临界区开始）</span><br>        lock.lock( ); <span class="hljs-comment">// Acquire the lock</span><br>        <br>        <span class="hljs-keyword">try</span>&#123; System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入inc: &quot;</span>);<br>            <span class="hljs-keyword">int</span> newValue = value + amount;  <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;  <span class="hljs-keyword">catch</span>(InterruptedException e)&#123; &#125;<br>            value = newValue; System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开inc.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span>&#123; lock.unlock(); &#125;<span class="hljs-comment">//inc退出方法前解Lock锁，退出临界区</span><br><br>    &#125;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">//dec方法用同一把Lock锁。</span><br>        lock.lock( ); <span class="hljs-comment">// Acquire the lock</span><br>        <br>        <span class="hljs-keyword">try</span>&#123; System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入dec: &quot;</span>);<br>            <span class="hljs-keyword">int</span> newValue = value - amount; <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">2</span>); &#125;  <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>            value = newValue; System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开dec.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123; lock.unlock(); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>Inc，dec方法用同一把Lock锁。因此如果调用lock.lock(); 加锁，这个锁同时锁住inc和dec方法。</strong></p></blockquote><p>与场景一相同的两个类,但是<strong>访问类型不同</strong>了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncTaskWithLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> ResourceWithLock r = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IncTaskWithLock</span><span class="hljs-params">(ResourceWithLock r,<span class="hljs-keyword">int</span> amount,<span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r; <span class="hljs-keyword">this</span>.amount = amount; <span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123; r.inc(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>IncTask是线程任务，会循环调用资源对象r.inc方法，loops是循环次数。</p><p>线程任务现在要访问的资源类型是<strong>ResourceWithLock</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecTaskWithLock</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> ResourceWithLock r = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecTaskWithLock</span><span class="hljs-params">(ResourceWithLock r, <span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r; <span class="hljs-keyword">this</span>.amount = amount; <span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123; r.dec(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>DecTask是线程任务，会循环调用资源对象r.dec方法，loops是循环次数。</p><p>线程任务现在要访问的资源类型是<strong>ResourceWithLock</strong></p></blockquote><p>如下运行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> decAmount = <span class="hljs-number">5</span>; <span class="hljs-keyword">int</span> loops = <span class="hljs-number">50</span>;<br><span class="hljs-comment">//创建资源对象r，注意资源类型是ResourceWithLock</span><br>        ResourceWithLock r = <span class="hljs-keyword">new</span> ResourceWithLock();<br>    <br>    <span class="hljs-comment">//构造线程任务incTask，decTask</span><br>    <span class="hljs-comment">//注意:二个任务的线程访问的是同一个ResourceWithLock对象，用的是同一把Lock锁。</span><br>    <span class="hljs-comment">//这时只要一个线程拿到锁，所有被这个锁控制的临界区都被锁住。</span><br>   <span class="hljs-comment">//即incTask的线程进入inc时，decTask的线程不能进入dec</span><br>        Runnable incTask = <span class="hljs-keyword">new</span> IncTaskWithLock( r ,incAmount,loops);<br>        Runnable decTask = <span class="hljs-keyword">new</span> DecTaskWithLock( r ,decAmount,loops);<br><br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask); es.execute(decTask);<br>        es.shutdown(); <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br><br>        <span class="hljs-keyword">int</span> correctValue = (incAmount - decAmount)  * loops;<br>        System.out.println(<span class="hljs-string">&quot;\nThe value: &quot;</span> + r.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + correctValue);<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>结果如下</p><blockquote><p><strong>Thread 13 进入inc: –&gt;Thread 13 离开inc.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>…</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 13 进入inc: –&gt;Thread 13 离开inc.</strong></p><p><strong>Thread 13 进入inc: –&gt;Thread 13 离开inc.</strong></p><p><strong>…</strong></p><p><strong>The value: 250, correct value: 250</strong></p></blockquote><blockquote><p>可以看到线程13进入inc，临界区inc和dec都被加锁，线程14必须等待线程13退出inc后，才能进入dec。所以输出结果里线程13和14的控制台输出没有乱.</p><p>最下面的输出的value值也是正确的</p></blockquote><h4 id="线程同步-场景4"><a href="#线程同步-场景4" class="headerlink" title="线程同步-场景4"></a>线程同步-场景4</h4><ul><li>如果一个类采用Lock锁对临界区上锁，而且这个Lock锁也是该类的实例成员（见ResourceWithLock的里的lock对象定义），那么<strong>这个类的二个实例的Lock锁就是不同的锁</strong>，下面的动画演示了这种场景：对象o1的Lock锁和对象o2的Lock锁是不同的锁对象。</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421214552381.png" alt="image-20210421214552381"></p><blockquote><p><strong>注意，和场景3不同，现在创建二个资源对象r1和r2.注意资源类型是ResourceWithLock</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>, decAmount = <span class="hljs-number">5</span>,loops = <span class="hljs-number">20</span>; <br>    <br>    <span class="hljs-comment">//两个ResourceWithLock对象</span><br>    ResourceWithLock r1 = <span class="hljs-keyword">new</span> ResourceWithLock();  <br>    ResourceWithLock r2 = <span class="hljs-keyword">new</span> ResourceWithLock();<br><br>    <span class="hljs-comment">/*四个线程访问二个不同对象</span><br><span class="hljs-comment">     *incTask1，decTask1的执行线程访问同一个对象r1，它们之间同步</span><br><span class="hljs-comment">     * incTask2，decTask2的执行线程访问同一个对象r2，它们之间同步</span><br><span class="hljs-comment">     * incTask1执行线程进入对象r1的inc，和incTask2执行线程是否可以进入对象r2的inc无关，因为锁不一样</span><br><span class="hljs-comment">*/</span><br>        <span class="hljs-comment">//incTask1，decTask1访问同一个对象r1，它们之间同步</span><br>        Runnable incTask1 = <span class="hljs-keyword">new</span> IncTaskWithLock(r1,incAmount,loops);<br>        Runnable decTask1 = <span class="hljs-keyword">new</span> DecTaskWithLock(r1,decAmount,loops);<br>        <span class="hljs-comment">//incTask2，decTask2访问同一个对象r2，它们之间同步</span><br>        Runnable incTask2 = <span class="hljs-keyword">new</span> IncTaskWithLock(r2,incAmount,loops);<br>        Runnable decTask2 = <span class="hljs-keyword">new</span> DecTaskWithLock(r2,decAmount,loops);<br><br>    <br>    <br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask1); es.execute(decTask1); es.execute(incTask2); es.execute(decTask2);<br>        es.shutdown();<br>        <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br>        <span class="hljs-keyword">int</span> r1CorrectValue = (incAmount - decAmount)  * loops ; <span class="hljs-keyword">int</span> r2CorrectValue = (incAmount - decAmount)  * loops;          <br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r1: &quot;</span> + r1.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r1CorrectValue);<br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r2: &quot;</span> + r2.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r2CorrectValue);<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><p>输出结果</p><blockquote><p><strong>Thread 13 进入inc:</strong></p><p><strong>Thread 15 进入inc: –&gt;Thread 15 离开inc.</strong></p><p><strong>Thread 16 进入dec: –&gt;Thread 13 离开inc.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 16 离开dec.</strong></p><p><strong>Thread 16 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 16 离开dec.</strong></p><p><strong>Thread 16 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 16 离开dec.</strong></p><p><strong>Thread 15 进入inc: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 13 进入inc: –&gt;Thread 15 离开inc.</strong></p><p><strong>Thread 15 进入inc: –&gt;Thread 13 离开inc.</strong></p><p><strong>Thread 13 进入inc: –&gt;Thread 15 离开inc.–&gt;Thread 13 离开inc.</strong></p><p><strong>The value of r1: 15, correct value: 15</strong></p><p><strong>The value of r2: 15, correct value: 15</strong></p></blockquote><blockquote><p>计算结果正确。</p><p>13和15分别访问二个对象的inc，没有同步约束，因此它们的输出是乱的；14和16也是如此。但是13和14是同步的，15和16也是同步的。如果只看13和14的输出，就没有乱。</p></blockquote><h3 id="线程同步-总结和思考"><a href="#线程同步-总结和思考" class="headerlink" title="线程同步-总结和思考"></a>线程同步-总结和思考</h3><ul><li><p>如果采用synchronized关键字对类 A的实例方法进行同步控制，这时等价于synchronized(this){ }</p><ul><li>一旦一个线程进入类A的对象o的synchronized实例方法，<strong>对象o被加锁，对象o所有的synchronized实例方法都被锁住</strong>，从而阻塞了要访问对象o的synchronized实例方法的线程，<strong>但是与访问A类其它对象的线程无关</strong></li></ul></li><li><p>如果采用synchronized关键字对类 A的静态方法进行同步控制，这时等价于synchronized(A.class){ }。一旦一个线程进入A的一个静态同步方法，A所有的静态同步方法都被锁（这个锁是类级别的锁），<strong>这个锁对所有访问该类静态同步方法的线程有效，不管这些线程是通过类名访问静态同步方法还是通过不同的对象访问静态同步方法。</strong></p></li><li><p>如果通过Lock对象进行同步，首先看Lock对象对哪些临界区上锁，一旦Lock锁被一个线程获得，那么被这把锁控制的所有临界区都被上锁（如场景3）；另外要区分Lock对象本身是否是不同的：不同的Lock对象能阻塞的线程是不一样的（如场景4）。</p></li></ul><h3 id="线程同步-线程协作"><a href="#线程同步-线程协作" class="headerlink" title="线程同步-线程协作"></a>线程同步-线程协作</h3><ul><li><p>线程之间有资源竞争，<strong>synchronized和Lock锁这些同步机制解决的是资源竞争问题</strong></p></li><li><p>线程之间还有相互协作的问题</p></li><li><p>假设创建并启动两个任务线程：</p><ul><li><p>存款线程用来向账户中存款</p></li><li><p>提款线程从同一账户中提款</p></li><li><p>当提款的数额大于账户的当前余额时，提款线程必须等待存款线程往账户里存钱</p></li><li><p>如果存款线程存入一笔资金，必须通知提款线程重新尝试提款，如果余额仍未达到提款的数额，提款线程必须继续等待新的存款 </p></li></ul></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421215036540.png" alt="image-20210421215036540"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——泛型</title>
    <link href="/2021/04/12/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/"/>
    <url>/2021/04/12/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li><p>泛型（Generic）指可以把类型参数化，这个能力使得我们可以定义带类型参数的泛型类、泛型接口、泛型方法，随后编译器会用唯一的具体类型替换它；</p></li><li><p>主要优点是在<strong>编译时</strong>（类型不匹配的错误）而不是运行时<strong>检测出错误</strong>(如果运行时才检查出错误，可能造成严重后果)。泛型类或方法允许用户指定可以和这些类或方法一起工作的对象类型。<strong>如果试图使用一个不相容的对象，编译器就会检测出这个错误。</strong></p></li><li><p>Java的泛型通过擦除法实现，和C++模板生成<strong>多个实例类</strong>不同。<strong>编译时会用<em>类型实参</em>代替<em>类型形参</em>进行严格的语法检查</strong>，（通过编译后）然后擦除类型参数、生成所有实例类型共享的唯一原始类型。这样使得泛型代码能兼容老的使用原始类型的遗留代码。</p></li></ul><span id="more"></span><blockquote><p>若不存在泛型，只能重载</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span>,<span class="hljs-keyword">double</span>)</span></span><br></code></pre></div></td></tr></table></figure><p>六个基本类型求和要写六个，但是</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">Sum</span><span class="hljs-params">(T o1,T o2)</span></span>;<br></code></pre></div></td></tr></table></figure><p>&lt;T&gt;必须为引用类型，六个基本值类型的包装类</p><p>调用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Sum(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>),<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">2</span>))<br></code></pre></div></td></tr></table></figure></blockquote><hr><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><ul><li><p>泛型类（Generic Class）是带形式化类型参数的类。<strong>形式化类型参数</strong>是一个<strong>逗号分隔的变量名列表</strong>，位于类声明中类名后面的尖括号&lt;&gt;中。下面的代码声明一个泛型类Wrapper，它接受一个形式化类型参数T：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>T是一个类型变量，它可以是Java中的<strong>任何引用类型</strong>，例如String，Integer，Double等。当把一个具体的类型实参传递给类型形参T时，就得到了一系列的<strong>参数化类型</strong>(Parameterized Types)，如Wrapper<String>，Wrapper<Integer> ，这些参数化类型是泛型类Wrapper<T>的<strong>实例类型</strong>（类似于Circle类型有实例对象c1,c2）</T></Integer></String></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Wrapper&lt;String&gt;  stringWrapper = <span class="hljs-keyword">new</span> Wrapper&lt;String&gt;();<br>Wrapper&lt;Circle&gt;  circleWrapper = <span class="hljs-keyword">new</span> Wrapper&lt;Circle&gt;();<br><br></code></pre></div></td></tr></table></figure><blockquote><p>参数化类型(Parameterized Types)是在JLS里面使用的术语，为了方便描述，本章后面称为实例类型</p></blockquote></li></ul><h3 id="RTTI（-Run-Time-Type-Identification）：运行时类型识别"><a href="#RTTI（-Run-Time-Type-Identification）：运行时类型识别" class="headerlink" title="RTTI（ Run-Time Type Identification）：运行时类型识别"></a><strong>RTTI（ Run-Time Type Identification）：运行时类型识别</strong></h3><ul><li>通过<strong>运行时类型</strong>信息，程序在<strong>运行时</strong>能够检查<strong>父类引用所指的对象</strong>的实际派生类型。</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210412170913361.png" alt="image-20210412170913361"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Shape s =<span class="hljs-keyword">null</span>;<br>s = <span class="hljs-keyword">new</span> Circe();<br>s.draw();  <span class="hljs-comment">//draw a circle</span><br><br>If(s <span class="hljs-keyword">instanceof</span> Circle)&#123;<br>    System.out.println(“s is a Circle”)<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>以上代码输出结果s is a Circle，表示s对象是Circle类的实例</p><p>上面的例子都是RTTI在起作用，<strong>程序在运行时，JVM知道一块内存到底是什么类型的对象</strong></p></blockquote><ul><li>要理解RTTI在Java中的工作原理，就必须知道类型信息在<strong>运行时是如何表示</strong>的。</li><li>类型信息是通过<strong>Class类（类名为Class的类，不是class，是一个类）的<em>对象</em></strong>表示的，Java利用Class对象来执行RTTI。</li><li>每个类都有一个对应的Class对象，每当编写并编译了一个类，就会<strong>产生一个Class对象</strong>，这个对象当JVM加载这个类时就产生了。</li></ul><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ol><li>  <strong>Class.forName方法</strong>，是Class类的静态方法</li></ol><p>   ch13下有如下三个类</p>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><blockquote><p>如下代码中，Class clz = Class.forName(“ch13.Manager”);产生ch13.Manager类的Class对象，赋值给Class类型的引用变量clz</p></blockquote>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class clz = Class.forName(“ch13.Manager”); <span class="hljs-comment">//参数是类完全限定名字符串</span><br>            System.out.println(clz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Manager</span><br>            System.out.println(clz.getSimpleName()); <span class="hljs-comment">//产生简单名Manager</span><br><br>            Class superClz = clz.getSuperclass(); <span class="hljs-comment">//获得直接父类型信息</span><br>            System.out.println(superClz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Employee</span><br>            System.out.println(superClz.getSimpleName()); <span class="hljs-comment">//产生简单名Employee</span><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意编译器是无法检查字符串”ch13.Manager”是否为一个正确的类的完全限定名，因此在运行时可能抛出异常，比如当不小心把类名写错了时。</p></blockquote><ol start="2"><li> 利用类字面常量：<strong>类名.class</strong>，得到类对应的Class对象</li></ol><p>   <strong>某个类名.class是Class类型的字面量</strong></p><p>   <strong>正如int类型的字面量有1，2，3，</strong></p><p>   <strong>Class类型的字面量有Person.class, Employee.class, Manager.class，它们都是Class类型的实例</strong></p>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Class clz = Manager.class;  <span class="hljs-comment">// Manager.class得到Manager的Class对象.赋给引用clz</span><br>        System.out.println(clz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Manager</span><br>        System.out.println(clz.getSimpleName()); <span class="hljs-comment">//产生简单名Manager   </span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>类字面常量不仅可以用于类，也可用于数组(int[].class)，接口，<strong>基本类型</strong>，如int.class</li><li>相比Class.forName方法，这种方法更安全，<strong>在编译时就会被检查，因此不需要放在Try/Catch块里（见上面的标注里说明）</strong></li><li>Class.forName会引起类的静态初始化块的执行，T.class不会引起类的静态初始化块的执行</li></ul><ol start="3"><li> <strong>通过对象。</strong>如果获得一个对象的引用o，通过<strong>o.getClass()方法</strong>获得这个对象的类型的Class对象</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Object o = <span class="hljs-keyword">new</span> Manager();<br>        Class clz = o.getClass();<br>        System.out.println(clz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Manager</span><br>        System.out.println(clz.getSimpleName()); <span class="hljs-comment">//产生简单名Manager</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>getClass返回的是运行时类型</p></blockquote><h3 id="泛型化的Class引用"><a href="#泛型化的Class引用" class="headerlink" title="泛型化的Class引用"></a>泛型化的Class引用</h3><blockquote><p>非泛化的Class引用（即不带类型参数的Class引用）可指向任何类型的Class对象，但这样不安全</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class clz ;     <span class="hljs-comment">//注意警告， Class is a raw type. References to generic type Class&lt;T&gt; should be parameterized</span><br>clz= Manager.class; <span class="hljs-comment">//OK</span><br>clz = <span class="hljs-keyword">int</span>.class; <span class="hljs-comment">//OK</span><br></code></pre></div></td></tr></table></figure><blockquote><p>有时我们需要限定Class引用能指向的类型：加上&lt;类型参数&gt;。这样可以可以强制编译器进行额外的类型检查，对于类型参数，编译器检测时不看继承关系</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class&lt;Person&gt; genericClz;    <span class="hljs-comment">//泛化Class引用，Class&lt;Person&gt;只能指向Person的类型信息， &lt;Person&gt;为类型参数</span><br>genericClz = Person.class;  <span class="hljs-comment">//OK</span><br><span class="hljs-comment">//genericClz = Manager.class; //Error，不能指向非Person类型信息。注意对于类型参数，编译器检测时不看继承关系。</span><br></code></pre></div></td></tr></table></figure><blockquote><p>能否声明一个可用指向Person及其子类的Class对象的引用？为了放松泛化的限制，用通配符?表示任何类型，并且与extends结合，创建一个范围</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class&lt;? extends Person&gt; clz2;  <span class="hljs-comment">//引用clz2可以指向Person及其子类的类型信息</span><br>clz2 = Person.class;<br>clz2 = Employee.class;<br>clz2 = Manager.class;<br><span class="hljs-comment">//注意Class&lt;?&gt; 与Class效果一样，但本质不同，一个用了泛型，一个没有用泛型。 Class&lt;?&gt; 等价于Class&lt;? extends Object &gt; </span><br></code></pre></div></td></tr></table></figure><h2 id="反射（Reflection）：应用案例：实例化对象"><a href="#反射（Reflection）：应用案例：实例化对象" class="headerlink" title="反射（Reflection）：应用案例：实例化对象"></a>反射（Reflection）：应用案例：实例化对象</h2><ul><li><p>要完成的功能：输入一个完全限定名字符串（如”java.lang.String”）,创建相应的对象：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o = <span class="hljs-keyword">new</span> String(“Hello”); <span class="hljs-comment">//注意String是类名标识符，不是字符串</span><br></code></pre></div></td></tr></table></figure><ol><li><p>方案1</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span>( input.equals(“java.lang.String”) )&#123;<br>     o = <span class="hljs-keyword">new</span> String(“”);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ( input.equals(“ch13.Student”) )&#123;<br>    o = <span class="hljs-keyword">new</span> Student();<br>&#125;<br>…更多的<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>语句<br><br></code></pre></div></td></tr></table></figure><blockquote><p>这种方法显然不行，因为事先不知道会输入一个什么类的完全限定名字符串，if语句不可能列出所有可能的类型</p></blockquote></li><li><p>方案2 实例化对象（java.lang.reflect包）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&quot;unknown&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Name:&quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>clz指向一个类的Class对象时，通过 clz可以得到这个类的所有构造函数对象，一个构造函数对象类型是：</p><p>   java.lang.reflect.Constructor</p><p>一个Constructor对象代表了类的一个构造函数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class  clz = Class.forName(<span class="hljs-string">&quot;ch13.Student&quot;</span>);<br>            <br>            <span class="hljs-comment">//获取所有的Constructor对象</span><br>            Constructor[] ctors = clz.getConstructors();<br>             <span class="hljs-comment">//ctors是clz构造函数对象的数组</span><br>            <span class="hljs-keyword">for</span>(Constructor c : ctors)&#123;<br>                System.out.println(c.toString());<br>        &#125;<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>输出，打印ch13.student的全部构造函数</p><p>public ch13.Student()<br>public ch13.Student(java.lang.String)<br>上述对象得到了这个Class中所有的构造方法，对应的构造方法通过数组返回<br>如果我们要知道一个类中，有那些构造方法，就可以这样去做<br>如下获得一个类中所有的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;<br>          Class clz = Class.forName(<span class="hljs-string">&quot;ch13.Student&quot;</span>);<br>            <span class="hljs-comment">//获取所有的Method</span><br>            <span class="hljs-comment">//Method[] methods = clz.getMethods(); //会显示所有方法，包括继承的</span><br>            Method[] methods = clz.getDeclaredMethods(); <span class="hljs-comment">//本类定义的方法</span><br>            <span class="hljs-keyword">for</span>(Method m: methods)&#123;<br>                System.out.println(m.toString());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>               e.printStackTrace();<br>        &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>输出，打印ch13.Student类的全部方法</p><p><strong>public</strong> <strong>java.lang.String</strong> <strong>ch13.Student.toString()</strong></p><p><strong>public</strong> <strong>java.lang.String</strong> <strong>ch13.Student.getName()</strong></p><p><strong>public void ch13.Student.setName(java.lang.String)</strong></p></blockquote><blockquote><p>得到了构造与方法，也是为了得到实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">  Class clz = Class.forName(<span class="hljs-string">&quot;ch13.Student&quot;</span>);<br>    <span class="hljs-comment">//实例化对象</span><br>    <span class="hljs-comment">//1：如有缺省构造函数，调用Class对象的newInstance方法</span><br>    Student s1 = (Student)clz.newInstance();<br>    <span class="hljs-comment">//2. 调用带参数的构造函数，Instance返回object</span><br>    Student s2 = (Student)clz.getConstructor(String.class).newInstance(<span class="hljs-string">&quot;John&quot;</span>);<br>    <span class="hljs-comment">//invoke method</span><br>    Method m = clz.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>    m.invoke(s1, <span class="hljs-string">&quot;Marry&quot;</span>); <span class="hljs-comment">//调用s1对象的setName方法，实参&quot;Marry&quot;</span><br>    System.out.println(s1.toString());<br>    System.out.println(s2.toString());        <br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>     e.printStackTrace();<br>     <br></code></pre></div></td></tr></table></figure><blockquote><p>Student s2 = (Student)clz.getConstructor(String.class).newInstance(“John”);</p><p>首先得到参数类型为String的构造函数对象，然后调用它的newInstance方法调用构造函数，参数为“John”。等价于：</p><p>Student s2 = new Student(“John”)；</p><p>但是是通过反射机制调用的</p></blockquote><blockquote><p>Method m = clz.getMethod(“setName”, String.class);</p><p>m.invoke(s1, “Marry”); //调用s1对象的setName方法，实参”Marry”</p><p>clz.getMethod(“setName”, String.class);得到方法名为setName,参数为String的方法对象m，类型是Method。</p><p>然后通过m.invoke去调用该方法，第一个参数为对象，第二个参数是传递给被调方法的实参。这二条语句等价于s1.setName(“Marry)，但是是通过反射去调的</p></blockquote></li></ol></li></ul><h2 id="泛型的动机和优点"><a href="#泛型的动机和优点" class="headerlink" title="泛型的动机和优点"></a>泛型的动机和优点</h2><ul><li><p>lJDK1.5开始，Java允许定义<strong>泛型类、泛型接口和泛型方法</strong>，API中的一些接口和类使用泛型进行了修改。如java.lang.comparable</p><blockquote><p>T表示类型形参，之后会用实际的类型实参来替换，称为“泛型实例化”（得到实例类型）。按照惯例，E或T这样的单个大写字母表示泛型类型的参数类型</p></blockquote><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414090606567.png" alt="image-20210414090606567"></p><blockquote><p>1.5之前，Data和String都引用了Comparable接口，因此c.compareTo(String)<strong>编译通过</strong>，但是由于类型不同，<strong>运行时就会出错</strong></p><p>1.5之后，编译时就会产生错误，因为c的Comparable为Data，String为String，<strong>编译就不通过</strong></p></blockquote></li></ul><blockquote><p>非泛型类Comparable接口的CompareTo方法的参数声明类型为Object，而传进去的实参”red”确实是Object类型，因此编译器通过。但实际运行时一个Data对象和字符串对象比较大小肯定出错。<strong>因此在非泛型年代，保证传进去的对象与另一个比较大小的对象实际类型的一致性是程序员的责任</strong></p></blockquote><blockquote><p>现在泛型接口Comparable&lt;T&gt;里的comparaTo方法的参数类型必须是T，这就规定了要比较的另外一个对象类型必须是T，即和this对象的类型必须一致，否则编译器就可以检查出类型不一致</p><p>Comparable&lt;Data&gt;是Comparable&lt;T&gt;的类型实例，因为Comparable&lt;T&gt;是泛型接口，而Comparable&lt;Date&gt;是具体接口类型</p></blockquote><ul><li><p>以ArrayList为例说明看看定义的不同，注意使用了泛型参数E的地方</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414091700351.png" alt="image-20210414091700351"></p><p><strong>下面举出一个非泛型ArrayList</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList list = <span class="hljs-keyword">new</span> ArrayList();   <span class="hljs-comment">//非泛型的ArrayList</span><br></code></pre></div></td></tr></table></figure><blockquote><p>存入String，取出String</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">   <span class="hljs-comment">//非泛型的ArrayList的add方法，参数类型是Object </span><br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);                  <br><span class="hljs-comment">//非泛型的ArrayList的get方法，返回类型也是Object，因此要强制类型转换</span><br>      String s = (String) list.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">//运行起来不报错  </span><br></code></pre></div></td></tr></table></figure><blockquote><p>存入Data，取Data，编译时不报错，但运行时抛出异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">  <span class="hljs-comment">//但是万一程序员不小心加入了Date对象</span><br>  list.add(<span class="hljs-keyword">new</span> Date()); <span class="hljs-comment">//Date对象也是Object类型，因此编译器不报错</span><br>  String s2 = (String)list.get(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译不报错，因为在编译时uncheck</span><br><span class="hljs-comment">//但是在运行时就抛出异常</span><br></code></pre></div></td></tr></table></figure><blockquote><p>因此，对非泛型ArrayList，保证放进去对象的类型一致性变成了程序员的责任</p></blockquote></li></ul><h3 id="泛型的ArrayList"><a href="#泛型的ArrayList" class="headerlink" title="泛型的ArrayList"></a>泛型的ArrayList</h3><blockquote><p>尖括号里E为类型形参，以和方法参数区分开(圆括号)规定了放入ArrayList里必须是某种类型E的对象。类型形参在类体里可以用在任何其它类型可以用的地方，如成员变量类型，方法形参类型，方法返回类型。</p><p>注意抽象父类和实现的接口List也带了类型参数E。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, </span><br><span class="hljs-class">    <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span>&#123;<br>        ...<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>内部结构就是一个Object数组</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">transient</span> Object[] elementData; <br></code></pre></div></td></tr></table></figure><blockquote><p>将下标为index的元素（注意类型是Object）强制转换为E类型返回。为什么不用instanceOf检查？</p><p>因为add方法保证了数组里元素的类型一定是E</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>add方法参数类型是E，这就规定了加入这个集合的元素都必须是E类型，如果add类型不一致的对象，编译器一定报错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><blockquote><p>调用上面elementData方法，该方法直接返回E类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        rangeCheck(index);<span class="hljs-comment">//检查index是否越界</span><br>        <span class="hljs-keyword">return</span> elementData(index);<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>因此，有了泛型机制，程序员的责任（保证类型一致性，例如用instanceOf检查也是程序员的责任）变成了编译器的责任。这就是引入泛型机制的优点。</strong></p></blockquote><ul><li><p>ArrayList<E>定义了一个带<strong>类型形参</strong>的泛型类， 类型参数<strong>E是形参</strong></E></p></li><li><p>ArrayList<String> 是一个参数化类型(<strong>实例类型</strong>)<strong>，</strong>其中String作为一个具体类型（实参）传递给形参E。 这里借用了术语”实例”，不是指对象，而是一个具体的类型</String></p></li><li><p>特别重要的时：<strong>类型实参String传递给类型形参E时发生在编译时（不是运行时）</strong>。因此，对于下面的语句，编译器会用<strong>String代替E，对代码进行类型检查</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//用实例类型ArrayList&lt;String&gt; 声明引用变量list</span><br>list.add(“China”);<span class="hljs-comment">//编译器会根据类型实参String检查传入add方法的对象类型是否匹配，否则报错</span><br><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414093844658.png" alt="image-20210414093844658"></p></li><li><p>ArrayList<String> list = new ArrayList<String>(); </String></String></p></li><li><p>ArrayList<String> list就规定了只能往list里添加String字符串</String></p><p>list.add(“Hust”);     //正确，只能向list中添加字符串</p><p>list.add(new Integer(1)); //错误，list中只能添加字符串</p></li><li><p><strong>泛型类型的参数类型必须是引用类型</strong></p><p>如 ArrayList<int> list = new ArrayList<int>(); //错误</int></int></p><p>ArrayList<Integer> list = new ArrayList<Integer>(); //正确</Integer></Integer></p><p>list.add(5); //正确 <strong>自动打包（装箱）机制</strong></p><p>int i = list.get(0); //正确，如果元素是包装类型，如Integer,Double,Character，可以直接将这个元素赋给一个基本类型的变量。这个过程称为<strong>自动拆箱机制</strong></p></li></ul><h2 id="定义泛型类和接口"><a href="#定义泛型类和接口" class="headerlink" title="定义泛型类和接口"></a>定义泛型类和接口</h2><h3 id="用泛型定义栈类"><a href="#用泛型定义栈类" class="headerlink" title="用泛型定义栈类"></a>用泛型定义栈类</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414185245589.png" alt="image-20210414185245589" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericStack</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>         <span class="hljs-keyword">private</span> ArrayList&lt;E&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;E&gt;();<br>    <span class="hljs-comment">//判空</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-keyword">return</span> list.isEmpty();<br>         &#125;<br>    <span class="hljs-comment">//获取长度</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> list.size();<br>         &#125;<br>    <span class="hljs-comment">//取值不出栈</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-keyword">return</span> list.get(getSize() - <span class="hljs-number">1</span>);<br>         &#125;<br>    <span class="hljs-comment">//出栈</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br> E o = list.get(getSize() - <span class="hljs-number">1</span>) ;<br> list.remove(getSize() - <span class="hljs-number">1</span>);<br> <span class="hljs-keyword">return</span> o;<br>          &#125;<br>    <span class="hljs-comment">//入栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E o)</span> </span>&#123;<br> list.add(o);<br>           &#125; <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;stack: &quot;</span> + list.toString();<br>          &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>GenericStack<String>是泛型类GenericStack<E>的一个实例类型</E></String></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">GenericStack&lt;String&gt; stack1 = <span class="hljs-keyword">new</span> GenericStack&lt; String &gt;();<br>stack1.push(“Londen”);<br>stack1.push(“Paris”);<br>stack1.push(“New York”);<br></code></pre></div></td></tr></table></figure><p>GenericStack<Integer>是泛型类GenericStack<E>的另一个实例类型</E></Integer></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">GenericStack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>stack1.push(<span class="hljs-number">5</span>);<br>stack1.push(<span class="hljs-number">10</span>);<br>stack1.push(<span class="hljs-number">15</span>);<br></code></pre></div></td></tr></table></figure><ul><li>注意：<strong>GenericStack<E>构造函数形式是擦除参数类型后的GenericStack( ),不是GenericStack&lt;&gt;();</E></strong></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericContainer</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">//注意泛型的构造函数不带泛型参数，连&lt;&gt;都不能有</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericContainer</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><p>注意</p><ul><li><p>泛型类或者泛型接口的一个实力类型，可以作为其他类的父类或者类要实现的接口</p></li><li><p>如Java API中，Java.lang.String类实现Comparable接口的写法是</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-title">inplements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;</span><br><span class="hljs-class">//<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;是泛型类接口<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;类型的实例类型（接口）</span><br><span class="hljs-class"></span><br><span class="hljs-class">//<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;是一个这样接口类型：可以比较两个<span class="hljs-title">String</span>对象的大小</span><br><span class="hljs-class"></span><br><span class="hljs-class">//而<span class="hljs-title">String</span>实现了这个接口<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>这样的目的主要是避免不同类的比较，限定只能String和String比，Circle和Circle比，不能引用了Comparable的类就可以比</p></li><li><p>类似的，如果我们要定义了一个实现Comparable接口的Cricle类，就要这么写</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Cricle</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ul><li><p>除了可以定义泛型接口和泛型类，也可以定义泛型方法。下面的例子在一个非泛型类里定义了泛型方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethodDemo</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer[] integers = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        String[] strings = &#123;<span class="hljs-string">&quot;Londen&quot;</span>,<span class="hljs-string">&quot;Paris&quot;</span>,<span class="hljs-string">&quot;New York&quot;</span>,<span class="hljs-string">&quot;Austin&quot;</span>&#125;;  <br>        GenericMethodDemo.&lt;Integer&gt;print(integers);    <br>        GenericMethodDemo.&lt;String&gt;print(strings);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(E[] list)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt;list.length; i++)&#123;<br>            System.out.print(list[i]+<span class="hljs-string">&quot; &quot;</span>);<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>调用泛型方法</strong>，将实际类型放于&lt;&gt;之中方法名之前；</p><p>也可以<strong>不显式指定实际类型（方法名前不加&lt;&gt;）</strong>，而直接给实参调用，如</p><p>print(integers); print(strings);由<strong>编译器自动发现实际类型</strong></p></blockquote><blockquote><p><strong>声明泛型方法</strong>，将类型参数<E>置于返回类型之前</E></p><p>方法的类型参数<strong>可以作为形参类型，方法返回类型，也可以用在方法体内其他类型可以用的地方</strong></p></blockquote></li></ul></li></ul><h2 id="受限泛型"><a href="#受限泛型" class="headerlink" title="受限泛型"></a>受限泛型</h2><ul><li><p>在定义泛型类、泛型接口、泛型方法时，可以将类型参数指定为另外一种类型（或泛型）的子类型（用extends），这样的类型参数称之为<strong>受限的</strong>（bounded）</p></li><li><p>想实现泛型方法比较二个几何对象的面积是否相等，几何对象类型很多，都从GeometricObject派生 （E代表一种几何对象类型，如Circle，Triangel）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoundedTypeDemo</span></span>&#123;<br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equalArea</span><span class="hljs-params">(E object1, E object2 )</span></span><br><span class="hljs-function">        </span>&#123;<br>        <span class="hljs-keyword">return</span> object1.getArea() == object2.getArea( );<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>E extends GeometricObject规定了E必须是GeometricObject及其子类，因此E类型对象有方法getArea</p></blockquote></li><li><p>注意: 类型参数放置的位置，应放在<strong>方法的返回类型之前</strong>(定义泛型方法)或者<strong>类名之后</strong>（定义泛型类时）</p></li></ul><h2 id="原始类型和向后兼容"><a href="#原始类型和向后兼容" class="headerlink" title="原始类型和向后兼容"></a>原始类型和向后兼容</h2><ul><li><p>没有指定具体实现类型的泛型类和泛型接口称为原始类型（raw type）。如：</p><ul><li><p>GenericStack stack = new GenericStack( ); <strong>等价</strong>于</p></li><li><p>GenericStatck&lt;Object&gt; stack = new GenericStack&lt;Object&gt;( );</p><p>(JDK1.5后出现泛型，为了让新老代码兼容，出现泛型后，第一句不报错，但是警告)</p></li></ul></li><li><p><strong>这种不带类型参数的泛型类或泛型接口称为原始类型。</strong>使用原始类型可以向后兼容Java的早期版本。如Comparable类型. </p></li><li><p><strong>尽量不要用！</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//从JDK1.5开始，Comparable就是泛型接口Comparable&lt;T&gt;的原始类型(raw type)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Max</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparable <span class="hljs-title">findMax</span><span class="hljs-params">(Comparable o1, Comparable o2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (o1.compareTo(o2) &gt; <span class="hljs-number">0</span>)?o1:o2;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p> 上例中，Comparable o1和Comparable o2都是原始类型声明，但是，<strong>原始类型是不安全的</strong>。如：Max.findMax(“Welcome”,123）；<strong>编译通过</strong>(都实现了Comparable)，但会<strong>引起运行时错误</strong>（类型不一致）。</p></blockquote></li><li><p>安全的办法是使用泛型，现在将findMax方法改成泛型方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Max</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="hljs-function">E <span class="hljs-title">findMax</span><span class="hljs-params">(E o1, E o2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (o1.compareTo(o2) &gt; <span class="hljs-number">0</span>)?o1:o2;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>E extends Comparable&lt;E&gt;指定类型E必须<strong>实现Comparable接口</strong>，而且接口比较<strong>对象类型必须是E</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Circle</span>&gt; </span>&#123;…&#125;<br><br>Max.findMax(<span class="hljs-keyword">new</span> Circle(),<span class="hljs-keyword">new</span> Circle(<span class="hljs-number">10.0</span>);<br><span class="hljs-comment">//编译上面这条语句时，编译器会自动发现findMax的类型实参为Circle，用Circle替换E</span><br></code></pre></div></td></tr></table></figure><blockquote><p>这个时候语句Max.findMax(“Welcome”,123）；会引起<strong>编译时错误</strong>，因为findMax方法要求两个参数类型必须一致，且<strong>E必须实现Comparable<E> 接口</E></strong></p></blockquote></li></ul><h2 id="通配泛型"><a href="#通配泛型" class="headerlink" title="通配泛型"></a>通配泛型</h2><h3 id="泛型集合类型没有协变性"><a href="#泛型集合类型没有协变性" class="headerlink" title="泛型集合类型没有协变性"></a><strong>泛型集合类型没有协变性</strong></h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WildCardNeedDemo</span> </span>&#123;<br>    <span class="hljs-comment">//参数类型为GenericStack&lt;Number&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(GenericStack&lt;Number&gt; stack)</span></span>&#123;<br>        <span class="hljs-keyword">double</span> max = stack.pop().doubleValue();<br>        <span class="hljs-keyword">while</span> (! stack.isEmpty())&#123;<br>            <span class="hljs-keyword">double</span> value = stack.pop().doubleValue();<br>            <span class="hljs-keyword">if</span>(value &gt; max)<br>                max = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        GenericStack&lt;Integer&gt; intStack = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>        intStack.push(<span class="hljs-number">1</span>);intStack.push(<span class="hljs-number">2</span>);intStack.push(<span class="hljs-number">3</span>);<br>   <span class="hljs-comment">//传入的参数为insack是GenericStack&lt;Integer&gt;</span><br>        System.out.println(<span class="hljs-string">&quot;Th max value is &quot;</span> + max(intStack));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>出错，因为intStack不是GenericStack<Number>实例</Number></p></blockquote><p>Integer是Number的子类，但是</p><p>GenericStack<Integer>并不是GenericStack<Number>的子类。</Number></Integer></p><p>原因：<strong>泛型集合类型没有协变性</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WildCardNeedDemo</span> </span>&#123;<br>    <span class="hljs-comment">//参数GenericStack&lt;？ extends Number&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(GenericStack&lt;？ extends Number&gt; stack)</span></span>&#123;<br>        <span class="hljs-keyword">double</span> max = stack.pop().doubleValue();<br>        <span class="hljs-keyword">while</span> (! stack.isEmpty())&#123;<br>            <span class="hljs-keyword">double</span> value = stack.pop().doubleValue();<br>            <span class="hljs-keyword">if</span>(value &gt; max)<br>                max = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>double max(GenericStack&lt;? extends Number&gt; stack)</strong></p><p><strong>extends表示了类型参数的范围关系。</strong> </p><p><strong>GenericStack&lt;? extends Number&gt;才是GenericStack<Integer>的父类，</Integer></strong>GenericStack<Number>不是GenericStack<Integer> <strong>的父类</strong></Integer></Number></p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        GenericStack&lt;Integer&gt; intStack = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>        intStack.push(<span class="hljs-number">1</span>);intStack.push(<span class="hljs-number">2</span>);intStack.push(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;Th max value is &quot;</span> + max(intStack));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>如上代码就不报错了</p></blockquote><p>三种形式：</p><ul><li>？ , 非受限通配，等价于 ? extends Object，注意<ul><li>GenericStack&lt;?&gt;不是原始类型， GenericStack是原始类型</li></ul></li><li>？ extends T, 受限通配,表示T或者T的子类，上界通配符，T定义了类型上限</li><li>? super T，下限通配，表示T或者T的父类型，下界通配符，T定义了类型下限</li></ul><h3 id="数组有协变性"><a href="#数组有协变性" class="headerlink" title="数组有协变性"></a>数组有协变性</h3><ul><li>数组的协变性是指，如果类A是类B的父类，那么A[]就是B[]的父类</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jonathan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Apple</span></span>&#123;&#125; <span class="hljs-comment">//一种苹果</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orange</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span></span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//由于数组的协变性，可以把Apple[]类型的引用赋值给Friut[]类型的引用</span><br>Fruit[] fruits = <span class="hljs-keyword">new</span> Apple[<span class="hljs-number">10</span>]; <br>fruits[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Apple();  <br>fruits[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Jonathan(); <span class="hljs-comment">// Jonathan是Apple的子类</span><br></code></pre></div></td></tr></table></figure><p>​                以上都正确，但是下面语句fruits的<strong>声明类型是Fruit</strong>因此编译通过，但<strong>运行时将Fruit转型为Apple错误</strong><br>​                数组是在<strong>运行时才去判断数组元素的类型约束</strong>；<br>​                而泛型正好相反，在<strong>运行时，泛型的类型信息是会被擦除的</strong>，编译的时候去检查类型约束</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">try</span>&#123;<br>    fruits[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Fruit();<span class="hljs-comment">//运行时抛出异常 java.lang.ArrayStoreException，这是数组协变性导致的问题</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    System.out.println(e);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="泛型容器（任何泛型类）没有协变性"><a href="#泛型容器（任何泛型类）没有协变性" class="headerlink" title="泛型容器（任何泛型类）没有协变性"></a>泛型容器（任何泛型类）没有协变性</h3><ul><li><p>为了解决数组协变性导致的问题，Java编译器规定泛型容器（任何泛型类）没有协变性</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;(); <span class="hljs-comment">//编译错误</span><br><span class="hljs-comment">//Type mismatch: cannot convert from ArrayList&lt;Apple&gt; to ArrayList&lt;Fruit&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>因为我们在谈论容器的类型，而不是容器持有对象的类型</p></li><li><p>A是B父类型，但泛型类（比如容器）ArrayList<A>不是ArrayList<B>的父类型，因此上面的语句报错</B></A></p></li><li><p>为什么数组有协变性而泛型没有协变性</p><ul><li>数组具有协变性，因此在运行时才会判断元素的类型约束，这将导致有时发生<strong>运行时错误</strong>，抛出异常java.lang.ArrayStoreException。这个功能在Java中是一个公认的“瑕疵”</li><li>泛型没有协变性：<strong>泛型设计者认为与其在运行失败，不如在编译时就失败（禁止泛型的协变性就是为了杜绝数组协变性带来的问题，即如果泛型有协变性，面临可协变的数组一样的问题）</strong>——静态类型语言（Java，C++）的全部意义再与代码运行前找出错误，Python，JavaScript之类的语言是动态类型语言（不安全）。</li><li>但有时希望像数组一样，一个父类型容器引用变量指向子类型同期，这时要使用通配符</li></ul></li></ul><h3 id="上界通配泛型-extends"><a href="#上界通配泛型-extends" class="headerlink" title="上界通配泛型? extends"></a>上界通配泛型? extends</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? extends Fruit&gt; list = <span class="hljs-keyword">new</span>  ArrayList&lt;Apple&gt;(); <span class="hljs-comment">//左边类型是右边类型的父类型</span><br></code></pre></div></td></tr></table></figure><blockquote><p>上面语句编译通过，但是这样的list不能加入任何东西，下面语句都会编译出错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">list.add(<span class="hljs-keyword">new</span> Apple()); list.add(<span class="hljs-keyword">new</span> Fruit()); <span class="hljs-comment">//编译都报错</span><br><span class="hljs-comment">//可加入null</span><br>list.add(<span class="hljs-keyword">null</span>);<br><br><span class="hljs-comment">//但是从这个list取对象没有问题，编译时都解释成Fruit，运行时可以是具体的类型如Apple（有多态性）</span><br>Fruit f = list.get(<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure><ul><li>因为ArrayList&lt;? entends Fruit&gt;意味着该list集合中存放的都是Fruit的子类型（包括Fruit自身），Fruit的子类型可能有很多，但list只能<strong>存放其中的某一种类型</strong>，编译器<strong>只能知道元素类型的上限是Fruit，而无法知道list引用会指向什么具体的ArrayList</strong>，可以是ArrayList<Apple>,也可能是ArrayList<Jonathan>,<strong>为了安全，Java泛型只能将其设计成不能添加元素</strong>。</Jonathan></Apple></li><li>虽然不能添加元素，但从里面获取元素的类型都是Fruit类型（编译时）</li><li>因此带&lt;! extends&gt;类型通配符的泛型类<strong>不能往里存内容（不能set），只能读取（只能get）</strong></li><li>那这样的声明的容器类型有什么意义？它的意义是作为一个<strong>只读（只从里面取对象）的容器</strong></li></ul><blockquote><p>假设已经实例化好了另外一个容器，对象已经放入其中，这时用ArrayList&lt;? extends Fruit&gt; list <strong>指向这个另外的容器，那么我们可以通过list取出容器的所有对象而没有任何问题</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;();<br><span class="hljs-comment">//调用apples.add方法添加很多Apple及其子类对象</span><br><br>ArrayList&lt;? extends Fruit&gt; list = apples; <span class="hljs-comment">//现在ArrayList&lt;? extends Fruit&gt; 类型的引用指向apples</span><br><span class="hljs-keyword">for</span>（<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++）&#123;<br>    Fruit f = list.get(i)；  <span class="hljs-comment">//运行时从容器里取出的都是Apple及其子类对象，赋值给Fruit引用没问题</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>这个例子还是比较极端（纯粹是语法功能演示），实际更有意义的是作为方法参数：该方法接受一个放好对象的容器，然后在方法里只是逐个取出元素进行处理</strong></p></blockquote><p>运用上限通配泛型</p><ul><li><p>程序的其他地方，创建具体类型的容器，添加对象，ArrayList作为实参调用handle方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;Apple&gt; appleList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">//等价于new ArrayList&lt;Apple&gt;(); </span><br>appleList.add(<span class="hljs-keyword">new</span> Apple());<span class="hljs-comment">//ArrayList&lt;Apple&gt;是具体类型，编译器很清楚地知道类型参数是Apple这时可以add</span><br><span class="hljs-comment">//由于形参类型ArrayList&lt;? extends Fruit&gt;是实参类型ArrayList&lt;Apple&gt;的父类型，因此实参可以传给形参</span><br>handle(appleList); <br></code></pre></div></td></tr></table></figure></li><li><p>handle方法，参数类型设置为ArrayList&lt;? extends Fruit&gt; </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(ArrayList&lt;? extends Fruit&gt; list)</span></span>&#123; <span class="hljs-comment">//注意方法里只能从list get元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++)&#123;<br>Fruit o = list.get(i); <span class="hljs-comment">//可以确定list里面对象一定是Fruit或子类类型</span><br>        <span class="hljs-comment">//处理对象o，注意这时调用o的实例方法时具有多态性</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如上我们可以看到上限通配泛型可以作为只读。</p></li></ul><h3 id="下限通配泛型-super"><a href="#下限通配泛型-super" class="headerlink" title="下限通配泛型? super"></a>下限通配泛型? super</h3><ul><li><p>采用下界通配符 <strong>？****super T</strong> 的泛型类引用，可以指向所有以T及其父类型为类型参数的实例类型</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Fruit&gt;(); <span class="hljs-comment">//这时new后边的Fruit可以省略</span><br>ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;(); <span class="hljs-comment">//允许，Object是Fruit父类</span><br>ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;(); <span class="hljs-comment">//但是不能指向Fruit子类的容器</span><br></code></pre></div></td></tr></table></figure></li><li><p>可以向List里面添加T及T的子类对象</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">list.add(<span class="hljs-keyword">new</span> Fruit()); <span class="hljs-comment">//OK</span><br>list.add(<span class="hljs-keyword">new</span> Apple()); <span class="hljs-comment">//OK</span><br>list.add(<span class="hljs-keyword">new</span> Jonathan()); <span class="hljs-comment">//OK</span><br>list.add(<span class="hljs-keyword">new</span> Orange())；<span class="hljs-comment">//OK</span><br><span class="hljs-comment">//list.add(new Object()); //添加Fruit父类则编译器禁止，报错</span><br></code></pre></div></td></tr></table></figure></li><li><p>但从list里get数据只能被编译器解释称Object</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o1 = list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//OK</span><br>Fruit o2 = list.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">//报错，Object不能赋给Fruit，需要强制类型转换，</span><br></code></pre></div></td></tr></table></figure></li><li><p>因此这种泛型类和采用？extends的泛型类正好相反：<strong>只能存数据</strong>，获取数据<strong>至少部分失效</strong>（编译器解释成Object）</p></li></ul><h3 id="extend和-super的理解"><a href="#extend和-super的理解" class="headerlink" title="? extend和? super的理解"></a>? extend和? super的理解</h3><blockquote><p>现在看看通配泛型 ？ extends，注意右边的new ArrayList的类型参数必须是Fruit的子类型</p><p>//? extends Fruit指定了类型上限，因此下面的都成立：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? extends Fruit&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Fruit&gt;(); <span class="hljs-comment">//=号右边，如果是Fruit，可以不写，等价于new ArrayList&lt;&gt;();</span><br>ArrayList&lt;? extends Fruit&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;();  <span class="hljs-comment">//=号右边，如果是Fruit的子类，则必须写</span><br>ArrayList&lt;? extends Fruit&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Jonathan&gt;(); <span class="hljs-comment">//=号右边，如果是Fruit的子类，则必须写</span><br>ArrayList&lt;? extends Fruit&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Orange&gt;();  <span class="hljs-comment">//=号右边，如果是Fruit的子类，则必须写</span><br></code></pre></div></td></tr></table></figure><ul><li><p>ArrayList&lt;? extends Fruit&gt; list可指向</p><ol><li>ArrayList<Fruit></Fruit></li><li>ArrayList<Apple></Apple></li><li>ArrayList<Jonathan></Jonathan></li><li>ArrayList<Orange>…</Orange></li></ol></li><li><p>一个ArrayList<Fruit>容器可以加入Fruit、Apple、Jonathan、Orange，</Fruit></p></li><li><p>一个ArrayList<Apple>容器可以加入Apple、Jonathan，</Apple></p></li><li><p>一个ArrayList<Orange>容器可以加入Orange，</Orange></p></li></ul><blockquote><p>假如当ArrayList&lt;? extends Fruit&gt; list为<strong>方法形参</strong>时，如果方法内部调list.add，</p><p>由于编译时，编译器无法知道ArrayList&lt;? extends Fruit&gt;类型的引用变量会<strong>指向哪一个具体容器类型</strong>，编译器<strong>无法知道该怎么处理add</strong>。</p></blockquote><blockquote><p>例如当add的对象类型是Orange，如果list指向ArrayList<Apple>，加不进去。但如果list指向为ArrayList<Orange>，就可以加进去。</Orange></Apple></p></blockquote><blockquote><p><strong>为了安全，编译器干脆禁止ArrayList&lt;? extends Fruit&gt;类型的list添加元素。</strong></p></blockquote><blockquote><p><strong>但从list里get元素，都解释成Fruit类型</strong></p></blockquote><hr><blockquote><p>? super Fruit指定了类型下限，因此下面二行都成立</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Fruit&gt;(); <span class="hljs-comment">//=号右边，这时Fruit可以省略，等价于new ArrayList&lt;&gt;();</span><br>ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;(); <span class="hljs-comment">//允许。=号右边，如果是Fruit的父类，必须写出类型</span><br><span class="hljs-comment">//ArrayList&lt;? super Fruit&gt; list3 = new ArrayList&lt;Apple&gt;(); //但是不能指向Fruit子类的容器</span><br></code></pre></div></td></tr></table></figure><blockquote><p>因此ArrayList&lt;? super Fruit&gt; list引用可以指向ArrayList<Fruit>以及Fruit父类型的容器如ArrayList<Object>。</Object></Fruit></p></blockquote><ul><li>当ArrayList&lt;? super Fruit&gt; list为方法形参时,<strong>编译器知道list指向的具体容器的类型参数至少是Fruit</strong>。当向list里add对象o时，分析几种可能的情况：<ol><li>o是Fruit及其子类类型，这里面又分二种情况<ol><li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Fruit>，可以加入</Fruit></li><li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Object>,可以加入</Object></li></ol></li><li> o是Fruit的父类型如Object，这里面又分二种情况</li><li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Fruit>，这时编译器不允许加入，Object不能转型为Fruit</Fruit></li><li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Object>，可以加入</Object></li></ol></li></ul><blockquote><p>综合以上四种情况，可以看到，只要对象o的类型是Fruit及其子类型，这时将对象o加入list一定是安全的（1.1, 1.2）；</p><p>如果对象是Fruit父类型，则不允许加入最安全（因为可能出现2.1的情况)。由于? super Fruit规定了list元素类型的下限，因此取元素时编译器只能全部解释成Object</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">list1.add(<span class="hljs-keyword">new</span> Fruit()); <br>list1.add(<span class="hljs-keyword">new</span> Apple()); <br>list1.add(<span class="hljs-keyword">new</span> Jonathan());<span class="hljs-comment">//只要加入Fruit及其子类对象都OK</span><br><span class="hljs-comment">//list1.add(new Object()); //添加Fruit父类则编译器禁止，报错</span><br></code></pre></div></td></tr></table></figure><blockquote><p>取对象时都必须解释成Object类型。因此我们说带&lt;? super&gt;通配符的泛型类的get方法至少是部分失效</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o1 = list.get(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//Fruit o2 = list.get(0);  //报错，Object不能赋给Fruit，需要强制类型转换，但是引入泛型就是想去掉强制类型转换</span><br></code></pre></div></td></tr></table></figure><h4 id="extends和-super的使用原则"><a href="#extends和-super的使用原则" class="headerlink" title="? extends和? super的使用原则"></a>? extends和? super的使用原则</h4><p>Producer Extends，Consumer Super原则（PECS）</p><blockquote><p>Producer Extends: 如果需要一个只读泛型类，用来Produce T，那么用? extends T</p><p>Consumer Super： 如果需要一个只写泛型类，用来Consume T，那么用? super T</p><p>如果需要同时读取和写入，那么久不能用通配符</p></blockquote><p>例如我们读JDK的Collections类的copy方法，可以看到一个经典使用PECS原则的例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collections</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br><span class="hljs-comment">//其中重要的代码片段为</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;srcSize; i++)<br>                dest.set(i, src.get(i)); <span class="hljs-comment">//dest:写，src：读</span><br>        &#125; <br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>看如下代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperWildCarDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        GenericStack&lt;String&gt; strStack= <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>  GenericStack&lt;Object&gt; objStack = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>  objStack.push(“Java<span class="hljs-string">&quot;);</span><br><span class="hljs-string">  objStack.push(2); //装箱</span><br><span class="hljs-string">  strStack.push(“Sun&quot;</span>);<br>  add(strStack , objStack);<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>方法1</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(GenericStack&lt;T&gt; stack1,</span></span><br><span class="hljs-function"><span class="hljs-params">GenericStack&lt;? <span class="hljs-keyword">super</span> T&gt; stack2)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!stack1.isEmpty())<br>stack2.push(stack1.pop()); <span class="hljs-comment">//只写</span><br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>编译时，编译器根据实参strStack的类型参数String确定类型形参T为String。GenericStack&lt;? super T&gt;stack2表示元素类型是String父类的堆栈，因此实参objStack的类型GenericStack<Object>与形参stack2的类型匹配，参数传递也没问题。<strong>注意stack2只写。</strong></Object></p></blockquote><p>方法2</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(GenericStack&lt;？extends T&gt; stack1,GenericStack&lt;T&gt; stack2)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!stack1.isEmpty())<br>stack2.push(stack1.pop());<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>add方法参数类型改为（GenericStack&lt;？extends T&gt; stack1,GenericStack<T> stack2）也没问题，这时根据第二个实参类型推断出T为Object，而第一个实参类型GenericStack<String>是GenericStack&lt;? Extends Object&gt;的子类型，因此参数传递也没问题。<strong>注意stack1只读。</strong></String></T></p></blockquote><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416203513322.png" alt="image-20210416203513322"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416203550072.png" alt="image-20210416203550072"></p><h2 id="泛型擦除和对泛型的限制"><a href="#泛型擦除和对泛型的限制" class="headerlink" title="泛型擦除和对泛型的限制"></a>泛型擦除和对泛型的限制</h2><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><ul><li>泛型是用类型擦除（type erasure）方法实现的。泛型的作用就是使得编译器在编译时通过类型参数来检测代码的类型匹配性。<strong>当编译通过，意味着代码里的类型都是匹配的。因此，所有的类型参数使命完成而全部被擦除</strong>。因此，泛型信息(类型参数)在运行时是不可用的，这种方法使得泛型代码<strong>向后兼容使用原始代码的遗留代码</strong>。</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416203725935.png" alt="image-20210416203725935"></p><ul><li><strong>泛型存在于编译时</strong>，当编译器认为泛型类型是安全的，就会将其转化为原始类型。<strong>这时(a)所示的源代码编译后变成(b)所示的代码</strong>。注意在(b)里，由于list.get(0)返回的对象运行时类型一定是String，因此<strong>强制类型转换一定是安全的。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeErasureTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        ArrayList&lt;String&gt; strList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Fruit&gt; fruitList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <br>        Class clz1 = strList.getClass(); <span class="hljs-comment">//getClass返回运行时信息</span><br>        Class clz2 = fruitList.getClass();<br>        <br>        System.out.println(clz1.getSimpleName());   <span class="hljs-comment">//ArrayList</span><br>        System.out.println(clz2.getSimpleName());   <span class="hljs-comment">//ArrayList</span><br>        System.out.println(clz1 == clz2);           <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>**所有参数化类型（实例类型）ArrayList<String> **、ArrayList<Fruit>在运行时共享同一个类型：ArrayList。</Fruit></String></p></blockquote><ul><li>当编译泛型类，接口和方法时，会用Object代替非首先类型参数E,<E extends object></E></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416204338780.png" alt="image-20210416204338780"></p><ul><li>如果一个泛型的参数类型是受限的，编译器会用该受限类型来替换它</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416204444415.png" alt="image-20210416204444415"></p><hr><ul><li><p>泛型类会擦除类型参数，所有泛型的实例类型共享擦除后形成的原始类型如ArrayList</p><ul><li><p>泛型类所有实例类型在运行时共享原始类型，如：</p><p>ArrayList<String> list1 = new ArrayList&lt;&gt;( );</String></p><p>ArrayList<Integer> list2= new ArrayList&lt;&gt;( );</Integer></p><p>在运行时只有一个擦除参数类型后的原始ArrayList类被加载到JVM中</p></li><li><p>所以， list1 instanceOf ArrayList<String>是错误的，可用：</String></p><p>list1 instanceOf ArrayList</p><p>list2 instanceOf ArrayList</p><p>instanceOf是根据运行时类型进行检查</p></li></ul></li></ul><h3 id="使用泛型类型的限制"><a href="#使用泛型类型的限制" class="headerlink" title="使用泛型类型的限制"></a>使用泛型类型的限制</h3><ul><li><p>不能使用new E( ); //只能想办法得到E的类型<strong>实参</strong>的Class信息，再newInstance(…)</p><p>不能用泛型的类型参数创建实例，如： E object = new E( ); //错误，泛型类型参数在运行时不可用</p></li><li><p>不能使用new E[ ]</p><p>不能用泛型的类型参数创建数组，如： E[ ] element = new E[cpacity]; //错误</p><ul><li><strong>new是运行是发生的，因此new 后面一定不能出现类型形参E，运行时类型参数早没了</strong></li></ul></li><li><p>强制类型转换可以用类型形参E，通过类型转换实现无法确保运行时类型转换是否成功</p><ul><li>E[ ] element = (E[ ])new Object[cpacity];  //编译可通过(所谓编译通过就是指编译时uncheck，至于运行时是否出错，那是程序员自己的责任</li></ul></li></ul><p>实例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericOneDimensionArray</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <br>    <span class="hljs-keyword">private</span> T[] elements = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//T[]类型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericOneDimensionArray</span><span class="hljs-params">(Class&lt;? extends T&gt; clz,<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>        elements = (T[])Array.newInstance(clz,size);<br>    &#125;<br>    <span class="hljs-comment">//get, put等其他方法省略</span><br><br>    <span class="hljs-keyword">public</span> T[] getElements()&#123; <span class="hljs-keyword">return</span> elements; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        GenericOneDimensionArray&lt;String&gt; stringArray = <br>                <span class="hljs-keyword">new</span> GenericOneDimensionArray(String.class,<span class="hljs-number">10</span>);<br>        String[] a = stringArray.getElements();  <span class="hljs-comment">//这里不会抛出运行时异常了</span><br><span class="hljs-comment">//        a[0] = new Fruit(); //不是String类型的对象，编译报错</span><br>        a[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意如下的构造函数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> T[] elements = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//T[]类型</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericOneDimensionArray</span><span class="hljs-params">(Class&lt;? extends T&gt; clz,<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>    elements = (T[])Array.newInstance(clz,size);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>这里第一个参数是Class&lt;? extends T&gt; clz，表示一个T类型及其子类的Class对象。通过Class对象，可以通过反射创建运行时类型为T[]的数组。</p></blockquote><blockquote><p>但是Array.newInstance方法返回的是Object，因此需要强制类型转换。但这里的强制类型转换是安全的，因为创建的数组的运行时类型就是T[]</p></blockquote><blockquote><p>Array.newInstance(数组元素类型的Class对象, size)</p><p>通过反射机制创建运行时类型为T[]的数组</p></blockquote><p>这个泛型数组实现的版本比前一个要好多了，但构造函数要多传一个<em><strong>Class</strong></em>对象，指明数组元素类型信息。举这个例子还想说明反射机制的重要性。</p><hr><ul><li><p>使用泛型类型的限制：不能new泛型数组（数组元素是泛型），但可以声明</p><ul><li><p>不能使用new A<E>[ ]的数组形式，因为E已经被擦除</E></p><p>ArrayList<String>[ ] list = new ArrayList<String>[10]；//错误</String></String></p></li></ul></li><li><p>E已经被擦除，只能用泛型的原始类型初始化数组, 必须改为new ArrayList[10]</p><p>ArrayList<String> [ ] list = new ArrayList[10]；</String></p><ul><li><p>为什么这里不需要强制类型转换：参数化类型与原始类型的兼容性</p></li><li><p>参数化类型对象可以被赋值为原始类型的对象，原始类型对象也可以被赋值为参数化类型对象</p><p> ArrayList a1 = new ArrayList(); //原始类型</p><p> ArrayList<String> a2 = a1; //参数化类型</String></p></li></ul></li></ul><hr><ul><li><strong>静态上下文</strong>中不允许使用泛型的类型参数。由于泛型类的所有实例类型都共享相同的运行时类，所以<strong>泛型类的静态变量和方法都被它的所有实例类型所共享</strong>。因此，在静态方法、数据域或者初始化语句中，使用泛型的参数类型是非法的。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(E o1)</span></span>&#123;<span class="hljs-comment">//Illegal</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> E o1; <span class="hljs-comment">//Illegal</span><br>    <br>    <span class="hljs-keyword">static</span>&#123;<br>        E o2;<span class="hljs-comment">//Illegal</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>Test<String>和Test<Integer>这二个实例类型共享同一个运行时类型，如果静态上下文可以使用类型参数E, 会导致矛盾：</Integer></String></p><p>m方法的形参类型到底是String还是Integer？</p></blockquote><hr><ul><li><p>异常类不能是泛型的。泛型类不能继承java.lang.Throwable。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>非法，因为如果允许这么做，则应为MyException添加一个catch语句</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">try</span>&#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">catch</span>(MyException&lt;T&gt; ex)&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>JVM必须检查这个从try语句中抛出的异常以确定与catch语句中的异常类型匹配，但这不可能，因为运行时的类型信息是不可获得的。</p></li></ul><h2 id="实现带泛型参数的对象工厂（一种设计模式）"><a href="#实现带泛型参数的对象工厂（一种设计模式）" class="headerlink" title="实现带泛型参数的对象工厂（一种设计模式）"></a>实现带泛型参数的对象工厂（一种设计模式）</h2><ul><li><p>使用泛型类型的限制</p><ul><li>不能使用new E();//只能用newInstance(…)</li></ul></li><li><p>如何利用反射机制，通过newInstance()来创建对象？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectFactory</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-keyword">private</span> Class&lt;T&gt; type;  <span class="hljs-comment">//定义私有数据成员，保存要创建的对象的类型信息</span><br>    <br><span class="hljs-comment">//构造函数传入要创建的对象的类型信息</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObjectFactory</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.type = type;<br>&#125;<br><span class="hljs-comment">//对象工厂的create方法负责产生一个T类型的对象，利用newInstance</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>T o = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>o= type.newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;<br>e.printStackTrace();<br>&#125;<br>        <span class="hljs-comment">//这里顺便说明和强调一下，一个类定义缺省构造函数（不带参数）多么重要</span><br><span class="hljs-keyword">return</span> o;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如下为一个实例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//首先创建一个负责生产Car的对象工厂，传进去需要创建对象的类的Class信息</span><br>ObjectFactory&lt;Car&gt; carFactory = <span class="hljs-keyword">new</span> ObjectFactory&lt;Car&gt;(Car.class);<br>Car o = carFactory.create();  <span class="hljs-comment">//由对象工厂负责产生car对象</span><br>System.out.println(carFactory.create().toString());<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br><span class="hljs-keyword">private</span> String s = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">()</span> </span>&#123;<br>s = <span class="hljs-string">&quot;Car&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>  以Car.class为参数去构造一个ObjectFactory<Car>类型的对象工厂，再调用对象工厂的create方法，一定会返回Car对象。</Car></p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java自学——List</title>
    <link href="/2021/04/12/Java_ArrayList/"/>
    <url>/2021/04/12/Java_ArrayList/</url>
    
    <content type="html"><![CDATA[<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 接口实现了 Collection 接口。</p><p>它主要有两个实现类：ArrayList 类和 LinkedList 类。</p><p>在 List 集合中允许出现重复元素。与 Set 集合不同的是，在 List 集合中的元素是有序的，可以根据索引位置来检索 List 集合中的元素，第一个添加到 List 集合中的元素的索引为 0，第二个为 1，依此类推。</p><p> List<String> person=new ArrayList&lt;&gt;();</String></p><span id="more"></span><h3 id="List中添加获取删除元素"><a href="#List中添加获取删除元素" class="headerlink" title="List中添加获取删除元素"></a>List中添加获取删除元素</h3><p>添加方法是：.add(e)；　　</p><p>获取方法是：.get(index)；　　</p><p>删除方法是： </p><p> .remove(index)； 按照索引删除；</p><p>.remove(Object o)； 按照元素内容删除；</p><h3 id="是否包含某个元素"><a href="#是否包含某个元素" class="headerlink" title="是否包含某个元素"></a>是否包含某个元素</h3><p>方法：.contains（Object o）； 返回true或者false</p><h3 id="根据索引将元素数值改变（替换）"><a href="#根据索引将元素数值改变（替换）" class="headerlink" title="根据索引将元素数值改变（替换）"></a>根据索引将元素数值改变（替换）</h3><p>.set(index, element)</p><h3 id="查看（判断）元素的索引"><a href="#查看（判断）元素的索引" class="headerlink" title="查看（判断）元素的索引"></a>查看（判断）元素的索引</h3><p>.indexOf（）； 和 lastIndexOf（）</p><h3 id="利用list中索引位置重新生成一个新的list-截取集合"><a href="#利用list中索引位置重新生成一个新的list-截取集合" class="headerlink" title="利用list中索引位置重新生成一个新的list(截取集合)"></a>利用list中索引位置重新生成一个新的list(截取集合)</h3><p>方法： .subList(fromIndex, toIndex)；　　</p><h3 id="获取list长度（元素个数）"><a href="#获取list长度（元素个数）" class="headerlink" title="获取list长度（元素个数）"></a>获取list长度（元素个数）</h3><p>.size() ； </p><h3 id="对比两个list中的所有元素"><a href="#对比两个list中的所有元素" class="headerlink" title="对比两个list中的所有元素"></a>对比两个list中的所有元素</h3><p>.equals()  .hashcode()</p><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><p>.isEmpty()</p><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><p>.toString()</p><h3 id="转换为数组"><a href="#转换为数组" class="headerlink" title="转换为数组"></a>转换为数组</h3><p>.toArray()</p><h3 id="数组转化为List"><a href="#数组转化为List" class="headerlink" title="数组转化为List"></a>数组转化为List</h3><p>.asList(array)</p><h2 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h2><p><strong>ArrayList 类提供了快速的基于索引的成员访问方式</strong>，对尾部成员的增加和删除支持较好。使用 ArrayList 创建的集合，允许对集合中的元素进行快速的随机访问，不过，向 ArrayList 中插入与删除元素的速度相对较慢。</p><h2 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h2><p>LinkedList 类采用<strong>链表结构</strong>保存对象，这种结构的优点是便于向集合中插入或者删除元素。需要频繁向集合中插入和删除元素时，使用 LinkedList 类比 ArrayList 类效果高，但是 LinkedList 类随机访问元素的速度则相对较慢。</p><p>除了List中的方法，还包括链表特有，</p><p>addFirst(E e)   addLast(E e)   getFirst()   getLast()   removeFirst()   removeLast()</p><p>直接打印List，是[a,b,c]</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git的一些常用操作</title>
    <link href="/2021/04/09/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/04/09/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>对于每一个计算机小白来讲，学习新事物总是不简单的，但是计算机专业的学生总是要强迫自己不断学习的。</p><p>我也总少了一份学习新知识的勇气，但是走出第一步就好了，不管是学习一门语言还是学习一种工具</p><p>学会git操作应该是程序员必备的，但是对于小白可能有点难入门（拖了一年多才开始学习使用git），感谢stormzhang的learn github from zero这本书，让我简单入门了git。</p><p>整理以下有关git操作的代码，只是浅尝辄止，整理如何用git的一些操作和如何和github联动</p><hr><h1 id="git仓库的创建"><a href="#git仓库的创建" class="headerlink" title="git仓库的创建"></a>git仓库的创建</h1><p>当你建立一个github仓库，想要在这个仓库中上传文件，可以先在本地创建一个git仓库，之后再push到github仓库，这样你在github建立的仓库里就有本地仓库的内容了。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p><strong>git init 初始化仓库</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181537402.png" alt="image-20210409181537402" style="zoom:33%;"><p>会提示你已初始化一个空仓库</p></li></ul><span id="more"></span><ul><li><p><strong>git status 查看当前目录的状态</strong></p><p>若当前目录未初始化</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181608273.png" alt="image-20210409181608273" style="zoom:33%;"><p>表示当前目录还不是一个仓库</p><p>若已初始化</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181629821.png" alt="image-20210409181629821" style="zoom:33%;"><p>默认在master分支，untracked files表示文件没有被追踪，还没有提交在git仓库</p></li><li><p><strong>git add将文件放入缓存中待提交</strong></p><p><strong>也可以用git rm –cached &lt;文件名&gt; 将其从缓存中移除</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181651251.png" alt="image-20210409181651251" style="zoom:33%;"><p>add后文件就处于待commit状态，处在缓存中</p><p>不过我一般情况下喜欢使用 git add .  空格加点，表示add所有待add的文件。</p></li><li><p><strong>git commit -m’first commit’  提交</strong>，其中-m表示附带信息，’’内包括此次提交的注释，github的文件后会附带这个提示，可以用来记录第几次提交</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png" alt="未命名图片" style="zoom:33%;"></li><li><p>如果想<strong>查看commit的记录</strong>，可以输入</p><p><strong>git log</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181721340.png" alt="image-20210409181721340" style="zoom:33%;"></li></ul><hr><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>git init初始化git仓库之后会默认生成一个主分支master，默认分支，也基本是实际开发正式环境下的分支，一般情况下master分支不会轻易直接在上面操作</p><ul><li><p><strong>git branch 查看分支情况</strong>，默认就一个分支</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181751811.png" alt="image-20210409181751811" style="zoom:33%;"><p>这样就查看了分支的情况，上图只有一个分支master，且在此分支</p></li><li><p><strong>git branch xxx 新建分支</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181804691.png" alt="image-20210409181804691" style="zoom:33%;"><p>git branch other，就是新建一个other分支，新建的分支和master分支是一样的内容</p><ul><li><p><strong>git branch -d xxx</strong></p><p><strong>删除分支xxx</strong></p></li><li><p><strong>git branch -D xxx</strong></p><p><strong>xxx分支中还有未合并的代码，强制删除</strong></p></li></ul></li><li><p><strong>git checkout xxx</strong> 切换分支，xxx为另一分支的名字</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181832481.png" alt="image-20210409181832481"></p><p>切换后就可以在新建的分支上任意代码改动</p><p> <strong>git checkout -b xxx</strong></p><p><strong>新建一个xxx分支并自动切换到xxx分支</strong></p></li><li><p>分支的作用是这样：在xxx分支完成代码，测试完成，准备上线，这时候将代码合并到主分支master中，然后发布，避免了直接在主分支上操作</p><ol><li><p>切换到master分支 git checkout master</p></li><li><p>合并xxx的代码 git merge xxx</p></li></ol></li><li><p><strong>合并xxx分支的代 码 git merge xxx</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181845551.png" alt="image-20210409181845551" style="zoom:33%;"></li><li><p><strong>git tag v1.0</strong> </p><p>表示在当前代码状态下<strong>新建了一个v1.0的标签</strong></p><p><strong>git tag</strong></p><p><strong>查看历史tag记录</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181905098.png" alt="image-20210409181905098" style="zoom:33%;"></li><li><p><strong>git checkout XXXtag</strong></p><p><strong>切换到xxxtag的代码状态</strong></p></li></ul><h2 id="Github的重要操作"><a href="#Github的重要操作" class="headerlink" title="Github的重要操作"></a>Github的重要操作</h2><p>流程大概如下</p><p>如果你想从github上下载别人写好的一个项目，或者想修改你已经有的仓库里的内容，可以通过clone实现(别再下载zip了！)</p><ul><li><p><strong>git clone 项目地址</strong></p><p>将项目clone到了本地，由于项目本身就为git仓库，就不需要git init再进行初始化了，此时得到的项目文件夹就是个仓库</p><p>远程仓库也默认关联好了，就是你clone的github仓库。在本地目录下任意修改，commit后，就可以上传。</p><p>项目地址相关的内容不赘述，主要有这两种</p><hr><ol><li><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409165138302.png" alt="image-20210409165138302" style="zoom:33%;"></li></ol><p>HTTPS，项目地址就是上图的<a href="https://github.com/Trent-Liu/ML_demo.git%EF%BC%8C%E5%8F%AF%E4%BB%A5git">https://github.com/Trent-Liu/ML_demo.git，可以git</a> clone 地址，但是用HTTPS需要你输入你的账号密码</p><ol start="2"><li><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409165242378.png" alt="image-20210409165242378" style="zoom:33%;"></li></ol><p>SSH，非常好用，需要你自己添加SSH key，具体添加方法不予说明了，这样的好处是 git clone 地址，不需要你再输入账号密码了</p><hr><p>之后你对clone下来的仓库进行了内容的改动，想要将改动提交到github上的远程仓库上</p></li><li><p><strong>git push origin master</strong></p><p>将修改后的代码push到远程仓库的master分支（github现在的默认为main分支）</p></li></ul><p>如果你想把本地的某个test2项目变成git的仓库，不要一个文件一个文件的上传了</p><ol><li><p><strong>在github上建立一个空仓库，比如test</strong></p></li><li><p><strong>cd到本地当前目录test2</strong></p><p><strong>git remote add origin &lt;远程仓库地址&gt;</strong></p><p>为test2添加一个远程仓库，origin为给这个项目的远程仓库起的名字，这个名字可以任意取，只有一个时一般默认为origin。远程仓库的地址就是上面说的HTTPS或者SSH</p></li><li><p><strong>git push origin master</strong>  </p><p>就将test2push到github上的test仓库中了。</p></li></ol><p>还有几个可能需要的代码</p><ul><li><p><strong>git remote -v</strong></p><p>查看当前目录有哪些远程仓库</p></li><li><p><strong>git remote rm origin</strong></p><p>删除已存在的远程仓库origin，是当你想换一个远程仓库的时候。</p></li></ul><p>由于github是个协同开发的环境，当别人修改了你的github仓库内容，push后，你如果想把别人修改的内容覆盖你的仓库（该仓库的远程仓库已经设置成你要拉取的了）</p><p><strong>git pull origin master</strong></p><p>把远程最新的代码更新到本地。一般我们再push之前都会先pull，这样不容易冲突</p><hr><h2 id="配置及技巧"><a href="#配置及技巧" class="headerlink" title="配置及技巧"></a>配置及技巧</h2><ol><li><p>每一次commit都会产生一条log，log标记了提交人的姓名与邮箱，以便其他人方便查看与联系提交人</p><p>设置用户名与邮箱</p><p><strong>git config –global user.name “XXX”</strong></p><p><strong>git config –global user.email “XXX@XX”</strong></p><p>为全局配置，若某个项目要用特定邮箱，就在该项目下，把global去除重新设置</p></li><li><p>你是否感觉git的代码挺长，如checkout之类的</p><p><strong>替换操作</strong></p><p><strong>alias</strong></p><p><strong>git config –global alias.co checkout</strong></p><p>此时checkout的别名就为co， 可以直接git co，等价于之前的git checkout</p><p>想定义成什么你可以随心所欲，甚至还可以设置组合</p><p>git config –global alias.psm ‘push origin master’</p><p>此时输入psm，就等价于输入push origin master</p><p>你可以尝试输入这样</p><p>git config –global alias.lg “log –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –date=relative”</p><p>这样设置了你的git log查看日志的颜色</p></li><li><p><strong>查看自己的配置</strong></p><p><strong>git config -l</strong></p></li><li><p>修改git用的编辑器</p><p><strong>git config –global core.editor “vim” #设置Editor使用vim</strong></p></li><li><p>给git终端增加颜色</p><p><strong>git config –global color.ui true</strong></p></li><li><p><strong>git config –global core.quotepath false #设置中文文件名</strong></p></li></ol><p>git config都是修改~/.gitconfig文件的内容。</p><h2 id="diff操作-比较不同"><a href="#diff操作-比较不同" class="headerlink" title="diff操作 比较不同"></a>diff操作 比较不同</h2><p>diff很常用，比如下面这个场景</p><p>我们经常改动代码，但是有时候一个代码两天之后，你忘记了你做过什么改动，两天前的代码是什么样子，在提交之前需要确认以下你添加了什么新功能，这时候要用diff来查看你到底做了哪些改动。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181942708.png" alt="image-20210409181942708" style="zoom:33%;"><p>红色为删除绿色为增加，git diff是比较当前文件和暂存区文件的差异，当前的暂存区文件就是你最后一次add的文件</p><p>你也许也想知道你在项目过程中，在某两次之间做过什么改动，可以比较两次commit之间的差异，比较两个分支之间的差异，比较暂存区和版本库之间的差异等。</p><p><strong>git diff &lt;$id1&gt; &lt;$id2&gt; 比较两次commit之间的差异</strong>，&lt;$id1&gt;tag或者SHA1值,同样也可以单独比较两个分支中的某个文件</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409182027293.png" alt="image-20210409182027293" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409182049017.png" alt="image-20210409182049017" style="zoom:33%;"><p><strong>git diff <branch1><branch2> 比较两个分支之间的差异</branch2></branch1></strong></p><p><strong>git diff –staged 比较暂存区和版本库的差异</strong></p><h2 id="checkout-切换-撤销"><a href="#checkout-切换-撤销" class="headerlink" title="checkout 切换+撤销"></a>checkout 切换+撤销</h2><p><strong>checkout</strong>不止用作切换分支，还可以用来切换tag，切换到某次的commit</p><p><strong>git checkout v1.0  切换到v1.0的代码状态</strong></p><p><strong>git checkout ffafasdfasdf……</strong>      fafasdfasdf…是commit_id,是每次commit的SHA1值，可以通过git log看到每次commit的SHA1值</p><hr><p>还有一个撤销的作用</p><p>在一个分支开发小功能，刚写完一半，需求变了，而且是大变化，之前写的代码完全用不了了，好在还没git add进暂存区，</p><p><strong>git checkout a.md</strong></p><p>原文件还原，a.md还原到之前的状态</p><p>只能撤销还<strong>没有add进暂存区的文件</strong></p><h2 id="stash操作-暂存代码"><a href="#stash操作-暂存代码" class="headerlink" title="stash操作 暂存代码"></a>stash操作 暂存代码</h2><p>（学生可能不会出现的）场景：程序员正在项目的一个新的分支添加新功能，这时候突然出现一个紧急的bug要修复， 并且要立即修复。</p><p>但是你已经写了好多新功能的代码了，如果没提交，切换分支以后新代码就没了。</p><p>总不能把新写的那些代码提交了，理论上是可以，但是这回产生垃圾commit，原则上每次的commit都要有实际意义，代码只写了一般，没什么实际意义是不建议commit。</p><p>stash提供了一种方法，可以让我们先暂时切到别的分支，修复完bug再切换回来，代码也能保留</p><p>使用前提：没有commit，add过也可以使用</p><ul><li><p><strong>git stash</strong></p><p>把当前分支所有还没commit的代码先暂存，如果这个时候执行git status可以发现目前分支很干净，你的代码改动也看不见，实际上是存起来。</p></li><li><p><strong>git stash</strong></p><p>发现暂存区已经有了记录</p></li><li><p>当你切换分支，改完了bug提交后，再切换回这个分支，想要继续写代码</p><p><strong>git stash apply</strong></p><p>代码全部回来了</p></li><li><p>建议接着就把暂存区的这次stash记录删除</p><p><strong>git stash drop</strong></p></li><li><p>如果还想图方便</p><p><strong>git stash pop</strong></p><p>这个代码等同于上两个，apply+drop，意思是还原后直接删除记录</p></li><li><p><strong>git stash clear</strong></p><p>删除所有暂存区的记录，drop只是删除一条，drop后面跟着stash_id就是删除指定的记录，不加stash_id是删除最近一条</p></li></ul><h2 id="merge-amp-rebase-分支合并"><a href="#merge-amp-rebase-分支合并" class="headerlink" title="merge &amp; rebase 分支合并"></a>merge &amp; rebase 分支合并</h2><p>再other分支上完成了某个功能，需要合并到主分支master上</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git checkout <span class="hljs-literal">master</span><br>git merge other<br></code></pre></div></td></tr></table></figure><p>或者使用rebase</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git checkout <span class="hljs-literal">master</span><br>git rebase other<br></code></pre></div></td></tr></table></figure><p>merge指直接将other分支的内容并入master，相当于合并两个书架，直接将一个书架清空一个位置，放入另一个书架的书</p><p>rebase指将other分支修改的次序和自己改动的次序依次合并，相当于other书架的书向master书架移动的时候，按照购书顺序给其排序</p><p>未完待续…</p><p>​     </p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客图床的搭建——国内快速访问</title>
    <link href="/2021/04/08/%E5%8D%9A%E5%AE%A2%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/04/08/%E5%8D%9A%E5%AE%A2%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>昨天发布游记文章发生了很尴尬的事情，图片加载不出来。  </p><p>因为我是小白，并不清楚具体原因，后来经过试验后得到结论：  </p><p>我为了方便，直接用github的仓库当作图床，来保存我博客上的图片，由于我的设备是一直科学上网的，因此图片在我看来是一直可以加载出来的。</p><p>实际上对于不能翻墙的用户来说，我博客上的图片由于链接是github，因此加载的极慢——国内对于github一直是半墙的状态，十分不稳定，且速度很慢。</p><p>更别说最开始我竟然还上传了15M大小的图片了。</p><span id="more"></span><p>今日想了不少办法解决这个事情，找了许多的教程，其中包括Coding平台搭建图床，在尝试过程中我的RSA公钥一直出问题，最后不得不放弃。</p><p>但是我后来找到了一个很不错的方法——<strong>gitee（码云）</strong>+ PicGo +Typora<br>Gitee有5G的免费容量，而且国内访问速度还是很快的，很适合作为图床使用。</p><p>下面根据个人经历做一个对新手友好的教程。</p><h2 id="Gitee（码云）"><a href="#Gitee（码云）" class="headerlink" title="Gitee（码云）"></a>Gitee（码云）</h2><p>简单来讲，码云相当于一个国内版的Github，它的其他功能暂且不提，这里只用它搭建一个图床。</p><p><a href="https://gitee.com/">https://gitee.com/</a></p><p>若还没有Gitee账号，请先注册一个账号。</p><p>注册成功后，点击右上角加号</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408202539662.png" alt="image-20210408202539662"></p><p>选择新建仓库</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408202612734.png" alt="image-20210408202612734" style="zoom:33%;"><p>如下，设置仓库名称</p><p>是否开源选择公开，添加开源许可证根据提示选一个</p><p>勾选使用Readme文件初始化这个仓库，这样可以使仓库直接创建一个master分支。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408203011885.png" alt="image-20210408203011885" width="%70"><p>点击创建，创建成功。</p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>下载PicGo： <a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>windows用户下载exe文件，下载后找路径安装。</p><p>打开PicGo，下载gitee-uploader插件</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408203455640.png" alt="image-20210408203455640"></p><p>重启gitee-uploader，左侧图床设置栏内就多出了gitee</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408203638826.png" alt="image-20210408203638826" style="zoom:33%;"><p>打开图床设置栏的gitee</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408203824864.png" alt="image-20210408203824864"></p><p>如图，repo栏填写 gitee的用户名/刚刚建立的仓库</p><p>如我的名字是Trent-Liuy，我建立的想要当图床的仓库名为blogimage，我就填的Trent-Liuy/blogimage</p><p>branch栏填master</p><p>path栏可以填img，意思是在仓库中创建一个文件夹img，上传的图片保存在img中</p><hr><p>下面讲token栏如何填写。</p><p>回到gitee码云，打开右上角的设置</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408204123927.png" alt="image-20210408204123927" style="zoom:33%;"><p>在设置界面找到打开私人令牌</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408204252976.png" alt="image-20210408204252976" style="zoom:33%;"><p>点击生成新令牌</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408204334101.png" alt="image-20210408204334101"></p><p>只勾选projects，随便添加描述</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408204409888.png" alt="image-20210408204409888" style="zoom:33%;"><p>注意，生成的令牌内容要及时保存，关闭此窗口后就再也不能找到此令牌内容。之后要用只能再重新生成令牌。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408204631385.png" alt="image-20210408204631385" style="zoom:33%;"><h2 id="将刚刚复制的内容粘贴进PicGo的token里就可以了"><a href="#将刚刚复制的内容粘贴进PicGo的token里就可以了" class="headerlink" title="将刚刚复制的内容粘贴进PicGo的token里就可以了"></a>将刚刚复制的内容粘贴进PicGo的token里就可以了</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408203824864.png" alt="image-20210408203824864" style="zoom:33%;"><p>点击确定，设置成功。</p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>下面介绍一个功能很强的markdown编辑工具Typora</p><p><a href="https://typora.io/">https://typora.io/</a></p><p>我之前一直用VScode变击md文件，虽然VScode有很多插件使用，但使用Typora后我还是觉得后者更香——毕竟是专业的markdown编辑工具。</p><p>下载成功后，文件——偏好设置或者直接ctrl+，进入设置</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408205140536.png" alt="image-20210408205140536"></p><p>如图，对其进行如上设置，注意PicGo路径是你安装路径下的exe文件，安装成功后便大功告成了。</p><p>当你再写博客的时候，可以直接复制本地图片或者网络图片，直接在Typora上粘贴，PicGo会将图片自动上传到Gitee上，并且得到Gitee上的图片链接，自动生成Markdown图片格式。</p><p>十分的方便。</p><p>同时gitee的国内访问还是很快的，这样我的博客分享给不能翻墙的小伙伴时，博客里的图片就能很快的加载出来了。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——面向对象思考</title>
    <link href="/2021/04/08/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E8%80%83/"/>
    <url>/2021/04/08/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="面向过程开发"><a href="#面向过程开发" class="headerlink" title="面向过程开发"></a>面向过程开发</h2><p>一个软件系统由一系列过程构成。因而采用功能划分或模块分解的方法进行。  </p><h2 id="面向对象开发"><a href="#面向对象开发" class="headerlink" title="面向对象开发"></a>面向对象开发</h2><p>一个软件系统由一系列参与活动的对象构成。故需建立对象模型、动态模型和功能模型。</p><ul><li><strong>对象模型</strong>：描述对象的组织结构。是核心模型。</li><li><strong>动态模型</strong>：描述对象之间的交互行为。</li><li><strong>功能模型</strong>：描述对象的行为或状态变化。<span id="more"></span><ul><li><strong>对象模型：描述类和类之间的关系，包括：关联、聚合、组合、依赖、继承。</strong></li><li><strong>UML建模语言的类图能够描述对象(类）的组织结构和行为。</strong></li></ul></li></ul><h2 id="类间的关系描述方法"><a href="#类间的关系描述方法" class="headerlink" title="类间的关系描述方法"></a>类间的关系描述方法</h2><h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联关系(association)是一种通用的二元关系，对象间通过活动发生联系。例如，学生(Student)选学课程(Course)，教师(Faculty)教授课程(Course)，这些联系可以在UML中表示。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E8%80%831.png?raw=true" alt="haha"></p><blockquote><p>一个关联可以用两个类之间的实线表示。<br>可带描述关系的标签。<br>关联中的每个类可以指定一个数目或数字<br>区间，指出这个关系涉及多少个对象  </p></blockquote><ul><li>在Java代码中，关联关系可以用数据域或方法来实现。对于方法，一个类中的方法包含另一个类的参数。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Course[] courseList;<span class="hljs-comment">//一对多用数组实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCourse</span><span class="hljs-params">( Course c)</span></span>&#123; …… &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Course</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Student[] classList;<br>    <span class="hljs-keyword">private</span> Faculty faculty;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">( Students s)</span></span>&#123; …… &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFaculty</span><span class="hljs-params">( Faculty f)</span> </span>&#123; …… &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Faculty</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Course[] courseList;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCourse</span><span class="hljs-params">( Course c)</span></span>&#123; …… &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>如果学生或教师不需要知道课程的信息，可以去掉courseList域，形成单向关联。这时可将Student类和Faculty类中的数据域courseList和addCourse方法去掉。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E8%80%832.png?raw=true" alt="haha"></li></ul><h4 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h4><p>同一个类的对象间存在关联，称自关联。例如，一个人有一个领导。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E8%80%833.png?raw=true" alt="haha"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Person supervior；<br>    ……<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>聚合关系(aggregation)是一种拥有关系，表示整体与部分之间的关系，即<strong>has-a</strong>的关系。所有者成为聚集者，从属对象称为被聚集者。<strong>在聚合关系中，一个对象可以被多个聚集者拥有(Weak has a)。</strong></p><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合关系(composition)是一种隶属关系，表示从属者强烈依赖于聚集者。<strong>一个从属者只能被一个聚集者所拥有，聚集者负责从属者的创建和销毁(Strong has a)。</strong><br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%833.png?raw=true" alt="haha"></p><blockquote><p>一个Name对象只能为一个Person所有，但一个Address对象可以被多个Person共享</p></blockquote><ul><li><p>聚合关系和组合关系在代码中通常表示为聚集类中的数据域，如上图中的关系可以表示为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span></span>&#123;<br><br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Name name;<br>    <span class="hljs-keyword">private</span> Address address;<br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span></span>&#123;<br><br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>对于组合关系，聚集者往往负责对从属者的创建和销毁，而聚集关系则不是</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Name name;<br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(Address a)</span></span>&#123;<br>name = <span class="hljs-keyword">new</span> Name();<br>address = a;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>Address对象是传递进来的一个引用，而Name对象是在Person对象创建时才创建。<br>当Person对象被析构时，Name对象也被析构，而Address对象可能还存在</p></blockquote></li></ul><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>依赖关系（dependency）指的是两个类之间一个（称为client）依存另一个（称为supplier）的关系。<br>在UML中，从client画一条带箭头的虚线指向supplier类<br>例如，可以向容器类ArrayList添加对象，因此ArrayList和Object之间的关系可以用依赖描述。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%835.png?raw=true" alt="haha"><br>依赖关系在代码中通常表示为client类的成员函数以supplier类型的对象为参数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object o)</span></span>&#123;<br>       …<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>继承关系(inheritance)表示子类与父类之间的is-a关系。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%836.png?raw=true" alt="[haha](6)"></p><blockquote><p>通过继承，子类可以重用父类的数据和代码。</p></blockquote><h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>实现关系(realization)表示类和接口之间的关系。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%837.png?raw=true" alt="[haha](7)"></p><hr><h2 id="类的设计原则"><a href="#类的设计原则" class="headerlink" title="类的设计原则"></a>类的设计原则</h2><ul><li>确定系统中的类</li><li>建立类之间的关系</li><li>描述每个类的属性和方法</li><li>编写类的代码</li><li>例如建立一个借方和贷款的模型，借方是要贷款的人，人有姓名和地址，因此可以确定以下类：<ul><li>人Person</li><li>姓名Name</li><li>地址Address</li><li>借方Borrow</li><li>一笔贷款Loan</li></ul></li></ul><h3 id="分析类的关系"><a href="#分析类的关系" class="headerlink" title="分析类的关系"></a>分析类的关系</h3><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%838.png?raw=true" alt="[haha](8)"></p><ul><li>Person对象包含Name对象和Address对象，Person和Name之间为组合关系，Person和Address之间为聚集关系</li><li>Borrower继承Person</li><li>Borrower对象包含一笔贷款，Borrower和Loan之间为组合关系。</li></ul><h3 id="设计实例-贷款的类模型"><a href="#设计实例-贷款的类模型" class="headerlink" title="设计实例-贷款的类模型"></a>设计实例-贷款的类模型</h3><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%839.png?raw=true" alt="[haha](9)"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面向对象思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>准程序员和女朋友在武汉</title>
    <link href="/2021/04/07/%E6%AD%A6%E6%B1%89%E6%81%8B%E7%88%B1%E5%AD%A3/"/>
    <url>/2021/04/07/%E6%AD%A6%E6%B1%89%E6%81%8B%E7%88%B1%E5%AD%A3/</url>
    
    <content type="html"><![CDATA[<p>更新内容：解决国内网络访问无法加载图片的情况<br>解决方案：<a href="https://trent-liu.github.io/2021/04/08/%E5%8D%9A%E5%AE%A2%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/">https://trent-liu.github.io/2021/04/08/%E5%8D%9A%E5%AE%A2%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</a><br><strong>综述</strong>  </p><p>  　　2021年4月2日下午，湖南省长沙市中南大学的小杨同志冒雨深入武汉市进行小刘同志的学习生活及安全工作视察。  </p><p>  　　刘同学全程陪同。刘同学首先向杨同志汇报了近期对其的想念之情及其美貌的不吝夸赞以及对未来三天的吃喝规划等。刘同学特别介绍了江汉路步行街和光谷的美食之多，为此做了许多工作。特别是今年，刘同学较去年的仓促准备，此次准备相对充分，挑选了以下一些特色美食：肉蟹煲，蔡林记，半秋山，夏氏砂锅，鲍师傅等，想法颇多。杨同志听完后露出了满意的笑容，肯定了小刘能的吃货本色，做足大量工作无私养胖自己和女朋友的行为值得颂赞，希望继续把吃喝玩乐做好，使双方继续展开体重的增长。  </p><span id="more"></span><p>  　　接着杨同志在绵绵的细雨中随小刘乘坐地铁来到了江汉路步行街，并在接下来的两天基本逛了个遍，后又来到光谷，视察了刘同学的校园生活及附近美食。觉得虽然人很多，但热闹非凡，同时也要求小刘还要加强身体素质锻炼，坚决杜绝继续变胖，并结合当前形势特别指出，由于异地恋十分不易，一定要在思想建设工作上下功夫，做好洁身自好努力学习等工作，要利用QQ、微信等形式加强沟通，共筑恋爱防护墙。杨同志的一席话，体现了其对刘同学的关心、关爱。我将不辜负领导希望，把生活中的各项工作继续做好、做扎实。</p><hr><p>文末贴一些女朋友精心修的图<br>想必会和下文的直男拍照风形成<strong>鲜明对比</strong>  </p><p><strong>记录一些吃吃喝喝玩乐的日子</strong></p><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><blockquote><p>华中科技大学站相遇——得到老板从长沙带来的一大包茶颜的茶包  </p></blockquote><blockquote><p>来到江汉路步行街，细雨蒙蒙<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/wx_camera_1617354771428.jpg" alt="wx_camera_1617354771428" width="50%"></p></blockquote><blockquote><p>晚上去江汉路的M+购物中心吃的胖哥俩肉蟹煲，七点半才到，但是前面还有四十桌，等到九点才入座<br>早就听舍友说味道不错，吃了以后确实不错，但是不愧是南方，微辣就让我这个青岛小哥受不了啦<br>第一次吃就吃肉蟹煲，但是吃螃蟹还是有点点麻烦，下次尝试牛蛙煲<br>鸡爪好吃，但是吃多了有点腻  </p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210402_203719.jpg" alt="IMG_20210402_203719" width="44%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210402_204151.jpg" alt="IMG_20210402_204151" width="25%"></blockquote><blockquote><p>晚上买了无骨鸡爪，糖葫芦和周黑鸭，用我的笔记本一起看了料理鼠王，童年回忆</p></blockquote><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><blockquote><p>第二天去地铁站接了小杨的闺蜜，买了一些廖记棒棒鸡，然后一起去万松园吃夏氏砂锅，据说是不错的湖北菜。<br>没想到前面有二十桌，又到了熟悉的等位时间<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_122551.jpg" alt="IMG_20210403_122551" width="40%"></p></blockquote><blockquote><p>点了牛蛙砂锅，味道很不错，有点油腻但是山东大汉狂喜<br>许久没吃的烤鸭，荷叶饼小葱烤鸭甜面酱永远的神！！  </p></blockquote><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_124311.jpg" alt="IMG_20210403_124311" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_124314.jpg" alt="IMG_20210403_124314" width="40%"><blockquote><p>香辣蟹烩面，也是听说很不错，吃了这一大碗让山东汉子辣哭啦<br>锅边馍，挺好吃，但是没想到底味是偏甜的。  </p></blockquote><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_125557.jpg" alt="IMG_20210403_125557" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_131030.jpg" alt="IMG_20210403_131030" width="40%"><blockquote><p>回江汉路的时候给小杨买了束雏菊<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_-2d4849fdde6c9cba..jpg" alt="Cache_-2d4849fdde6c9cba." width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_713b9e32662d1445..jpg" alt="Cache_713b9e32662d1445." width="40%"></p></blockquote><blockquote><p>晚上准备出去吃饭的时候，一出门当场愣住。<br>锣鼓喧天，鞭炮齐鸣，红旗招展，人山人海<br>人多的太吓人啦  </p></blockquote><blockquote><p>在人群中挤到了大洋百货，又一次熟悉的等位<br>为减肥（并没有）的我点了份金枪鱼沙拉  　　西冷牛排<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_200541.jpg" alt="IMG_20210403_200541" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_201200.jpg" alt="IMG_20210403_201200" width="40%"></p></blockquote><blockquote><p>我很喜欢的牛奶绵绵冰　　　　　　　　　半熟芝士<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_204447.jpg" alt="IMG_20210403_204447" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_200728.jpg" alt="IMG_20210403_200728" width="40%"></p></blockquote><blockquote><p>小杨喜欢的缤纷水果披萨<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_203542.jpg" alt="IMG_20210403_203542" width="40%"></p></blockquote><blockquote><p>吃完后一起去看了个电影<br>万万没想到小杨背着我先看了哥斯拉大战金刚<br>呜呜<br>然后就一起看了我的姐姐  </p></blockquote><hr><blockquote><p>非专业人士对电影不做点评，但是莫名突然想起了知乎上各种有关山东不让女性上桌吃饭的谣言<br>山东的酒桌文化深入生活，但男女分桌的目的一方面方便喝酒的人吹牛拉胡，另一方面也防止女性和儿童闻烟味之类的<br>往往是喝酒抽烟的男性在一桌吃饭，妇女儿童在另一桌吃饭<br>在我能喝酒之前我也是妇女桌的常客<br>跑题了跑题了<br>总之我觉得绝大部分山东好青年还是很尊重女同志的  </p></blockquote><hr><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><blockquote><p>一起去买了鲍师傅，鲍师傅的小贝还是那么好吃  </p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210404_150611.jpg" alt="IMG_20210404_150611" width="40%">  </blockquote><blockquote><p>一起去吃了蔡林记，第一次带小杨吃了正宗的热干面，豆皮，蛋酒，热干面yyds！！  </p></blockquote>   <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210404_112903.jpg" alt="IMG_20210404_112903" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210404_112907.jpg" alt="IMG_20210404_112907" width="40%"><blockquote><p>下午一起回到了光谷，带着小杨逛了逛我的校园，骑上共享小电动，拉着女朋友到处乱窜<br>有点小激动<br>这是我来到华中大以后第一次不是<strong>载男生</strong>  </p></blockquote><blockquote><p>森林大学里这种阴雨天气总是有些冷冽，逛了一大圈没想好带小杨吃什么，吉野家周麻婆还是我很喜欢的越南粉，最后去了百景园<br>请小杨吃了锅盔，还买了她最喜欢的甜红烧肉，玉米水饺和黑米糕<br>这张图我忘记拍啦<br>晚上一起逛了光谷步行街，我基本每个周都去玩的地方，但是这次终于有女朋友陪着啦，给小杨买了个兔兔，对的,和我一样可爱<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_-27cfa259814a90df..jpg" alt="Cache_-27cfa259814a90df." width="40%">   </p></blockquote><blockquote><p>夜宵狂魔lyk买了一大碗炸串,据说这个胡炸炸还是个武汉老店    </p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210404_203731.jpg" alt="IMG_20210404_203731" width="40%"></blockquote><hr><blockquote><p>最后一天，一起去做了蛋糕<br>那种看上去很简单但是做起来很难的工作<br>我觉得我抹的挺好看<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210405_120431.jpg" alt="IMG_20210405_120431" width="40%"><br>和小杨一起做的蛋糕，画的图案，提前纪念一千天纪念日  </p></blockquote><p><strong>高二——大二了</strong>  </p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_294eccba82cb0c5c..jpg" alt="Cache_294eccba82cb0c5c." style="zoom:25%;">  <blockquote><p>吉野家的饭<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210405_135648.jpg" alt="IMG_20210405_135648" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_42ba23b3e6b3218a..jpg" alt="Cache_42ba23b3e6b3218a." width="40%/">  </p></blockquote><blockquote><p>下午四点半和小杨分别<br>有些些难过，异地恋总是这样，披着恋爱的皮过着单身的生活<br>感觉能坚持下去<br>有爱就可以吧  </p></blockquote><blockquote><p>篇末附一张合照(别骂了一定减肥——恋爱使我肥胖)<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_4efbb5ccbd6d4139..jpg" alt="Cache_4efbb5ccbd6d4139." width="40%/">  </p></blockquote><hr><p>女朋友的图  </p><p>&lt;<img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795804095.jpeg" alt="1617795804095" width="25%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795808363.jpeg" alt="1617795808363" width="25%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795806185.jpeg" alt="1617795806185" width="25%"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795814863.jpeg" alt="1617795814863" width="25%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795810524.jpeg" alt="1617795810524" width="25%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795812595.jpeg" alt="1617795812595" width="25%"></p><p><strong>异地恋是挺辛苦的，<br>但我不希望有谁因为一时的距离，<br>和一些细枝末节的疏忽，<br>错过本该厮守一生的人。<br>“距离之于爱情，就像风之于火，<br>它吹熄那些微弱的，它助长那些强烈的。”</strong><br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/v2-98b6b849a347031ff2a458091f0f2a37_r.jpg" alt="v2-98b6b849a347031ff2a458091f0f2a37_r" style="zoom: 33%;">  </p><p><strong>完</strong></p>]]></content>
    
    
    <categories>
      
      <category>大学生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——异常处理</title>
    <link href="/2021/03/31/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2021/03/31/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li>异常(Exception)：又称为例外，是程序在<strong>运行过程中发生的非正常事件</strong>，其发生会影响程序的正常执行。</li><li>当一个方法中发生错误时，将<strong>创建</strong>一个<strong>对象</strong>并将它<strong>交给运行时系统</strong>，此对象被称为异常对象(exception object)</li><li>创建异常对象并将它交给运行时系统被称为<strong>抛出一个异常</strong>(throw an exception) 。</li></ul><h3 id="异常产生的原因"><a href="#异常产生的原因" class="headerlink" title="异常产生的原因"></a>异常产生的原因</h3><ul><li>Java虚拟机同步检测到一个<strong>异常的执行条件</strong>，间接抛出异常，例如：<ul><li>表达式违反了正常的语义，例如整数除零。</li><li>通过<strong>空引用</strong>访问<strong>实例变量或方法</strong>。</li><li>访问数组超界。</li><li>资源超出了某些限制，例如使用了过多的内存。</li></ul></li></ul><span id="more"></span><ul><li>显式地执行throw语句抛出异常</li></ul><hr><h3 id="异常的抛出都是由throw语句直接或间接抛出"><a href="#异常的抛出都是由throw语句直接或间接抛出" class="headerlink" title="异常的抛出都是由throw语句直接或间接抛出"></a>异常的抛出都是由throw语句直接或间接抛出</h3><ol><li><p>程序运行时的逻辑错误导致异常间接抛出，例如通过空引用访问实例变量和方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123; &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>       A o = <span class="hljs-keyword">null</span>;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">通过空引用访问实例方法, 会间接地抛出异常NullPointerException</span><br><span class="hljs-comment">*/</span>       <br>       o.m1(); <br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E5%BC%82%E5%B8%B81.png" alt="异常1"></p></li><li><p>程序在满足某条件时，用throw语句直接抛出异常，如</p><blockquote><p>if(满足某条件){<br>  throw new Exception(“异常描述信息”);}</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>   <span class="hljs-comment">//由于main方法里抛出的异常没有被处理,因此在main方法必须加上异常声明throws Exception</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>       <span class="hljs-keyword">int</span> i = <span class="hljs-keyword">new</span> Scanner(System.in).nextInt();<br>       <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">10</span>)&#123; <span class="hljs-comment">//假设应用逻辑要求用户输入整数不能大于10</span><br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Input value is too big&quot;</span>); <span class="hljs-comment">//显式地用throw抛出异常</span><br>       &#125;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>这里的main函数，加异常声明，但前一个例子没有加，因为一个是必检异常，一个不是。<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E5%BC%82%E5%B8%B82.png" alt="异常2"></p></blockquote><h3 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h3><ul><li>Java异常都必须<strong>继承Throwable</strong>的直接或间接子类。用户<strong>通过继承自定义异常</strong>。</li><li>Java的异常分为二大类：从Exception派生的是<strong>程序级错误</strong>，<strong>可由程序本身处理</strong>；从Error派生是<strong>系统级错误</strong>，程序可不用处理（也基本上<strong>处理不了</strong>，例如JVM内存空间不够）。</li><li>Exception的子类里，除了RuntimeException这个分支外，其他的都是<strong>必检异常（即：要么在函数里用catch子句捕获并处理，要么在所在函数加上异常声明</strong>，PPT第5页例子）。 RuntimeException的子类是<strong>非必检异常</strong>（PPT第4页例子）（这类异常一般我们是不处理的，因为会很判断会出现什么问题，而且有些异常你也无法运行时处理，比如空指针。）<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E5%BC%82%E5%B8%B83.png" alt="异常3">  </li></ul><hr><ul><li>运行时异常系统处理异常的过程如下：<ul><li>当发生异常时，运行时系统按与方法调用次序相反的次序搜索调用堆栈，寻找一个包含可处理异常的代码块的方法，这个代码块称为异常处理器(exception handler)，即try/catch语句</li><li>如果被抛出的异常对象与try/catch块可以处理的类型匹配，运行时系统将异常对象传递给它，这称为捕获异常(catch the exception)</li><li>如果运行时系统彻底搜索了调用堆栈中的所有方法（一直返回到了JVM还没有处理好），但没有找到合适的异常处理器，程序则终止<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E5%BC%82%E5%B8%B84.png" alt="异常4"></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallStack</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;in methodA&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;  <br>methodB(); <br>&#125; <br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>System.out.println(e);   <span class="hljs-comment">//方法A捕获异常兵处理，这里只是简单打印出异常对象e</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;end methodA&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;in methodB&quot;</span>);<br>        methodC();    <span class="hljs-comment">//方法B没有处理，顺着调用栈向上抛到方法A</span><br>        System.out.println(<span class="hljs-string">&quot;end methodB&quot;</span>);<br>    &#125;<br><br>     <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodC</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;in methodC&quot;</span>);<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;        <span class="hljs-comment">//方法C出现异常，抛出异常，但没有处理，顺着调用栈向上抛到方法B</span><br>        System.out.println(i);  <br>        System.out.println(<span class="hljs-string">&quot;end methodC&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;in methodMain&quot;</span>);<br>        methodA();<br>        System.out.println(<span class="hljs-string">&quot;end methodMain&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E5%BC%82%E5%B8%B85.png" alt="异常5"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210411202840760.png" alt="image-20210411202840760"></p><h3 id="非必检异常-Unchecked-Exception"><a href="#非必检异常-Unchecked-Exception" class="headerlink" title="非必检异常(Unchecked Exception)"></a>非必检异常(Unchecked Exception)</h3><ul><li>非必检异常是<strong>运行时异常(RuntimeException)<strong>和</strong>错误(Error)类及它们的子类</strong>, 非必检异常在方法里可不捕获异常同时方法头<strong>可不声明异常，编译器不会报错</strong>。但该发生的异常还是要发生。<h3 id="其它的异常称为必检异常-Checked-Exception"><a href="#其它的异常称为必检异常-Checked-Exception" class="headerlink" title="其它的异常称为必检异常(Checked Exception)"></a>其它的异常称为必检异常(Checked Exception)</h3></li><li>非必检异常，编译器确保<strong>必检异常被捕</strong>获或<strong>声明（即要不在方法里捕获异常，要不在方法头声明异常）</strong><ul><li><strong>捕获</strong>：方法可以通过try/catch语句来捕获异常</li><li><strong>声明</strong>：方法可以在方法头使用throws子句声明可能抛出异常</li></ul></li><li>方法可以抛出的异常<ul><li>方法里调用throw语句直接抛出的任何异常</li><li>调用另一个方法时，由被调用方法间接抛出的异常</li></ul></li></ul><h2 id="异常声明，抛出及保护"><a href="#异常声明，抛出及保护" class="headerlink" title="异常声明，抛出及保护"></a>异常声明，抛出及保护</h2><h3 id="异常声明，抛出异常"><a href="#异常声明，抛出异常" class="headerlink" title="异常声明，抛出异常"></a>异常声明，抛出异常</h3><ul><li>异常声明：由方法声明可能抛出的异常</li><li><strong>如果方法不捕获其中发生的必检异常，那么方法必须声明它可能抛出的这些异常</strong></li><li>通过<strong>throws</strong>子句<strong>声明</strong>方法<strong>可能抛出的异常</strong>。throws子句由throws关键字和一个以逗号分隔的<strong>列表</strong>（可能很多异常种类）组成，列表列出此方法抛出的所有异常，即<strong>一个方法可以声明多个可能抛出的异常</strong><br>例如<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;  <br>    <span class="hljs-comment">//声明可能抛出的异常</span><br>InputStream in = <br><span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(“C:\\<span class="hljs-number">1.</span>txt”));<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>抛出异常</li><li>抛出异常有二种情况</li></ul><ol><li>间接抛出：执行语句（如new FileInputStream(new File(“C:\1.txt”)); ）或调用方法时由<strong>被调用方法抛出的异常</strong>（如上），当前发生异常的方法自动抛出</li><li>显式直接抛出，人为手动抛出<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> i = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>.next<span class="hljs-constructor">Int()</span>;<br>         <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">10</span>)&#123; <span class="hljs-comment">//假设应用逻辑要求用户输入整数不能大于10</span><br> throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Exception(<span class="hljs-string">&quot;Input value is too big&quot;</span>)</span>; <br>         &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>上图就是调用throw，显式</p></blockquote></li></ol><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;<br>statements<br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType1 id1) &#123;<br>statements1<br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType2 id2) &#123;<br>statements2<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>statements3<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>当包含catch语句时，finally子句是可选的<br>当包含finally子句时，catch子句是可选的  </p></blockquote><ul><li>将可能抛出异常的语句放在try块中。<strong>当try块中的语句发生异常时</strong>，异常由后面的<strong>catch块捕获处理</strong>。</li><li>一个try块后面可以有<strong>多个catch块</strong>。每个catch块可以处理的异常类型由异常类型参数指定。异常参数类型必须是从<strong>Throwable派生的类</strong>。</li><li>当try块中的语句抛出异常对象时，运行时系统将调用第一个异常对象类型与参数类型匹配的catch子句。<strong>如果被抛出的异常对象可以被合法地赋值给catch子句的参数，那么系统就认为它是匹配的（和方法调用传参一样，子类异常对象匹配父类型异常参数类型）</strong>。</li><li><strong>无论try块中是否发生异常，都会执行finally块中的代码</strong>。通常用于关闭文件或释放其它系统资源。</li><li><strong>处理异常时</strong>，也可以抛出新异常，或者处理完异常后继续向上（本方法调用者）抛出异常以让上层调用者知道发生什么事情：链式异常。</li><li>当一个catch匹配时，别的就都被跳过了。</li></ul><blockquote><p>读取整个文件的操作，其中就应用了上述。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">read</span><span class="hljs-params">(String filePath)</span></span>&#123;<br>   <br>    String s = <span class="hljs-keyword">null</span>;<br>    BufferedReader reader = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//BufferedReader一次读文本文件一行，也是一个类。</span><br>    <br>    <span class="hljs-keyword">try</span>&#123;<br>        StringBuffer buf = <span class="hljs-keyword">new</span> StringBuffer();<br>        reader <br>        = <span class="hljs-keyword">new</span> BufferedReader<br>        (<span class="hljs-keyword">new</span> InputStreamReader<br>        (<span class="hljs-keyword">new</span> FileInputStream   <span class="hljs-comment">//这一句可能抛出FileNotFoundException。</span><br>        (<span class="hljs-keyword">new</span> File(filePath))));  <br>        <span class="hljs-comment">//这个操作记住就可以，reader就得到了整个文件</span><br>        <br>        <span class="hljs-keyword">while</span>( (s = reader.readLine()) != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//readLine方法读取到文件末尾返回null</span><br>            buf.append(s).append(<span class="hljs-string">&quot;\n&quot;</span>); <span class="hljs-comment">//readLine自动去掉\n，因此结尾要再加上</span><br>        &#125;<span class="hljs-comment">//readLine可能抛出IOException</span><br> s = buf.toString().trim();<br>    &#125; <br>    <br>    <span class="hljs-keyword">catch</span> (FileNotFoundException e)  <span class="hljs-comment">//上文new FileInputStream可能抛出的</span><br>    &#123; <br>        e.printStackTrace();  <span class="hljs-comment">//打印调用栈</span><br>    &#125; <br>    <br>    <span class="hljs-keyword">catch</span> (IOException e)    <span class="hljs-comment">//上文readLine可能抛出的</span><br>    &#123; <br>        e.printStackTrace();<br>    &#125;<br>    <br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span>(reader != <span class="hljs-keyword">null</span>) &#123;   <br>    <span class="hljs-keyword">try</span> &#123; reader.close()&#125;   <span class="hljs-comment">//也可能发生异常</span><br>    <span class="hljs-keyword">catch</span> (IOException e) &#123; e.printStackTrace();&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//由于reader打开后，执行readLine时可能抛出异常，因此在finally块里关闭流是最合适的地方。</span><br>    <span class="hljs-comment">//注意close也可能抛出异常，因此还得用try/catch处理</span><br><br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>方法read内部已经处理了所有可能发生的异常，因此方法首部不需要加throws声明。同时外部read方法的调用代码不需要try/catch</p></blockquote><h3 id="方法异常声明与方法内捕获处理异常的关系"><a href="#方法异常声明与方法内捕获处理异常的关系" class="headerlink" title="方法异常声明与方法内捕获处理异常的关系"></a>方法异常声明与方法内捕获处理异常的关系</h3><ol><li>方法内部处理了所有异常，没有throws声明<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowDeclaration1</span> </span>&#123;<br>    <span class="hljs-comment">//由于m1内部处理了所有异常，因此不用加throws声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//执行可能抛出异常的语句</span><br>        &#125;<br>        <span class="hljs-keyword">catch</span>(Throwable e)&#123; <span class="hljs-comment">//由于Throwable是所有异常的父类，因此这里可以捕获所有异常</span><br>            <span class="hljs-comment">//处理异常</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span></span>&#123;<br>        m1(); <br>        <span class="hljs-comment">//由于m1没有异常声明，因此m1的调用者不需要try/catch</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>方法内部可能抛出的异常没有处理，要加throws声明<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowDeclaration2</span> </span>&#123;<br>    <span class="hljs-comment">//m1内部可能抛出的异常没有处理，因此必须加throws声明</span><br>    <span class="hljs-comment">//throws声明就是告诉方法的调用者，调用本方法可能抛出什么异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        <span class="hljs-comment">//执行可能抛出异常IOException的语句,但没有try/catch</span><br><br>    &#125;<br></code></pre></div></td></tr></table></figure>如上的m1没有处理异常，m2有两个选择<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//由于m1有异常声明，因此m2调用m1时有第一个选择：1 用try/catch捕获和处理异常</span><br><span class="hljs-comment">//这时m2就不用加throws异常声明</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            m1();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>或者<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//由于m1有异常声明，因此m2调用m1时有第2个选择：</span><br>    <span class="hljs-comment">//2 也在方法头声明异常，方法体里不捕获异常。</span><br>    <span class="hljs-comment">//这时如果有方法m3调用m2, m3也就面临二个选择：声明异常或者在m3里捕获异常</span><br>    m1();<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><blockquote><p>非必检异常(Unchecked Exception)是运行时异常(RuntimeException)和错误(Error)类及它们的子类, 方法<strong>可以不捕获同时不声明非必检异常</strong>（注意只是编译器不检查了，但如果真的有异常该抛出还是会抛出）<br>10/0这种异常<br><strong>方法如果声明或捕获非必检异常也没问题</strong></p></blockquote><hr><h3 id="异常的捕获顺序"><a href="#异常的捕获顺序" class="headerlink" title="异常的捕获顺序"></a>异常的捕获顺序</h3><ul><li>每个catch<strong>根据自己的参数类型</strong>捕获相应的类型匹配的异常。</li><li>由于父类引用参数可接受子类对象，因此，<strong>若把Throwable作为第1个catch子句的参数，它将捕获任何类型的异常，导致后续catch没有捕获机会。</strong></li><li>通常将继承链最底层的异常类型作为第1个catch子句参数，次底层异常类型作为第2个catch子句参数，以此类推。<strong>越在前面的catch子句其异常参数类型应该越具体</strong>。以便所有catch都有机会捕捉相应异常。<blockquote><p>异常类，最底层的类放入第1个catch子句，最后一个放Throwable</p></blockquote></li><li>无论何时，throw以后的语句都不会执行。</li><li><strong>无论同层catch子句是否捕获、处理本层的异常</strong>（即使在catch块里抛出或转发异常），<strong>同层的finally总是都会执行。</strong></li><li><strong>一个catch捕获到异常后，同层其他catch都不会执行</strong>，然后执行同层finally。</li></ul><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.lang.System;<br><span class="hljs-keyword">import</span> java.lang.ArithmeticException;<br><span class="hljs-keyword">public</span>  <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-comment">//各种Exception都被捕获，函数无须声明异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;  <br>        <span class="hljs-keyword">int</span>   r=<span class="hljs-number">0</span>;  <span class="hljs-comment">//2</span><br>        <br>        <span class="hljs-keyword">try</span>&#123;  <br><span class="hljs-comment">//自己抛出异常对象 </span><br><span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)   <span class="hljs-comment">//3 发现异常</span><br>        <span class="hljs-keyword">throw</span>  <span class="hljs-keyword">new</span> ArithmeticException( ); <span class="hljs-comment">//抛出这个异常      </span><br>        <br>        r=x/y; <br>        &#125;<br>        <span class="hljs-keyword">catch</span>(ArithmeticException  ae)   <span class="hljs-comment">//4  从具体异常到不具体，catch发现就是这个异常</span><br>        &#123;   <br>            System.out.print(ae.toString( ));   <span class="hljs-comment">//5</span><br>            <span class="hljs-keyword">throw</span> ae;   <br>            <span class="hljs-comment">//处理完异常后可以继续抛出异常，交给上层调用者继续处理。</span><br>            <span class="hljs-comment">//注意即使这里抛出异常，同层的finally仍会执行</span><br>        &#125; <br>        <span class="hljs-keyword">catch</span>(Exception  ae)<br>        &#123;<span class="hljs-comment">//捕获各种Exception：若是第1个catch，则后续的catch子句无机会捕获   </span><br>    System.out.print(ae.toString( ));   <br>        &#125; <br>        <span class="hljs-keyword">finally</span>&#123;  r=-<span class="hljs-number">1</span>; &#125;  <span class="hljs-comment">//6   //无论是否有异常，r=-1</span><br>        <br>        <span class="hljs-keyword">return</span>  r;       <span class="hljs-comment">//7        </span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title">main</span><span class="hljs-params">(String[ ] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;   <br>            div(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>);   <br>            &#125; <span class="hljs-comment">//1</span><br>        <span class="hljs-keyword">catch</span>(Throwable  ae) &#123; <span class="hljs-comment">//任何异常都被捕获，包括Error类型异常</span><br>            <span class="hljs-comment">//8  div方法内的继续抛出了异常，交给了上层调用者继续处理</span><br>System.out.print(ae.toString( ));   <br>        &#125;<span class="hljs-comment">//虽然div没有异常声明，再main里调用div也用了try/catch</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><ul><li>自定义异常类必须继承Throwable或其子类。//太抽象了</li><li>自定义异常类<strong>通常继承Exception及其子类</strong>，因为Exception是程序<strong>可处理</strong>的类。</li><li>如果自定义异常类在父类的基础上增加了成员变量，<strong>通常需要覆盖toString函数。</strong>//通常返回描述异常的字符串</li><li>自定义异常类通常不必定义clone：捕获和处理异常时通常只是引用异常对象而已。//不需要clone，仅仅引用。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span>  java.lang.<span class="hljs-keyword">Exception</span>;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ValueBeyondRangeException extends <span class="hljs-keyword">Exception</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">value</span>, range;<br>    <span class="hljs-built_in">public</span> ValueBeyondRangeException(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> r)&#123; <span class="hljs-keyword">value</span>=v; range=r; &#125;<br>    <span class="hljs-built_in">public</span> toString( )&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> + ” beyonds “ + range;<br>    &#125;<br>&#125;<br>//使用例子,自定义了一个异常<br><span class="hljs-type">int</span> v = <span class="hljs-number">1000</span>，range = <span class="hljs-number">100</span>；<br>try&#123; <br><span class="hljs-keyword">if</span>(v &gt; range)<br>throw <span class="hljs-built_in">new</span> ValueBeyondRangeException （v,range）;<br>&#125;<br>catch(ValueBeyondRangeException e)&#123; <br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(e.toString( )); <br>    &#125;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>异常处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——抽象类及接口</title>
    <link href="/2021/03/31/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/03/31/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>子类继承父类后，通常会添加新的属性和方法。因此沿着继承链<strong>越往下继承的子类其属性和方法越来越具体</strong>。相反，越<strong>上层的祖先类其实现越抽象</strong>，甚至无法给出具体实现。一个长方形图形有面积，但其祖先类GeometricObject的getArea()方法可能没法给出具体实现，这时可以定义成抽象方法。</li><li>Java可定义<strong>不含方法体</strong>的方法（由子类覆盖），其方法体由子类根据具体情况实现，这样的方法称为抽象方法(abstract method)，包含抽象方法的类必须是抽象类(abstract clas给子类的一个约束s)。</li><li>抽象类和抽象方法的声明<strong>必须加上abstract关键字</strong>。<span id="more"></span></li><li>抽象方法的<strong>意义</strong>：加<strong>给子类的一个约束</strong>。例如Circle类和Rectangle类计算面积<strong>必须使用父类规定的函数签名</strong>。这样可以充分利用多态特性使得代码变得<strong>更通用</strong><br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8A%BD%E8%B1%A1%E7%B1%BB1.png?raw=true" alt="RUNOOB 图标">  <blockquote><p>包含抽象方法的类必须是抽象类<br>抽象类和抽象方法必须用abstract关键字修饰<br>没有包含抽象方法的类也可以定义成抽象类  </p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeometricObject</span></span>&#123;<br>    <span class="hljs-comment">//属性和方法定义</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPerimeter</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GeometricObject</span></span>&#123;<br>    <span class="hljs-comment">//新的属性</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//给出具体实现</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPerimeter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//给出具体实现</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>抽象方法：使用<strong>abstract</strong>定义的方法或者<strong>接口中定义的</strong>方法（接口中定义的方法<strong>自动是抽象的</strong>，可以省略abstract）。</li><li>一个类C如果满足下面的任一条件，则该类包含抽象方法且是抽象类：<ol><li>类C显式地包含一个抽象方法的声明；</li><li>类C的父类中声明的抽象方法未在类C中实现；</li><li>类C所实现的接口中有的方法在类C里没有实现</li><li><strong>只要类C有一个未实现的方法（自己定义的或继承的），就是抽象类</strong>,new后的类一定不可以时抽象类。</li></ol></li><li>但是，一个不包含任何抽象方法的类，也可以定义成抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-comment">//抽象类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-comment">//抽象类</span><br>     <span class="hljs-comment">//B继承了二个抽象方法，但是只实现了m1,方法m2在B里还是抽象的，因此B必须是抽象类</span><br>     <span class="hljs-meta">@OverrideA</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span>&#123;       <span class="hljs-comment">//所有方法均实现，因此不是抽象类了</span><br>     <span class="hljs-comment">//C继承B，又实现了方法m2, 因此m1,m2二个方法在C里都有了具体实现</span><br>     <span class="hljs-comment">//因此C就是可以是具体类</span><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>     <br>     <span class="hljs-comment">//当然，C还可以继续覆盖B的m1，给出C的m1实现</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">//接口里方法编译器自动加上public abstract来修饰</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m4</span><span class="hljs-params">()</span></span>;<br> &#125;<br><br> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">I</span></span>&#123;<br>     <span class="hljs-comment">//class D声明实现了接口I，但只实现了一个接口方法m3</span><br>     <span class="hljs-comment">//接口方法m4在D里还是抽象的，因此D只能是抽象类</span><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123; &#125;<br> &#125;<br><br> <span class="hljs-comment">//类E继承D，并实现了另一个接口方法m4</span><br> <span class="hljs-comment">//因此类E是具体类</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">I</span></span>&#123; <span class="hljs-comment">//注意既然E继承了D，所以这里的implements I可以不写</span><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m4</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>     <span class="hljs-comment">//当然，E还可以继续覆盖D的m3，给出自己的的m3实现</span><br> &#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>只有实例方法可以声明为抽象方法</strong>（Java里所有实例方法自动是虚函数，因此Java里没有virtual关键字）。</li><li><strong>抽象类不能被实例化</strong>，即不能用new关键字创建对象（即<strong>new 右边的类型不能是抽象类</strong>）。<ul><li>但是抽象类可以作为<strong>变量声明类型</strong>、<strong>方法参数类型</strong>、<strong>方法返回类型</strong>（强烈建议）</li><li>为什么？因为一个抽象类型引用变量可以指向具体子类的对象</li></ul></li><li>抽象类可以定义构造函数，并可以被子类调用。</li><li>抽象类可以<strong>定义变量、非抽象方法</strong>并被子类使用（抽象类中可以先实现基础方法，供各种子类使用）</li><li><strong>抽象类的父类可以是具体类：自己引入了抽象方法</strong>。例如，具体类Object是所有类的祖先父类。  </li></ul><h2 id="接口-本文章均按JDK8标准"><a href="#接口-本文章均按JDK8标准" class="headerlink" title="接口(本文章均按JDK8标准)"></a>接口(本文章均按JDK8标准)</h2><ul><li>接口是<strong>公共静态常量（public,static,final）</strong>和<strong>公共抽象实例方法</strong>的集合。接口是<strong>能力、规范、协议</strong>的反映。</li><li>接口不是类：(1)<strong>不能定义构造函数</strong>；(2)<strong>接口之间可以多继承</strong>，类可implements<strong>多个</strong>接口。(3)和抽象类一样，<strong>不能new</strong>一个接口</li><li>语法：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">[modifier]  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interfaceName</span> </span>&#123;<br>             constant_declaration*   <br>             abstract_method_declaration* <br>      &#125;<br></code></pre></div></td></tr></table></figure></li><li>接口中的所有数据字段隐含为public static final</li><li>接口体中的所有方法隐含为public abstract  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I1</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>；<span class="hljs-comment">//可省略public static final</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">//可省略public abstract</span><br>&#125;<br></code></pre></div></td></tr></table></figure>等价<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I1</span></span>&#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>；  <span class="hljs-comment">//=1不可省略，因为它是final的，必须初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">( )</span></span>;   <span class="hljs-comment">//不可定义函数体，它是abstract</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>类和类之间是ISA关系，但是类和接口之间是实现关系。这种实现关系是<strong>CANDO</strong>关系。例如Airplane实现接口Flayer，意味着Airplane的实例CANDO Flyer<br>实例：  </li></ul><ol><li>接口<strong>描述了一种能力</strong>。Flyer接口描述了一种飞行的能力，飞行能力包括三个行为：takeOff、land、fly。但接口需要<strong>类来实现</strong>，因为接口描述的能力需要具体类的对象来体现。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyer</span> </span>&#123; <span class="hljs-comment">//程序文件1</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">takeOff</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>一个类实现一个接口，表示这个类<strong>具有接口规定的能力</strong>。Airplane实现接口Flyer，表示Airplane具有飞行的能力，因此Airplane 必须给出飞行能力的三个行为takeOff、land、fly的具体实现<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Airplane</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeOff</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//程序文件2</span><br>        <span class="hljs-comment">// 加速直到离地升空</span><br>        <span class="hljs-comment">// 收起起落架</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 放下起落架</span><br>        <span class="hljs-comment">// 减速并降低副翼直到降落</span><br>        <span class="hljs-comment">// 刹车</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 保持引擎运转   </span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><ul><li><p>接口中的方法通过“接口类型的引用变量.方法名”调用，但接口类型的引用变量必须指向<strong>实现了该接口的类</strong>的<strong>实例对象</strong></p></li><li><p>接口中的常量名通过“接口名.常量名”访问。<br>接口方法的访问</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//接口方法的访问</span><br>Flyer f = <span class="hljs-keyword">new</span> AirPlane();<br><br>f.takeOff( ); <span class="hljs-comment">//f传给this</span><br>f.fly( );<br>f.land( );    <span class="hljs-comment">//f传给this </span><br></code></pre></div></td></tr></table></figure><p>这是接口f的行为是飞机的飞行行为：多态。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A32.png?raw=true" alt="RUNOOB 图标"></p></li><li><p>可以在能够使用任何其他数据类型的地方使用接口。（定义接口后，就是种数据类型了）</p></li><li><p>接口类型属于引用类型，接口类型的变量可以是：</p><ul><li>空引用(null)</li><li>引用实现了该接口的类的实例</li></ul></li><li><p>接口需要具体的类去实现。类实现接口的语法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">[modifier] class className [extends superclass][implements interfaceNameList ] &#123;<br> member_declaration*<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>除非类为abstract,所有接口的成员方法必须被实现（只要不是抽象类，所有方法就要实现）</p></li><li><p>一个类只能继承一个父类（类为单继承），但可以实现<strong>多个接口</strong>，多个接口以“，”分开（多接口，多种能力）。</p></li></ul><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A33.png?raw=true" alt="RUNOOB 图标">  </p><blockquote><p>这一个UML模型描述了AirPlane、Bird、Superman都实现了Flayer接口，因此这三个类型都具有飞行的能力(CANDO Fly)。但是他们各自的飞行行为可以不一样（<strong>每个类对takeOff、land、fly的具体实现都不一样</strong>），当用接口类型引用变量引用了三个类的实例时，通过接口引用变量调用接口方法就呈现出多态性。  </p></blockquote><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A35.png?raw=true" alt="RUNOOB 图标">  </p><blockquote><p>接口描述了能力，继承描述了类之间的血缘关系。来自不同继承链(树）的类可以具有相同的能力。（像家谱一样）</p></blockquote><blockquote><p>例如：Airplane和Superman来自不同的继承链（即来自不同的家族，没有血缘关系），但他们都实现了接口Flyer，都具有飞行的能力。</p></blockquote><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A36.png?raw=true" alt="RUNOOB 图标">  </p><blockquote><p>这个图描述了二个继承树（二个家族），二个接口，其中：<br> Airplane、Bird、Superman实现了接口Flyer<br> RiverBarge实现了接口Sailer<br> SeaPlane同时实现了接口Flyer和Sailer，这意味着Seaplane同时具有飞行能力和海上巡航的能力。这个例子说明了一个类可以实现多个接口（具备多种能力）  </p></blockquote><h3 id="接口-继承"><a href="#接口-继承" class="headerlink" title="接口-继承"></a>接口-继承</h3><ul><li> 接口不是类（Java支持单继承类），一个接口<strong>可以继承多个接口</strong>。</li><li>语法<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">[modifier] interface interfaceName [extends interfaceNameList] &#123;<br>declaration* <br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>如果接口声明中提供了<strong>extends子句</strong>，那么该接口就<strong>继承了父接口的方法和常量</strong>。被继承的接口称为声明接口的直接父接口。</li><li>任何实现该接口的类，<strong>必须实现该接口继承的其他接口。</strong></li></ul><ul><li>实例<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I1</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>;<br>&#125; <br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">I1</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I3</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">I2</span>, <span class="hljs-title">I3</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// implements&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// implements&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// implements&#125;</span><br><br>&#125;<br><br><br>A a = <span class="hljs-keyword">new</span> A();<br><br><span class="hljs-function">a <span class="hljs-keyword">instanceof</span> <span class="hljs-title">I1</span>         <span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span><br><span class="hljs-function">a <span class="hljs-keyword">instanceof</span> <span class="hljs-title">I2</span>         <span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span><br><span class="hljs-function">a <span class="hljs-keyword">instanceof</span> <span class="hljs-title">I3</span>         <span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span><br><span class="hljs-function">a <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Object</span>     <span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">I1 i1 </span>= <span class="hljs-keyword">new</span> A();<br>I2 i2 = <span class="hljs-keyword">new</span> A();<br>I3 i3 = <span class="hljs-keyword">new</span> A();<br></code></pre></div></td></tr></table></figure><blockquote><p>当一个类实现多个接口时，<br>这个类的实例可以是多种类型<br>如下列表达式都返回true</p></blockquote></li></ul><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><ul><li>有时需要比较二个对象，但不同类型对象的比较具有不同的含义，因此Java定义了Comparable接口（比较对象的大小，而不是变量）。</li><li>因此，任何需要比较对象的类，都要实现该接口。</li><li>Cloneable、Runnable、Comparable等接口均在包java.lang中：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java.lang;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>CompareTo判断this对象相对于给定对象o的顺序，当this对象小于、等于或大于给定对象o时，分别返回负数、0或正数</li></ul><ul><li>有了Comparable接口，我们可以实现很通用的类来比较对象，例如实现一个从两个对象中找出最大者的方法。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Max</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparable <span class="hljs-title">findMax</span> <span class="hljs-params">(Comparable o1, Comparable o2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(o1.CompareTo(o2) &gt; <span class="hljs-number">0</span> )<br>            <span class="hljs-keyword">return</span> o1;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> o2;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>注意findMax方法的<strong>参数类型和返回类型都是Comparable</strong>（<strong>只要是实现了Comparable接口的对象都可以传进</strong>来。 Comparable接口描述了可以比较大小的能力，一个类实现了这个接口，意味着这个类的<strong>对象</strong>直接可以比较大小）</li><li>Max.findMax与Comparable接口的具体实现子类无关。<strong>只要是实现了Comparable接口的具体类的二个对象（注意是同一个具体类的二个对象）传进来， Max.findMax都能工作。</strong>这就是接口的好处。（程序存在的问题：如果是2个实现了Comparable接口的不同具体类对象传进来怎么办？最好通过泛型解决）</li><li>另外要注意的是：o1.CompareTo(o2)调用是动态绑定（<strong>多态</strong>，compateTo是什么，取决于O的类型）（调用具体子类对象的CompareTo方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComparableRectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/** Construct a ComparableRectangle with specified properties */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ComparableRectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> width, <span class="hljs-keyword">double</span> height)</span>   <span class="hljs-comment">//构造函数</span></span><br><span class="hljs-function">    </span>&#123;<br><span class="hljs-keyword">super</span>(width, height);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Implement the compareTo method defined in Comparable */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span>    <span class="hljs-comment">//定义ComparableRectangle类的比较是通过比较面积来完成</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getArea( ) &gt;((ComparableRectangle)o).getArea()) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getArea( ) &lt;((ComparableRectangle)o).getArea()) <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125; <br>注意由于篇幅所限没有用instanceOf检查o的类型。但如果o不是ComparableRectangle类型怎么办？这时返回什么样的整数都不合适，最好的这个问题最好的解决办法是用泛型。<br></code></pre></div></td></tr></table></figure><ul><li> 对于ComparableRectangle的两个对象r1和r2，直接调用Max.findMax(r1,r2)找出最大的对象</li><li>对于实现了Comparable接口任何类的二个对象（同一个类）(不管其具体实现是什么)a1和a2，都可以调用Max.findMax(a1,a2)找出最大的对象。这就是接口和多态的威力。</li></ul><hr><h3 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h3><ul><li>Java定义了Cloneable接口，任何想克隆的类必须<strong>实现该接口</strong>，同时<strong>覆盖从Object类继承的clone方法</strong>，并将访问属性改为public</li><li>Cloneable接口为空接口(未定义任何函数)，其定义为<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java.lang;<br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cloneable</span> </span>&#123; &#125;<br></code></pre></div></td></tr></table></figure></li><li>空接口称为标记接口(markup interface)      </li><li>空接口有什么作用？唯一目的允许你用instanceof检查对象的类型：   <div class="hljs code-wrapper"><pre><code>  `if(obj instanceof Cloneable)…//任何一个实现Cloneable的对象，类型一定是Cloneable`  例子见继承与多态下。</code></pre></div></li></ul><h3 id="接口与抽象类的比较"><a href="#接口与抽象类的比较" class="headerlink" title="接口与抽象类的比较"></a>接口与抽象类的比较</h3><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A38.png?raw=true" alt="RUNOOB 图标"></p><blockquote><p>JDK8之后，其差距越来越小，接口越来越像抽象类。</p></blockquote><hr><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ul><li>基本数据类型包装类的作用<ul><li>为基本数据类型提供有用的方法和常量值</li><li>用于只能处理对象引用的地方（比如Java所有的集合类里只能放对象）</li></ul></li><li>包装类对象的值不变（内部valule是final的），只能读取。<blockquote><p>8个包装类都实现了Comparable接口。Number为抽象类。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A37.png?raw=true" alt="RUNOOB 图标"></p></blockquote></li></ul><ul><li>构造函数<ul><li>以一个对应的基本数据类型为参数</li><li>以字符串为参数(除了Character)</li></ul></li><li>如Double类的构造函数如下：（别的都是这样，只有Character类只有char）<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Double</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Double</span> <span class="hljs-params">(String value)</span></span>;<br></code></pre></div></td></tr></table></figure></li><li>例如<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Double doubleObject = <span class="hljs-keyword">new</span> Double(<span class="hljs-number">5.0</span>);<br>Double doubleObject = <span class="hljs-keyword">new</span> Double(<span class="hljs-string">&quot;5.0&quot;</span>);<br></code></pre></div></td></tr></table></figure></li><li><strong>包装类没有无参构造方法</strong></li></ul><hr><ul><li>每一个数值包装类都有相应类型常量MAX_VALUE和MIN_VALUE。<ul><li>MAX_VALUE对应本数据类型的最大值。</li><li>对Byte ,Short ,Integer和Long， MIN_VALUE对应最小值</li><li>对Float和Double， MIN_VALUE对应最小正值</li></ul></li><li>上述常量用于排序算法时很有用。</li><li>直接用包装类名访问其常量值：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">System.out.println(“The maximum integer is”+ <br>Integer.MAX_VALUE); <span class="hljs-comment">//MAX_VALUE是int类型</span><br>System.out.println(“The minimum positive <span class="hljs-keyword">float</span> <br>is”+ Float.MIN_VALUE); <span class="hljs-comment">//MIN_VALUE是float类型</span><br></code></pre></div></td></tr></table></figure></li></ul><hr><ul><li><p>Number是基本数值类型包装类的抽象父类，里面有如下方法返回包装类对象对应的基本数据类型值：</p><ul><li>public abstract int intValue()</li><li>public abstract long longValue()</li><li>public abstract float floatValue()</li><li>public abstract double doubleValue()</li><li>public byte byteValue()</li><li>public short shortValue()</li></ul></li><li><p>如 int i = new Integer(10).intValue();</p></li><li><p>另外每个类的toString（）方法将数值转换成字符串</p></li><li><p>字符串转数值<br> 转换为Byte，Short，Integer，Long，Float，Double</p><ul><li>public static type parseType(String s)</li><li>public static type parseType(String s, int radix)<br>如<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">int</span> i = Integer.parseInt(“<span class="hljs-number">11</span>”,<span class="hljs-number">2</span>); <span class="hljs-comment">//3</span><br><span class="hljs-keyword">int</span> i = Integer.parseInt(“<span class="hljs-number">12</span>”,<span class="hljs-number">8</span>); <span class="hljs-comment">//10</span><br><span class="hljs-keyword">int</span> i = Integer.parseInt(“1A”,<span class="hljs-number">16</span>); <span class="hljs-comment">//26</span><br><span class="hljs-keyword">double</span> d = Double.parseDouble(“<span class="hljs-number">3.14</span>”);<span class="hljs-comment">//3.14</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p> 方法valueOf创建一个新的包装对象，并将它初始化为指定字符串的值<br>例如:(返回的是包装类)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Double doubleObject = Double.valueOf(“<span class="hljs-number">12.4</span>”);<br>Integer integerObject = Integer.valueOf(“<span class="hljs-number">12</span>”);<br></code></pre></div></td></tr></table></figure></li><li><p>JDK1.5开始允许基本类型和包装类之间的自动转换。</p><ul><li>将基本类型的值转换为包装类对象，称为装箱(boxing)</li><li>将包装类对象转换为基本类型的值，称为开箱(unboxing)</li></ul></li></ul><p><code>Integer intObject = 2; //装箱</code><br>等价于<br><code>Integer intObject = new Integer(2); </code>  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Integer intObject1 = <span class="hljs-number">2</span>, intObject2 = <span class="hljs-number">3</span> ;<br>System.out.println(intObject1 + intObject2 );<span class="hljs-comment">//开箱</span><br><span class="hljs-keyword">int</span> j = intObject ; <span class="hljs-comment">//开箱</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>抽象类</tag>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的常用包</title>
    <link href="/2021/03/28/Java%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85/"/>
    <url>/2021/03/28/Java%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="import-java-util-Scanner-输入的一种方式"><a href="#import-java-util-Scanner-输入的一种方式" class="headerlink" title="import java.util,Scanner; //输入的一种方式"></a>import java.util,Scanner; //输入的一种方式</h2><blockquote><p>Scanner scanner =new Scanner(System.in);<br>double d=scanner.nextDouble();//举例，输入double型<br>nextInt() nextFloat() next()分别输入int，float，String</p></blockquote><h2 id="import-javax-swing-JOptionPane；-弹窗输入字符串"><a href="#import-javax-swing-JOptionPane；-弹窗输入字符串" class="headerlink" title="import javax.swing.JOptionPane； //弹窗输入字符串"></a>import javax.swing.JOptionPane； //弹窗输入字符串</h2><blockquote><p>String string = JOptionPane.showInputDialog(<br>null,”Prompting Message”,”Dialog Title”,JOptionPane.QUESTION_MESSAGE));<br>由从控制台输入变为弹出一个弹窗输入  </p></blockquote><span id="more"></span><h2 id="import-java-lang-Math；-数学函数-定义了一些常量如PI，E"><a href="#import-java-lang-Math；-数学函数-定义了一些常量如PI，E" class="headerlink" title="import java.lang.Math；  //数学函数   定义了一些常量如PI，E"></a>import java.lang.Math；  //数学函数   定义了一些常量如PI，E</h2><ul><li>Math中的三角函数<ul><li>sin(radians)–返回以弧度为单位的角度的三角正弦函数值  </li><li>cos(radians)–返回以弧度为单位的角度的三角余弦函数值</li><li>tan(radians)–返回以弧度为单位的角度的三角正切函数值</li><li>toRandians(degree)–将以度为单位的角度值转化为以弧度表示</li><li>toDegrees(radians)–将以弧度为单位的角度值转化为以度表示</li><li>sain(a)–返回以弧度为单位的角度的反三角正弦函数值</li><li>acos(a)–返回以弧度为单位的角度的反三角余弦函数值</li><li>atan(a)–返回以弧度为单位的角度的反三角正切函数值</li></ul></li><li>Math中的指数函数<ul><li>exp(x)–返回e的x次方</li><li>log(x)–返回x的自然底数</li><li>log10(x)–返回x的以10为底的对数</li><li>pow(a,b)–返回a的b次方</li><li>sqrt(x)–对于x&gt;=0的数字，返回x的平方根</li></ul></li><li>Math中的取整函数<ul><li>ceil(x)–x向上取整为它最接近的整数，该整数作为一个双精度值返回</li><li>floor(x)–x向下取整为它最接近的整数，该整数作为一个双精度值返回</li><li>rint(x)–x取整为它最接近的整数，如果x与两个整数的距离相等，偶数的整数作为一个双精度值返回</li><li>round(x)–如果x是单精度数，返回(int) Math.floor(x+0.5);如果x是双精度数，返回(long)Math.floor(x+0.5)</li></ul></li><li><strong>Math中的随机数</strong><br>  Math.random方法生成[0.0,1.0)之间的double类型的随机数，可以用它写出简单的任意范围的随机数  </li></ul><ol><li><strong>生成整数</strong><br> <code>a+(int)(Math.random()*b)</code><br> 返回[a,a+b)  <strong>不包括b</strong><br> <code>a+(int)(Math.random()*(b+1))</code><br> 返回[a,a+b]  </li><li><strong>生成随机字符</strong><br> Java采用<strong>UniCode编码</strong>，0000到FFFF，生成随机字符就是生成0到65535之间的随机数<br> <code>(int)(Math.random()*(65535+1))</code><br> 随机生成所有的字符<br> <code>(char)(&#39;a&#39;+(int)(Math.random()*(&#39;z&#39;-&#39;a&#39;+1)))</code><br> 随机生成’a’-‘z’之间的字符<br> 随机生成别的区间字符的同理  </li></ol><blockquote><p>Java为每个基本类型实现了对应的包装类，char类型的包装类是Character类。包装类的对象为引用类型，不是值类型</p></blockquote><h2 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h2><ol><li>将char类型的数据封装成对象  </li><li>包含处理字符的方法和常量  <ul><li>isDigit方法判断一个字符是否是数字</li><li>isLetter方法判断一个字符是否是字母</li><li>isLetterOrDigit方法判断一个字符是否是字母或数字</li><li>isLowerCase方法判断一个字符是否是小写</li><li>isUpperCase方法判断一个字符是否是大写</li><li>toLowerCase方法将一个字符转换成小写</li><li>toUpperCase方法将一个字符转换成大写</li></ul></li></ol><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>是一个final类，不能被继承<br>java.lang.String表示一个固定长度的字符串序列，实例化后其内容不能改<br>按照规范来说，创建一个字符串应该是<br><code>String newString=new String(stringLiteral);   //存入堆中</code><br>由于字符串经常使用，java提供了创建字符串的简写形式<br><code>String newString =stringLiteral;   //存入常量池中</code></p><p><code>String m4 = &quot;Wel&quot; +new String(&quot;come&quot;)； //存入堆中，只要new的使用就存入堆中</code><br><img src="https://raw.githubusercontent.com/Trent-Liu/picture/main/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%851.png" alt="avatar"><br>intern()方法——堆-&gt;常量池<br><img src="https://raw.githubusercontent.com/Trent-Liu/picture/main/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%852.png" alt="avatar"><br>改变字符串的值，实际上是改变了指向，并没有在原有的基础上修改</p><ul><li><strong>字符串的比较</strong><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">String s=<span class="hljs-string">&quot;Welcome to Java&quot;</span>;   <span class="hljs-comment">//常量池</span><br>String s1=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Welcome to Java&quot;</span>);   <span class="hljs-comment">//堆</span><br></code></pre></div></td></tr></table></figure>如果直接比较s==s1，返回为false，因为比较的是指向的是不是一个内容，显然不是  </li></ul><ol><li><strong>equals</strong> 比较两个字符串是否包含相同的内容，这时候就可以s.equals(s1),返回值为TRUE，表示内容相同。  </li><li><strong>equalsIgnoreCase</strong>忽略大小写比较内容是否相同  </li><li><strong>regionMatch</strong>比较部分内容是否相同   </li></ol><p><strong>s2.regionMatches(11,s0,0,4)</strong> 要给定两个串的起始位置和长度<br>4. <strong>startsWith</strong>判断是否以某个字符串开始<br>5. <strong>endsWith</strong>判断是否以某个字符串结束<br>6. <strong>compareTo</strong>方法用于比较两个字符串的大小，即第一个不同字符串的差值（字典序）。<br>**s1.compareTo(s2)**，相同返回0，s1&gt;s2返回小于0的值，反之。</p><ul><li><p><strong>字符串长度</strong><br>调用length()方法可以获取字符串的长度  </p></li><li><p><em>message.length()</em>* 返回长度   </p></li><li><p>获取单个字符   </p></li><li><p><em>charAt(index)*</em> 方法可以获取指定位置的字符。<strong>index必须在0——s.length-1之间。</strong><br><img src="https://raw.githubusercontent.com/Trent-Liu/picture/main/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%853.png" alt="avatar">  </p></li><li><p><strong>连接字符串</strong>  </p></li></ul><ol><li><strong>concat</strong>方法用于连接两个字符串<br><code>String s3=s1.concat(s2);</code></li><li>(+)连接<br><code>String s3=s1+s2;</code>  </li></ol><p><strong>s1+s2+s3等价于s1.concat(s2).concat(s3)</strong><br>连接操作返回一个新得字符串，因为String类型的实例内容不可修改。  </p><ul><li><p><strong>截取子串</strong>  </p></li><li><p><em>substring</em>* 用于截取字符串的一部分，返回新字符串<br><code>public String substring(int beginIndex,int endIndex)</code><br>返回字符串的子串。子串从beginIndex开始，直到endIndex-1<br>或者只写beginIndex，就从beginIndex字符开始直到结尾。</p></li><li><p><strong>字符串转换</strong>  </p></li><li><p>*toLowerCase**将字符串转换成小写,得到新串  </p></li><li><p><em>toUpperCase</em>* 大写  </p></li><li><p><em>trim</em>* 删除两端空格  </p></li><li><p>*replace**字符替换<br><code>s1.replace(&quot;Java&quot;,&quot;HTML&quot;) 将s1中的Java换成HTML</code></p></li><li><p>查找字符或字符串  </p></li><li><p>*indexOf**返回字符串中字符或字符串匹配的位置，返回-1表示未找到。  </p></li><li><p>*lastIndexOf**返回字符串中字符或字符串最后出现的位置，返回-1表示未找到   </p></li><li><p><strong>字符数组和字符串之间的转换</strong>  </p></li></ul><p><strong>toChararray</strong>将字符串转换成字符数组</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">String s=<span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-keyword">char</span>[] charArray=s.toCharArray(); <span class="hljs-comment">//charArray.length=4</span><br></code></pre></div></td></tr></table></figure><p> <strong>将字符数组转换成字符串</strong>  </p><ol><li>使用String的构造函数，可同时初始化<br><code>new String(new char[]&#123;&#39;J&#39;,&#39;a&#39;,&#39;v&#39;,&#39;a&#39;&#125;);</code>  </li><li>使用valueOf方法：静态方法<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">String.valueOf(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]&#123;<span class="hljs-string">&#x27;J&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>&#125;);<br>String.vaueOf(<span class="hljs-number">2.34</span>); <span class="hljs-comment">//2.34转&quot;2.34&quot;</span><br></code></pre></div></td></tr></table></figure></li></ol><ul><li><strong>基本数据类型和字符串之间的转换</strong>  </li><li>*valueOf**方法将基本数据类型转换为字符串。例如  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">String s1=String.valueOf(<span class="hljs-number">1.0</span>); <span class="hljs-comment">//&quot;1.0&quot;</span><br>String s2=String.valueOf(<span class="hljs-keyword">true</span>);  <span class="hljs-comment">//&quot;true&quot;</span><br></code></pre></div></td></tr></table></figure>字符串转换为基本类型：利用<strong>包装类</strong>  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Double.parseDouble(str)<br>Integer.parseInt(str)<br>Boolean.parseBoolean(str)<br></code></pre></div></td></tr></table></figure></li></ul><blockquote><p>String类一旦初始化完成，字符串就是不可修改的<br>StringBuilder与StringBuffer(final类)初始化后还可以修改字符串<br>StringBuffer修改缓冲区的方法是同步（synchronized）的，更适合多线程环境。<br>StringBuilder线程不安全，与StringBuffer工作机制类似。<br>由于可修改字符串， StringBuilder 与StringBuffer 增加了String类没有的一些函数，例如：append、insert、delete、replace、reverse、setCharAt等。<br>仅以StringBuilder为例：<br>StringBuilder  stringMy=new StringBuilder( );<br>StringMy.append(“Welcome to”);<br>      StringMy.append(“ Java”);  </p></blockquote><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><ul><li>修改StringBuffer中的字符串<ul><li><strong>追加</strong><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">StringBuffer bf = <span class="hljs-keyword">new</span> StringBuffer();<br>bf.append(“Welcome”);<br>bf.append(‘ ‘);<br>bf.append(“to ”);<br>bf.append(“Java”);<br>System.out.println(bf.toString()); <span class="hljs-comment">//Welcome to Java</span><br></code></pre></div></td></tr></table></figure>上式中的toString是将StringBuffer类型转化为String类型  </li><li>*toString()**:从缓存区返回字符串</li><li><strong>插入</strong><br><code>bf.insert(11,”HTML and ”) //Welcome to HTML and JAVA</code>  </li><li><strong>删除</strong>：Welcome to Java<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">bf.delete(<span class="hljs-number">8</span>,<span class="hljs-number">11</span>); <span class="hljs-comment">//Welcome Java,将第8到第10删除，不含11</span><br>bf.deleteCharAt(<span class="hljs-number">8</span>);<span class="hljs-comment">//Welcome o Java 删除第8个</span><br>bf.reverse(); <span class="hljs-comment">//avaJ ot emocleW 字符串反转</span><br>bf.replace（<span class="hljs-number">11</span>，<span class="hljs-number">15</span>，“HTML”）;<span class="hljs-comment">//Welcome to HTML，第11到第14替换，不含15</span><br>bf.setCharAt(<span class="hljs-number">0</span>,’w’);<span class="hljs-comment">//welcome to Java</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ul><blockquote><p>所有对StringBuffer对象内容进行修改的方法，都返回指向相同StringBuffer对象的引用<br>StringBuffer bf = new StringBuffer();<br>StringBuffer bf1 = bf.append(“Welcome “);<br>StringBuffer bf2 = bf.append(“to “);<br>StringBuffer bf3 = bf.append(“Java”);<br>assert bf==bf1 &amp;&amp; bf==bf2 &amp;&amp; bf == bf3;<br>因此以上语句可以直接写成：<br>bf.append(“Welcome “).append(“to “).append(“Java”);  </p></blockquote><p><strong>toString()</strong>: 从缓冲区返回字符串<br>**capacity()**：返回缓冲区容量。length &lt;= capacity<br>    当字符串长度超过缓冲区容量，capacity会自动增加<br>**length()**：返回缓冲区中字符数量<br>**setLength(newLength)**：设置缓冲区长度<br>**charAt(index)**：返回下标为index的字符  </p><ul><li>StringBuffer实例<br>编写程序，检查回文。<br>解决方案<br>创建一个新的StringBuffer，将字符串的字母和数字添加到StringBuffer中，返回过滤后的String对象。<br>翻转过滤后的字符串，并与过滤后的字符串进行比较，如果内容相同则是回文。  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br><br><span class="hljs-comment">// Create a new string that is the reversal of s</span><br>String s2 = reverse(s);<br><span class="hljs-comment">// Compare if the reversal is the same as the original stringreturn s2.equals(s);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">reverse</span><span class="hljs-params">(String s)</span> </span>&#123;<br>StringBuffer strBuf = <span class="hljs-keyword">new</span> StringBuffer(s);<br>strBuf.reverse();<br><span class="hljs-keyword">return</span> strBuf.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>arrayRefVar.length</strong>  直接求数组长度  </p><ul><li>复制数组的方法</li></ul><ol><li>使用<strong>循环</strong>来复制每个元素  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[ ] sourceArray = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>&#125;;<br><span class="hljs-keyword">int</span>[ ] targetArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sourceArray.length];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sourceArray.length; i++)&#123;<br>targetArray[i] = sourceArray[i];<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>使用 <strong>System.arraycopy</strong><br>前提： sourceArray和targetArray都已经实例化好  </li></ol><p><code>arraycopy(sourceArray,srcPos,targetArray,tarPos,length)</code><br>原数组下标为几的元素开始，目标数组从几开始，长度</p><p><code>System.arraycopy(sourcearray,0,targetArray,0,sourceArray.length)</code>  </p><ol start="3"><li>数组<strong>克隆</strong><br>int [] targetArray=sourceArray.clone()  直接初始化。  </li></ol><ul><li>java.util.Array类包括各种静态方法，其中实现了数组的<strong>排序和查找</strong></li></ul><p><strong>排序</strong><br><code>double[] numbers=&#123;6.0,4.4,1.9,2.9&#125;;</code><br>java.util.Arrays.sort(numbers);  //直接在原数组排序</p><p><strong>二分查找</strong>  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">int</span> [] list=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">45</span>,<span class="hljs-number">50</span>&#125;  <br><span class="hljs-keyword">int</span> index=java.util.Arrays.binarySearch(list,<span class="hljs-number">11</span>)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>常用的包</tag>
      
      <tag>String</tag>
      
      <tag>StringBuffer</tag>
      
      <tag>随机数，数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——继承和多态下</title>
    <link href="/2021/03/26/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E4%B8%8B/"/>
    <url>/2021/03/26/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="实例方法覆盖"><a href="#实例方法覆盖" class="headerlink" title="实例方法覆盖"></a>实例方法覆盖</h2><ul><li>如果子类<strong>重新定义</strong>了从父类中继承的实例方法，称为方法覆盖(method override)。<ul><li>仅当父类方法在子类里是<strong>可访问的</strong>，该实例方法<strong>才能被子类覆盖</strong>，即父类<strong>私有</strong>实例方法不能被子类覆盖，父类实例私有方法自动视为final的。</li><li>静态方法不能被覆盖，如果静态方法在子类中重新定义，那么父类方法将被<strong>隐藏</strong>。</li><li><strong>覆盖特性</strong>：一旦父类中的实例方法被子类覆盖，同时用父类型的引用变量引用了子类对象，这时不能通过这个父类型引用变量去访问被覆盖的父类方法(即这时被覆盖的父类方法不可再被发现)。因为实例方法具有多态性（晚期绑定）<ul><li>在子类类体函数中可以使用super调用被覆盖的父类方法。</li></ul></li><li>隐藏特性：指父类的变量（实例变量、静态变量）和静态方法在子类被重新定义，但由于<strong>类的变量和静态方法没有多态性</strong>，因此通过<strong>父类型引用变量访问的一定是父类变量、静态方法</strong>(即被隐藏的可再发现)。</li><li>方法覆盖的哲学涵义：子对象当然可以修改父类的行为（生物进化除了遗传，还有变异）  </li></ul></li></ul><p>例子：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;               <span class="hljs-comment">//父类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A&#x27;s m&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A&#x27;s s&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-comment">//子类</span><br>    <span class="hljs-comment">//覆盖父类实例方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B&#x27;s m&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//隐藏父类静态方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B&#x27;s s&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OverrideDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A o = <span class="hljs-keyword">new</span> B();  <span class="hljs-comment">//父类型变量引用子类对象</span><br>        o.m();  <span class="hljs-comment">//由于父类实例方法m被子类覆盖，o运行时指向B类对象，由于多态性，执行的是B的m</span><br>        o.s();    <span class="hljs-comment">//由于s是静态方法，没有多态性，编译器编译时对象o的声明类型是A，所以执行的是A的s</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>父类型变量o引用了子类对象，通过o调用被覆盖的实例方法m时，调用的一定是子类方法，这时不可能调用到父类的方法m(父类函数不能被发现），因为多态特性。<strong>多态性使得根据new 后面的类型决定调用哪个m</strong>，new后是谁，实例方法就是谁的  </p></blockquote><blockquote><p>静态方法和成员变量没有多态性，因此要<strong>根据声明类型决定调用哪个s</strong>，声明是谁，静态方法就是谁。</p></blockquote><p>因此上面的结果为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">B<span class="hljs-string">&#x27;s m</span><br><span class="hljs-string">A&#x27;</span>s s<br></code></pre></div></td></tr></table></figure><p>A o = new B();<br>o的实例方法是B的，静态方法是A的</p><blockquote><p>引用变量o有二个类型：声明类型A，实际运行时类型B  </p></blockquote><blockquote><p>判断o.s()执行的是哪个函数按照o的<strong>声明类型</strong>，因为静态函数s<strong>没有多态性</strong>，<br>函数入口地址在<strong>编译时</strong>就确定（早期绑定），而编译时所有变量的类型都按声明类型。  </p></blockquote><blockquote><p>判断o.m()执行的是哪个函数按照o的<strong>实际运行类型</strong>，在<strong>运行时</strong>按照o指向<br>的实际类型B来<strong>重新计算函数入口地址</strong>（晚期绑定。多态性），因此调用的是B的m</p></blockquote><blockquote><p>因此一旦引用变量o指向了B类型对象（A o = new B()），o.m()调用的永远是B的m，再也无法通过o调用A的m，哪怕强制转换都不行： ((A)o).m();调用的还是B的m这就是前面PPT所说的不能再发现。</p></blockquote><p>对上面AB两个类，如果这样</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"> B o = <span class="hljs-keyword">new</span> B();<br> o.s(); <span class="hljs-comment">//调用B的s，将父类A的s隐藏，即通过B类型的引用变量o是不可能调用A的s</span><br>((A)o).s(); <span class="hljs-comment">//通过强制类型转换，可以调用A的s，可以找回。也可以通过类名调用来找回:A.s( );</span><br></code></pre></div></td></tr></table></figure><p>这就是被隐藏的变量和静态方法可以再发现</p><p>实例方法覆盖的一个应用：在子类里覆盖父类方法  (父类的toString可以打印颜色，填充等)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A circle &quot;</span> + <span class="hljs-keyword">super</span>.toString() <br>        + <span class="hljs-string">&quot;\n\tradius: &quot;</span> + radius;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>这样做的好处是Circle对象的基本属性,如color，filled，dateCreated由父类方法打印，Circle对象只负责打印新的属性值  </p></blockquote><h2 id="Object中的方法"><a href="#Object中的方法" class="headerlink" title="Object中的方法"></a>Object中的方法</h2><blockquote><p>任何类在设计时应考虑覆盖祖先类Object的如下函数： equal，clone，toString等。</p></blockquote><ul><li>java.lang.Object类是<strong>所有类的祖先类</strong>。如果一个类在声明时没有指定父类，那么这个类的<strong>父类是Object类</strong>。<ul><li>它提供方法如<strong>toString</strong>、<strong>equals</strong>、<strong>getClass</strong>、<em>clone</em>、<em>finalize</em>。前3个为公有，后2个为保护。getClass为final（用于泛型和反射机制，禁止覆盖）。</li><li>equals方法:用于测试两个对象是否相等。<strong>Object类的默认实现是比较两个对象引用是否引用同一个对象。</strong> 只是比较引用是否相同，不能真正判断是否相同，引用相同一定相同，但是相同不一定是引用相同， 在很多子类中要覆盖。</li><li>toString方法：返回代表这个对象的字符串。<strong>Object类的默认实现是返回由类名、@和hashCode组成。</strong><br>Circle circle = new Circle();<br>circle.toString();//Circle@15037e5，如果Circle没有覆盖toString<br>Object的toString方法提供的信息不是很有用。因此<strong>通常子类应该覆盖该方法，提供更有意义的信息</strong></li></ul></li></ul><h3 id="equals的覆盖"><a href="#equals的覆盖" class="headerlink" title="equals的覆盖"></a>equals的覆盖</h3><ul><li>equals用于判断一个对象同另一个对象的所有成员内容是否相等。覆盖时应考虑：<ul><li>对<strong>基本类型数值</strong>成员。直接使用==判断即可。</li><li>对<strong>引用类型变量</strong>成员。则需要对这些变量成员调用equals判断，不能用==。</li></ul></li><li>覆盖equals函数，最好<strong>同时覆盖hashCode()方法</strong>，该方法返回对象的hashCode值。<ul><li>需要对比的时候，<strong>首先用hashCode去对比</strong>，如果hashCode不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,<strong>如果hashCode相同，此时再用equals()比，如果equals()也相同</strong>，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</li></ul></li><li>覆盖equals函数，首先用instanceof检查参数的类型是否和当前对象的类型一样。<br>instanceof和加减乘除一样，当作运算符。<br>例如在Circle类中覆盖<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>&#123;   <span class="hljs-comment">//父类的参数就为Object，覆盖参数必须与父类一致</span><br>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Circle)<span class="hljs-comment">//应先检查另一对象o的类型 检查参数o的类型是否与当前对象的类型一样。</span><br>            <span class="hljs-keyword">return</span>  radius==((Circle)o).radius;  <span class="hljs-comment">//o中无radius这个变量，需要强制类型转换</span><br>        <span class="hljs-comment">//上面的式子，radius也可以写成this.radius,是c1的radius</span><br>        <span class="hljs-comment">//o是c2传进equals时被转换为的Object，需要强制类型转换。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br>Circle c1= ...;<br>Circle c2= ...;<br>c1.equals(c2);<br><span class="hljs-comment">//c1为Circle，为this引用，在对象中就是Circle</span><br><span class="hljs-comment">//c2在进入函数后被转换为Object类，相当于 Object o=c2； 实际上在函数中，o还是有Circle类的各种实例</span><br><span class="hljs-comment">//只不过由于在进入equals时转换成Object，在上文中需要再强制转换为Circle再与this.radius比较</span><br></code></pre></div></td></tr></table></figure></li></ul><blockquote><p>hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？<br> <br>     因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？<br> <br>           因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：<br> <br>         1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。<br>         2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。<br> <br>所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！  </p></blockquote><h3 id="clone的覆盖"><a href="#clone的覆盖" class="headerlink" title="clone的覆盖"></a>clone的覆盖</h3><ul><li>要实现一个类的clone方法，首先这个类需要实现Cloneable接口，否则会抛出CloneNotSupportedException异常</li><li>Cloneable接口其实就是一个标记接口，里面没有定义任何接口方法，只是用来<strong>标记</strong>一个类是否支持克隆：没有实现该接口的类不能克隆</li><li>还要公有覆盖clone方法，即Object类里clone方法是保护的，<strong>子类覆盖这个方法时应该提升为public</strong></li><li>方法里应实现<strong>深拷贝</strong>clone，Object的clone实现是<strong>浅拷贝</strong>。<ul><li>浅拷贝指所有类型都直接赋值=，这就导致数值类型没问题，但是引用类型就不是拷贝，而是指向同一个值<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    String j;<br>&#125;<br><br>A o1=...;<br>A <span class="hljs-number">02</span>;<br>o2.i=o1.i; <span class="hljs-comment">//值类型可以</span><br><span class="hljs-number">02.</span>j=o1.j; <span class="hljs-comment">//引用类型不可以，因为这会导致o2.j指向o1.j，而不是拷贝。</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li>克隆的深度：要克隆的对象可能包含基本类型数值成员或引用类型变量成员，对于基本类型数值成员使用=赋值即可，对于引用类型成员则需要<strong>进一步嵌套调用该成员的克隆方法</strong>进行赋值。  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">o2.j=o1.j  <span class="hljs-comment">//错误，引用类型</span><br>o2.j=o1.j.clone();  <span class="hljs-comment">//实现该成员的克隆方法后</span><br></code></pre></div></td></tr></table></figure></li></ul><p>实例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//首先必须实现Cloneable接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] values = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE]; <span class="hljs-comment">//A的values成员是数组</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getValues()&#123;<br>        <span class="hljs-keyword">return</span> values;<br>    &#125;<br>    <span class="hljs-comment">//覆盖clone方法，提升为public，只是调用Object的的clone，</span><br>    <span class="hljs-comment">//不修改行为</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<span class="hljs-comment">//Clone方法不带参数，返回Object，同时可能会抛出CloneNotSupportedException异常</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<span class="hljs-comment">//调用Object的clone</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        A o1 = <span class="hljs-keyword">new</span> A();<br>        A o2 = (A)(o1.clone()); <span class="hljs-comment">//clone返回Object，因此要强制类型转换</span><br>        System.out.println(o1 == o2); <span class="hljs-comment">//false，说明clone返回的是新的引用</span><br>        System.out.println(o1.getValues() == o2.getValues()); <span class="hljs-comment">//true 但为浅拷贝克隆</span><br>    &#125;<span class="hljs-comment">//因为o1和o2内部values引用指向了内存里同一个数组</span><br>    <span class="hljs-comment">//说明A的clone方法里，所调用的super.clone()是浅拷贝</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>如上，A实现Cloneable接口，表示A支持克隆，然后A中的clone覆盖父类Object中的clone，直接调用了父类clone，得到的结果表示父类clone为浅拷贝。  </p></blockquote><p>为此，若要实现类A的深拷贝，如下  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] values = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE];<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getValues()&#123; <span class="hljs-keyword">return</span> values; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValues</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] newValues)</span> </span>&#123;<span class="hljs-comment">//添加setValues方法，设置内部数组内容</span><br><span class="hljs-keyword">this</span>.values = newValues;<br>    &#125;<br>    <br>    <span class="hljs-comment">//覆盖equals方法，比较二个A类型对象内容是否一样</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> A)&#123;<br>            A o = (A)obj;<br>            <span class="hljs-keyword">return</span> java.util.Arrays.equals(<span class="hljs-keyword">this</span>.getValues(),o.getValues());<br>        &#125;<span class="hljs-comment">//Attays中已完备的equals</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//覆盖clone方法，提升为public，重新实现为深拷贝</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        A newObj = <span class="hljs-keyword">new</span> A(); <span class="hljs-comment">//new一个新对象，不好的选择</span><br>  建议：  上一行语句换为 A newObj=(A)<span class="hljs-keyword">super</span>.clone();<br>newObj.values = <span class="hljs-keyword">this</span>.values.clone(); <span class="hljs-comment">//数组的clone是深拷贝，如果去掉clone，则是浅拷贝</span><br><span class="hljs-keyword">return</span> newObj;<br>    &#125;<br><br>    <span class="hljs-comment">//覆盖toString方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuffer buf = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v : values)&#123;<br>            buf.append(v + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> buf.toString().trim(); <span class="hljs-comment">//去掉最后多余的空格</span><br>    &#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        A o1 = <span class="hljs-keyword">new</span> A();<br>        o1.setValues(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;);<br>        A o2 = (A)(o1.clone());<br>        System.out.println(o1 == o2); <span class="hljs-comment">//false</span><br>        System.out.println(o1.getValues() == o2.getValues()); <span class="hljs-comment">//false 说明不是浅拷贝克隆</span><br>        System.out.println(o1.equals(o2)); <span class="hljs-comment">//true,二个对象的内容相等， 说明是深拷贝克隆          </span><br>        System.out.println(o2.toString()); <span class="hljs-comment">//显示 1 2 3 4 5 6 7 8 9 10</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><ul><li>如果B类里包含了A类型成员，只要A实现了深拷贝克隆，则B可以很方便地实现深拷贝克隆。如C类里包含了B类型成员，D类型里包含了C类型成员…,以此类推，只要每个类型都实现了深拷贝克隆，那么<strong>最外层的包装类可以非常方便的实现深拷贝克隆</strong>。这就是第37页PPT里讲到的<strong>克隆的深度问题</strong><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    A a;    <span class="hljs-comment">//引用类型成员</span><br>    <span class="hljs-keyword">int</span> i;  <span class="hljs-comment">//值类型</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        B newObj = <span class="hljs-keyword">new</span> B();<br>        newObj.i = <span class="hljs-keyword">this</span>.i;   <span class="hljs-comment">//值类型成员直接=赋值</span><br>        newObj.a = (A)(<span class="hljs-keyword">this</span>.a.clone()); <span class="hljs-comment">//引用类型的成员不能直接赋值，必须调用clone方法，深拷贝</span><br>        <span class="hljs-keyword">return</span> newObj;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="多态性、动态绑定和对象的强制类型转换"><a href="#多态性、动态绑定和对象的强制类型转换" class="headerlink" title="多态性、动态绑定和对象的强制类型转换"></a>多态性、动态绑定和对象的强制类型转换</h2><ul><li>继承关系使一个子类可以继承父类的特征(属性和方法），并附加新特征</li><li>子类是父类的具体化（沿着继承链从祖先类到后代类，特征越来越具体；反过来，从后代类往祖先类回溯，越来越抽象）</li><li>每个<strong>子类的实例都是父类的实例</strong>（<strong>子类对象ISA父类</strong>），但反过来不成立  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class Student extends Person&#123; …&#125;<br>Person p = <span class="hljs-keyword">new</span> Student();<span class="hljs-comment">//OK 父类引用可直接指向子类对象</span><br>Student s = <span class="hljs-keyword">new</span> Person();<span class="hljs-comment">//error  子类引用不能指向父类对象</span><br></code></pre></div></td></tr></table></figure></li><li>这个特性是多态的重要基础  <blockquote><p>多态：通过引用变量调用实例函数时，根据所引用的实际对象的类型，执行该类型的相应实例方法，从而表现出不同的行为称为多态。通过<strong>继承</strong>时<strong>覆盖父类的实例方法实现多态</strong>。多态实现的原理：在<strong>运行时</strong>根据引用变量指向对象的实际类型，<strong>重新计算调用方法的入口地址（晚期绑定）。</strong></p></blockquote></li></ul><p>先看一个例子</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-comment">//父类</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Greeting</span><span class="hljs-params">()</span></span>&#123; <br>        System.out.println(<span class="hljs-string">&quot;Best wish from a person!&quot;</span>); <br>        &#125; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123; <span class="hljs-comment">//子类</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Greeting</span><span class="hljs-params">( )</span></span>&#123; <br>        System.out.println(<span class="hljs-string">&quot;Best wish from a employee!&quot;</span>);<br>        &#125; <br>    &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;   <span class="hljs-comment">//子类的子类</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Greeting</span><span class="hljs-params">( )</span></span>&#123; <br>            System.out.println(<span class="hljs-string">&quot;Best wish from a manager!&quot;</span>);<br>            &#125; <br>        &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingTest1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>       <span class="hljs-comment">//父类引用变量可以引用本类和子类对象，p1,p2,p3的声明类型都是Person(父类型），p2,p3执行子类对象</span><br>       Person p1= <span class="hljs-keyword">new</span> Person( ),p2= <span class="hljs-keyword">new</span> Employee( ),p3= <span class="hljs-keyword">new</span> Manager( );      <br>p1.Greeting( ); <span class="hljs-comment">//调用Person的Greeting()    ，由于实际指向对象类型是Person</span><br> p2.Greeting( ); <span class="hljs-comment">//调用Employee的Greeting()  ，由于实际指向对象类型是Employee</span><br> p3.Greeting( ); <span class="hljs-comment">//调用Manager的Greeting()   ，由于实际指向对象类型是Manager</span><br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//根据实际指向的类型，执行实际的实例方法</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingSender</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span> <span class="hljs-params">(Person p)</span></span>&#123; <br>        p.Greeting(); <span class="hljs-comment">//编译时应该是Person的Greeing</span><br>        &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingTest1</span></span>&#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>GreetingSender g = <span class="hljs-keyword">new</span> GreetingSender();<br>       g.newYearGreeting(<span class="hljs-keyword">new</span> Person()); <span class="hljs-comment">//调用Person的Greeting()</span><br>       g.newYearGreeting(<span class="hljs-keyword">new</span> Employee());<span class="hljs-comment">//调用Employee的Greeting()</span><br>       g.newYearGreeting(<span class="hljs-keyword">new</span> Manager());<span class="hljs-comment">//调用Manager的Greeting()</span><br>      &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>以最后一条语句为例来解释多态特性：<br>当<strong>实参new Manager()传给形参Person p</strong>时，<strong>等价于Person p = new Manager()</strong>, 因此执行p.Greeting()语句时根据形参p指向的对象的<strong>实际类型动态计算</strong>Greeting方法的入口地址，调用了Manager的Greeting()</p><ul><li><p>这段程序的微妙之处在于：</p><ul><li>GreetingSender类的newYearGreeting方法的参数是Person类型，那么<br>newYearGreeting的行为应该是Person对象的行为。</li><li>但是在实际运行时我们看到<strong>随着实参对象类型的变化</strong>， newYearGreeting<br>方法却表现出了多种不同的行为，这种机制称为多态</li></ul></li><li><p>仔细观察程序，可以发现产生多态的三个重要因素：</p></li></ul><ol><li>不同类之间有继承链</li><li>newYearGreeting方法的<strong>参数</strong>类型用的<strong>父类类型</strong></li><li>newYearGreeting调用的Greeting方法都被<strong>子类</strong>用自己的行为<strong>覆盖</strong><br>满足了这三个条件，用继承链中不同子类的对象做为方法的实参去调用方法会使该方法表现出不同的行为。由于子类的实例也是父类的实例，所以用子类对象作为实参传给方法中的父类型的形参是没有问题的。</li></ol><ul><li>多态条件：<strong>父类变量可引用本类和子类对象</strong>，子类对象isA父类对象</li><li>当调用<strong>实例方法</strong>时，由Java虚拟机动态地决定所调用的方法，称为动态绑定(dynamic binding)或者晚期绑定或者延迟绑定(lazy binding)或者多态。<br>假定对象o是类C1的实例，C1是C2的子类，C2是C3的子类，…，Cn-1是Cn的子类。也就是说，Cn是最一般的类，C1是最具体的类。在Java中，Cn是Object类。<br>如果调用继承链里子类型C1对象o的方法p，Java虚拟机按照C1、C2、…、Cn的顺序依次查找方法p的实现。一旦找到一个实现，将停止查找，并执行找到的第一个实现(覆盖的实例函数)。<br><img src="https://raw.githubusercontent.com/Trent-Liu/picture/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-03-29%20231337.png" alt="haha">  </li></ul><p>上例中，若p3指向Manager类的对象。当通过newYearGreeting(p3)方法去调用p3.Greeting()方法时，Java虚拟机会沿着继承链，从Manager类到父类查找Greeting的实现，结果找到Manager自己的实现<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-03-29%20231740.png?raw=true" alt="haha">  </p><p>若Employee覆盖了Greeting，而Manager没有覆盖，那么p3.Greeting()调用的是Employeede的  </p><h3 id="通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用"><a href="#通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用" class="headerlink" title="通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用"></a>通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用</h3><ul><li>由于父类变量可以引用子类对象，针对父类型设计的任何代码都可以<strong>应用于子类对象</strong>。  <ul><li>newYearGreeting(Person p){p.Greeting()}这段代码可以应用于所有Person子类型对象</li><li>多态性允许方法使用更通用的类作为参数类型。</li><li>如果方法参数是父类，那么这个参数可以接受任何子类对象作为实参。当调用这对象的方法时，将动态绑定方法的实现。<ul><li>newYearGreeting(Person p):该方法能接受从Person类型开始所有子类型对象作为实参</li><li>newYearGreeting(Manager p):该方法只能能接受从Manager类型开始所有子类型对象作为实参  </li></ul></li></ul></li></ul><p>哪个更好？<br>显然前者通用性更强。  </p><p>如果没有多态机制，针对Person，Employee及Manager类，我们必须写出三个重载版本的newYearGreeting函数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingSender</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span><span class="hljs-params">(Person p)</span></span>&#123; p.Greeting(); &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span><span class="hljs-params">(Employee e)</span></span>&#123; e.Greeting(); &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span><span class="hljs-params">(Manager m)</span></span>&#123; m.Greeting(); &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>假如我们新增加一个从Manager派生的CEO类，也实现了Greeting方法，我们需要增加一个新的newYearGreeing的重载版本。</li><li>更为糟糕的是，我们需要重新编译GreetingSender类。</li><li>回到第44页实现的多态版的GreetingSender类，可以适用于任何Person子类型，哪怕GreetingSender类作为商业类已经卖出去了，对后来新派生的CEO类型都可以不用重新编译地很好地工作</li></ul><hr><ul><li><p>父类变量引用子类对象，可视为将子类对象转换为父类（不需强制类型转换）。</p></li><li><p>类型转换(type casting)可以将一个对象的类型转换成继承链中的另一种类型。</p><ul><li>从子类到父类的转换是合法的，称为隐式转换。<br><code>Person p=new Manager();//将子类对象转换为父类对象</code></li><li>从父类到子类必须显式（强制）转换。<br><code>Manager m = p; //编译错 ，p是Person父类型，Person不一定是Manager</code><br><code>Manager m = (Manager)p;//ok，但转换前没有检查 </code>  </li><li>从父类到子类转换必须显式转换，转换前应进行检查更安全。<br><code>Manager m = null;</code><br><code>if(p instanceof Manager) m= (Manager)p; //安全：转换前检查 </code>  </li></ul></li><li><p>为什么从父类到子类转换必须强制类型转换？</p></li><li><p>首先要理解类型检查（type checking）发生在编译时</p></li><li><p>然后要理解Person p = new Manager()的真正涵义<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-03-29%20232726.png?raw=true" alt="haha">  </p></li><li><p>但是创建Manager对象并由p来引用是在运行时发生</p></li><li><p>因为程序还没运行，编译器无法知道p会指向什么对象，<strong>编译器在编译时只能根据变量p的声明类型（Person）来类型检查</strong></p></li><li><p>当编译器检查到 Manager m = p；编译器认为Person类型引用p要赋值给类型为Manager类型引用，扩展内存可能引起麻烦且不安全，因此，编译器认为类型不匹配，会报错。</p></li><li><p>加上强制转换 Manager m = (<strong>Manager</strong>)p；意思是强烈要求编译器，把p解释成Manager类型，风险我来承担。这个时候编译器就按Manager类型来解释p</p></li><li><p>因此，强制类型转换意味着你自己承担风险，编译器不会再做类型检查。</p></li><li><p>强制类型转换的风险是：运行时如果p指向的对象不是Manager的实例时程序会出错。</p></li><li><p>为了避免风险，最好用instanceof来做实例类型检查。</p></li></ul><h4 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h4><ul><li>可以用instanceof操作符判断一个引用指向的对象是否是一个类的实例。表达式返回boolean值。</li><li>语法  <div class="hljs code-wrapper"><pre><code>`referenceVariable  instanceof  TypeName`  </code></pre></div></li><li>所以上面的例子安全的写法为： <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Person p = <span class="hljs-keyword">new</span> Manager()<br><span class="hljs-keyword">if</span>（p <span class="hljs-keyword">instanceof</span> Manager）<br>Manager m = （Manager）p;<br></code></pre></div></td></tr></table></figure></li><li>意思是如果p指向的对象真的是Manager实例，再强制转换类型</li></ul><hr><ul><li>重载发生在编译时(Compile time)，编译时编译器根据实参比对重载方法的形参找到最合适的方法。</li><li>多态发生在运行(Run time)时，运行时JVM根据变量所引用的对象的真正类型来找到最合适的实例方法。</li><li>有的书上把重载叫做“编译时多态”，或者叫“早期绑定”(早期指编译时)。</li><li>多态是晚期绑定(晚期指运行时)</li><li>绑定是指找到函数的入口地址的过程。</li></ul><hr><ul><li>编写程序，创建两个几何对象：圆和矩形。调用displayObject来显示结果。<ul><li>如果对象是圆，显示半径和面积</li><li>如果对象是矩形，显示面积</li><li>警告: 对象访问运算符(.)优先于类型转换运算符。使用括号保证在(.)运算符之前转换<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">((Circle)object).getArea() <span class="hljs-comment">//OK</span><br>(Circle)object.getArea(); <span class="hljs-comment">//错误</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>实例方法覆盖</tag>
      
      <tag>Object中的方法</tag>
      
      <tag>clone的覆盖</tag>
      
      <tag>equals的覆盖</tag>
      
      <tag>！多态</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——继承和多态上</title>
    <link href="/2021/03/26/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <url>/2021/03/26/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>利用继承机制（提供了源代码重用机制，提高了<strong>开发效率</strong>（直接继承已有）同时也提高了软件可靠性：父类的代码如果经过了<strong>可靠性测试，我们通过继承机制可放心直接使用</strong>，只需要关注子类代码的实现）<br>总的来说，不需要重新写，而且父类可靠，继承下来的子类一定也可靠。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> salary;<br>    <span class="hljs-keyword">public</span> Date birthDate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDetails</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name; <span class="hljs-comment">//同名成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> salary; <span class="hljs-comment">//同名成员</span><br>    <span class="hljs-keyword">public</span> Date birthDate; <span class="hljs-comment">//同名成员</span><br>    <span class="hljs-keyword">public</span> String department;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDetails</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><span id="more"></span><p>以上两个类，Manager只比Employee多出了一个，其他的都重复定义。  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> salary;<br>    <span class="hljs-keyword">public</span> Date birthDate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDetails</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String department;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>继承就可以省去很多麻烦。  </p></li><li><p>语法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Superclass</span> </span>&#123;  <br>             <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">body</span></span><br><span class="hljs-class">      &#125;</span><br></code></pre></div></td></tr></table></figure><p>如果父类是Object，则extends部分可省略（前面的示例代码里，每个的父类都是Object)</p></li><li><p>如果class C1 extends C2，则称C1为子类(subclass)，C2为父类(superclass)。</p><ul><li>子类继承了父类中可访问的数据和方法，子类也可添加新的数据和方法，</li><li>子类不继承父类的<strong>构造函数</strong>。</li><li>一个类只能有一个直接父类（Java不支持多重继承，因为Java的设计者认为没有必要）。</li></ul></li><li><p>Java的继承都是公有继承，因此被继承的就是父类，继承的类就是子类。因此父类的成员如果被继承到子类，访问权限不变(public还是public，protected还是protected)<br>因此子类和父类是ISA关系：一个子类对象ISA父类对象</p></li></ul><h3 id="设计案例"><a href="#设计案例" class="headerlink" title="设计案例"></a>设计案例</h3><blockquote><p>假设要设计模拟几何对象的类，如圆和矩形，考虑的因素有颜色，是否填充，创建日期，圆的半径，矩形的周长等<br>不要直接就定义Class Circle和Class Rectangle,<strong>先分析几何对象的共同属性和行为</strong>。共同的属性和行为有颜色、是否填充，创建时间，以及这些属性的getter和setter行为。而圆的半径、矩形的长宽不是几何图形共有的属性。<br>可以设计<strong>通用类GeometricObject来模拟共有的属性和方法</strong>。而Circle、Rectangle类通过继承GeometricObject获得共同的属性和行为，同时添加自己特有的属性和行为  </p></blockquote><p>  如下设计一个通用类，定义了一些共同属性和方法,如图形的颜色，是否填充等</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeometricObject</span> </span>&#123; <span class="hljs-comment">//等价于public class GeometricObject extends Object</span><br>    <span class="hljs-keyword">private</span> String color = <span class="hljs-string">&quot;white&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> filled;<br>    <span class="hljs-keyword">private</span> Date dateCreated; <span class="hljs-comment">//java.util.Date是JDK定义的类，表示日期和时间</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GeometricObject</span><span class="hljs-params">()</span> </span>&#123; dateCreated = <span class="hljs-keyword">new</span> Date();&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> color; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(String color)</span> </span>&#123; <span class="hljs-keyword">this</span>.color = color;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFilled</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> filled; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFilled</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> filled)</span> </span>&#123; <span class="hljs-keyword">this</span>.filled = filled;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getDateCreated</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> dateCreated;&#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//覆盖Object类的toString()方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">( )</span> </span>&#123; <span class="hljs-comment">//还应考虑equals，clone</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;created on &quot;</span> + dateCreated + <span class="hljs-string">&quot;\n\tcolor: &quot;</span> + color<br>+ <span class="hljs-string">&quot; and filled: &quot;</span> + filled;<br>   &#125;<span class="hljs-comment">//toString方法应该返回一个描述当前对象的有意义的字符串</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>如下为这个通用类的继承类，只需要添加一些自己特有的东西就可以。比如圆的半径</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GeometricObject</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius; <span class="hljs-comment">//新增属性</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span> </span>&#123; &#125;   <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>&#123; <span class="hljs-keyword">this</span>.radius = radius; &#125; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> radius; &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRadius</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>&#123; <span class="hljs-keyword">this</span>.radius = radius; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> radius * radius * Math.PI;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getDiameter</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * radius;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPerimeter</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * radius * Math.PI;<br>&#125;<br>       <span class="hljs-comment">//还应考虑equals，clone，toString等函数</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>父类<br>私有属性： color  filled  dateCreated<br>公有方法： getColor  setColor IsFilled setFilled getDataCreated<br>GeometricObject的私有属性在子类中<br>不可见（即不能在子类里直接访问）<br>但可以通过所继承的get和set<br>方法设置和访问</p><h2 id="实例初始化模块"><a href="#实例初始化模块" class="headerlink" title="实例初始化模块"></a>实例初始化模块</h2><ul><li><p>初始化块是Java类中可以出现的第四种成员（前三种包括属性、方法、构造函数），分为实例初始化块和静态初始化块。</p></li><li><p>实例初始化模块（instance initialization block，IIB）是一个用<strong>大括号括住的语句块</strong>，直接<strong>嵌套于类体中</strong>，不在方法内。</p></li><li><p>它的作用就像把它放在了类中<strong>每个构造方法的最开始位置</strong>（也是为了省事，不用每个构造函数中都写一遍）。用于初始化对象。<strong>实例初始化块先于构造函数执行</strong>  （相当于C++成员初始化列表）</p></li><li><p>作用：如果<strong>多个构造方法共享一段代码</strong>，并且每个构造方法不会调用其他构造方法，那么可以把这段<strong>公共代码</strong>放在初始化模块中。</p></li><li><p>一个类可以有多个初始化模块，模块按照<strong>在类中出现的顺序</strong>执行  </p></li><li><p>作用</p></li></ul><ol><li>简化代码：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numOfObjects;<br>  <span class="hljs-keyword">private</span> String title<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(String title)</span></span>&#123;<br>    numOfObjects++;    <span class="hljs-comment">//一个</span><br>    <span class="hljs-keyword">this</span>.title = title;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>    numOfObjects++;  <span class="hljs-comment">//两个</span><br>    <span class="hljs-keyword">this</span>.id = id<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>和如下等价，只需要将构造函数中公共的部分放到块中。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numOfObjects;<br>  <span class="hljs-keyword">private</span> String title<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(String title)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.title = title;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.id = id<br>  &#125;<br>  <br>  &#123;<br>    numOfObjects++;   <span class="hljs-comment">//只需要这一个</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>截获异常<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-comment">//下面数据成员初始化语句可能会抛出异常，所以下面语句不成立</span><br>    <span class="hljs-keyword">private</span> InputStream fs = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(“C:\\<span class="hljs-number">1.</span>txt”));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>； <span class="hljs-comment">//InputStream fs是所有输入流的主线类</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-comment">//在实例初始化块里初始化数据成员可以截获异常</span><br>    <span class="hljs-keyword">private</span> InputStream fs = <span class="hljs-keyword">null</span>;<br>    &#123;<br>      <span class="hljs-keyword">try</span>&#123; fs = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(“C:\\<span class="hljs-number">1.</span>txt”));&#125;  <span class="hljs-comment">//试图执行，若无此文件会异常。</span><br>      <span class="hljs-keyword">catch</span>(Exception e)&#123; …&#125;                  <span class="hljs-comment">//解惑异常</span><br>    &#125;      <span class="hljs-comment">//任何一种面向对象语言都有try和catch</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>&#123; … &#125;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>实例初始化模块最重要的作用是当我们需要写一个内部匿名类时：匿名类不可能有构造函数，这时可以用实例初始化块来初始化数据成员<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISay</span></span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceInitializationBlockTest</span> </span>&#123;    <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <br>            ISay say = <span class="hljs-keyword">new</span> ISay()        <br>            &#123;   <span class="hljs-comment">//这里定义了一个实现了ISay接口的匿名类            </span><br>            <span class="hljs-comment">//final类型变量一般情况下必须马上初始化，一种例外是：final实例变量可以在构造函数里再初始化。            </span><br>            <span class="hljs-comment">//但是匿名类又不可能有构造函数，因此只能利用实例初始化块            </span><br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> j;  <span class="hljs-comment">//为了演示实例初始化块的作用，这里特意没有初始化常量j            </span><br>            &#123;                <br>                j = <span class="hljs-number">0</span>;  <span class="hljs-comment">//在实例初始化块里初始化j     final类型在实例初始化块中可以后赋值。       </span><br>            &#125;            <br>            <span class="hljs-meta">@Override</span>            <br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);&#125;        <br>            &#125;;        <br>            say.sayHello();    <br>        &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure></li></ol><ul><li>实例初始化模块只有在创建类的实例时才会调用。</li><li><strong>定义并初始化类的实例变量等价于实例初始化块</strong>：private int id = 0；</li><li>一个类可以有多个实例初始化块，对象被实例化时，模块按照在<strong>类中出现的顺序执行</strong>，构造函数最后运行。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;<span class="hljs-comment">//执行次序：1</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<span class="hljs-comment">//执行次序：4，构造函数最后运行</span><br>    <span class="hljs-keyword">this</span>.id = id<br>  &#125;<br>  <br>  &#123;<br>     <span class="hljs-comment">//实例初始化块//执行次序：2</span><br>  &#125;<br>  <br>  &#123;<br>     <span class="hljs-comment">//实例初始化块//执行次序：3</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="静态初始化模块"><a href="#静态初始化模块" class="headerlink" title="静态初始化模块"></a>静态初始化模块</h2><ul><li>静态初始化模块是由<strong>static修饰</strong>的初始化模块{}，只能访问类的静态成员，并且在JVM的Class Loader将类装入内存时调用。<strong>（类的装入和类的实例化是两个不同步骤，首先是将类装入内存，然后再实例化类的对象）。</strong></li><li>在类体里直接定义静态变量相当于静态初始化块<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>   <span class="hljs-comment">//类的属性和方法定义</span><br>   &#123;<br>     <span class="hljs-comment">//实例初始化模块</span><br>   &#125;<br><br>   <span class="hljs-keyword">static</span> &#123;<br>     <span class="hljs-comment">//静态初始化模块</span><br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//直接定义静态变量相当于静态初始化块</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>一个类可以有多个静态初始化块，类被加载时，这些模块按照在类中出现的顺序执行<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;<span class="hljs-comment">//执行次序：1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br> <span class="hljs-keyword">this</span>.id = id     <br>  &#125;<br>  <span class="hljs-keyword">static</span> &#123;<br>     <span class="hljs-comment">//静态初始化块//执行次序：2</span><br>  &#125;<br>  <span class="hljs-keyword">static</span> &#123;<br>     <span class="hljs-comment">//静态初始化块//执行次序：3</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="初始化模块的执行顺序"><a href="#初始化模块的执行顺序" class="headerlink" title="初始化模块的执行顺序"></a>初始化模块的执行顺序</h2><ul><li><p>第一次使用类时装入类（此时是装载进JVM）</p><ul><li>如果父类没装入则<strong>首先装入父类</strong>，这是个<strong>递归</strong>的过程，直到继承链上所有祖先类全部装入</li><li>装入一个类时，类的<strong>静态数据成员和静态初始化模块</strong>按它们在类中出现的顺序执行</li></ul></li><li><p>实例化类的对象</p><ul><li>首先<strong>构造父类对象</strong>，这是个<strong>递归</strong>过程，直到继承链上所有祖先类的对象构造好</li><li>构造一个类的对象时，按在类中出现的顺序执行<strong>实例数据成员的初始化及实例初始化模块</strong></li><li>执行<strong>构造函数</strong>函数体</li></ul></li><li><p>注意，如下语句等价</p><blockquote><p>如果声明类的实例变量时具有初始值，如</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">double</span> radius = <span class="hljs-number">5.0</span>；<br></code></pre></div></td></tr></table></figure><blockquote><p>变量的初始化就像在实例初始化模块中一样，即等价于</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">double</span> radius；<br>&#123; radius = <span class="hljs-number">5.0</span>；&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>如果声明类的静态变量时具有初始值，如</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numOfObjects = <span class="hljs-number">0</span>；<br></code></pre></div></td></tr></table></figure><blockquote><p>变量的初始化就像在静态初始化模块中一样，即等价于</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numOfObjects；<br><span class="hljs-keyword">static</span>&#123; numOfObjects = <span class="hljs-number">0</span>；&#125;<br></code></pre></div></td></tr></table></figure><p>在Java中，变量声明的位置是任意的（不同于C，定义必须在声明之后。）<br>因此声明类的实例/静态变量就相当于一个初始化块，按照实例和静态先后顺序完成。</p></li><li><p>下面举出一个案例，查看各个代码块的运行先后顺序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">N</span></span>&#123;      <span class="hljs-comment">//子类N</span><br>    N()&#123; System.out.println(<span class="hljs-string">&quot;(6) &quot;</span>); &#125;   <span class="hljs-comment">//子类N的构造函数</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;(5) &quot;</span>);    <span class="hljs-comment">//子类N的实例初始化模块</span><br>    &#125;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;(3) &quot;</span>);   <span class="hljs-comment">//子类N的静态初始化模块</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">N</span></span>&#123;     <span class="hljs-comment">//父类M</span><br>    M()&#123; System.out.println(<span class="hljs-string">&quot;(8) &quot;</span>); &#125;    <span class="hljs-comment">//父类M的构造函数</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;(7) &quot;</span>);     <span class="hljs-comment">//父类M的实例初始化模块</span><br>    &#125;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;(4) &quot;</span>);     <span class="hljs-comment">//父类M的静态初始化模块</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitDemo</span></span>&#123;<br>    InitDemo()&#123;<br>        <span class="hljs-keyword">new</span> M();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;(1) &quot;</span>);     <span class="hljs-comment">//main中第一条语句</span><br>  <span class="hljs-keyword">new</span> InitDemo();               <span class="hljs-comment">//实例化主类方法</span><br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;(2) &quot;</span>);   <span class="hljs-comment">//主类的实例初始化模块</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;(0) &quot;</span>);    <span class="hljs-comment">//主类的静态初始化模块</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>分析：<br>主类InitDemo是程序入口，因此先加载JVM，将Init的静态先初始化，输出0;<br>主类还没有实例化，因此还不需要运行主类的实例化初始模块，进入main，打印1;<br>new InitDemo()，实例化主类，运行主类的实例化初始模块，打印2;<br>主类的实例化初始模块都运行后，进入主类的构造函数。<br>构造函数中要第一次实例化M，而M是N的子类，因此要先将父类N的静态初始化模块加载，打印3<br>父类的静态模块加载后，加载子类M的静态模块，打印4<br>由于实例化了M，因此先实例化父类N，先加载父类N的实例初始化块，再加载父类N的构造函数，打印5，6。<br>实例化父类完成后，回到子类M，同样先实例化初始化块，再构造函数，打印7，8  </p></li></ul><p><strong>总之，若实例化一个类，那就按最原始的祖先直到它的顺序，加载它们的静态初始化块，递归完成。</strong><br><strong>然后由于实例化，需要不断实例化父类，还是按照最原始的祖先直到它的顺序，加载实例初始化块和构造函数</strong></p><p>在IDEA代码运行后得到结果为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-string">&quot;C:\Program Files\Java\jdk-15.0.2\bin\java.exe&quot;</span> <span class="hljs-string">&quot;-javaagent:E:\Download\IDEA\IntelliJ IDEA Community Edition 2020.3.2\lib\idea_rt.jar=2843:E:\Download\IDEA\IntelliJ IDEA Community Edition 2020.3.2\bin&quot;</span> -Dfile.encoding=UTF-<span class="hljs-number">8</span> -classpath E:\eclipse-workspace\JavaTest\out\production\Module01 InitDemo<br>(<span class="hljs-number">0</span>) <br>(<span class="hljs-number">1</span>) <br>(<span class="hljs-number">2</span>) <br>(<span class="hljs-number">3</span>) <br>(<span class="hljs-number">4</span>) <br>(<span class="hljs-number">5</span>) <br>(<span class="hljs-number">6</span>) <br>(<span class="hljs-number">7</span>) <br>(<span class="hljs-number">8</span>) <br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><ul><li><p>利用super可以显式调用父类的构造函数  </p><ul><li>super(parametersopt)调用<strong>父类的的构造函数</strong>。  </li><li>必须是子类构造函数的**第1条且仅1条语句(先构造父类)**。  </li><li>如果子类构造函数中没有显式地调用父类的构造函数，那么将<strong>自动调用父类不带参数的构造函数。</strong></li><li>父类的构造函数在子类构造函数<strong>之前</strong>执行。  </li></ul></li><li><p>访问父类的<strong>成员（包括静态和实例成员）</strong></p><ul><li>super<strong>不能用于静态</strong>上下文（即静态方法和静态初始化块里不能使用super），this也不能用于静态上下文</li><li>super.data（如果父类属性在子类可访问）</li><li>super.method(parameters)（如果父类方法在子类可访问（无限定词））</li><li>不能使用super.super.p()这样的super<strong>链</strong>（Java创造者认为没有必要）  </li></ul></li><li><p>如果子类中没有显式地调用父类的构造函数，那么将<strong>自动调用父类不带参数的构造函数</strong>，因为编译器会偷偷地在子类构造函数第一条语句前加上super() ；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> A（）&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>等价于</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> A（）&#123;<br>  <span class="hljs-keyword">super</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> A（<span class="hljs-keyword">double</span> d）&#123;<br><span class="hljs-comment">//some statements</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>等价于</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> A（<span class="hljs-keyword">double</span> d）&#123;<br>  <span class="hljs-keyword">super</span>();<br><span class="hljs-comment">//some statements</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>在任何情况下，构造一个类的实例时，会沿着继承链调用所有父类的构造方法，这叫构造方法链。<br>先构造最祖先的父类，依次往前调用，直到调用自己的。</li></ul><ol><li>如果一个类自定义了构造函数（不管有无参数），编译器不会自动加上无参构造函数。</li><li>如果一个类没定义任何构造函数，编译器会<strong>自动地</strong>加上无参构造函数。</li><li>编译器在为子类添加无参构造函数时，函数体里会用super( )默认调用父类的无参构造函数，<strong>如果找不到父类无参构造函数，则编译器为子类添加无参构造函数失败</strong>，编译报错。</li><li>如果一个类定义了带参数的构造函数，一定别忘了<strong>定义一个无参的构造函数</strong>，原因是：由于系统不会再自动加上无参构造函数，就造成该类没有无参构造函数</li></ol><ul><li>如果父类没有无参构造函数，那么子类构造函数里若调用父类无参构造函数就会编译出错。<br>以下为实例及解释<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fruit</span><span class="hljs-params">(String name)</span> </span>&#123;      <span class="hljs-comment">//父类，没有无参构造函数</span><br>System.out.println(<span class="hljs-string">&quot;调用Fruit的构造函数&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123; &#125;       <span class="hljs-comment">//子类</span><br></code></pre></div></td></tr></table></figure><blockquote><p>//编译器为Apple提供无参构造函数时出错<br>//子类Apple没定义任何构造函数，故编译为子类提供无参构造函数Apple();<br>//提供的Apple()会调用父类无参构造函数Fruit(),因下列原因无法调用：<br>//父类定义了有参构造函数，所以编译没有为父类提供无参Fruit( )。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>继承</tag>
      
      <tag>super关键字</tag>
      
      <tag>实例初始化模块&amp;静态初始化模块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——包以及方法重载、覆盖、隐藏</title>
    <link href="/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%E3%80%81%E9%9A%90%E8%97%8F/"/>
    <url>/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%E3%80%81%E9%9A%90%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li>包除了起到名字空间的作用外，还有个很重要的作用：提供了package一级的访问权限控制（在Java里，成员访问控制权限除了公有、保护、私有，还多了包一级的访问控制；类的访问控制除了public外，也多了包一级的访问控制）</li><li>包的命名习惯: 将Internet域名作为包名 （但级别顺序相反），这样的好处是<strong>避免包名的重复</strong><ul><li>org.apache.tools.zip</li><li>cn.edu.hust.cs.javacourse.ch1</li><li>如果所有程序员都遵循这种包命名的约定，包名重复的可能性就非常小</li></ul></li></ul><h2 id="方法的重载、覆盖、隐藏"><a href="#方法的重载、覆盖、隐藏" class="headerlink" title="方法的重载、覆盖、隐藏"></a>方法的重载、覆盖、隐藏</h2><ul><li>方法重载：同一个类中、或者父类子类中的多个方法具有<strong>相同的名字</strong>，但这些方法具有<strong>不同的参数列表</strong>(不含返回类型，即<strong>无法以返回类型</strong>作为方法重载的区分标准）<span id="more"></span></li><li>方法覆盖和方法隐藏：发生在<strong>父类和子类</strong>之间，<strong>前提是继承</strong>。子类中定义的方法与父类中的方法具有<strong>相同的方法名字、相同的参数列表、相同的返回类型</strong>（也允许子类中方法的返回类型是父类中方法返回类型的子类。<ul><li>方法覆盖：实例方法</li><li>方法隐藏：静态方法<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;&#125;<br><br><span class="hljs-comment">//下面语句报错m(int,int)已经定义, 重载要求参数列表不同,下图重构</span><br><span class="hljs-comment">//重载函数不能通过返回类型区分</span><br><span class="hljs-comment">//    public int m(int x, int y) &#123; return 0;&#125;; </span><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123; <span class="hljs-comment">//B继承了A</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y)</span> </span>&#123; &#125; <span class="hljs-comment">//重载了父类的m(int,int)和m(double,double)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;&#125; <span class="hljs-comment">//覆盖了父类的void m(int,int)，注意连返回类型都必须一致</span><br><br>    <span class="hljs-comment">//注意下面这个语句报错，既不是覆盖（与父类的void m(int,int)返回类型不一样）</span><br>    <span class="hljs-comment">// 也不是合法的重载（和父类的m(int,int)参数完全一样，只是返回类型不一致</span><br><span class="hljs-comment">//    public int m(int x, int y) &#123;&#125; //错误</span><br>    <br>    <span class="hljs-comment">//子类定义了新的重载函数int m()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>C++重载会报错，不认为子类定义会覆盖父类。<br>final关键字修饰的方法不可以被覆盖或隐藏。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m4</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-comment">//覆盖父类A的void  m1()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123; &#125;<br><br>    <span class="hljs-comment">//下面语句报错，不能覆盖父类的final 方法</span><br><span class="hljs-comment">//    public void m2()&#123; &#125;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123; &#125; <span class="hljs-comment">//隐藏了父类的static void m3()</span><br>    <span class="hljs-comment">//下面语句报错，父类final 静态方法不能被子类隐藏</span><br><span class="hljs-comment">//    public static void m4() &#123; &#125;</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>重载</tag>
      
      <tag>隐藏</tag>
      
      <tag>覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——对象</title>
    <link href="/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><ul><li><p>new创建对象  </p><ul><li>与基本数据类型一样，可声明并用new创建对象数组。<br>int[]a=new int[10];//所有元素缺省初值=0  </li><li>当创建对象数组时，数组元素的缺省初值为null。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Circle[] circleArray = <span class="hljs-keyword">new</span> Circle[<span class="hljs-number">10</span>]; <span class="hljs-comment">//这时没有构造Circle对象，只是构造数组,此时的circleArray[i]都指向null</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; circleArray.length; i++) &#123;<br>circleArray[i] = <span class="hljs-keyword">new</span> Circle( );    <span class="hljs-comment">//这时才构造Circle对象，可使用有参构造函数  </span><br>&#125;  <br></code></pre></div></td></tr></table></figure><span id="more"></span></li></ul></li><li><p>对象是引用变量，当new出的对象没有变量来引用时，该对象会由JVM自动回收。</p></li><li><p>对象引用，可以</p><ul><li><p>访问实例变量 c2.radius</p></li><li><p>调用对象的实例方法 c2.rindArea();</p></li><li><p>实例对象也可以访问静态成员和静态方法，但是很不推荐，<strong>静态建议用类名来访问</strong>。</p></li></ul></li><li><p>匿名对象也可访问实例(或静态)成员：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">new</span> Circle( ).radius=<span class="hljs-number">2</span>;<br></code></pre></div></td></tr></table></figure></li><li><p> 在实例方法中有个this引用，代表当前对象(引用当前对象：相当于指针)，因此在实例方法里，可以用this引用访问当前对象成员</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> radius = <span class="hljs-number">1.0</span>;<br><br>    Circle() &#123;  <br>radius = <span class="hljs-number">1.0</span>;<br>    &#125;<br><br>    Circle(<span class="hljs-keyword">double</span> r) &#123;    <span class="hljs-comment">//this可以省略，this就指当前对象</span><br>        <span class="hljs-keyword">this</span>.radius = r;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findArea</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> radius * radius * Math.PI;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRadius</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newRadius)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.radius = newRadius;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSimpleCircle</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Circle c1 = <span class="hljs-keyword">new</span> Circle();<br>        System.out.println(<span class="hljs-string">&quot;Area = &quot;</span> + c1.findArea() + <br>                <span class="hljs-string">&quot;, radius = &quot;</span> + c1.radius);   <span class="hljs-comment">//c1调用类中方法，当进入c1对象时，this就自动赋值，变成c1</span><br><br>        Circle c2 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">10.0</span>);<br>        System.out.println(<span class="hljs-string">&quot;Area = &quot;</span> + c2.findArea() + <br>                <span class="hljs-string">&quot;, radius = &quot;</span> + c2.radius);<br><br>        <span class="hljs-comment">//modify radius</span><br>        c2.setRadius(<span class="hljs-number">20.0</span>);<br>        System.out.println(<span class="hljs-string">&quot;Area = &quot;</span> + c2.findArea() + <br>                <span class="hljs-string">&quot;, radius = &quot;</span> + c2.radius);  <span class="hljs-comment">//c2调用，进入对象调用值时，this就自动变成c2</span><br>    &#125;<br></code></pre></div></td></tr></table></figure></li><li><p>this引用指向调用某个方法的当前对象</p><ul><li>在实例方法中，实例变量被同名局部变量或方法形参隐藏，可以通过this.instanceVariable访问实例变量。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;<br>   <span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> k = <span class="hljs-number">0.0</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setI</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;   <span class="hljs-comment">//i为局部变量，若不加下面的this，调用完后上面i的值不变，</span><br>                       <span class="hljs-comment">//this.i指的是上面的i,i则是方法的形参i</span><br>      <span class="hljs-keyword">this</span>.i= i;<br>   &#125;<br><br>   Foo f1 =<span class="hljs-keyword">new</span> Foo();<br>Foo f2 = <span class="hljs-keyword">new</span> Foo();<br><br>f1.setI(<span class="hljs-number">10</span>);<span class="hljs-comment">//这时this引用f1</span><br>f2.setI(<span class="hljs-number">45</span>);<span class="hljs-comment">//这时this引用f2</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>调用当前类的其它构造函数，需防止递归调用。</p></li><li><p>对象的参数传递</p><ul><li>基本数据类型传递的是实际值的拷贝，传值后形参和实参不再相关：修改形参的值，不影响实参。</li><li>引用类型变量传递的是对象的引用，通过形参修改对象object，将改变实参引用的对象object。</li><li>Java无类似C++的&amp;或者C#的ref来修饰方法参数，只能靠形参的声明类型来区分是传值还是传引用，因此一定要区分。</li></ul></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>对象</tag>
      
      <tag>this</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——构造函数</title>
    <link href="/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><ul><li><strong>无返回类型</strong>（包括void，void也是返回类型：无返回值），名字与类名相同，用于初始化对象。  <blockquote><p>注意的是构造函数是对象一建立就运行，给对象初始化，包括属性、方法中的语句。只<strong>运行一次</strong><br>而一般函数是对象调用才执行，用“.方法名”的方式。</p></blockquote></li><li>注意JAVA如果类名前加了void，定义void className(…),被认为是普通方法，而不是构造函数。（如果是C++语言，这样写void 类名 会报错）</li><li>只在new时被自动执行，不可以被显示调用（<del>.构造函数（）</del>）。</li><li>必须是实例方法（无static），可为公有、保护、私有和包级权限。</li><li>类的变量为引用(相当于C指针)，指向实例化好的对象。  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Circle c2=<span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5.0</span>);<span class="hljs-comment">//调用时必须有括弧,可带参初始化</span><br></code></pre></div></td></tr></table></figure><span id="more"></span></li><li>缺省构造函数(同C++)  <blockquote><p>如果类未定义任何构造函数，编译器会自动提供一个不带参数的默认构造函数。<br>如果已自定义构造函数，则<strong>不会提供默认构造函数</strong>。<br>因此如果程序员定义了一个带参数的构造函数，最好再定义一个不带参数的构造函数。</p></blockquote></li><li>Java没有析构函数，但垃圾自动回收之前会自动调用finalize( ),可以覆盖定义该函数（但是finalize调用时机程序员无法控制，C++则需要手动调用）。  </li><li>如果定义了构造函数和一个与类名相同的方法  </li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructorTest</span> </span>&#123;<br>  <span class="hljs-comment">//构造函数前面不能有void   </span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConstructorTest</span><span class="hljs-params">()</span> </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;constructor&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//如果和类名同名函数前面加了void(可返回任何类型), 编译器看成是普通函数，这和C++不一样 </span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConstructorTest</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;normal instance method return void&quot;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">ConstructorTest</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d)</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;normal method return double&quot;</span>);<br>      <span class="hljs-keyword">return</span> d;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String ... args)</span></span>&#123;<br><span class="hljs-comment">//先调用构造，再调用void ConstructorTest() </span><br>      <span class="hljs-keyword">new</span> ConstructorTest().ConstructorTest();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意上图中，先调用了构造函数后，紧接着调用普通函数。</p><ul><li>注意在构造函数中调用构造函数，需要防止递归调用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>构造函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——修饰符</title>
    <link href="/2021/03/23/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2021/03/23/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><hr><ul><li>修饰变量：  <blockquote><p><strong>未用static修饰的成员变量</strong>，属于类的具体实例（对象），只能通过对象访问，如“对象名.变量名”<br><strong>使用static修饰的变量</strong>，被类的所有实例（对象）<strong>共享</strong>，也称类变量。可以通过对象或类名访问，提倡“类名.变量名”访问。<br>实际上，实例变量是作为对象内存的一部分存在，每new一个对象，内存中就分配一个无静态变量的对象。<br>静态变量是<strong>单独的内存单元</strong>，与对象内存分开，任何对象都可访问。而且此内存单元不需要实例化方法，事先分配。被所有对象共享。</p></blockquote></li></ul><hr><span id="more"></span><ul><li>修饰方法  <blockquote><p><strong>静态方法</strong>：用static修饰的方法。<br>静态方法只能访问类的静态成员（因为实例成员必须有实例才存在，当通过类名调用静态方法时，可能该类还没有一个实例）<br>静态方法无多态性（无this引用）<br>静态方法，方法名和类名都可以调用<br>每个程序必须有<strong>piblic static void main(String[])</strong> 方法</p></blockquote></li></ul><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li>实例常量：没有用static修饰的final常量。<br>静态常量：使用static修饰的final常量。<br>如 public static final double PI =3.13315….</li><li>常量不可以用等号赋值修改，由于不能修改，故通常定义为public</li><li>final还可以修饰方法：<br>修饰实例方法：表示该方法不可以被子类覆盖。<br>修饰静态方法：表示该方法不能被子类隐藏。</li><li>构造函数不可以为final</li></ul><hr><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><ul><li>修饰成员变量  <blockquote><p>被private修饰的变量和方法，只能在自己对象<strong>内部</strong>使用<br>面向对象的<strong>封装性</strong>要求最好把实例成员变量设为私有的或保护的<br>为私有、保护的实例成员变量提供公有的<strong>get</strong>和<strong>set</strong>方法。get和set方法遵循JavaBean的命名规范  </p></blockquote>DataType为私有成员  </li><li><strong>get获取成员值</strong>  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> DataType <span class="hljs-title">getPropertyName</span><span class="hljs-params">()</span>   </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">return</span> a;  <br>&#125;  <br></code></pre></div></td></tr></table></figure></li><li><strong>set设置成员值</strong>  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPropertyName</span><span class="hljs-params">(DataType value)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    value =xx;  <br>&#125; <br></code></pre></div></td></tr></table></figure></li></ul><blockquote><p>封装起来，防止程序员写出类似o.radius=-100（radius要求&gt;0）这样的错误值，类是给别人使用的，要防止别人乱写，因此将这个元素封装起来，起控制作用。<br>  可以在上面set中添加if判断条件语句，保证一定设置正值。<br>    另一应用:<strong>计数器</strong>  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius;<br>    <span class="hljs-comment">/** 私有静态变量，记录当前内存里被实例化的Circle对象个数*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numberOfObjects = <span class="hljs-number">0</span>; <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span> </span>&#123; radius = <span class="hljs-number">1.0</span>; numberOfObjects++; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newRadius)</span> </span>&#123; radius = newRadius; numberOfObjects++; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> radius;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRadius</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newRadius)</span> </span>&#123; radius = newRadius;&#125;<br>    <span class="hljs-comment">/** 公有静态方法，获取私有静态变量内容*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumberOfObjects</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> numberOfObjects;&#125;<br><br>    <span class="hljs-comment">/** Return the area of this circle */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findArea</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> radius * radius * Math.PI; &#125;<br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-comment">/*覆盖从Object继承的finalize方法，该方法在对象被回收时调用，方法里对象计数器-1。</span><br><span class="hljs-comment">    注意该方法调用时机不可控制。</span><br><span class="hljs-comment">    @Override是注解（annotation），告诉编译器这里是覆盖父类的方法。*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        numberOfObjects--; <span class="hljs-comment">//对象被析构时，计数器减1</span><br>        <span class="hljs-keyword">super</span>.finalize();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>private static构造计数器，在每个重载的构造函数里计数器+1。  </p></blockquote><p>  @Override可以不加，但是使用@Override注解有如下好处：<br>1：可以当注释用,方便阅读；<br>2：编译器可以给你验证@Override下面的方法名是否是父类中所有的，如果没有则报错。例如，如果没写@Override，而下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。</p><p>Java注解为 Java 代码提供元数据。注解可以指示编译器做些额外的动作，甚至可以自定义Java注解让编译器执行自定义的动作。Java提供了Annotation API让我们自定义注解。</p><h2 id="类的成员访问控制符"><a href="#类的成员访问控制符" class="headerlink" title="类的成员访问控制符"></a>类的成员访问控制符</h2><blockquote><p>private：只能被当前类定义的函数访问。<br>包级：无修饰符的成员，可以被同一包中的类访问。<br>protected： 子类 ，同一包中的类的函数可以访问。<br>public： 所有类的函数都可以访问。<br>以上访问权限由小到大。<br>后两者可以被子类访问。继承会自动继承除私有成员外的父类成员。<br>子类类体可以访问从父类继承来的protected成员。如果子类和父类不在一个包里，子类不能访问另外的父类实例（非继承）的protected成员。  </p></blockquote><table><thead><tr><th>访问权限</th><th>本类</th><th>本包</th><th>子类</th><th>它包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>包级</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h2><ul><li>有一些对象只需要一个，并且可以在需要时才开始创建对象，保证只有一对象被创建。<br>不能在外部创建对象，只能在类的内部<br>可以定义全局变量，但是全局变量会在程序一开始就创建好，如果该对象在程序执行过程中对资源消耗非常大且使用率不高，就非常累赘。  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>  </span><br><span class="hljs-class"></span>&#123;  <br>　　　<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance =<span class="hljs-keyword">null</span>;  <br>  <br>  <br>  <span class="hljs-comment">//其他的实例变量  </span><br>    <br>    <span class="hljs-comment">//构造方法是私有的，所以在类外不能new出多个实例  </span><br> 　　　<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">singleton</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"> 　　 </span>&#123;  <br> 　　 &#125;<br>　　　<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">　　 </span>&#123;  <br> 　　　　　 <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-keyword">null</span>)  <br> <span class="hljs-comment">//如果为null，就创建对象，否则不创建，直接在下面返回已经存在的对象  </span><br> 　　　 &#123;  <br>  　　　　　　　  uniqueInstance == <span class="hljs-keyword">new</span> Singleton();  <br>  　　　 &#125;  <br>  　　　 <span class="hljs-keyword">return</span> uniqueInstance;  <br>&#125;  <br></code></pre></div></td></tr></table></figure>//调用的时候，我们可以通过<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Singleton uniqueInstance = Singleton.getInstance();  <br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance =<span class="hljs-keyword">null</span>;<span class="hljs-keyword">static</span>，<span class="hljs-comment">//静态变量，是所有实例化对象共有的  </span><br> <span class="hljs-comment">// 就算构造多个对象，它们指向的都是一个实例对象。</span><br></code></pre></div></td></tr></table></figure></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>单件模式</tag>
      
      <tag>计数器</tag>
      
      <tag>访问控制符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自述</title>
    <link href="/2021/03/23/%E8%87%AA%E8%BF%B0/"/>
    <url>/2021/03/23/%E8%87%AA%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="自述"><a href="#自述" class="headerlink" title="自述"></a>自述</h1><p>一名普通的Huster。<br>在卷饼中比较佛系的度日。<br>有一段很稳定的恋爱。<br>有些不甘平凡却能力有限。<br>写博客主要为了整理笔记，其中学习相关的东西均来自华中科技大学的课堂，非原创。<br>也会在其中分享一些日常。</p>]]></content>
    
    
    <categories>
      
      <category>大学生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
