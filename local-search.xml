<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CodeTop</title>
    <link href="/2022/03/07/CodeTop/"/>
    <url>/2022/03/07/CodeTop/</url>
    
    <content type="html"><![CDATA[<h5 id="1翻转链表"><a href="#1翻转链表" class="headerlink" title="1翻转链表"></a>1翻转链表</h5><ol><li>迭代</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++剑指offer2</title>
    <link href="/2022/03/03/C++%E5%89%91%E6%8C%87offer2/"/>
    <url>/2022/03/03/C++%E5%89%91%E6%8C%87offer2/</url>
    
    <content type="html"><![CDATA[<h5 id="剑指offer-001-整数除法"><a href="#剑指offer-001-整数除法" class="headerlink" title="剑指offer 001 整数除法"></a>剑指offer 001 整数除法</h5><p>要点在于掌握int型数据的存储</p><p>正负数的边界不同，0x8000 0000表示最小的负数-2^-31，不存在对应的正数，而其他的负数均存在对应的正数，因此可以先单独处理结果为2^31，即那个不存在的最大正数的情况，被除数应该是INI_MIN，除数应该是-1，结果应返回INT_MAX</p><p>除此之外，由于负数的范围比正数大1，因此可以先将正数转化为负数，对两个负数进行除法，最后再进行符号的调整。</p><p>由于题目中不可以使用*，/，%，我们考虑使用减法来实现除法，即不断减去二的倍数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-comment">//第一种情况，首先排除结果为2^31，即int型无法表示的最大正数的情况</span><br>        <span class="hljs-keyword">if</span> (a == INT_MIN &amp;&amp; b== <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> INT_MAX;<br>        &#125;<br>        <span class="hljs-comment">//保存最终结果的符号，只有当一正一负，最终结果是负数</span><br>        <span class="hljs-keyword">int</span> flag = (a &gt; <span class="hljs-number">0</span>) ^ (b &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//再将正数的被除数或者除数转化为正数</span><br>        <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>) &#123;<br>            a = -a;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>            b = -b;<br>        &#125;<br><br>        <span class="hljs-comment">//这里设置res的类型为unsigned是必须的，考虑下面商绝对值的结果是2^31的情况</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//只要被除数仍然小于等于除数（负数），则还可以继续除</span><br>        <span class="hljs-keyword">while</span> (a &lt;= b) &#123;<br>            <span class="hljs-comment">//计算本轮，被除数剩下的部分等于2的多少倍的除数</span><br>            <span class="hljs-keyword">int</span> value = b;<br>            <span class="hljs-keyword">int</span> quotient = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//这里限定每轮value的值大于等于0xc0000 0000 是必要的，如果小于，且仍大于被除数，则这一轮value+value就会越界。</span><br>            <span class="hljs-keyword">while</span> (value &gt; <span class="hljs-number">0xc0000000</span> &amp;&amp; a &lt;= value + value) &#123;<br>                quotient += quotient;<br>                value += value;<br>            &#125;<br>            res += quotient;<br>            a -= value;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> flag == <span class="hljs-number">1</span> ? res : -res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-002-二进制加法"><a href="#剑指offer-002-二进制加法" class="headerlink" title="剑指offer 002 二进制加法"></a>剑指offer 002 二进制加法</h5><p>最朴素的思想，从字符串最末端，即表示的二进制的第0位开始进行运算，记录进位端以及每次运算的结果</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">addBinary</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b)</span> </span>&#123;<br>        <span class="hljs-built_in">string</span> res;<br>        <span class="hljs-keyword">int</span> i = a.size() - <span class="hljs-number">1</span>;   <span class="hljs-comment">//二进制串a的末端开始</span><br>        <span class="hljs-keyword">int</span> j = b.size() - <span class="hljs-number">1</span>;   <span class="hljs-comment">//二进制串b的末端开始</span><br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;      <span class="hljs-comment">//进位端</span><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry !=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//当二进制串a没有运算完，计算当前位是1还是0，否则为0</span><br>            <span class="hljs-keyword">int</span> tempa = i &gt;=<span class="hljs-number">0</span> ? a[i--] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//二进制串b同理</span><br>            <span class="hljs-keyword">int</span> tempb = j &gt;=<span class="hljs-number">0</span> ? b[j--] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">char</span> temp_result = tempa + tempb + carry;<br>            carry =  temp_result / <span class="hljs-number">2</span>;<br>            res += to_string(temp_result%<span class="hljs-number">2</span>);<br><br>        &#125;<br>        reverse(res.begin(), res.end());<br>        <span class="hljs-keyword">return</span> res;<br>        <br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>to_string() 将数字量转化为字符串</p><p>res.append(stirng) 等价于 res += string</p><p>字符串中push_back(char)的参数是char型的</p><h5 id="剑指offer-003-前n个数字二进制中1的个数-动态规划"><a href="#剑指offer-003-前n个数字二进制中1的个数-动态规划" class="headerlink" title="剑指offer 003 前n个数字二进制中1的个数 动态规划"></a>剑指offer 003 前n个数字二进制中1的个数 动态规划</h5><p>可以很轻松的看出这道题可以通过动态规划解决，将所有2的倍数为界限，按区域划分即可，比如4的二进制表示为0100，8的二进制表示为1000，对于4到8之间的数，比如7，只需要7-4=3，3的二进制表示为0011，7的二进制表示为0111，7二进制中1的个数就是4的个数加（7-4）的个数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">int</span> boundary = <span class="hljs-number">1</span>;<br>        res[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == boundary * <span class="hljs-number">2</span>) &#123;<br>                res[i] = <span class="hljs-number">1</span>;<br>                boundary *= <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res[i] = <span class="hljs-number">1</span> + res[i - boundary];<br>            &#125;<br><br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-004-只出现一次的数字"><a href="#剑指offer-004-只出现一次的数字" class="headerlink" title="剑指offer 004 只出现一次的数字"></a>剑指offer 004 只出现一次的数字</h5><p>方法1： 哈希表，很容易想到，只需要统计每个数字出现的次数，从中找到只出现1次的数字就可以</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num: nums) &#123;<br>            ++<span class="hljs-built_in">map</span>[num];<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> freq : <span class="hljs-built_in">map</span>) &#123;<br>            <span class="hljs-keyword">if</span> (freq.second == <span class="hljs-number">1</span>) &#123;<br>                ans = freq.first;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。</p><p>方法2</p><p>由于除了需要寻找的那个数字，其他数字均出现三次，因此我们可以按位求出所要的结果</p><p>为求结果的某一位，将所有数字的这一位相加，除了答案的数字，其他数字的这一位均出现3此，相加值为0或者3，因此一定是3的倍数，只需要将最终结果%3，就可以只剩下所要求结果的那一位。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> tmp_ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> tmp_tool = <span class="hljs-number">1</span> &lt;&lt; i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>                tmp_ans += (num &amp; tmp_tool) &gt;&gt; i;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tmp_ans % <span class="hljs-number">3</span>) &#123;<br>                ans |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-005-单词长度的最大乘积"><a href="#剑指offer-005-单词长度的最大乘积" class="headerlink" title="剑指offer 005 单词长度的最大乘积"></a>剑指offer 005 单词长度的最大乘积</h5><p>要找到两个不包含相同字符的字符串，最直接的想法是对于每一个字符串进行循环比较，然而这种方法的时间复杂度过于复杂，很不适合。</p><p>考虑到只需要比较是否存在相同字符，我们可以采用二进制存储的方法，当某个字符串中出现某个字符，就保存在某一位，最后比较两个字符串是否有公共字符，只需要进行与操作即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; b_words;<br>        <span class="hljs-comment">//构建出一个数组，存放每个字符串的字符存在情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> word : words) &#123;<br>            <span class="hljs-keyword">int</span> b_tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word) &#123;<br>                b_tmp |= <span class="hljs-number">1</span> &lt;&lt; (c-<span class="hljs-string">&#x27;a&#x27;</span>);<br>            &#125;<br>            b_words.push_back(b_tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.size(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; words.size(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (b_words[i] &amp; b_words[j]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">int</span> tmp = words[i].size() * words[j].size();<br>                    res = res &gt; tmp ? res : tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-006-排序数组中的两个数字之和"><a href="#剑指offer-006-排序数组中的两个数字之和" class="headerlink" title="剑指offer 006 排序数组中的两个数字之和"></a>剑指offer 006 排序数组中的两个数字之和</h5><p>给定的数组已经完成排序，因此思路很容易得到，使用双指针法，从左右两端进行比较</p><p>如果当前数字和大于target，右指针向左移动，如果当前数字和小于target，左指针向右移动。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = numbers.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] == target) &#123;<br>                <span class="hljs-keyword">return</span> &#123;left,right&#125;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] &gt; target) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-007-数组中和为0的三个数"><a href="#剑指offer-007-数组中和为0的三个数" class="headerlink" title="剑指offer 007 数组中和为0的三个数"></a>剑指offer 007 数组中和为0的三个数</h5><p>这道题看上去复杂，实际上和上一道题有很大的相似度</p><p>可以先对数组进行排序，然后固定一个元素nums[i]，将之后的元素按照双指针法，寻找两数和为-nums[i]的位置即可，但是这道题没有上一道题不存在重复元素的限制，因此为了提高效率，可以进行一定的去重处理，其实只要遇见与上一个数字重复的数字，直接跳过即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; threeSum(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">if</span> (nums.size() &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        <span class="hljs-comment">//排序</span><br>        sort(nums.begin(), nums.end());<br><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">//首先要确定第一个值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size()<span class="hljs-number">-2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//接下来只需要用双指针法找结果为target的组合</span><br>            <span class="hljs-keyword">int</span> target = -nums[i];<br>            <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>, right = nums.size() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span> (nums[left] + nums[right] == target) &#123;<br>                    res.push_back(&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-comment">//当遇见重复时需要跳过</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[++left]);<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[--right]);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] + nums[right] &gt; target) &#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    left++;<br>                &#125;<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-008-和大于等于target的最短子数组"><a href="#剑指offer-008-和大于等于target的最短子数组" class="headerlink" title="剑指offer 008 和大于等于target的最短子数组"></a>剑指offer 008 和大于等于target的最短子数组</h5><p>方法一可以使用双指针——滑动窗口法，逐渐后移，求出每个以当前尾指针为末尾的最短的符合条件的子数组。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = nums.size();<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = INT_MAX;<br>        <span class="hljs-keyword">while</span> (end &lt; length) &#123;<br>            <span class="hljs-comment">//尾指针后移，同时sum增加尾指针对应的新元素</span><br>            sum += nums[end];<br>            <span class="hljs-comment">//当此时的子数组已经满足条件，则逐渐回缩头指针，直到找到以当前尾指针为末尾的子数组的最短长度</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                ans = min(ans, end - start + <span class="hljs-number">1</span>);<br>                sum -= nums[start];<br>                start++;<br>            &#125;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == INT_MAX ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-009-乘积小于K的子数组"><a href="#剑指offer-009-乘积小于K的子数组" class="headerlink" title="剑指offer 009 乘积小于K的子数组"></a>剑指offer 009 乘积小于K的子数组</h5><p>上一道题要求出的是最短子数组，而这道题要求出成绩小于K的所有子数组，我们还是使用双指针法，求出每个以当前尾指针为末尾的那个最大的符合条件的子数组，然后只需要增加当前尾指针为末尾的新增的子数组数量。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSubarrayProductLessThanK</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = nums.size();<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; length) &#123;<br>            sum *= nums[end];<br>            <span class="hljs-comment">//这里start &lt;= end是必要的，因为可能存在k为0的情况，此时若不加此限制条件，start将一直增加，直到越界。</span><br>            <span class="hljs-keyword">while</span> (start &lt;= end &amp;&amp; sum &gt;= k) &#123;<br>                sum /= nums[start];<br>                start++;<br>            &#125;<br>            <span class="hljs-comment">//找到以end为尾指针的最长子数组，则只需要增加以end为末尾的所有满足条件的子数组数量，共end - start + 1 个</span><br>            ans += end - start + <span class="hljs-number">1</span>;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-010-和为k的子数组"><a href="#剑指offer-010-和为k的子数组" class="headerlink" title="剑指offer 010 和为k的子数组"></a>剑指offer 010 和为k的子数组</h5><p>同样是求连续的子数组，但是数组中出现了负数，则这种情况不能使用滑动窗口</p><p>滑动窗口的条件是while窗口内元素超过或者不满足条件时，进行移动，如果数组存在了负数，则我们无法决定左移动还是右移动。</p><p>一种场景存在多种可能，就使用数组中另一种常用的算法——前缀和。</p><p>前缀和的思想是，申请一个哈希表，遍历数组，对于遍历到的每个元素，存入这个元素之前所有元素的和，并且查找此时哈希表中有没有当前前缀和-目标的值，若存在，说明中间存在这一段满足要求。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;<br>        <span class="hljs-built_in">map</span>.insert(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历所有的前缀和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            sum += num;<br>            <span class="hljs-comment">//查看此时哈希表中之前有没有存入前缀和为sum-k的情况，如果有，就存在子数组的和为k</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.count(sum - k)) &#123;<br>                res += <span class="hljs-built_in">map</span>[sum - k];<br>            &#125;<br>            <span class="hljs-comment">//存入当前位置前缀和的值</span><br>            <span class="hljs-built_in">map</span>[sum]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>map::count()是C++ STL中的内置函数，如果在映射容器中存在带有键K的元素，则该函数返回1。如果容器中不存在键为K的元素，则返回0。</p><h5 id="剑指offer-011-0和1个数相同的子数组"><a href="#剑指offer-011-0和1个数相同的子数组" class="headerlink" title="剑指offer 011 0和1个数相同的子数组"></a>剑指offer 011 0和1个数相同的子数组</h5><p>一个思路是既然要求0和1个数相同的子数组，不妨将0看成-1，问题就转化为求和为0的子数组</p><p>采用上题的思路，对于这种前缀和问题仍然需要补充一个起始点，</p><p>求最长前缀和，对于每种出现的和的情况，只需要保存最早出现的那个。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxLength</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;<br>        <span class="hljs-comment">//初始边界</span><br>        <span class="hljs-built_in">map</span>.insert(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-comment">//计算前缀和，0当成-1</span><br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count--;<br>            &#125;<br>            <span class="hljs-comment">//若之前保存的前缀和中存在这个和，则计算当前最大长度</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.count(count)) &#123;<br>                res = max(res, i - <span class="hljs-built_in">map</span>[count] + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//每种前缀和只需要保存最早出现的</span><br>                <span class="hljs-built_in">map</span>.insert(&#123;count, i+<span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-012-左右两边子数组的和相等"><a href="#剑指offer-012-左右两边子数组的和相等" class="headerlink" title="剑指offer 012  左右两边子数组的和相等"></a>剑指offer 012  左右两边子数组的和相等</h5><p>求一个中心下标，即这个下标的左右两侧的元素的和相等，我们想到的思路是</p><p>首先计算所有元素的和，只需要进行一次遍历，找到某个位置，这个位置左边元素和的两倍等于所有元素和减去当前位置的值</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//计算总和</span><br>        <span class="hljs-keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> cursum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-comment">//当前位置的前一个位置的所有和的两倍是否等于综合减当前位置。</span><br>            <span class="hljs-keyword">if</span> (cursum * <span class="hljs-number">2</span> == sum - nums[i]) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            cursum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>accumulate函数将一段数字从头到尾累加起来，或者使用指定的运算符进行运算<br> accumulate函数的前两个参数指定累加的范围，第三个参数为累加的初值，第四个参数为进行的操作，默认为累加<br> 使用accumulate要添加<code>#include&lt;numeric&gt;</code></p><h5 id="剑指offer-013-二维子矩阵的和"><a href="#剑指offer-013-二维子矩阵的和" class="headerlink" title="剑指offer 013 二维子矩阵的和"></a>剑指offer 013 二维子矩阵的和</h5><p>很无聊，左上角和右下角的标度不一样是实在没想到</p><p>Matrix.resize(m+1, vector<int>(n+1));</int></p><p>vector&lt;vector&lt;int&gt;&gt;的重新设置大小</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    NumMatrix(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix) &#123;<br>        <span class="hljs-keyword">int</span> m = matrix.size();<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">if</span> (m != <span class="hljs-number">0</span>) &#123;<br>            n = matrix[<span class="hljs-number">0</span>].size();<br>            Matrix.resize(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                Matrix[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = Matrix[i+<span class="hljs-number">1</span>][j] + Matrix[i][j+<span class="hljs-number">1</span>] + matrix[i][j] - Matrix[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Matrix[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>] -Matrix[row2+<span class="hljs-number">1</span>][col1] - Matrix[row1][col2+<span class="hljs-number">1</span>] + Matrix[row1][col1];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; Matrix;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-014-字符串中的变位词"><a href="#剑指offer-014-字符串中的变位词" class="headerlink" title="剑指offer 014 字符串中的变位词"></a>剑指offer 014 字符串中的变位词</h5><p>双指针法，没有弄明白</p><p>滑动窗口</p><p>思路是创建两个哈希表，里面的元素个数与第一个字符串相同，首先记录s1中各个字符出现的次数，以及s2中前s1.size()个字符出现的次数，接着就可以保持s1.size()的窗口，沿着s2滑动，每次循环比较此时两个哈希表是否相等，若不相等，则窗口向后滑动，同时更新s2的哈希表。</p><p>若两个哈希表相等的适合，则找到想要的结果</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> s1_length = s1.size(), s2_length = s2.size();<br>        <span class="hljs-keyword">if</span> (s1_length &gt; s2_length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; table1;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; table2;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s1_length; i++) &#123;<br>            table1[s1[i]]++;<br>            table2[s2[i]]++;<br><br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = s1_length;<br>        <span class="hljs-keyword">for</span> (left,right; right &lt;= s2_length; left++,right++) &#123;<br>            <br>            <span class="hljs-keyword">bool</span> f = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; c++)&#123;<br>                <span class="hljs-keyword">if</span>(table1[c] != table2[c])&#123;<br>                    f = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(f)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (right == s2_length) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//第二个字符串每次以s1.size()的长度向右移一个位置，</span><br>            table2[s2[left]]--;<br>            table2[s2[right]]++;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-015-字符串中的所有变位词"><a href="#剑指offer-015-字符串中的所有变位词" class="headerlink" title="剑指offer 015 字符串中的所有变位词"></a>剑指offer 015 字符串中的所有变位词</h5><p>该题思路和上一题完全一致，简简单单变化一下即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> p_length = p.size(), s_length = s.size();<br>        <span class="hljs-keyword">if</span> (p_length &gt; s_length) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; table1;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; table2;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p_length; i++) &#123;<br>            table1[p[i]]++;<br>            table2[s[i]]++;<br><br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = p_length;<br>        <span class="hljs-keyword">for</span> (left,right; right &lt;= s_length; left++,right++) &#123;<br>            <br>            <span class="hljs-keyword">bool</span> f = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; c++)&#123;<br>                <span class="hljs-keyword">if</span>(table1[c] != table2[c])&#123;<br>                    f = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(f)<br>                res.push_back(left);<br>            <span class="hljs-keyword">if</span> (right == s_length) &#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            <span class="hljs-comment">//第二个字符串每次以s1.size()的长度向右移一个位置，</span><br>            table2[s[left]]--;<br>            table2[s[right]]++;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-016-不含重复字符的最长子字符串"><a href="#剑指offer-016-不含重复字符的最长子字符串" class="headerlink" title="剑指offer 016 不含重复字符的最长子字符串"></a>剑指offer 016 不含重复字符的最长子字符串</h5><p>可以使用滑动窗口的思想，窗口先向右扩展，每次扩展都要检查新加入的字符是否和窗口内已存在的字符重复，如果重复，则窗口左端向右缩，直到新加入的字符不与窗口内已存在字符重复。</p><p>每次右扩展窗口，直到满足条件时，就要记录当前长度，与当前最长长度比较，并更新最长长度。</p><p>每轮结束时，记录的是以当前右侧字符为末尾的符合条件的字串的长度。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> max_length = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mp;<br><br>        <span class="hljs-comment">//窗口右侧为记录对象，右侧不断扩展</span><br>        <span class="hljs-keyword">for</span> (right; right &lt; s.size(); right++) &#123;<br>            mp[s[right]]++;<br><br>            <span class="hljs-comment">//当右侧新加入的字符与窗口内已存在字符产生冲突</span><br>            <span class="hljs-comment">//就要回缩左侧的字符，直到没有冲突，此时就记录了已当前右字符为末尾的符合条件的最长字符。</span><br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; mp[s[right]] &gt;= <span class="hljs-number">2</span>) &#123;<br>                mp[s[left]]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//更新最长长度</span><br>            max_length = max(max_length, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_length;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-017-含有所有字符的最短字符串"><a href="#剑指offer-017-含有所有字符的最短字符串" class="headerlink" title="剑指offer 017 含有所有字符的最短字符串"></a>剑指offer 017 含有所有字符的最短字符串</h5><p>仍然采用滑动窗口思想，但是要注意一些问题。</p><p>根据我的总结，滑动窗口思想一般都是，确保当前滑动窗口内的子串或者子数组是满足条件的，更新最右侧范围后，再回缩左侧范围，但要确保回缩不影响当前字串的正确性。</p><p>每次遍历，最终得到的都是以当前的最右侧字符为末尾的，最优的子串。</p><p>这道题思想同样是这样。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">minWindow</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mpt, mps;<br>        <span class="hljs-keyword">int</span> res_left = <span class="hljs-number">0</span>, min_length = INT_MAX;<br>        <span class="hljs-comment">//记录t中各字符出现次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c: t) &#123;<br>            mpt[c]++;<br>        &#125;<br>        <span class="hljs-comment">//记录此时的滑动窗口中，包含的t中的字符的数量</span><br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历窗口</span><br>        <span class="hljs-keyword">for</span> (; right &lt; s.size(); right++) &#123;<br>            <span class="hljs-comment">//窗口每次向右移动</span><br>            mps[s[right]]++;<br>            <span class="hljs-comment">//当窗口内新增一个尚且没有的t中字符，则窗口内的包含t的字符数量加一</span><br>            <span class="hljs-keyword">if</span> (mps[s[right]] &lt;= mpt[s[right]]) &#123;<br>                cnt++;<br>            &#125;<br>            <span class="hljs-comment">//当窗口左侧的字符在窗口中的数量，已经超过t中该字符的数量时，就可以向右移动，减去这个多余的字符</span><br>            <span class="hljs-comment">//循环，直到左侧字符数量与t中一致，也就是说不可以再向右移动，再移动，窗口将不满足包含t中所有字符</span><br>            <span class="hljs-keyword">while</span> (mps[s[left]] &gt; mpt[s[left]]) &#123;<br>                mps[s[left]]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//当窗口中包含所有的t中字符时，就更新，事实上只要第一次满足，后面每一次移动窗口右侧，肯定会满足</span><br>            <span class="hljs-comment">//因为我们在移动左侧窗口的时候，一定不会让条件不满足</span><br>            <span class="hljs-comment">//意思是每次遍历，窗口都表示：以当前最右侧字符为末尾的，所有s中子串中符合条件的最短字符串。</span><br>            <span class="hljs-keyword">if</span> (cnt == t.size()) &#123;<br>                <span class="hljs-keyword">if</span> (min_length &gt; right - left + <span class="hljs-number">1</span>) &#123;<br>                    min_length = right - left + <span class="hljs-number">1</span>;<br>                    res_left = left;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min_length == INT_MAX) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-built_in">string</span> res = s.substr(res_left, min_length);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>str.substr(1, 3);   <em>//要创建新的变量接收获取的子符串           两个参数一个起始位置 一个截取长度</em></p><h5 id="剑指offer-018-有效的回文"><a href="#剑指offer-018-有效的回文" class="headerlink" title="剑指offer 018 有效的回文"></a>剑指offer 018 有效的回文</h5><p>思路很简单，只需要使用爽指针，一个开头一个末尾，向中间移动，判断左右对称位置的字符是否相等即可。</p><p>但是这道题给出的输入字符串并不是标准的纯小写字符字符串，需要进行一定的操作</p><p>学习一些string的函数</p><p>isalpha ：判断一个字符是否为字母，如果是则返回true，否则返回false；<br>isdigit : 判断一个字符是否表示数字，如果是则返回true，否则返回false；<br>isalnum : 判断一个字符是否表示数字或者字母，如果是则返回true，否则返回false;<br>islower : 判断一个字符是否为小写字母，如果是则返回true，否则返回false;<br>isupper : 判断一个字符是否为大写字母，如果是则返回true，否则返回false；<br>tolower : 若字符为字母则转化为小写字母；<br>toupper : 若字符为字母则转化为大写字母；</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = s.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">//如果当前left位置的字符不是字母，就向后移动一位</span><br>            <span class="hljs-keyword">while</span> (left &lt; s.size() &amp;&amp; !<span class="hljs-built_in">isalnum</span>(s[left])) &#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//right位置同理</span><br>            <span class="hljs-keyword">while</span> (right &gt;= <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-built_in">isalnum</span>(s[right])) &#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left &lt;= right &amp;&amp; <span class="hljs-built_in">tolower</span>(s[left]) != <span class="hljs-built_in">tolower</span>(s[right])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指019-最多删除一个字符得到回文"><a href="#剑指019-最多删除一个字符得到回文" class="headerlink" title="剑指019 最多删除一个字符得到回文"></a>剑指019 最多删除一个字符得到回文</h5><p>一定要注意看题，是最多删除一个字符，而不是必须删除一个字符，因此正常的回文字符串应该也返回true。</p><p>这道题我们可以仍然按部就班判断是否为回文，当遇到第一个不相等的对称位置时，就跳过此位置，分别检验跳过左或者跳过右的剩余字符串部分是否为回文即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = s.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (s[left] != s[right]) &#123;<br>                <span class="hljs-keyword">return</span> isPalindrome(s, left+<span class="hljs-number">1</span>, right) || isPalindrome(s, left, right<span class="hljs-number">-1</span>);<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (s[left++] != s[right--]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-020"><a href="#剑指offer-020" class="headerlink" title="剑指offer 020"></a>剑指offer 020</h5><p>除了暴力枚举也可以使用动态规划的算法</p><p>遍历从1到length的所有长度，显然subLen为1时，是回文子串，subLen为2时，只要当前子串的两个字符相等即为回文子串，当subLen大于2时，若s[i] == s[i+subLen-1]，只要看内层的子串dp[i+1][i+subLen-2]是否相等即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = s.size();<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(length, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(length,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//子串长度为1时肯定为回文</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>            res++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> subLen = <span class="hljs-number">2</span>;subLen &lt;= length; subLen++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + subLen - <span class="hljs-number">1</span> &lt; length; i++) &#123;<br>                <span class="hljs-comment">//子串长度为2且字符相等，为回文</span><br>                <span class="hljs-keyword">if</span> (subLen == <span class="hljs-number">2</span> &amp;&amp; s[i] == s[i+<span class="hljs-number">1</span>]) &#123;<br>                    dp[i][i+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>                    res++;<br>                &#125;<br>                <span class="hljs-comment">//子串长度大于2，只需要看它内层长度减2的那个子串是否为回文。</span><br>                <span class="hljs-keyword">if</span> (subLen &gt; <span class="hljs-number">2</span> &amp;&amp; s[i] == s[i+subLen<span class="hljs-number">-1</span>]) &#123;<br>                    dp[i][i+subLen<span class="hljs-number">-1</span>] = dp[i+<span class="hljs-number">1</span>][i+subLen<span class="hljs-number">-2</span>];<br>                    res += dp[i][i+subLen<span class="hljs-number">-1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-021-删除链表的倒数第n个结点"><a href="#剑指offer-021-删除链表的倒数第n个结点" class="headerlink" title="剑指offer 021 删除链表的倒数第n个结点"></a>剑指offer 021 删除链表的倒数第n个结点</h5><p>快慢指针法即可完成，让快指针先向后移动n个结点，之后快指针和慢指针一起移动，直到快指针为nullptr的时候，慢指针就到了将要删除的结点的位置</p><p>为了考虑只有一个结点的情况，特别定义一个哨兵结点，就可以解决删除头结点的问题。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);<br>        ListNode* fast = head;<br>        ListNode* slow = dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span>) &#123;<br>            fast = fast -&gt; next;<br>            slow = slow -&gt; next;<br>        &#125;<br><br>        ListNode* tmp = slow -&gt; next;<br>        slow -&gt; next = tmp -&gt; next;<br>        <span class="hljs-keyword">delete</span> tmp;<br><br>        <span class="hljs-keyword">return</span> dummy -&gt; next;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-022-链表中环的入口结点"><a href="#剑指offer-022-链表中环的入口结点" class="headerlink" title="剑指offer 022 链表中环的入口结点"></a>剑指offer 022 链表中环的入口结点</h5><p>方法1 可以使用哈希表的方法，记录每个结点是否被访问过，遇到的第一个被访问过的结点，就是环的入口结点</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_set</span>&lt;ListNode *&gt; visited;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (visited.count(head)) &#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            visited.insert(head);<br>            head = head -&gt; next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>方法2 快慢指针</p><p>使用两个指针fast和slow，都从链表头出发，slow每次移动一个位置，而fast每次移动两个位置，由于存在移动差，这两个指针一定在环中再次相遇。</p><p>相遇后</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220303163744281.png" alt="image-20220303163744281"></p><p>slow走过的距离是a+b</p><p>而fast走过的距离是a + n(b+c) + b</p><p>fast走过的距离又是slow的两倍</p><p>因此有关系 a + n(b+c) + b = 2(a+b)</p><p>得到<em>a</em>=<em>c</em>+(<em>n</em>−1)(<em>b</em>+<em>c</em>)</p><p>因此到相遇点的距离等于c加上n-1倍的圈长，此时我们再设置一个指针从头出发，以每次移动一个结点的速度和slow一起，当新指针走过a的距离到入口时，slow也到入口。</p><p>注意判断是否存在环，即会不会走到nullptr</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* slow = head, *fast = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span>) &#123;<br>            slow = slow -&gt; next;<br>            <span class="hljs-keyword">if</span> (fast -&gt; next ==<span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            fast = fast-&gt; next -&gt; next;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                ListNode* tmp = head;<br>                <span class="hljs-keyword">while</span> (slow != tmp) &#123;<br>                    slow = slow -&gt; next;<br>                    tmp = tmp -&gt; next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-024-翻转链表"><a href="#剑指offer-024-翻转链表" class="headerlink" title="剑指offer 024 翻转链表"></a>剑指offer 024 翻转链表</h5><p>1.递归</p><p>当递归到最后一个结点，即head-&gt;next = nullptr时，应当返回自身，称为新的头节点。</p><p>递归过程中，我们的思想是当前的结点方向改变，即他指向的结点指向他，他自身指向nullptr</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* new_head = reverseList(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> new_head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>2.迭代</p><p>迭代的思路很容易，就是不断将当前结点指向前一个结点，同时保留后一个结点。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++\">class Solution &#123;<br>public:<br>    ListNode* reverseList(ListNode* head) &#123;<br>        ListNode * cur &#x3D; head;<br>        ListNode * pre &#x3D; nullptr;<br>        while (cur) &#123;<br>            ListNode * next &#x3D; cur -&gt; next;<br>            cur -&gt; next &#x3D; pre;<br>            pre &#x3D; cur;<br>            cur &#x3D; next;<br>        &#125;<br>        return pre;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-025-链表中的两数相加"><a href="#剑指offer-025-链表中的两数相加" class="headerlink" title="剑指offer 025 链表中的两数相加"></a>剑指offer 025 链表中的两数相加</h5><p>可以考虑翻转链表，使得从地位开始进位相加</p><p>也可以使用栈，将两个链表的所有元素分别全部压栈，再依次出栈相加</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s1, s2;<br>        ListNode* res = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (l1) &#123;<br>            s1.push(l1-&gt;val);<br>            l1 = l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (l2) &#123;<br>            s2.push(l2-&gt;val);<br>            l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!s1.empty() || !s2.empty() || carry != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (!s1.empty()) &#123;<br>                sum += s1.top();<br>                s1.pop();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!s2.empty()) &#123;<br>                sum += s2.top();<br>                s2.pop();<br>            &#125;<br>            sum += carry;<br>            carry = sum/<span class="hljs-number">10</span>;<br>            sum = sum%<span class="hljs-number">10</span>;<br>            ListNode* tmp_node = <span class="hljs-keyword">new</span> ListNode(sum);<br>            tmp_node -&gt; next = res;<br>            res = tmp_node;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="剑指offer-026-重排链表"><a href="#剑指offer-026-重排链表" class="headerlink" title="剑指offer 026 重排链表"></a>剑指offer 026 重排链表</h4><p>最开始的思路是想，将后1/2的链表翻转，求出中点的结点，再将两端链表根据规则插入排序</p><p>这种指定排序规律的链表可以使用哈希表的方法，存储结点指针，直接随机访问下标进行排序，难度大大降低。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;ListNode*&gt; table;<br>        ListNode* res = head;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            table.push_back(head);<br>            head = head-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = table.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <br>            table[i]-&gt;next = table[j];<br>            table[j]-&gt;next = table[i+<span class="hljs-number">1</span>];<br>            i++;<br>            j--;<br>        &#125;<br>        table[(table.size())/<span class="hljs-number">2</span>]-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h6 id="剑指offer-027-回文链表"><a href="#剑指offer-027-回文链表" class="headerlink" title="剑指offer 027 回文链表"></a>剑指offer 027 回文链表</h6><ol><li><p>可以考虑使用数组将链表中的所有结点的值按序保存，之后可以随机访问的形式，双指针一前一后遍历，判断数组是否回文即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; list_val;<br>        <span class="hljs-keyword">while</span> (head) &#123;<br>            list_val.push_back(head -&gt; val);<br>            head = head-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = list_val.size() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (list_val[left] != list_val[right]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure></li><li><p>递归</p><p>递归的思想是一直递归到链表末端，保存一个与之对称的指针指向头，当指向末端后，就可以逐个比较，当值相同时，头指针后移，同时回到上一层递归，递归中的指针前移。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    ListNode * frontPointer;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">recursivelyCheck</span><span class="hljs-params">(ListNode* curPointer)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (curPointer!= <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (recursivelyCheck(curPointer-&gt;next) == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (curPointer-&gt;val != frontPointer-&gt;val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            frontPointer = frontPointer-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        frontPointer = head;<br>        <span class="hljs-keyword">return</span> recursivelyCheck(head);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure></li></ol><h5 id="剑指offer-028-展平多级双向链表"><a href="#剑指offer-028-展平多级双向链表" class="headerlink" title="剑指offer 028 展平多级双向链表"></a>剑指offer 028 展平多级双向链表</h5><p>思路一是类比二叉树，二叉树的结构就是一个结点有左右孩子，而多级双向链表中，child可以看作左孩子，next可以看作右孩子，因此我们可以考虑使用先序遍历的方法，即中-左-右的遍历顺序遍历该链表，即可得到所需要的结构</p><p>将遍历结果存储在数组中，最后对数组中的每一个结点前后相连即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* prev;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* child;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;Node*&gt; res;<br>    <span class="hljs-function">Node* <span class="hljs-title">flatten</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-comment">//先序遍历得到所要顺序的数组</span><br>            dfs(head);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        Node* new_head = head;<br>        head-&gt;child = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; res.size(); i++) &#123;<br>            new_head-&gt;next = res[i];<br>            res[i]-&gt;prev = new_head;<br>            new_head = new_head-&gt;next;<br>            new_head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            new_head-&gt;child = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;        <br>    &#125;<br>    <span class="hljs-comment">//先序遍历递归写法</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node* cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            res.push_back(cur);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(cur-&gt;child);<br>        dfs(cur-&gt;next);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-029-排序的循环链表"><a href="#剑指offer-029-排序的循环链表" class="headerlink" title="剑指offer 029 排序的循环链表"></a>剑指offer 029 排序的循环链表</h5><p>将插入情况理顺清楚即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _next) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = _next;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">insert</span><span class="hljs-params">(Node* head, <span class="hljs-keyword">int</span> insertVal)</span> </span>&#123;<br>        Node *new_node = <span class="hljs-keyword">new</span> Node(insertVal);<br>        <span class="hljs-comment">//空结点的情况，直接插入</span><br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            head = new_node;<br>            new_node-&gt;next = new_node;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">//设置一前一后两个指针，根据不同情况进行选择</span><br>        Node* front = head-&gt;next;<br>        Node* behind = head;<br>        <span class="hljs-comment">//绕环遍历一周</span><br>        <span class="hljs-keyword">while</span> (front != head) &#123;<br>            <span class="hljs-comment">//临界情况</span><br>            <span class="hljs-keyword">if</span> (behind-&gt;val &gt; front-&gt;val) &#123;<br>                <span class="hljs-comment">//比两个都大或者都小</span><br>                <span class="hljs-keyword">if</span> (front-&gt;val &gt;= insertVal) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (behind-&gt;val &lt;= insertVal) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//普通情况</span><br>            <span class="hljs-keyword">if</span> (behind-&gt;val &lt;= insertVal &amp;&amp; front-&gt;val &gt;= insertVal) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            front = front-&gt;next;<br>            behind = behind-&gt;next;<br>        &#125;<br>        behind-&gt;next = new_node;<br>        new_node-&gt;next = front;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-030-插入、删除和随机访问都是O-1-的容器"><a href="#剑指offer-030-插入、删除和随机访问都是O-1-的容器" class="headerlink" title="剑指offer 030 插入、删除和随机访问都是O(1)的容器"></a>剑指offer 030 插入、删除和随机访问都是O(1)的容器</h5><p>哈希表</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomizedSet</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; numToLocation;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;<br><span class="hljs-keyword">public</span>:<br>    RandomizedSet() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (numToLocation.count(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        numToLocation[val] = nums.size();<br>        nums.push_back(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!numToLocation.count(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;    <br>        <span class="hljs-keyword">int</span> location = numToLocation[val];<br>        numToLocation[nums.back()] = location;<br>        numToLocation.erase(val);<br>        nums[location] = nums.back();<br>        nums.pop_back();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nums[rand() % nums.size()];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RandomizedSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RandomizedSet* obj = new RandomizedSet();</span><br><span class="hljs-comment"> * bool param_1 = obj-&gt;insert(val);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;remove(val);</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;getRandom();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-031-最近最少使用缓存"><a href="#剑指offer-031-最近最少使用缓存" class="headerlink" title="剑指offer 031 最近最少使用缓存"></a>剑指offer 031 最近最少使用缓存</h5><p>同时使用哈希表和双向链表</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>        <span class="hljs-keyword">int</span> key = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;<br>        Node * next;<br>        Node * prev;<br>        Node() &#123;&#125;;<br>        Node(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val):key(key), val(val) &#123;&#125;;<br>    &#125;;<br>    Node * dummy;<br>    Node * tail; <br>    <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> curnum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, Node*&gt; hashtable;<br><span class="hljs-keyword">public</span>:<br>    LRUCache(<span class="hljs-keyword">int</span> capacity) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;capacity = capacity; <br>        dummy = <span class="hljs-keyword">new</span> Node();<br>        tail = <span class="hljs-keyword">new</span> Node();<br>        dummy-&gt;next = tail;<br>        tail-&gt;prev = dummy;<br>        tail-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hashtable.count(key)) &#123;<br>            movetotail(key);<br>            <span class="hljs-keyword">return</span> hashtable[key]-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hashtable.count(key)) &#123;<br>            hashtable[key]-&gt;val = value;<br>            movetotail(key);<br>            <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (curnum &lt; capacity) &#123;<br>                addtotail(key,value);<br>                curnum++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                deletefront();<br>                addtotail(key,value);<br>                hashtable[key]-&gt;val = value;<br>                hashtable[key]-&gt;key = key;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">movetotail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        Node* cur = hashtable[key];<br>        <span class="hljs-keyword">if</span> (cur == tail) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur-&gt;prev-&gt;next = cur-&gt;next;<br>            cur-&gt;next-&gt;prev = cur-&gt;prev;<br>            tail-&gt;prev-&gt;next = cur;<br>            cur-&gt;prev = tail-&gt;prev;<br>            cur-&gt;next = tail;<br>            tail-&gt;prev = cur;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addtotail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        Node * tmp = <span class="hljs-keyword">new</span> Node(key,value);<br>        tail-&gt;prev-&gt;next = tmp;<br>        tmp-&gt;prev = tail-&gt;prev;<br>        tmp-&gt;next = tail;<br>        tail-&gt;prev = tmp;<br>        hashtable[key] = tmp;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deletefront</span> <span class="hljs-params">()</span> </span>&#123;<br>        hashtable.erase(dummy-&gt;next-&gt;key);<br>        Node * tmp = dummy-&gt;next;<br>        dummy-&gt;next = dummy-&gt;next-&gt;next;<br>        dummy-&gt;next-&gt;prev = dummy;<br><br>        <span class="hljs-keyword">delete</span> tmp;<br><br>    &#125;<br><br>    <br><br><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-032-有效的变位词"><a href="#剑指offer-032-有效的变位词" class="headerlink" title="剑指offer 032 有效的变位词"></a>剑指offer 032 有效的变位词</h5><p>哈希表即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == t) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> table[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s) &#123;<br>            table[c-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) &#123;<br>            table[c-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (table[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-033-变位词组"><a href="#剑指offer-033-变位词组" class="headerlink" title="剑指offer 033 变位词组"></a>剑指offer 033 变位词组</h5><p>注意变位词组的特点是字符串中各字符的数量一致，因此我们对变位词排序，得到的新单词一定相同，因此我们可以考虑对于每个字符串排序，根据得到的排序后字符串归类</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; groupAnagrams(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs) &#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> s : strs) &#123;<br>            <span class="hljs-built_in">string</span> tmp = s;<br>            sort(tmp.begin(), tmp.end());<br>            mp[tmp].push_back(s);<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mp.begin(); it != mp.end(); it++) &#123;<br>            res.push_back(it-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-034-外星语言是否排序"><a href="#剑指offer-034-外星语言是否排序" class="headerlink" title="剑指offer 034 外星语言是否排序"></a>剑指offer 034 外星语言是否排序</h5><p>将字母表顺序根据顺序号存在哈希表中，比较两个单词时比较每个字母的顺序大小即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAlienSorted</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">string</span> order)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            mp[order[i]] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.size()<span class="hljs-number">-1</span>; i++) &#123;<br>            <span class="hljs-built_in">string</span> front = words[i];<br>            <span class="hljs-built_in">string</span> behind = words[i+<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">bool</span> res = compare(front, behind);<br>            <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = min(s1.size(), s2.size());<br>        <span class="hljs-keyword">bool</span> sub_equal = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp[s1[i]] &lt; mp[s2[i]]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mp[s1[i]] &gt; mp[s2[i]]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s1[i] != s2[i]) &#123;<br>                sub_equal = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sub_equal == <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">return</span> s1.size() &lt;= s2.size() ? <span class="hljs-literal">true</span>: <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-035-最小时间差"><a href="#剑指offer-035-最小时间差" class="headerlink" title="剑指offer 035 最小时间差"></a>剑指offer 035 最小时间差</h5><p>首先将所有时间都转化为分钟，存入vector中，当然如果存在重复的值，直接返回0。</p><p>对其排序，排序后逐个比较前后元素的差，返回最小的。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++\">class Solution &#123;<br>public:<br>    int findMinDifference(vector&lt;string&gt;&amp; timePoints) &#123;<br>        vector&lt;int&gt; vec;<br>        for (string tmp : timePoints) &#123;<br>            int curtime &#x3D; (tmp[0] - &#39;0&#39;) * 10 * 60 + (tmp[1] - &#39;0&#39;) * 60 + (tmp[3] - &#39;0&#39;) * 10 + (tmp[4] - &#39;0&#39;);<br>            auto iter&#x3D;find(vec.begin(), vec.end(), curtime);<br>            if (iter !&#x3D; vec.end()) &#123;<br>                return 0;<br>            &#125; else &#123;<br>                vec.push_back(curtime);<br>            &#125;<br>        &#125;<br>        sort(vec.begin(), vec.end());<br>        int res &#x3D; 1440;<br>        for (int i &#x3D; 0; i &lt; vec.size()-1; i++) &#123;<br>            res &#x3D; min(res, vec[i+1] - vec[i]);<br>        &#125;<br>        res &#x3D; min(res, (vec[0] + 1440 - vec[vec.size()-1]));<br><br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-036-后缀表达式"><a href="#剑指offer-036-后缀表达式" class="headerlink" title="剑指offer 036 后缀表达式"></a>剑指offer 036 后缀表达式</h5><p>经典栈问题</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> s : tokens) &#123;<br>            <span class="hljs-keyword">if</span> (isDegital(s)) &#123;<br>                st.push(atoi(s.c_str()));<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">char</span> c = s[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> tmp1 = st.top();<br>                st.pop();<br>                <span class="hljs-keyword">int</span> tmp2 = st.top();<br>                st.pop();<br>                <br>                <span class="hljs-keyword">switch</span> (c) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    result = tmp1 + tmp2;<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    result = tmp2 - tmp1;<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    result = tmp1 * tmp2;<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                    result  = tmp2 / tmp1;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                st.push(result);<br><br>            &#125;<br>        &#125;<br>        result = st.top();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDegital</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; str.size();i++) &#123;<br>            <span class="hljs-keyword">if</span> (str.at(i) == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; str.size() &gt; <span class="hljs-number">1</span>)  <span class="hljs-comment">// 有可能出现负数</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (str.at(i) &gt; <span class="hljs-string">&#x27;9&#x27;</span> || str.at(i) &lt; <span class="hljs-string">&#x27;0&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>判断C++中的字符串是否为整数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDegital</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; str.size();i++) &#123;<br>        <span class="hljs-keyword">if</span> (str.at(i) == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; str.size() &gt; <span class="hljs-number">1</span>)  <span class="hljs-comment">// 有可能出现负数</span><br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (str.at(i) &gt; <span class="hljs-string">&#x27;9&#x27;</span> || str.at(i) &lt; <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将string类型的整数转换为数字</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt; // 包含头文件</span></span><br><br><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;54321&quot;</span>;<br><span class="hljs-built_in">stringstream</span> ss;<br>ss&lt;&lt;str;<br><span class="hljs-keyword">int</span> temp;<br>ss&gt;&gt;temp;<br></code></pre></div></td></tr></table></figure><p>或者</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;54231&quot;</span>;<br><span class="hljs-keyword">int</span> result = atoi(str.c_str());<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-037-小行星碰撞"><a href="#剑指offer-037-小行星碰撞" class="headerlink" title="剑指offer 037 小行星碰撞"></a>剑指offer 037 小行星碰撞</h5><p>自己的版本，不够优化，没有充分利用栈的思想</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">asteroidCollision</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; asteroids)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-comment">//先将所有的行星压栈</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : asteroids) &#123;<br>            st.push(i);<br>        &#125;<br><br>        <span class="hljs-comment">//当栈中存在两个及以上行星的时候</span><br>        <span class="hljs-keyword">while</span> (st.size() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> tmp1 = st.top();<br>            st.pop();<br>            <span class="hljs-keyword">int</span> tmp2 = st.top();<br>            st.pop();<br>            <span class="hljs-comment">//相撞的情况</span><br>            <span class="hljs-keyword">if</span> (tmp1 &lt; <span class="hljs-number">0</span> &amp;&amp; tmp2 &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">int</span> tmp_res;<br>                <span class="hljs-comment">//质量相同的行星湮灭</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(tmp1) != <span class="hljs-built_in">abs</span>(tmp2)) &#123;<br>                    <span class="hljs-comment">//质量大的行星存活</span><br>                    tmp_res = <span class="hljs-built_in">abs</span>(tmp1) &gt; <span class="hljs-built_in">abs</span>(tmp2) ? tmp1 : tmp2;<br>                    st.push(tmp_res); <br>                &#125; <br>                <span class="hljs-comment">//这里要取回之前已经存放安全的行星，因为左边的行星可能会被更左边的行星撞碎</span><br>                <span class="hljs-keyword">if</span> (!res.empty()) &#123;<br>                    <span class="hljs-keyword">int</span> tmp = res.back();<br>                st.push(tmp);<br>                res.pop_back();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//同方向的行星，一颗放入存活集</span><br>                res.push_back(tmp1);<br>                st.push(tmp2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将最后一颗存活的行星放入存活集</span><br>        <span class="hljs-keyword">if</span> (!st.empty()) &#123;<br>            <span class="hljs-keyword">int</span> tmp = st.top();<br>            st.pop();<br>            res.push_back(tmp);<br>        &#125;<br>        <br><br>        reverse(res.begin(), res.end());<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>可以直接在入栈和入存活集的时候进行判断</p><p>当然若左边只剩下负数行星的时候肯定会存活，因此如果栈中最后只剩负数行星，就入存活集</p><p>最后将所有剩余的正数行星入存活集</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">asteroidCollision</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; asteroids)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : asteroids) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) st.push(i);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>                    <span class="hljs-keyword">int</span> j = st.top();<br>                    <span class="hljs-keyword">if</span> (j &gt; -i) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; -i)&#123;<br>                        st.pop();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        st.pop();<br>                        i = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> &amp;&amp; st.empty()) ans.push_back(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            tmp.push(st.top());<br>            st.pop();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!tmp.empty()) &#123;<br>            ans.push_back(tmp.top());<br>            tmp.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-038-每日温度"><a href="#剑指offer-038-每日温度" class="headerlink" title="剑指offer 038 每日温度"></a>剑指offer 038 每日温度</h5><p>这道题可以使用两个栈解决，温度栈入栈的是新的一天的温度一定要比前一天低，天数栈入栈的是温度栈对应温度是第几天。</p><p>让每天的温度与温度栈中的数据进行比对，如果新一天的温度高于温度栈顶的温度，那么就出栈，并记录温度栈顶那天等待的天数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-comment">//单调栈，栈中存放的只能是递减的数据</span><br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-comment">//记录单调栈中存放的温度是第几天</span><br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; wait_day;<br>        <span class="hljs-comment">//保存等待结果</span><br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (!st.empty())  &#123;<br>                <span class="hljs-comment">//新的一天的温度比之前的温度高</span><br>                <span class="hljs-keyword">while</span>(!st.empty() &amp;&amp; st.top() &lt; temperatures[i]) &#123;<br>                    st.pop();<br>                    <span class="hljs-comment">//则单调栈中的天已经等待了当前天减去单调栈中存放的温度那天</span><br>                    res[wait_day.top()] = i - wait_day.top();<br>                    wait_day.pop();<br>                &#125;   <br>            &#125;<br>            res[i] = <span class="hljs-number">0</span>;<br>            st.push(temperatures[i]);<br>            wait_day.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-039-直方图最大矩形面积"><a href="#剑指offer-039-直方图最大矩形面积" class="headerlink" title="剑指offer 039 直方图最大矩形面积"></a>剑指offer 039 直方图最大矩形面积</h5><p>设置一个单调栈</p><p>当目前元素大于栈顶元素，直接存入目前元素的位置，当目前元素小于栈顶元素，就先将栈顶位置出栈，得到目前栈顶位置的高度，再用当前位置i - st.top() -1 ，得到的是以当前出栈位置为高度的最大矩形的面积，因为单调栈特性是高度递增，遇到不递增的高度出栈，因此出栈元素的前一个栈中元素和当前要入栈元素的位置，就是当前出栈元素高度两侧延申，左右遇到的第一个比出栈元素低的元素。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max_area = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        st.push(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.size(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (st.size() &gt; <span class="hljs-number">1</span> &amp;&amp; heights[i] &lt; heights[st.top()]) &#123;<br>                <span class="hljs-keyword">int</span> cur_pos = st.top();<br>                <span class="hljs-keyword">int</span> cur_height = heights[cur_pos];<br>                st.pop();<br>                max_area = max(max_area, cur_height*(i-st.top()<span class="hljs-number">-1</span>));<br>            &#125;<br>            st.push(i);<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = heights.size();<br>        <span class="hljs-keyword">while</span> (st.top() != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">int</span> cur_pos = st.top();<br>            <span class="hljs-keyword">int</span> cur_height = heights[cur_pos];<br>            st.pop();<br>            max_area = max(max_area, cur_height*(i-st.top()<span class="hljs-number">-1</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_area;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-040-矩阵中的最大矩形"><a href="#剑指offer-040-矩阵中的最大矩形" class="headerlink" title="剑指offer 040 矩阵中的最大矩形"></a>剑指offer 040 矩阵中的最大矩形</h5><p>将矩阵按行转化为直方图即可，当一行中出现0，则这行的这个位置清零，若为1则加上入一次的直方图中。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = matrix.size();<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">histogram</span><span class="hljs-params">(matrix[<span class="hljs-number">0</span>].size(),<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            getHistogram(histogram, matrix[i]);<br><br>            res = max(res, getMaxRectangle(histogram));<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getHistogram</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;prehistogram, <span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                prehistogram[i] += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prehistogram[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMaxRectangle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; heights)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        st.push(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">int</span> max_area = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.size(); i++) &#123;<br>            <span class="hljs-keyword">while</span>(st.top() != <span class="hljs-number">-1</span> &amp;&amp; heights[st.top()] &gt; heights[i]) &#123;<br>                <span class="hljs-keyword">int</span> curheight = heights[st.top()];<br>                st.pop();<br>                max_area = max(max_area, curheight * (i-st.top()<span class="hljs-number">-1</span>));<br>            &#125;<br>            st.push(i);<br>        &#125;<br>        <span class="hljs-keyword">int</span> i =  heights.size();<br>        <span class="hljs-keyword">while</span> (st.top() != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">int</span> curheight = heights[st.top()];<br>            st.pop();<br>            max_area = max(max_area, curheight * (i-st.top()<span class="hljs-number">-1</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_area;<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-041-滑动窗口的平均值"><a href="#剑指offer-041-滑动窗口的平均值" class="headerlink" title="剑指offer 041 滑动窗口的平均值"></a>剑指offer 041 滑动窗口的平均值</h5><p>简单的队列问题</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovingAverage</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">int</span> max_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; que;<br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;<br>    MovingAverage(<span class="hljs-keyword">int</span> size) &#123;<br>        max_size = size;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (que.size() &lt; max_size) &#123;<br>            sum += val;<br>            que.push(val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!que.empty()) &#123;<br>                sum -= que.front();<br>                que.pop();<br>            &#125;<br>            que.push(val);<br>            sum += val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum / que.size();<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MovingAverage object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MovingAverage* obj = new MovingAverage(size);</span><br><span class="hljs-comment"> * double param_1 = obj-&gt;next(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-042-最近请求次数"><a href="#剑指offer-042-最近请求次数" class="headerlink" title="剑指offer 042 最近请求次数"></a>剑指offer 042 最近请求次数</h5><p>设置一个队列，每次将小于当前时间-3000的所有数从队列中清除即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecentCounter</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; que;<br>    <span class="hljs-keyword">int</span> time_width;<br>    RecentCounter() &#123;<br>        time_width = <span class="hljs-number">3000</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ping</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> earlytime = t - <span class="hljs-number">3000</span>;<br>        <span class="hljs-keyword">while</span> (!que.empty() &amp;&amp; que.front() &lt; earlytime) &#123;<br>            que.pop();<br>        &#125;<br>        que.push(t);<br>        <span class="hljs-keyword">return</span>  que.size();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RecentCounter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RecentCounter* obj = new RecentCounter();</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;ping(t);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-043-往完全二叉树添加节点"><a href="#剑指offer-043-往完全二叉树添加节点" class="headerlink" title="剑指offer 043 往完全二叉树添加节点"></a>剑指offer 043 往完全二叉树添加节点</h5><p>二叉树层序遍历！</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CBTInserter</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">queue</span> &lt;TreeNode*&gt; que;<br>    TreeNode * root;<br>    CBTInserter(TreeNode* root) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;root = root;<br>        que.push(root);<br>        <span class="hljs-keyword">while</span> (que.front()-&gt;left &amp;&amp; que.front()-&gt;right) &#123;<br>            que.push(que.front()-&gt;left);<br>            que.push(que.front()-&gt;right);<br>            que.pop();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (que.front()-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            que.push(que.front()-&gt;left);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        TreeNode *tmp = <span class="hljs-keyword">new</span> TreeNode(v);<br>        TreeNode *tmpfather = que.front();<br>        <span class="hljs-keyword">if</span> (tmpfather-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            tmpfather-&gt;right = tmp;<br>            que.pop();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmpfather-&gt;left = tmp;<br>        &#125;<br>        que.push(tmp);<br>        <br>        <span class="hljs-keyword">return</span> tmpfather-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">get_root</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CBTInserter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CBTInserter* obj = new CBTInserter(root);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;insert(v);</span><br><span class="hljs-comment"> * TreeNode* param_2 = obj-&gt;get_root();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-044-二叉树每层的最大值"><a href="#剑指offer-044-二叉树每层的最大值" class="headerlink" title="剑指offer 044 二叉树每层的最大值"></a>剑指offer 044 二叉树每层的最大值</h5><p>队列 层序遍历</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">int</span> cur_size;<br>        <span class="hljs-keyword">int</span> cur_max;<br>        que.push(root);<br><br>        <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>            cur_size = que.size();<br>            cur_max = INT_MIN;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_size; i++) &#123;<br>                TreeNode* node = que.front();<br>                cur_max = max(cur_max, node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    que.push(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    que.push(node-&gt;right);<br>                &#125;<br>                que.pop();<br>            &#125;<br>            res.push_back(cur_max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-045-二叉树最底层最左边的值"><a href="#剑指offer-045-二叉树最底层最左边的值" class="headerlink" title="剑指offer 045 二叉树最底层最左边的值"></a>剑指offer 045 二叉树最底层最左边的值</h5><p>仍然是层序遍历</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode *&gt; que;<br>        <span class="hljs-keyword">int</span> res;<br>        que.push(root);<br>        <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>            <span class="hljs-keyword">int</span> cur_length = que.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_length; i++) &#123;<br>                TreeNode* node = que.front();<br><br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                    res = node-&gt;val;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    que.push(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    que.push(node-&gt;right);<br>                &#125;<br>                que.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-046-二叉树的右侧视图"><a href="#剑指offer-046-二叉树的右侧视图" class="headerlink" title="剑指offer 046 二叉树的右侧视图"></a>剑指offer 046 二叉树的右侧视图</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        que.push(root);<br><br>        <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>            <span class="hljs-keyword">int</span> cur_length = que.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_length; i++) &#123;<br>                TreeNode * node = que.front();<br>                <span class="hljs-keyword">if</span> (i == cur_length<span class="hljs-number">-1</span>) &#123;<br>                    res.push_back(node-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    que.push(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    que.push(node-&gt;right);<br>                &#125;<br>                que.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="二叉树的三种遍历"><a href="#二叉树的三种遍历" class="headerlink" title="二叉树的三种遍历"></a>二叉树的三种遍历</h5><p>统一写法 后序遍历</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.push(root);<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            TreeNode *node = st.top();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.pop();<br>                st.push(node);<br>                st.push(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.push(node-&gt;right);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.push(node-&gt;left);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.pop();<br>                node = st.top();<br>                st.pop();<br>                result.push_back(node-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-047-二叉树剪纸"><a href="#剑指offer-047-二叉树剪纸" class="headerlink" title="剑指offer 047 二叉树剪纸"></a>剑指offer 047 二叉树剪纸</h5><p>考虑到当孩子节点都是0的时候，该节点也是0，意思是左子树和右子树都是0的时候，自己也为0，因此应先遍历左右子节点，左右子节点的值影响父节点的值。</p><p>因此应使用后续遍历，当左右孩子为0的时候，将父节点也设为0。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        root-&gt;left = pruneTree(root-&gt;left);<br>        root-&gt;right = pruneTree(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (root-&gt;val == <span class="hljs-number">0</span> &amp;&amp; root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-048-序列化与反序列化二叉树"><a href="#剑指offer-048-序列化与反序列化二叉树" class="headerlink" title="剑指offer 048 序列化与反序列化二叉树"></a>剑指offer 048 序列化与反序列化二叉树</h5><p>将一个二叉树保存为一个string类型，再用string还原一个二叉树</p><p>先序遍历 </p><p>多看代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br>        &#125;<br>        <span class="hljs-built_in">string</span> leftstr = serialize(root-&gt;left);<br>        <span class="hljs-built_in">string</span> rightstr = serialize(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> to_string(root-&gt;val) + <span class="hljs-string">&quot;,&quot;</span> + leftstr + <span class="hljs-string">&quot;,&quot;</span> + rightstr;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-built_in">string</span> data)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; dataArray&#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : data) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>                dataArray.push_back(<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dataArray.back().push_back(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dfs(dataArray, i);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; &amp;dataArray, <span class="hljs-keyword">int</span> &amp;i)</span> </span>&#123;<br>        <span class="hljs-built_in">string</span> str = dataArray[i];<br>        i++;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br><br>        TreeNode * node = <span class="hljs-keyword">new</span> TreeNode(stoi(str));<br>        node-&gt;left = dfs(dataArray, i);<br>        node-&gt;right = dfs(dataArray,i);<br>        <span class="hljs-keyword">return</span> node;<br>                  <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec ser, deser;</span><br><span class="hljs-comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span><br></code></pre></div></td></tr></table></figure><h5 id="049-从根节点到叶节点的路径数字之和"><a href="#049-从根节点到叶节点的路径数字之和" class="headerlink" title="049 从根节点到叶节点的路径数字之和"></a>049 从根节点到叶节点的路径数字之和</h5><p>先序遍历递归版本</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> prevsum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> sum = prevsum * <span class="hljs-number">10</span> + root-&gt;val;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> dfs(root-&gt;left, sum) + dfs(root-&gt;right, sum);<br>        &#125;<br>    &#125;<br><br><br><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>层序遍历队列版本</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que_node;<br>        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; que_num;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        que_node.push(root);<br>        que_num.push(root-&gt;val);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que_node.empty()) &#123;<br>            <span class="hljs-keyword">int</span> cur_length = que_node.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_length; i++) &#123;<br>                TreeNode * tmpnode = que_node.front(); <br>                <span class="hljs-keyword">int</span> tmpnum = que_num.front();<br>                <span class="hljs-keyword">if</span> (tmpnode-&gt;left) &#123;<br>                    que_node.push(tmpnode-&gt;left);<br>                    que_num.push(tmpnum*<span class="hljs-number">10</span> + tmpnode-&gt;left-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (tmpnode-&gt;right) &#123;<br>                    que_node.push(tmpnode-&gt;right);<br>                    que_num.push(tmpnum*<span class="hljs-number">10</span> + tmpnode-&gt;right-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (tmpnode-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; tmpnode-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                    sum += tmpnum;<br>                &#125;<br>                que_node.pop();<br>                que_num.pop();<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="050-向下的路径节点之和"><a href="#050-向下的路径节点之和" class="headerlink" title="050 向下的路径节点之和"></a>050 向下的路径节点之和</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rootSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val == targetSum) &#123;<br>            ret++;<br>        &#125; <br><br>        ret += rootSum(root-&gt;left, targetSum - root-&gt;val);<br>        ret += rootSum(root-&gt;right, targetSum - root-&gt;val);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> ret = rootSum(root, targetSum);<br>        ret += pathSum(root-&gt;left, targetSum);<br>        ret += pathSum(root-&gt;right, targetSum);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br></code></pre></div></td></tr></table></figure><h5 id="节点之和最大的路径"><a href="#节点之和最大的路径" class="headerlink" title="节点之和最大的路径"></a>节点之和最大的路径</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> ans = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//获取左右两支的最大值</span><br>        <span class="hljs-keyword">int</span> sumleft = dfs(root-&gt;left);<br>        <span class="hljs-keyword">int</span> sumright = dfs(root-&gt;right);<br><br>        <span class="hljs-comment">//检测当前的^,是点最大，一支最大，还是^最大</span><br>        ans = max(ans, root-&gt;val);<br>        ans = max(ans, root-&gt;val + max(sumright, sumleft));<br>        ans = max(ans, root-&gt;val + sumleft +sumright);<br><br>        <span class="hljs-comment">//向上一层返回，返回的一定是一条线，而不是一个^，因此取左右分支最大的一支返回</span><br>        <span class="hljs-keyword">return</span> max(root-&gt;val, root-&gt;val + max(sumright, sumleft));<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-052-展平二叉搜索树"><a href="#剑指offer-052-展平二叉搜索树" class="headerlink" title="剑指offer 052 展平二叉搜索树"></a>剑指offer 052 展平二叉搜索树</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; res;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        st.push(root);<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            TreeNode * node = st.top();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.push(node-&gt;right);<br>                &#125;<br>                st.push(node);<br>                st.push(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.push(node-&gt;left);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.pop();<br>                node = st.top();<br>                res.push_back(node);<br>                st.pop();<br>            &#125;<br>        &#125;<br><br>        <br>        TreeNode * tmp = res[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size()<span class="hljs-number">-1</span>; i++) &#123;<br>            tmp-&gt;right = res[i+<span class="hljs-number">1</span>];<br>            tmp-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            tmp = tmp-&gt;right;<br>        &#125;<br>        tmp-&gt;right = <span class="hljs-literal">nullptr</span>;<br>        tmp-&gt;left = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer053-二叉搜索树中的中序后继"><a href="#剑指offer053-二叉搜索树中的中序后继" class="headerlink" title="剑指offer053 二叉搜索树中的中序后继"></a>剑指offer053 二叉搜索树中的中序后继</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode* root, TreeNode* p)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">bool</span> next = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        st.push(root);<br>        <span class="hljs-keyword">while</span>(!st.empty()) &#123;<br>            TreeNode* node = st.top();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.push(node-&gt;right);<br>                &#125;<br>                st.push(node);<br>                st.push(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.push(node-&gt;left);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.pop();<br>                node = st.top();<br>                <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">return</span> node;<br>                &#125;<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (node == p) &#123;<br>                    next = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-054-所有大于等于节点的值之和"><a href="#剑指offer-054-所有大于等于节点的值之和" class="headerlink" title="剑指offer 054 所有大于等于节点的值之和"></a>剑指offer 054 所有大于等于节点的值之和</h5><p>既然树是有序的，而且要将每个节点的值替换成树种大于或者等于该节点值得所有节点之和，不妨直接由中序遍历，变成逆中序遍历，按照右中左的顺序，从大到小遍历，并将数值依次相加保存。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        convertBST(root-&gt;right);<br>        sum += root-&gt;val;<br>        root-&gt;val = sum;<br>        convertBST(root-&gt;left);<br><br>        <span class="hljs-keyword">return</span> root; <br><br>    &#125; <br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-055-二叉搜索树迭代器"><a href="#剑指offer-055-二叉搜索树迭代器" class="headerlink" title="剑指offer 055 二叉搜索树迭代器"></a>剑指offer 055 二叉搜索树迭代器</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; result;<br>    <span class="hljs-keyword">int</span> curnode;<br>    <span class="hljs-keyword">int</span> nodesize;<br><span class="hljs-keyword">public</span>:<br><br>    BSTIterator(TreeNode* root) &#123;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.push(root);<br>            <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>                TreeNode* node = st.top();<br>                <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                    st.pop();<br>                    <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                        st.push(node-&gt;right);<br>                    &#125;<br>                    st.push(node);<br>                    st.push(<span class="hljs-literal">nullptr</span>);<br>                    <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                        st.push(node-&gt;left);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    st.pop();<br>                    node = st.top();<br>                    st.pop();<br>                    result.push_back(node);<br>                &#125;<br>            &#125;<br>        &#125;<br>        curnode = <span class="hljs-number">0</span>;<br>        nodesize = result.size();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> result[curnode++]-&gt;val;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (curnode &lt; nodesize) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * BSTIterator* obj = new BSTIterator(root);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;next();</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;hasNext();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-056-二叉搜索树中两个节点之和"><a href="#剑指offer-056-二叉搜索树中两个节点之和" class="headerlink" title="剑指offer 056 二叉搜索树中两个节点之和"></a>剑指offer 056 二叉搜索树中两个节点之和</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        st.push(root);<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            TreeNode* node = st.top();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.push(node-&gt;right);<br>                &#125;<br>                st.push(node);<br>                st.push(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.push(node-&gt;left);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.pop();<br>                node = st.top();<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (mp.count(k - node-&gt;val)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                mp[node-&gt;val] = <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-057-值和下标只差都在给定的范围内"><a href="#剑指offer-057-值和下标只差都在给定的范围内" class="headerlink" title="剑指offer 057 值和下标只差都在给定的范围内"></a>剑指offer 057 值和下标只差都在给定的范围内</h5><p>滑动窗口 + 桶思想</p><p>滑动窗口负责淘汰数据，桶帮助简化比较过程</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-keyword">int</span> tmpID = getID(nums[i], t+<span class="hljs-number">1ll</span>);<br>            <span class="hljs-keyword">if</span> (mp.count(tmpID)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mp.count(tmpID<span class="hljs-number">-1</span>) &amp;&amp; <span class="hljs-built_in">abs</span>((<span class="hljs-keyword">long</span>)mp[tmpID<span class="hljs-number">-1</span>] - nums[i]) &lt;= t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mp.count(tmpID+<span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">abs</span>((<span class="hljs-keyword">long</span>)mp[tmpID+<span class="hljs-number">1</span>] - nums[i]) &lt;= t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            mp[tmpID] = nums[i];<br>            <span class="hljs-keyword">if</span> (i &gt;= k) &#123;<br>                mp.erase(getID(nums[i - k], t + <span class="hljs-number">1ll</span>));<br>            &#125;<br>            <br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getID</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">long</span> range)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ID;<br>        <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">0</span>) &#123;<br>            ID = num/range;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;<br>            ID = (num + <span class="hljs-number">1</span>) / range - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ID;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer058-日程表"><a href="#剑指offer058-日程表" class="headerlink" title="剑指offer058 日程表"></a>剑指offer058 日程表</h5><p>利用map，first和second都可以存数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCalendar</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//由小到大的有序对</span><br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>    MyCalendar() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> iter = mp.lower_bound(start);<br>        <span class="hljs-comment">//第一个结束时间比end晚的，比较它的开始时间是否比end早</span><br>        <span class="hljs-keyword">if</span> (iter != mp.end() &amp;&amp; iter-&gt;first &lt; end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//第一个结束时间比end早的，比较它的开始时间是否比start晚</span><br>        <span class="hljs-keyword">if</span> (iter != mp.begin() &amp;&amp; (--iter)-&gt;second &gt; start) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        mp[start] = end;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyCalendar object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyCalendar* obj = new MyCalendar();</span><br><span class="hljs-comment"> * bool param_1 = obj-&gt;book(start,end);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-059-数据流的第K大数值"><a href="#剑指offer-059-数据流的第K大数值" class="headerlink" title="剑指offer 059 数据流的第K大数值"></a>剑指offer 059 数据流的第K大数值</h5><p>priority_queue</p><p>priority_queue 模板有 3 个参数，其中两个有默认的参数；第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象，它定义了一个用来决定元素顺序的断言。因此模板类型是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Container=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;, <span class="hljs-keyword">typename</span> Compare=<span class="hljs-built_in">std</span>::less&lt;T&gt;&gt; class <span class="hljs-built_in">priority_queue</span><br></code></pre></div></td></tr></table></figure><p>如你所见，priority_queue 实例默认有一个 vector 容器。函数对象类型 less<T> 是一个默认的排序断言，定义在头文件 function 中，决定了容器中最大的元素会排在队列前面。fonction 中定义了 greater<T>，用来作为模板的最后一个参数对元素排序，最小元素会排在队列前面。当然，如果指定模板的最巵一个参数，就必须提供另外的两个模板类型参数。</T></T></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KthLargest</span> &#123;</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; heap;<br>    <span class="hljs-keyword">int</span> size;<br><span class="hljs-keyword">public</span>:<br>    KthLargest(<span class="hljs-keyword">int</span> k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        size = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : nums) &#123;<br>            heap.push(i);<br>            <span class="hljs-keyword">if</span> (heap.size() &gt; size) &#123;<br>                heap.pop();<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (heap.size() &lt; size) &#123;<br>            heap.push(val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (heap.top() &lt; val) &#123;<br>                heap.pop();<br>                heap.push(val);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> heap.top();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * KthLargest* obj = new KthLargest(k, nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;add(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++几种排序方式</title>
    <link href="/2022/02/20/C++%20%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/02/20/C++%20%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220310202649537.png" alt="image-20220310202649537" style="zoom:50%;"><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><iframe height="270" width="600" src="https://img-blog.csdnimg.cn/235434e6bb014d3a8d892aa5156ced09.gif"><p>冒泡排序的思想是遍历数组长度遍，比如升序排序，如果右边的数比左边的大，则交换</p><p>下面的版本做一定的优化，避免不必要的排序</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Bubble_Sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = nums.size();<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span> &amp;&amp; flag; ++i) &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n-i<span class="hljs-number">-1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j+<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">int</span> tmp = nums[j];<br>                nums[j] = nums[j+<span class="hljs-number">1</span>];<br>                nums[j+<span class="hljs-number">1</span>] = tmp;<br>                <span class="hljs-comment">//flag的作用是直到这次循环有修改，设为true。</span><br>               <span class="hljs-comment">//如果一次循环没有修改，则排序完成，无需继续。</span><br>                flag = <span class="hljs-literal">true</span>; <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><iframe height="270" width="600" src="https://img-blog.csdnimg.cn/884945969c82467a9e0c7f0aee850d52.gif"><p>选择排序是每次选出最小/最大的数，排在首位，再选第二小/大的数，放在第二位。</p><p>性能略高于冒泡排序</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Selection_Sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = nums.size();<br>    <span class="hljs-keyword">int</span> min;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        min = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[min]) &#123;<br>                min = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> tmp = nums[i];<br>        nums[i] = nums[min];<br>        nums[min] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><iframe height="270" width="600" src="https://img-blog.csdnimg.cn/3670a545effc46f895bfa2b2c71b6eca.gif"><p>从索引1开始，逐渐向前插入，插入到当前索引之前的有序数组中</p><p>最好的情况：所有数据是正序，每次排序都不用移动元素，此时为O(N)；<br>最坏的情况：所有数据都是倒序，每次都要将前面的元素后移，此时为O(N^2);</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++) &#123;<br>        <span class="hljs-keyword">int</span> tmp = nums[i];<br>        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (j; j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &gt; tmp; j--) &#123;<br>            nums[j+<span class="hljs-number">1</span>] = nums[j];<br>        &#125;<br>        nums[j+<span class="hljs-number">1</span>] = tmp; <br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> base = partition(nums, left, right);<br>            quickSort(nums, left, base<span class="hljs-number">-1</span>);<br>            quickSort(nums, base+<span class="hljs-number">1</span>, right);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> ran = rand() % (right-left+<span class="hljs-number">1</span>) + left;<br>        swap(nums[left], nums[ran]);<br>        <span class="hljs-keyword">int</span> base = nums[left];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= base) &#123;<br>                right--;<br>            &#125;<br>            nums[left] = nums[right];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt; base) &#123;<br>                left++;<br>            &#125;<br>            nums[right] = nums[left];<br>        &#125;<br>        nums[left] = base;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        srand((<span class="hljs-keyword">int</span>)time(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span>;<br>        quickSort(nums, left, right);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure></iframe></iframe></iframe>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统考前知识点整理</title>
    <link href="/2021/12/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%80%83%E5%89%8D%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <url>/2021/12/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%80%83%E5%89%8D%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><h4 id="操作系统在计算机系统中的位置及作用⭐"><a href="#操作系统在计算机系统中的位置及作用⭐" class="headerlink" title="操作系统在计算机系统中的位置及作用⭐"></a>操作系统在计算机系统中的位置及作用⭐</h4><p>介于裸机（硬件）和用户程序（软件）之间</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220102223554469.png" alt="image-20220102223554469" style="zoom: 50%;"><ol><li><p>OS对于两层的管理和控制</p><ol><li>对硬件：控制CPU工作，访问存储器，设备驱动，中断处理（向下控制裸机资源）</li><li>对软件：控制、管理，提供方便的用户界面，提供优质的服务（向上应用程序管理控制支持）</li></ol></li><li><p>两层对于OS的制约和影响</p><ol><li>硬件：提供OS运行环境，限制了OS的功能实现</li><li>软件：用户需求，提供优质的服务，方便的用户界面</li></ol></li></ol><h4 id="存储程序式计算机的结构与特点⭐⭐⭐"><a href="#存储程序式计算机的结构与特点⭐⭐⭐" class="headerlink" title="存储程序式计算机的结构与特点⭐⭐⭐"></a>存储程序式计算机的结构与特点⭐⭐⭐</h4><ol><li><p>基本部件：CPU，存储器，I/O设备</p></li><li><p>特点：</p><p>集中顺序过程控制</p><ol><li>过程性：模拟人们手工操作</li><li>集中控制：由CPU集中管理</li><li>顺序性：程序计数器</li></ol></li></ol><h4 id="操作系统的定义与特征⭐⭐⭐"><a href="#操作系统的定义与特征⭐⭐⭐" class="headerlink" title="操作系统的定义与特征⭐⭐⭐"></a>操作系统的定义与特征⭐⭐⭐</h4><ol><li><p>定义：</p><p>操作系统是一个大型的程序系统，它负责计算机系统软硬件资源的分配；控制和协调并发活动；提供用户接口。使用户获得良好的工作环境</p></li><li><p>操作系统的特征</p><ol><li>并发 能处理多个同时性活动的能力。</li><li>共享 多个计算任务对系统资源的共同享用。</li><li>不确定性 操作系统能处理大量的、随机的事件序列，使各用户的计算任务正确地完成。</li></ol></li></ol><h4 id="操作系统的基本功能⭐"><a href="#操作系统的基本功能⭐" class="headerlink" title="操作系统的基本功能⭐"></a>操作系统的基本功能⭐</h4><ol><li><p>处理机管理</p><ol><li>提出进程调度策略</li><li>给出进程调度算法</li><li>进行处理机的分派</li></ol></li><li><p>存储器管理</p><ol><li>存储分配和存储无关性</li><li>存储保护</li><li>存储扩充</li></ol></li><li><p>设备管理</p><ol><li>设备无关性</li><li>设备分配</li><li>设备的传输控制</li></ol></li><li><p>信息管理（文件系统）</p></li><li><p>操作系统的资源管理观点</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220102225252777.png" alt="image-20220102225252777" style="zoom:33%;"></li></ol><h4 id="操作系统的基本技术：多道程序设计技术⭐⭐⭐⭐⭐"><a href="#操作系统的基本技术：多道程序设计技术⭐⭐⭐⭐⭐" class="headerlink" title="操作系统的基本技术：多道程序设计技术⭐⭐⭐⭐⭐"></a>操作系统的基本技术：多道程序设计技术⭐⭐⭐⭐⭐</h4><ol><li><p>概念</p><p>在计算机<strong>主存</strong>中同时存放<strong>几道</strong>相互独立的程序，这些程序在<strong>管理程序控制</strong>之下，<strong>相互穿插地运行</strong>。当某道程序因某种原因不能继续运行下去时（如等待外部设备传输数据），管理程序便将<strong>另一道程序</strong>投入运行。</p></li><li><p>特征</p><p>多道、宏观上并行、微观上串行</p></li><li><p>应用在脱机批处理系统</p><ol><li>联机批处理 特点是监督程序，作业自动过渡，主机负责计算与I/O，有CPU高速与I/O慢速的矛盾，由此引出脱机批处理</li><li>脱机批处理 特点是主机与卫星机并行操作，问题是调度不灵活与保护问题，通过硬件解决：通道技术（DMA）、中断技术，主机负责计算，卫星机负责I/O，主机与卫星机可以并行操作</li></ol></li></ol><h4 id="操作系统的基本技术：分时技术⭐⭐⭐⭐"><a href="#操作系统的基本技术：分时技术⭐⭐⭐⭐" class="headerlink" title="操作系统的基本技术：分时技术⭐⭐⭐⭐"></a>操作系统的基本技术：分时技术⭐⭐⭐⭐</h4><ol><li><p>概念</p><p>所谓分时技术，是把处理机时间划分成很短的时间片（如几百毫秒）轮地分配给各个应用程程序使用，如果某个程序在分配时间片用完之前计算还未完成，该程序就暂时中断，等待下一轮继续计算。</p></li><li><p>分时处理</p><p>一台计算机与许多终端设备连接，终端用户以联机方式使用计算机。</p></li><li><p>应用在分时系统</p></li></ol><h4 id="操作系统的基本类型⭐⭐⭐"><a href="#操作系统的基本类型⭐⭐⭐" class="headerlink" title="操作系统的基本类型⭐⭐⭐"></a>操作系统的基本类型⭐⭐⭐</h4><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220102225350198.png" alt="image-20220102225350198" style="zoom:67%;"><ul><li><p>批量操作系统</p><ul><li><p>批量操作系统是操作系统的一种类型。该系统把用户提交的程序组织成作业形式。作业成批送入计算机，然后由作业调度程序自动选择作业，在系统内多道运行。早期计算机一般都配置批量操作系统。</p></li><li><p>特点</p><ul><li>系统吞吐量高：脱机操作，多道运行，合理搭配作业</li><li>作业周转时间长，用户使用不方便</li></ul></li></ul></li><li><p>分时操作系统</p><ul><li><p>分时操作系统是操作系统的另一种类型。它一般采用时间</p><p>片轮转的办法，使一台计算机同时为多个终端用户服务。</p><p>该系统对每个用户都能保证足够快的响应时间，并提供交</p><p>互会话功能。</p></li><li><p>特点</p><ul><li>并行性</li><li>独占性</li><li>交互性</li></ul></li></ul></li><li><p>实时操作系统</p><ul><li> 实时操作系统对外部输入的信息，能够在规定的时间内处理完毕并作出反应。</li><li>特点<ul><li>可靠性和安全性</li><li>及时响应</li></ul></li><li>类型<ul><li>实时控制</li><li>实时信息处理</li></ul></li></ul></li><li><p>个人计算机操作系统</p></li><li><p>多处理机系统</p><ul><li>也称并行系统或紧耦合系统</li></ul></li><li><p>网络操作系统</p></li><li><p>分布式系统</p></li></ul><p>​    </p><h3 id="操作系统的结构和硬件支持"><a href="#操作系统的结构和硬件支持" class="headerlink" title="操作系统的结构和硬件支持"></a>操作系统的结构和硬件支持</h3><h4 id="什么是操作系统虚拟机⭐"><a href="#什么是操作系统虚拟机⭐" class="headerlink" title="什么是操作系统虚拟机⭐"></a>什么是操作系统虚拟机⭐</h4><p>在裸机上配置了操作系统程序后就构成了操作系统虚拟机</p><ul><li>OS对裸机进行了包装，使应用在包装后的平台上运行，仿佛独占这个计算机一样。</li></ul><h4 id="操作系统的结构⭐"><a href="#操作系统的结构⭐" class="headerlink" title="操作系统的结构⭐"></a>操作系统的结构⭐</h4><ul><li><p>操作系统的设计方法</p><ul><li><p>单体结构</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220103190103662.png" alt="image-20220103190103662" style="zoom:50%;"></li><li><p>模块化结构（逻辑结构各部分换成模块，模块仍在操作系统内）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220103190235098.png" alt="image-20220103190235098" style="zoom:50%;"></li><li><p>可扩展内核结构（操作系统其他功能是可加载模块</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220103191050203.png" alt="image-20220103191050203" style="zoom:50%;"></li><li><p>层次结构</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220103191118028.png" alt="image-20220103191118028" style="zoom:50%;"></li></ul></li><li><p>内核</p><ul><li><p>单一大内核（Monolithic Kernel），也叫宏内核，宏内核里内存，文件，IO，网络这些模块都是集成在一起，运行在内核进程，模块之间的交互直接通过方法调用</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220103193303003.png" alt="image-20220103193303003" style="zoom: 33%;"></li><li><p>微内核（Microkernel） 内核只提供最核心的功能，比如任务调度和内存管理等，其他模块移除内核运行在不同的进程中，即使某一个模块出现问题，只要重启这个模块的进程即可，不会影响到其他模块，稳定性大大增加。甚至可以在系统运行过程中替换现有模块的实现。而且由于模块独立的性质，可以做到模块的按需加载。但是模块间的相互调用需要通过进程间通信，通信效率相对较低。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220103195423711.png" alt="image-20220103195423711" style="zoom:33%;"></li><li><p>混合内核：解决效率问题</p></li></ul></li></ul><h4 id="区分处理机的态的目的⭐⭐⭐"><a href="#区分处理机的态的目的⭐⭐⭐" class="headerlink" title="区分处理机的态的目的⭐⭐⭐"></a>区分处理机的态的目的⭐⭐⭐</h4><p>保护操作系统</p><ul><li>两类程序<ul><li>管理程序：管理系统资源；控制程序运行</li><li>用户程序：使用资源，提出申请；被控制。</li></ul></li></ul><h4 id="管态、用户态二者的区别⭐⭐⭐⭐"><a href="#管态、用户态二者的区别⭐⭐⭐⭐" class="headerlink" title="管态、用户态二者的区别⭐⭐⭐⭐"></a>管态、用户态二者的区别⭐⭐⭐⭐</h4><p>处理机的态，又称处理机的特权级，是中央处理机的工作状态，当前处理机正在执行哪类程序，决定处理机的态。</p><ul><li><p><strong>管态（supervisor mode）</strong></p><p>操作系统的管理程序执行时机器所处的状态，又称处理机的特权级。</p><p>在此状态下<strong>处理机可以使用全部指令</strong>（包括一组特权指令）；<strong>使用全部系统资源</strong>（包括整个存储区域）</p></li><li><p><strong>用户态（user mode）</strong></p><p>用户程序执行时机器所处的状态成为用户态。在此状态下<strong>禁止使用特权指令</strong>，<strong>不能直接取用资源与改变机器状态</strong>，并且只允许用户程序<strong>访问自己的存储区域</strong>。</p><table><thead><tr><th>管态</th><th>用户态</th></tr></thead><tbody><tr><td>操作系统的程序执行</td><td>用户程序执行</td></tr><tr><td>使用全部指令</td><td>禁止使用特权指令</td></tr><tr><td>使用全部系统资源（包括整个存储区域）</td><td>只允许用户程序访问自己的存储区域（主存中）</td></tr></tbody></table><p>处理机状态的特权指令集包括：1. 涉及外部设备的输入输出指令 2. 修改特殊寄存器的指令 3. 改变机器状态的指令</p></li></ul><h4 id="中断的定义、类型⭐⭐⭐"><a href="#中断的定义、类型⭐⭐⭐" class="headerlink" title="中断的定义、类型⭐⭐⭐"></a>中断的定义、类型⭐⭐⭐</h4><p>Intel定义：</p><p>异常（Exception）与中断（IRQ）都是 受保护的控制转换，会导致处理器从用户态切换到内核态，而不会给用户态任何机会干扰内核或者其他环境。</p><p>中断（IRQ）是一种受保护的控制转移，通常由<strong>处理器外部</strong>的<strong>异步</strong>事件引起，例如外部设备I/O活动的通知。</p><p>异常（Exception）是由<strong>当前运行的代码同步</strong>引起的受保护的控制转移，例如除零或者无效的内存访问</p><p><strong>类型</strong></p><p><strong>中断（IRQ）</strong>是指某个事件（例如键盘输入、IO传输结束等）发生时，系统<strong>中止现行程序的运行</strong>、引出<strong>处理事件程序</strong>对该事件进行处理，处理完毕后返回<strong>现行程序的下一条指令</strong>，继续执行。处理的时机是在<strong>指令的间隙</strong>，当前指令执行完毕后会检测是否有中断到达，并由系统决定是否进入中断处理。</p><p><strong>异常（Exception）</strong>是由于程序的行为（如除0错，缺页等）导致的<strong>同步事件</strong>，必须由计算机<strong>立刻处理</strong>。处理完成后，<strong>回到程序发生异常处</strong>继续执行。</p><p><strong>syscall（系统中断）</strong></p><h4 id="中断响应的定义、实质、所需的硬件支持⭐⭐⭐"><a href="#中断响应的定义、实质、所需的硬件支持⭐⭐⭐" class="headerlink" title="中断响应的定义、实质、所需的硬件支持⭐⭐⭐"></a>中断响应的定义、实质、所需的硬件支持⭐⭐⭐</h4><p><strong>定义</strong>：中断响应是当中央处理机发现已有中断请求时，中止现行程序执行，并自动引出中断处理程序的过程。</p><p><strong>实质</strong>：受保护的控制转移，交换指令地址及处理机的状态信息</p><p><strong>需要的硬件支持</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220103204608854.png" alt="image-20220103204608854" style="zoom:50%;"><p>正在执行的程序是低优先态，中断处理程序是高优先态，中断进入只能由硬件完成</p><h4 id="软件中断处理过程⭐⭐⭐"><a href="#软件中断处理过程⭐⭐⭐" class="headerlink" title="软件中断处理过程⭐⭐⭐"></a>软件中断处理过程⭐⭐⭐</h4><p>当硬件完成了中断进入过程（保存程序断点及处理机有关信息，自动转入相应的中断处理程序执行）后，由相应的中断处理程序得到控制权，进入了软件的中断处理过程。</p><p>过程如下</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220103205121261.png" alt="image-20220103205121261" style="zoom:50%;"><h4 id="必要的硬件支持，PIT、DMA等⭐"><a href="#必要的硬件支持，PIT、DMA等⭐" class="headerlink" title="必要的硬件支持，PIT、DMA等⭐"></a>必要的硬件支持，PIT、DMA等⭐</h4><ul><li><p>主存储器（主存、内存）：</p><p>处理机能直接访问的存储器称为主存储器，用来存放正在或将要执行的系统和用户程序和数据以及程序执行时要求的临时存储空间。</p><p>只读存储器ROM(Read-only memory)： ROM称为BIOS，用来存放基本的I/O程序。</p></li></ul><p>​        随机访问存储器 RAM（random access memory)</p><ul><li><p>辅存储器（辅存、外存）：</p><p>处理机不能直接访问的存储器，如磁盘、磁带、光盘等，用来存放大量的数据信息。</p></li></ul><p>可编程间隔定时器（Programmable Interval Timer，PIT)</p><p>略</p><h3 id="操作系统的用户接口"><a href="#操作系统的用户接口" class="headerlink" title="操作系统的用户接口"></a>操作系统的用户接口</h3><h4 id="用户程序的步骤以及各步骤之间的关系⭐"><a href="#用户程序的步骤以及各步骤之间的关系⭐" class="headerlink" title="用户程序的步骤以及各步骤之间的关系⭐"></a>用户程序的步骤以及各步骤之间的关系⭐</h4><ol><li><p><strong>编辑</strong></p><p>建立一个新文件，或对已有的文件中的错误进行修改</p></li><li><p><strong>编译</strong></p><p>将源程序翻译成浮动的目标代码（没有逻辑地址）</p></li><li><p><strong>连接</strong></p><p>主程序和其他所需要的子程序和例行程序连接装配在一起，使之成为一个可执行的，完整的主存映像文件。（每个语句对应的逻辑地址固定）</p></li><li><p><strong>运行</strong></p><p>将主存映像文件调入主存，启动运行，得出计算结果</p></li></ol><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220103223826452.png" alt="image-20220103223826452" style="zoom:50%;"><h4 id="静态连接和动态链接的区别⭐⭐⭐"><a href="#静态连接和动态链接的区别⭐⭐⭐" class="headerlink" title="静态连接和动态链接的区别⭐⭐⭐"></a>静态连接和动态链接的区别⭐⭐⭐</h4><ol><li>静态连接是<strong>将所有的外部调用函数都连接到目标文件中形成一个完整的主存映像文件</strong>。</li><li>当有多个应用程序都需要调用同一个库函数时，这<strong>多个应用程序的目标文件中都将包含这个外部函数对应的代码，这将造成主存的极大浪费</strong>，不能支持有效的共享。</li><li>如果静态库有更新的话，所有可执行文件都要重新链接才能用上新的静态库。</li><li>程序发布时不需要依赖库，也就是不需要再带着库一起发布。</li><li>静态连接运行速度快。</li></ol><ol><li><p>动态链接时将这一连接工作延迟到程序运行的时候进行，所需要的支持是动态链接库DLL，动态链接<strong>不需要将应用程序所需要的外部函数代码从库中提取出来并连接到目标文件中，而是在应用程序需要调用外部函数的地方做记录，并说明要使用的外部函数名和引用入口号，形成调用链表。</strong></p></li><li><p>当所需的动态链接库DLL在主存时，就可以正确地引用这个外部函数了，多个程序执行时共享一份副本，节省空间。</p></li><li><p>动态库更新方便。</p></li><li><p>发布需要依赖库。</p></li><li><p>动态链接由于执行程序需要进行链接，有性能损失。</p></li></ol><h4 id="操作系统提供哪两个接口，使用场合⭐⭐⭐"><a href="#操作系统提供哪两个接口，使用场合⭐⭐⭐" class="headerlink" title="操作系统提供哪两个接口，使用场合⭐⭐⭐"></a>操作系统提供哪两个接口，使用场合⭐⭐⭐</h4><p><strong>命令接口</strong>（操作命令，不能叫操作界面，因为不一定有操作界面）</p><ul><li>用户通过这个操作接口来组织自己的工作流程和控制程序的运行</li></ul><p><strong>程序接口</strong>（系统调用）</p><ul><li>任何一个用户在其运行过程中，可以使用操作系统提供的功能调用来请求操作系统的服务（如申请主存，使用各种外设，创建进程或线程）</li></ul><h4 id="系统调用的概念及实现方法⭐⭐⭐"><a href="#系统调用的概念及实现方法⭐⭐⭐" class="headerlink" title="系统调用的概念及实现方法⭐⭐⭐"></a>系统调用的概念及实现方法⭐⭐⭐</h4><p><strong>系统功能调用</strong>是用户在程序一级请求操作系统服务的一种手段，它不是一条简单的硬指令，而是带有一定功能号的访管指令，它的功能并非由硬件直接提供，而是由操作系统中的一段程序完成的，即由软件方法实现的。但是特权级的切换与恢复现场是由硬件完成。</p><p><strong>实现方法</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220103234946938.png" alt="image-20220103234946938" style="zoom: 33%;"><p>采用统一进管方式——系统提供访管指令与访管中断</p><p>访管指令又叫自愿进管指令，svc n（svc表示机器访管指令的操作码记忆符，n为地址码（功能号））</p><p>在用户程序中，需要请求操作系统服务的地方安排一条系统调用，这样，当程序执行到这一条命令时，就会发生中断，系统由用户态转为管态，操作系统的访问中断处理程序得到控制权，它将按系统调用的功能号，借助例行子程序入口地址表转到相应的例行程序去执行，在完成了用户所需的服务功能后，退出中断，返回到用户程序的断点继续执行。</p><h3 id="进程及进程管理"><a href="#进程及进程管理" class="headerlink" title="进程及进程管理"></a>进程及进程管理</h3><h4 id="进程引入⭐⭐⭐"><a href="#进程引入⭐⭐⭐" class="headerlink" title="进程引入⭐⭐⭐"></a>进程引入⭐⭐⭐</h4><p>进程是Time sharing分时方面的概念，与多道要进行区分</p><h5 id="程序的顺序执行-定义-特点"><a href="#程序的顺序执行-定义-特点" class="headerlink" title="程序的顺序执行 定义 特点"></a>程序的顺序执行 定义 特点</h5><p>顺序执行一般指单道，若是多道系统，一般不存在顺序执行</p><p><strong>定义</strong>：一个计算的<strong>若干操作</strong>必须按照<strong>严格</strong>的<strong>先后次序顺序地</strong>执行，而且中间不会被任何事件或程序所打断（<strong>单道</strong>），这类计算过程就是程序地顺序执行<strong>过程</strong></p><p><strong>特点：</strong></p><ol><li><strong>顺序性</strong> —— 处理机的操作严格按照程序所规定的顺序执行。</li><li><strong>封闭性</strong> —— 程序一旦开始执行，其计算结果不受外界因素的影响，不可被打断，包括OS。</li><li><strong>可再现性</strong> —— 程序执行的结果与它的执行速度无关 (即与时间无关)，而只与初始条件有关。（放在不同地机器上，初始条件一致，结果相同） </li></ol><p>​                            <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220104160210404.png" alt="image-20220104160210404" style="zoom:33%;"></p><p>同一时间只能存在一道程序                                        </p><h5 id="程序的并发执行-定义-特点"><a href="#程序的并发执行-定义-特点" class="headerlink" title="程序的并发执行 定义 特点"></a>程序的并发执行 定义 特点</h5><p>并发并未强调处理部件的数量</p><p><strong>定义</strong>：若干个程序段同时在系统中运行，这些程序段的执行在<strong>时间上是重叠的</strong>，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠时很小的一部分，也称这几个程序是并发执行的</p><p><strong>特点：</strong></p><ol><li>（可能）失去程序的封闭性和可再现性</li><li>程序与计算不再一一对应</li><li>程序并发执行的相互制约</li></ol><h4 id="进程定义⭐⭐⭐⭐⭐"><a href="#进程定义⭐⭐⭐⭐⭐" class="headerlink" title="进程定义⭐⭐⭐⭐⭐"></a>进程定义⭐⭐⭐⭐⭐</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>所谓进程，就是一个程序在给定的<strong>活动空间</strong>和<strong>初始环境</strong>下在一个处理机上的<strong>执行过程</strong>。</p><p>（不是程序实体，而是实体的执行过程）</p><h5 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h5><ol><li>程序是静态的概念（磁盘上的一个文件），而进程是动态的概念</li><li>进程是一个独立运行的活动单位</li><li>进程是竞争系统资源的基本单位，资源只可能分配给进程</li><li>一个程序可以对应多个进程（一个程序可以多开），一个进程至少包含一个程序</li></ol><h4 id="进程状态⭐⭐⭐"><a href="#进程状态⭐⭐⭐" class="headerlink" title="进程状态⭐⭐⭐"></a>进程状态⭐⭐⭐</h4><h5 id="三个基本状态、状态变迁图"><a href="#三个基本状态、状态变迁图" class="headerlink" title="三个基本状态、状态变迁图"></a>三个基本状态、状态变迁图</h5><ol><li>运行状态（running） 该进程以获得运行所必需的资源，它的程序正在处理机上执行</li><li>等待状态(wait)  进程正等待着某一事件的发生而暂时停止执行。这时,即使给它CPU控制权，它也无法执行。</li><li>就绪状态（ready） 进程已获得除CPU之外的运行所必需的资源，一旦得到CPU控制权，立即可以运行。    </li></ol><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220104162609157.png" alt="image-20220104162609157"></p><p>等待-&gt;运行不可能发生，等待完后一定到就绪状态，等待运行</p><p>运行-&gt;等待，只要就绪队列非空，就可以</p><p>运行-&gt;就绪，一定会发生，当前运行进程自身就能完成</p><h5 id="不同操作系统类型的进程状态变迁"><a href="#不同操作系统类型的进程状态变迁" class="headerlink" title="不同操作系统类型的进程状态变迁"></a>不同操作系统类型的进程状态变迁</h5><ul><li><p>三程序（排序，只使用CPU）在不同的操作系统环境中的执行结果</p><ul><li>不支持多进程的操作系统 单道顺序执行 T = T1 + T2 + T3</li></ul></li><li><p>支持多进程的操作系统</p><ul><li>单核，有调度开销 T &gt;= T1 + T2 + T3</li></ul></li><li><p>两程序（打印与计算，不同设备）</p><ul><li>不支持多进程 T = T1 + T2</li><li>支持多进程 T = max{T1, T2} 占用不同设备</li></ul></li></ul><h4 id="进程描述⭐⭐⭐⭐"><a href="#进程描述⭐⭐⭐⭐" class="headerlink" title="进程描述⭐⭐⭐⭐"></a>进程描述⭐⭐⭐⭐</h4><h5 id="PCB（进程控制块）的定义与作用"><a href="#PCB（进程控制块）的定义与作用" class="headerlink" title="PCB（进程控制块）的定义与作用"></a>PCB（进程控制块）的定义与作用</h5><p>定义：描述进程与其他进程、系统资源的关系以及进程在各个不同时期所处的状态的<em>数据结构</em>，称为<strong>进程控制块</strong> </p><h5 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h5><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220104194224638.png" alt="image-20220104194224638" style="zoom: 50%;"><ol><li>程序与数据：描述进程本身所应完成的功能</li><li>PCB：进程的动态特征，该进程与其他进程和系统资源的关系</li></ol><h4 id="线程定义⭐⭐⭐"><a href="#线程定义⭐⭐⭐" class="headerlink" title="线程定义⭐⭐⭐"></a>线程定义⭐⭐⭐</h4><p>定义：线程是比进程更小的活动单位，它是进程中的一个执行路径。</p><h4 id="进程控制⭐"><a href="#进程控制⭐" class="headerlink" title="进程控制⭐"></a>进程控制⭐</h4><h5 id="进程控制原语"><a href="#进程控制原语" class="headerlink" title="进程控制原语"></a>进程控制原语</h5><ul><li><p>基本进程控制原语</p><p>创建原语、撤消原语、阻塞原语、唤醒原语</p></li><li><p>进程控制原语的执行与进程状态的变化</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220104231715636.png" alt="image-20220104231715636" style="zoom: 50%;"></li></ul><h5 id="进程创建、进程撤销原语的功能"><a href="#进程创建、进程撤销原语的功能" class="headerlink" title="进程创建、进程撤销原语的功能"></a>进程创建、进程撤销原语的功能</h5><ul><li><p>进程创建原语</p><p>create (name，priority) </p><ul><li>name为被创建进程的标识符</li><li>priority为进程的优先级</li></ul><p>功能：创建一个具有指定标识符的进程，建立进程的PCB结构</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220104231959148.png" alt="image-20220104231959148" style="zoom:50%;"></li><li><p>进程撤销原语</p><p>当进程完成任务后希望终止自己时使用进程撤销原语kill或者exit（kill可能导致内存泄漏，只释放了PCB资源，没有释放allocated资源</p><p>功能：撤消当前运行的进程。将该进程的PCB结构归还到PCB资源池，所占用的资源归还给父进程，从总链队列中摘除它，然后转进程调度程序。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220104232113727.png" alt="image-20220104232113727" style="zoom:50%;"></li></ul><h5 id="进程等待、进程唤醒原语的功能"><a href="#进程等待、进程唤醒原语的功能" class="headerlink" title="进程等待、进程唤醒原语的功能"></a>进程等待、进程唤醒原语的功能</h5><ul><li><p>进程等待原语</p><p>当进程需要等待某一事件完成时，它可以调用等待原语挂起自己 susp(chan) 入口参数chan：进程等待的原因</p><p>功能：中止调用进程的执行，并加入到等待chan的等待队列中，最后使控制转向进程调度</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220104232333020.png" alt="image-20220104232333020" style="zoom:50%;"></li><li><p>进程唤醒原语</p><p>当处于等待状态的进程所期待的事件来到时，由发现者进程使用唤醒原语唤醒它。 wakeup(chan) 入口参数chan：进程唤醒的原因</p><p>功能：当进程等待的事件发生时，唤醒等待该事件的进程。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220104232617155.png" alt="image-20220104232617155" style="zoom:50%;"></li></ul><h4 id="进程的相互制约关系⭐⭐⭐⭐⭐"><a href="#进程的相互制约关系⭐⭐⭐⭐⭐" class="headerlink" title="进程的相互制约关系⭐⭐⭐⭐⭐"></a>进程的相互制约关系⭐⭐⭐⭐⭐</h4><p>互斥与同步都是相互制约关系，但是互斥是相互排斥，一定有临界资源，同步是互相等待，互通消息，不一定有临界资源。</p><h5 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h5><ul><li><p>临界资源（critical resource）</p><p>定义：一次仅允许一个进程使用的资源称为临界资源</p><p>硬件：输入机、打印机、磁带机等</p><p>软件：公用变量，数据，表格，队列等。</p></li><li><p>互斥</p><p>在操作系统中，当某一进程正在访问同一临界资源所在的临界区时，就不允许其他进程来读出或者修改临界区的内容，否则，就会产生后果无法估计的错误。进程间的这种相互制约关系称为互斥。</p></li><li><p>临界区</p><p>临界区是进程中对公共变量 (或存储区)进行<strong>审查与修改</strong>（即使用临界资源）的程序段，称为相对于该公共变量的临界区。 </p><p>临界区越小越好，意味着系统并发度高，效率高。</p></li></ul><h5 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h5><ul><li><p>进程同步的概念</p><p>并发进程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通消息称为进程同步。</p></li><li><p>进程同步的例</p><ul><li>病员就医</li><li>共享缓冲区的计算进程与打印进程的同步</li></ul></li></ul><h4 id="进程同步机构⭐⭐⭐⭐⭐"><a href="#进程同步机构⭐⭐⭐⭐⭐" class="headerlink" title="进程同步机构⭐⭐⭐⭐⭐"></a>进程同步机构⭐⭐⭐⭐⭐</h4><h5 id="锁、上锁原语、开锁原语⭐⭐"><a href="#锁、上锁原语、开锁原语⭐⭐" class="headerlink" title="锁、上锁原语、开锁原语⭐⭐"></a>锁、上锁原语、开锁原语⭐⭐</h5><p>用变量w代表某种资源的状态，w称为锁，一般用于多核，使用锁会有风险（关中断）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220104234756022.png" alt="image-20220104234756022" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105003212164.png" alt="image-20220105003212164" style="zoom:33%;"><h5 id="信号灯及P、V操作"><a href="#信号灯及P、V操作" class="headerlink" title="信号灯及P、V操作"></a>信号灯及P、V操作</h5><p>信号灯是一个确定的二元组（s，q），s是一个具有非负初值的整形变量，q是一个初始状态为空的队列，操作系统利用信号灯的状态对并发进程和共享资源进行控制和管理。</p><p>信号灯是整型变量</p><p>变量值&gt;=0时，表示绿灯，进程执行</p><p>变量值&lt;0时，表示红灯，进程停止执行</p><p>注：创建信号灯时，应准确说明信号灯s的意义和初值，这个初值绝不能为负值。</p><ul><li><p>P操作，又称wait</p><p>对信号灯s的 p操作记为 p(s)。p(s)是一个不可分割的<strong>原语操作</strong>，即取信号灯值减1，<strong>若相减结果为负，则调用p(s)的进程被阻，并插入到该信号灯的等待队列中，否则可以继续执行</strong>。</p></li><li><p>V操作，又称signed</p><p>对信号灯s的 v操作记为 v(s)。v(s)是一个不可分割的原语操作，即取信号灯值加1，若<strong>相加结果大于零，进程继续执行，否则，要帮助唤醒在信号灯等待队列上的一个进程。</strong></p></li></ul><h4 id="进程同步与互斥的实现⭐⭐⭐⭐⭐"><a href="#进程同步与互斥的实现⭐⭐⭐⭐⭐" class="headerlink" title="进程同步与互斥的实现⭐⭐⭐⭐⭐"></a>进程同步与互斥的实现⭐⭐⭐⭐⭐</h4><p>锁与PV操作是两种机制，锁通过busy polling实现进程互斥，PV是通过进程状态转换实现进程互斥，但是在状态切换频繁时，会有额外开销，运用于大临界区。</p><h5 id="用信号灯的P、V操作实现进程互斥"><a href="#用信号灯的P、V操作实现进程互斥" class="headerlink" title="用信号灯的P、V操作实现进程互斥"></a>用信号灯的P、V操作实现进程互斥</h5><h5 id="两类同步问题的解答"><a href="#两类同步问题的解答" class="headerlink" title="两类同步问题的解答"></a>两类同步问题的解答</h5><ul><li>合作进程的执行次序</li><li>共享缓冲区的合作进程的同步</li></ul><h5 id="生产者——消费者问题及解答"><a href="#生产者——消费者问题及解答" class="headerlink" title="生产者——消费者问题及解答"></a>生产者——消费者问题及解答</h5><h4 id="操作系统的并发控制机制⭐"><a href="#操作系统的并发控制机制⭐" class="headerlink" title="操作系统的并发控制机制⭐"></a>操作系统的并发控制机制⭐</h4><h5 id="创建进程、创建线程-及其使用"><a href="#创建进程、创建线程-及其使用" class="headerlink" title="创建进程、创建线程 及其使用"></a>创建进程、创建线程 及其使用</h5><h5 id="等待进程、线程的终止及其使用"><a href="#等待进程、线程的终止及其使用" class="headerlink" title="等待进程、线程的终止及其使用"></a>等待进程、线程的终止及其使用</h5><h5 id="信号量与使用方法"><a href="#信号量与使用方法" class="headerlink" title="信号量与使用方法"></a>信号量与使用方法</h5><h5 id="共享内存与使用方法"><a href="#共享内存与使用方法" class="headerlink" title="共享内存与使用方法"></a>共享内存与使用方法</h5><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><h5 id="进程调度的功能⭐⭐⭐⭐"><a href="#进程调度的功能⭐⭐⭐⭐" class="headerlink" title="进程调度的功能⭐⭐⭐⭐"></a>进程调度的功能⭐⭐⭐⭐</h5><ol><li>进程管理的数据结构</li><li>决定调度策略<ol><li>优先调度 就绪队列按进程优先级高低排序 会产生低优先级饿死的问题</li><li>先来先服务 就绪队列按进程阿里到的先后次序排序 没有照顾高优先级服务</li></ol></li><li>实施处理机的分配和回收</li></ol><h5 id="调度方式-非剥夺方式-剥夺方式⭐⭐⭐"><a href="#调度方式-非剥夺方式-剥夺方式⭐⭐⭐" class="headerlink" title="调度方式 非剥夺方式 剥夺方式⭐⭐⭐"></a>调度方式 非剥夺方式 剥夺方式⭐⭐⭐</h5><p><strong>调度方式</strong>： 当一进程正在处理机上执行时，若有某个更为“重要而紧迫”的进程需要运行，系统如何分配处理机</p><p><strong>非剥夺方式</strong>：当“重要而紧迫”的进程来到时，让正在执行的进程继续执行，直到该进程完成或发生某事件而进入“完成”或“阻塞”状态时，才把处理机分配给“重要而紧迫”的进程。</p><p>不抢占，剥夺方式的开销大，因此计算服务器这种速度更重要的使用非剥夺方式</p><p><strong>剥夺方式</strong>：当“重要而紧迫”的进程来到时，便暂停正在执行的进程，立即把处理机分配给优先级更高的进程。</p><p>手机平板PC，速度不重要，响应重要，进程切换次数频繁，花在进程切换的开销大。</p><h5 id="常用的进程调度算法⭐⭐⭐⭐"><a href="#常用的进程调度算法⭐⭐⭐⭐" class="headerlink" title="常用的进程调度算法⭐⭐⭐⭐"></a>常用的进程调度算法⭐⭐⭐⭐</h5><ul><li><p>进程优先数调度算法</p><p>预先确定各进程的优先数，系统把处理机的使用权赋予就绪队列中具备最高优先权 (优先数和一定的优先级相对应)的就绪进程。</p></li><li><p>循环轮转调度算法</p><p>当CPU空闲时，选取就绪队列首元素，赋予一个时间片，当时间片用完时，该进程转为就绪态并进入就绪队列末端。</p></li></ul><h5 id="调度用的进程状态变迁图的分析⭐⭐⭐"><a href="#调度用的进程状态变迁图的分析⭐⭐⭐" class="headerlink" title="调度用的进程状态变迁图的分析⭐⭐⭐"></a>调度用的进程状态变迁图的分析⭐⭐⭐</h5><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105010927340.png" alt="image-20220105010927340" style="zoom:50%;"><p>   <strong>优先调度与时间片调度相结合的调度算法</strong></p><ol><li>当CPU空闲时，若高优先就绪队列非空，则从高优先就绪队列中选择一个进程运行，分配时间片为100ms。</li><li>当CPU空闲时，若高优先就绪队列为空，则从低优先就绪队列中选择一个进程运行，分配时间片为500ms。</li></ol><p>​    优先照顾了IO量大的进程，适当照顾计算量大的进程</p><h3 id="资源分配与调度"><a href="#资源分配与调度" class="headerlink" title="资源分配与调度"></a>资源分配与调度</h3><h4 id="资源管理功能⭐"><a href="#资源管理功能⭐" class="headerlink" title="资源管理功能⭐"></a>资源管理功能⭐</h4><p>   <strong>(1)</strong> <strong>资源数据结构的描述</strong></p><p>​       包含资源的物理名、逻辑名、类型、地址、分配状态等信息。</p><p>   <strong>(2)</strong> <strong>确定资源的分配原则</strong> (调度原则)</p><p>​        决定资源应分给谁，何时分配，分配多少等问题。</p><p>   <strong>(3)</strong> <strong>实施资源分配</strong></p><p>​       执行资源分配；资源收回工作。</p><p>   <strong>(4)</strong> <strong>存取控制和安全保护</strong></p><p>​        对资源的存取进行控制并对资源实施安全保护措施。</p><h4 id="资源分配策略⭐"><a href="#资源分配策略⭐" class="headerlink" title="资源分配策略⭐"></a>资源分配策略⭐</h4><h5 id="先请求先服务"><a href="#先请求先服务" class="headerlink" title="先请求先服务"></a>先请求先服务</h5><p>每一个新产生的请求均排在队尾</p><p>当资源可用时，取队首元素，并满足其需要</p><p>排序原则：按请求的先后次序排列</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105012058727.png" alt="image-20220105012058727" style="zoom:50%;"><h5 id="优先调度"><a href="#优先调度" class="headerlink" title="优先调度"></a>优先调度</h5><p>对每一个进程指定一个优先级</p><p>每一个新产生的请求，按照其优先级的高低插到相应的位置</p><p>当资源可用时，取队首元素，并满足其需要</p><p>排序原则：按优先级的高低排序</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105012222895.png" alt="image-20220105012222895" style="zoom:50%;"><h5 id="针对设备特性的调度"><a href="#针对设备特性的调度" class="headerlink" title="针对设备特性的调度"></a>针对设备特性的调度</h5><h4 id="死锁⭐⭐⭐⭐⭐"><a href="#死锁⭐⭐⭐⭐⭐" class="headerlink" title="死锁⭐⭐⭐⭐⭐"></a>死锁⭐⭐⭐⭐⭐</h4><h5 id="定义-举例"><a href="#定义-举例" class="headerlink" title="定义 举例"></a>定义 举例</h5><p>在两个或多个并发进程中，如果每个进程持有某种资源而有都等待着别的进程释放它或它们现在保持着的资源，所有进程都是等待态否则就不能向前推进，此时，称这一组进程产生了死锁。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105013150128.png" alt="image-20220105013150128" style="zoom:50%;"><h5 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h5><ol><li>系统资源不足</li><li>进程推进顺序非法</li></ol><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105013356382.png" alt="image-20220105013356382" style="zoom: 33%;"><h5 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h5><p>发生死锁必然会有的条件</p><ul><li><p>互斥条件</p><p>涉及的资源是非共享的，即为临界资源</p></li><li><p>不剥夺条件</p><p>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走</p></li><li><p>部分分配</p><p>进程每次申请它所需要的一部分资源，在等待一新资源的同时，进程继续占用已分配到的资源</p></li><li><p>环路条件</p><p>存在一种进程的循环连，链中的每个一进程已获得的资源同时被链中下一个进程所请求。</p><p>这个条件是充要条件，存在环路也一定有死锁</p></li></ul><h4 id="解决死锁问题"><a href="#解决死锁问题" class="headerlink" title="解决死锁问题"></a>解决死锁问题</h4><p>破坏产生死锁的四个必要条件之一</p><p>预防死锁——采用静态资源分配</p><p>避免死锁——有控资源分配方法</p><h5 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h5><ul><li><p>静态预防死锁的方法</p><p>在作业调度时为选中的作业分配它所需要的所有资源，当资源一旦分配给该作业后，在其整个运行期间这些资源为它独占。</p></li></ul><h5 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h5><ul><li><p>有序资源分配方法（动态预防死锁的方法）</p><p>系统中所有资源都给定一个唯一的编号，所有分配请求必须以上升的次序进行。当遵守上升次序的规则时，若资源可用，则予以分配；否则，请求者等待。</p></li><li><p>银行家算法</p><p>申请者事先说明对各类资源的最大需求量。在进程活动期间动态申请某类资源时，由系统审查现有该类资源的数目是否能满足当前进程的最大需求量，如能满足就予以分配，否则拒绝。</p><p>安全状态：如果系统存在一条资源分配路径，使系统不发生死锁。</p></li></ul><h3 id="处理机调度⭐⭐"><a href="#处理机调度⭐⭐" class="headerlink" title="处理机调度⭐⭐"></a>处理机调度⭐⭐</h3><h4 id="处理机的二级调度"><a href="#处理机的二级调度" class="headerlink" title="处理机的二级调度"></a>处理机的二级调度</h4><p>只有内存中的程序才能在CPU上运行。因此，处理机的调度通常分为两层</p><p>宏观：作业调度</p><p>对存放在辅存设备上的大量作业，以一定的策略进行挑选，分配主存等必要的资源，建立作业对应的进程，使其投入运行。</p><p>微观上：进程调度</p><p>对进入主存的所有进程，确定哪个进程在什么时候获得处理机，使用多长时间。</p><h4 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h4><h5 id="作业的状态"><a href="#作业的状态" class="headerlink" title="作业的状态"></a>作业的状态</h5><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105113204143.png" style="zoom:50%;"><p>作业由磁盘调度到主存时，就创建了进程，进行进程的三态转换。</p><h5 id="作业控制块"><a href="#作业控制块" class="headerlink" title="作业控制块"></a>作业控制块</h5><p>作业控制块（JCB），记录进入系统的作业情况（类型、状态、资源请求与分配等）</p><h5 id="作业调度的功能"><a href="#作业调度的功能" class="headerlink" title="作业调度的功能"></a>作业调度的功能</h5><ol><li><p>确定数据结构（JCB）</p></li><li><p>确定调度策略与调度算法</p></li><li><p>分配资源</p></li><li><p>善后处理</p></li></ol><h5 id="周转时间、带权周转时间：定义、物理意义"><a href="#周转时间、带权周转时间：定义、物理意义" class="headerlink" title="周转时间、带权周转时间：定义、物理意义"></a>周转时间、带权周转时间：定义、物理意义</h5><p><strong>周转时间</strong>：各作业<strong>提交给计算机系统</strong>到该<strong>作业的结果返回给用户</strong>所需要的时间。注意不是执行时间，包括后备状态（等待）时间，不是提交就能运行。</p><p>ti：作业周转时间        tci：作业完成时间       tsi：作业提交时间</p><p>ti = tci - tsi</p><ul><li>意义：说明作业i在系统中停留的时间长短</li><li>平均周转时间</li></ul><p><strong>带权周转时间</strong>：一个作业的周转时间与其运行时间的比值 wi = ti/tr &gt;=1</p><ul><li>意义：说明作业i在系统中的相对等待时间</li><li>平均带权周转时间 </li><li>精确度高于周转时间和平均周转时间</li></ul><h5 id="常用的作业调度算法"><a href="#常用的作业调度算法" class="headerlink" title="常用的作业调度算法"></a>常用的作业调度算法</h5><ul><li><p>先来先服务（FCFS）</p><p>策略：按照作业到来的先后次序进行调度，先来先服务，效率较低</p><p>特点：</p><ol><li>每次选择等待时间最久的作业，而不考虑作业运行时间的长短</li><li>实现简单，效率较低，在一些实际的系统和一般应用程序中应用较多。</li></ol></li><li><p>短作业优先</p><p>策略：考虑作业的运行时间，每次总选择一个请求运行时间最小的作业调入内存（系统）</p><p>特点：</p><ol><li>易实现，系统吞吐量高</li><li>只考虑短作业，而没有考虑长作业的利益</li><li>相对先来先服务调度算法实现要困难些，如果作业的到来顺序以及运行时间不合适，会出现饿死现象</li></ol></li></ul><p>解题时表格格式如下</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105153555407.png" alt="image-20220105153555407" style="zoom:33%;"><h4 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度"></a>进程调度</h4><h5 id="进程调度的功能"><a href="#进程调度的功能" class="headerlink" title="进程调度的功能"></a>进程调度的功能</h5><ol><li><p>记录和保持系统中所有进程的有关情况和状态特征</p></li><li><p>决定分配（处理机）策略</p><p>调度策略的不同，组织就绪进程队列的方式也不同。</p><ul><li>先来先服务调度：就绪进程按等待时间大小的顺序排队</li><li>优先数调度：就绪进程按优先数的先后次序排队</li></ul></li><li><p>实施处理机的分配和回收</p></li></ol><h5 id="调度方式：非剥夺方式-剥夺方式"><a href="#调度方式：非剥夺方式-剥夺方式" class="headerlink" title="调度方式：非剥夺方式 剥夺方式"></a>调度方式：非剥夺方式 剥夺方式</h5><ul><li>非剥夺方式（来了一个紧急任务，就让它等待，先运行当前的程序，不能剥夺当前正在运行的系统的控制权）<ul><li>优点： 实现简单，系统开销小</li><li>缺点：难以满足紧急任务的要求</li></ul></li><li>剥夺方式（目前的桌面系统都是剥夺方式）<ul><li>优点：及时响应紧急任务</li><li>缺点：增加了系统开销</li></ul></li></ul><h5 id="常用的进程调度算法"><a href="#常用的进程调度算法" class="headerlink" title="常用的进程调度算法"></a>常用的进程调度算法</h5><ul><li><p>优先数调度</p><p>按照优先数调度</p></li><li><p>循环轮转调度</p><p>系统的响应时间分成大小相等（或不等）的时间片。每个进程被调度到后，占用一个时间片，时间片用完后，该进程让出CPU，排在就绪队列的队尾。多个进程循环轮转。</p><p>T(响应时间)=N(进程数目)*q(时间片)</p></li></ul><h5 id="调度用的进程状态变迁图（多种进程状态及变迁）"><a href="#调度用的进程状态变迁图（多种进程状态及变迁）" class="headerlink" title="调度用的进程状态变迁图（多种进程状态及变迁）"></a>调度用的进程状态变迁图（多种进程状态及变迁）</h5><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105010927340.png" style="zoom:33%;"><h3 id="主存管理"><a href="#主存管理" class="headerlink" title="主存管理"></a>主存管理</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="虚实分离⭐⭐⭐⭐⭐"><a href="#虚实分离⭐⭐⭐⭐⭐" class="headerlink" title="虚实分离⭐⭐⭐⭐⭐"></a>虚实分离⭐⭐⭐⭐⭐</h5><ul><li><p>逻辑地址 作业地址空间</p><p>又叫相对地址或者虚地址，用户的程序地址（指令地址或操作数地址）均为逻辑地址。</p><p>程序地址空间是用户程序所有的逻辑地址集合对应的空间。</p></li><li><p>物理地址 存储空间</p><p>又叫逻辑地址或者实地址，时计算机主存单元的真实地址，又称为绝对地址或实地址</p><p>物理地址的集合所对应的空间组成了主存空间</p></li></ul><h5 id="地址映射⭐⭐⭐⭐"><a href="#地址映射⭐⭐⭐⭐" class="headerlink" title="地址映射⭐⭐⭐⭐"></a>地址映射⭐⭐⭐⭐</h5><ul><li><p>定义</p><p>将程序地址空间中使用的逻辑地址变换成主存中的物理地址的过程，称为地址映射</p></li><li><p>类型——静态地址重定位的定义和实现</p><p>程序装入过程中随机进行的地址变换方式称为静态地址映射，目标代码不可浮动</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105160529766.png" alt="image-20220105160529766" style="zoom:50%;"></li><li><p>类型——动态地址重定位的定义和实现</p><p>在程序执行期间，随着每条指令和数据的访问自动地连续地进行地址映射，这种地址变换方式称为动态地址映射。（需要硬件的支持）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105160639958.png" alt="image-20220105160639958" style="zoom: 50%;"></li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105160757857.png" alt="image-20220105160757857" style="zoom:50%;"><h5 id="虚存⭐⭐⭐⭐"><a href="#虚存⭐⭐⭐⭐" class="headerlink" title="虚存⭐⭐⭐⭐"></a>虚存⭐⭐⭐⭐</h5><p>由操作系统和硬件相配合来完成主存和辅存之间的信息的动态调度。这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器。</p><p>核心：</p><ol><li>逻辑地址与物理地址分开</li><li>存储空间与虚地址空间分开</li><li>提供地址变换机构</li></ol><p>物质基础是要有相当容量地辅存，有一定容量的主存，以及地址变换机构。</p><h5 id="存储保护⭐⭐⭐⭐"><a href="#存储保护⭐⭐⭐⭐" class="headerlink" title="存储保护⭐⭐⭐⭐"></a>存储保护⭐⭐⭐⭐</h5><ul><li><p>定义</p><p>在多用户环境中，主存储器按区分配给各用户程序使用。为了互不影响，必须由硬件 (软件配合)保证各用户程序只能在给定的存储区域内活动，这种措施叫做存储保护。</p></li><li><p>界地址保护的实现方法</p><ul><li><p>上下界防护</p><p>设置上下界寄存器</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105163318040.png" alt="image-20220105163318040" style="zoom:50%;"></li><li><p>基地址，限长防护</p><p>设置基址寄存器和限长寄存器</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105163421358.png" alt="image-20220105163421358" style="zoom:50%;"></li></ul></li></ul><h4 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h4><h5 id="分区分配中的数据结构⭐⭐⭐⭐"><a href="#分区分配中的数据结构⭐⭐⭐⭐" class="headerlink" title="分区分配中的数据结构⭐⭐⭐⭐"></a>分区分配中的数据结构⭐⭐⭐⭐</h5><ul><li><p>空闲区队列(自由主存队列)结构</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105164315437.png" alt="image-20220105164315437" style="zoom:50%;"></li></ul><h5 id="放置策略⭐⭐⭐⭐"><a href="#放置策略⭐⭐⭐⭐" class="headerlink" title="放置策略⭐⭐⭐⭐"></a>放置策略⭐⭐⭐⭐</h5><ul><li><p>首次适应算法</p><p>首次适应算法是将输入的程序放置到主存里<strong>第一个</strong>足够装下它的地址最低的空闲区中。</p><ul><li><p>空闲区队列结构：空闲区地址由低到高排序</p></li><li><p>特点</p><p>尽可能地利用存储器中低地址地空闲区，而尽量保存高地址的空闲区</p></li></ul></li><li><p>最佳适应算法（最佳匹配）</p><p>最佳适应算法是将输入的程序放置到主存中与它所需<strong>大小最接近</strong>的空闲区中</p><ul><li><p>空闲区队列结构：空闲区大小由小到大排序</p></li><li><p>特点</p><p>尽可能地利用存储器中小地空闲区，而尽量保存大的空闲区</p></li></ul></li><li><p>最坏适应算法（最坏匹配）</p><p>最坏适应算法是将输入的程序放置到主存中与它所需大小差距最大的空闲区中。</p><ul><li><p>空闲区队列结构：空闲区大小由大到小排序</p></li><li><p>特点</p><p>尽可能地利用存储器中大的空闲区</p></li></ul></li><li><p>三种策略的讨论</p></li></ul><h5 id="分区的缺点及解决⭐⭐⭐⭐"><a href="#分区的缺点及解决⭐⭐⭐⭐" class="headerlink" title="分区的缺点及解决⭐⭐⭐⭐"></a>分区的缺点及解决⭐⭐⭐⭐</h5><ul><li><p>碎片与拼接</p><p>在已分配区之间存在着的一些没有被充分利用的空闲区</p><p>所谓的拼接技术是指移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲区</p></li></ul><h4 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h4><h5 id="页式地址变换⭐⭐⭐⭐"><a href="#页式地址变换⭐⭐⭐⭐" class="headerlink" title="页式地址变换⭐⭐⭐⭐"></a>页式地址变换⭐⭐⭐⭐</h5><ul><li><p>页表 虚地址结构</p><p>为了实现从逻辑地址空间到物理主存的映像，系统建立的虚页与实页之间的对应关系的地址变换的机构称为页面映像表，简称页表。</p><p>页表的组成</p><ul><li>高速缓冲存储器，地址变换速度快，但是成本高</li><li>主存区域，地址变换速度比硬件慢，成本较低</li></ul></li><li><p>页式地址变换过程</p><p>虚地址结构，举例</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105165942501.png" alt="image-20220105165942501" style="zoom:50%;"><p>变换步骤：</p><p>   ⅰ CPU给出操作数地址 (为2500) ；</p><p>   ⅱ 由分页机构自动地把逻辑地址分为两部分，得到页号p</p><p>​      和页内相对位移w (p =2， w =452)；</p><p>   ⅲ 根据页表始址寄存器指示的页表始地址，以页号为索</p><p>​       引，找到第2页所对应的块号 (为7) ；</p><p>   ⅳ 将块号b和页内位移量w拼接在一起，就形成了访问主</p><p>​       存的物理地址 (7´1024+452=7620)</p></li><li><p>使用联想存储器（缓冲存储器），存放正在运行的进程当前用到的页号和对应的块号，又称为快表。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105170215352.png" alt="image-20220105170215352" style="zoom: 33%;"></li></ul><h5 id="请调策略⭐⭐⭐⭐"><a href="#请调策略⭐⭐⭐⭐" class="headerlink" title="请调策略⭐⭐⭐⭐"></a>请调策略⭐⭐⭐⭐</h5><ul><li><p>扩充页表功能——中断位 辅存地址</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105170259706.png" alt="image-20220105170259706" style="zoom:33%;"><p>中断位i，标识该页是否在主存，若i=1，表示此页不在主存，若i=0，表示该页在主存</p><p>辅存地址：该页面在辅存的位置。</p></li><li><p>缺页处理</p><p>若主存中有空白块，且n &lt; m(程序消耗内存中的块的个数小于可以给程序的块的个数)，则直接调入</p><p>若主存中无空白块，或n &gt;= m，则需淘汰该程序在主存中的一页。</p></li></ul><h5 id="淘汰策略⭐⭐⭐⭐"><a href="#淘汰策略⭐⭐⭐⭐" class="headerlink" title="淘汰策略⭐⭐⭐⭐"></a>淘汰策略⭐⭐⭐⭐</h5><p>用来选择淘汰哪一页的规则叫做置换策略，或称淘汰算法。</p><ul><li><p>扩充页表功能——引用位  改变位</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105170709056.png" alt="image-20220105170709056" style="zoom:33%;"><p>引用位——标识该页最近是否被访问，为0没有，为1有</p><p>改变位——标识该页是否被修改，为0没有，为1有</p></li><li><p>抖动</p><p>导致系统效率急剧下降的主存和辅存之间的频繁页面置换现象</p></li><li><p>置换算法</p><ul><li><p>理想中的最佳算法，淘汰的那一页都是以后不再 要用的</p></li><li><p>先进先出淘汰算法FIFO</p><p>总是选择在主存中居留时间最长（即最早进入主存）的一页淘汰。</p></li><li><p>最久未使用淘汰算法（LRU算法）</p><p>总是选择最长时间未被使用的那一页淘汰。</p></li><li><p>LRU近似淘汰算法</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105212021886.png" alt="image-20220105212021886" style="zoom: 33%;"></li></ul></li></ul><h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><h5 id="段式系统的二维地址结构"><a href="#段式系统的二维地址结构" class="headerlink" title="段式系统的二维地址结构"></a>段式系统的二维地址结构</h5><p>分段是程序中自然划分的一组逻辑意义完整的信息集合。</p><p>程序地址空间由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，它是一个连续的地址区</p><p>地址结构</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105213033369.png" alt="image-20220105213033369" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105213418055.png" alt="image-20220105213418055" style="zoom:50%;"><p>页式系统中用户地址空间是一维地址空间，而段式系统中用户地址空间是二维地址空间</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105213644848.png" alt="image-20220105213644848" style="zoom:50%;"><h5 id="段页式系统中段表、页表与主存的关系"><a href="#段页式系统中段表、页表与主存的关系" class="headerlink" title="段页式系统中段表、页表与主存的关系"></a>段页式系统中段表、页表与主存的关系</h5><p>在段式存储管理中结合分页存储管理技术，在一个分段内划分页面，就形成了段页式存储管理。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105213839725.png" alt="image-20220105213839725" style="zoom:50%;"><p>段页式系统中段表、页表与主存的关系</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105213925390.png" alt="image-20220105213925390" style="zoom:50%;"><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><h4 id="设备管理的基本概念"><a href="#设备管理的基本概念" class="headerlink" title="设备管理的基本概念"></a>设备管理的基本概念</h4><h5 id="设备管理的功能"><a href="#设备管理的功能" class="headerlink" title="设备管理的功能"></a>设备管理的功能</h5><ol><li>状态跟踪 动态地记录各种设备的状态</li><li>设备分配与回收<ol><li>静态分配——应用程序级，程序进入系统时分配，退出系统时收回全部资源</li><li>动态分配——进程级，进程提出设备申请时进行分配，使用完毕后立即收回</li></ol></li><li>设备控制 实施设备驱动和中断处理的工作</li></ol><h5 id="设备独立性-定义-优点⭐⭐⭐⭐"><a href="#设备独立性-定义-优点⭐⭐⭐⭐" class="headerlink" title="设备独立性 定义 优点⭐⭐⭐⭐"></a>设备独立性 定义 优点⭐⭐⭐⭐</h5><p>定义：用户在程序中使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名</p><ul><li>逻辑设备名是用户自己指定的设备名（或设备号），是暂时的、可更改的。</li><li>物理设备名是系统提供的设备的标准名称，它是永久的，不可更改的。</li></ul><p>优点：</p><ul><li>方便用户</li><li>改善设备利用率</li><li>提高系统的可扩展性和可适应性</li></ul><h5 id="设备控制块-定义"><a href="#设备控制块-定义" class="headerlink" title="设备控制块 定义"></a>设备控制块 定义</h5><p>系统为每一台设备都配置了一个用来记录设备的硬件特性、链接和使用情况的一组数据，称为设备控制块。</p><h4 id="缓冲技术⭐⭐⭐⭐"><a href="#缓冲技术⭐⭐⭐⭐" class="headerlink" title="缓冲技术⭐⭐⭐⭐"></a>缓冲技术⭐⭐⭐⭐</h4><h5 id="什么是缓冲，引入缓冲的目的"><a href="#什么是缓冲，引入缓冲的目的" class="headerlink" title="什么是缓冲，引入缓冲的目的"></a>什么是缓冲，引入缓冲的目的</h5><p>缓冲是两种不同速度的设备之间传输信息时平滑传输过程的常用手段。</p><p>目的：</p><ol><li>处理数据流的生产者与消费者间的速度差异</li><li>协调传输数据大小不一致的设备</li><li>应用程序的拷贝语义</li></ol><h5 id="常用的缓冲技术"><a href="#常用的缓冲技术" class="headerlink" title="常用的缓冲技术"></a>常用的缓冲技术</h5><p>双缓冲、环形缓冲、缓冲池</p><h5 id="双缓冲技术"><a href="#双缓冲技术" class="headerlink" title="双缓冲技术"></a>双缓冲技术</h5><p>在双缓冲方案下，为输入或输出分配两个缓冲区buf1，buf2</p><ul><li><p>双缓冲输入数据</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105221740963.png" alt="image-20220105221740963" style="zoom: 50%;"></li><li><p>双缓冲输出数据</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105221808539.png" alt="image-20220105221808539" style="zoom:50%;"></li><li><p>双缓冲同时用于输入/输出数据的操作</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105222315689.png" alt="image-20220105222315689" style="zoom:50%;"></li></ul><p>单缓冲的效率      1/((1/x)+(1/y)) = xy/(x+y)</p><p>双缓冲的效率       y</p><p>双缓冲效率 &gt; 单缓冲效率</p><h5 id="UNIX缓冲管理中的空闲缓冲区的淘汰算法"><a href="#UNIX缓冲管理中的空闲缓冲区的淘汰算法" class="headerlink" title="UNIX缓冲管理中的空闲缓冲区的淘汰算法"></a>UNIX缓冲管理中的空闲缓冲区的淘汰算法</h5><p>精确的最久未使用淘汰算法LRU</p><h4 id="设备分配⭐⭐⭐⭐"><a href="#设备分配⭐⭐⭐⭐" class="headerlink" title="设备分配⭐⭐⭐⭐"></a>设备分配⭐⭐⭐⭐</h4><h5 id="常用的设备分配技术"><a href="#常用的设备分配技术" class="headerlink" title="常用的设备分配技术"></a>常用的设备分配技术</h5><p>独享分配、共享分配、虚拟分配</p><h5 id="独享设备-独享分配-定义"><a href="#独享设备-独享分配-定义" class="headerlink" title="独享设备 独享分配 定义"></a>独享设备 独享分配 定义</h5><p>独占设备就只有独享分配，相当于临界资源</p><ul><li><p><strong>独享设备</strong>：</p><p>让一个作业在整个运行期间独占使用的设备</p></li><li><p><strong>特点</strong>：1. 临界资源 2.费时的I/O操作或需人工干预</p></li><li><p><strong>独享分配</strong>：</p><p>在一个作业执行前，将它所要使用的设备分配给它，当它结束撤离时，将分配给它的这类设备收回。</p></li></ul><h5 id="共享设备-共享分配-定义"><a href="#共享设备-共享分配-定义" class="headerlink" title="共享设备 共享分配 定义"></a>共享设备 共享分配 定义</h5><p>如果把内存当作共享设备，若是多字节内存，可以当作共享设备，若是单字节，则是独占设备</p><p>空分复用：不同的作业放在不同位置才可以共享</p><ul><li><p><strong>共享设备</strong>：</p><p>由多个作业、进程共同使用的设备称为共享设备</p></li><li><p><strong>特点</strong>：1. 旋转设备，可直接或随机访问 2.便于共享，转接简单，耗费较少</p></li><li><p><strong>共享分配</strong>：</p><p>在一个作业执行并发出设备申请时，将它所要使用的设备分配给它，当作业释放设备或结束撤离时，将分配给它的设备收回。</p></li></ul><h5 id="虚拟设备-虚拟技术-定义"><a href="#虚拟设备-虚拟技术-定义" class="headerlink" title="虚拟设备 虚拟技术 定义"></a>虚拟设备 虚拟技术 定义</h5><ul><li><p><strong>虚拟技术</strong>：所谓虚拟技术，是在一类<strong>物理设备上模拟另一类物理设备</strong>的技术，是将独占设备转化为共享设备的技术。</p></li><li><p><strong>虚拟设备</strong>：通常把用来代替独占型设备的那部分外村空间（包括有关的控制表格）称为虚拟设备</p></li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105224937347.png" alt="image-20220105224937347" style="zoom:33%;"><p>输入井是外存构成的，并发时就像同时使用输入机一样。</p><p>当进程需要与独占型设备交换信息时，系统将分配磁盘空间，并建立相应的数据结构，这种分配方法称为设备的虚拟分配。</p><h5 id="Spooling系统-定义"><a href="#Spooling系统-定义" class="headerlink" title="Spooling系统 定义"></a>Spooling系统 定义</h5><p>是虚拟设备技术的实现与落地</p><p>利用<strong>通道</strong>和<strong>中断</strong>技术，在<strong>主机控制之下</strong>（不需要CPU），由通道完成输入输出工作。系统提供一个<strong>软件系统</strong>（对Σ井进行管理） (包括预输入程序、缓输出程序、井管理程序、预输入表、缓输出表)。它提供输入收存和输出发送的功能，使外部设备可以并行操作。这一软件系统称为SPOOLING系统。</p><h4 id="I-O控制⭐⭐"><a href="#I-O控制⭐⭐" class="headerlink" title="I/O控制⭐⭐"></a>I/O控制⭐⭐</h4><p>循环测试I/O方式，I/O中断方式，DMA方式</p><h5 id="I-O控制的主要功能"><a href="#I-O控制的主要功能" class="headerlink" title="I/O控制的主要功能"></a>I/O控制的主要功能</h5><ol><li>解释用户的I/O系统调用</li><li>设备驱动</li><li>中断处理</li></ol><h5 id="请求I-O的进程、I-O过程、设备处理进程、中断处理"><a href="#请求I-O的进程、I-O过程、设备处理进程、中断处理" class="headerlink" title="请求I/O的进程、I/O过程、设备处理进程、中断处理"></a>请求I/O的进程、I/O过程、设备处理进程、中断处理</h5><h5 id="程序之间的同步关系"><a href="#程序之间的同步关系" class="headerlink" title="程序之间的同步关系"></a>程序之间的同步关系</h5><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="文件系统基本概念"><a href="#文件系统基本概念" class="headerlink" title="文件系统基本概念"></a>文件系统基本概念</h4><h5 id="文件、文件系统、定义⭐⭐"><a href="#文件、文件系统、定义⭐⭐" class="headerlink" title="文件、文件系统、定义⭐⭐"></a>文件、文件系统、定义⭐⭐</h5><p>文件是在逻辑上具有完整意义的信息集合，它由一个名字以供表示，文件名是字母开头的字母数字串</p><p>文件系统是操作系统中负责管理和存取文件信息的软件机构</p><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><h5 id="文件的逻辑结构⭐⭐"><a href="#文件的逻辑结构⭐⭐" class="headerlink" title="文件的逻辑结构⭐⭐"></a>文件的逻辑结构⭐⭐</h5><ul><li><p>流式文件</p><p>流式文件是相关的有序字符的集合，是无结构的（比如.txt，.c），存取是按信息的个数或以特殊字符为界进行存取。</p></li><li><p>记录式文件</p><p>记录式文件是一种有结构的文件，这种文件在逻辑上总是被看成一组连续顺序的记录的集合（如数据库文件）</p></li></ul><h5 id="文件的存取方法⭐⭐"><a href="#文件的存取方法⭐⭐" class="headerlink" title="文件的存取方法⭐⭐"></a>文件的存取方法⭐⭐</h5><ul><li><p>顺序存取</p><p>后一次存取总是在前一次存取的基础上进行的，顺序存取时不必给出具体的存取位置</p></li><li><p>随机存取</p><p>用户以任意次序请求某个记录，随机存取时要指出起始存取位置（例如记录号）</p></li></ul><h5 id="文件的物理结构⭐⭐⭐⭐"><a href="#文件的物理结构⭐⭐⭐⭐" class="headerlink" title="文件的物理结构⭐⭐⭐⭐"></a>文件的物理结构⭐⭐⭐⭐</h5><ul><li><p>连续文件定义、结构、特点</p><ul><li><p>连续文件是由一组分配在磁盘连续区域的物理块组成的。</p></li><li><p>结构</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105234712735.png" alt="image-20220105234712735" style="zoom:33%;"></li><li><p>特点：</p><ul><li>结构简单，实现容易，连续存取时速度较快</li><li>创建文件时要给出文件大小，文件长度一经固定便不易改变，动态增加和修改不易</li><li>存储空间利用率不高</li></ul><p>​                                                                                                                                                                                                                                    </p></li></ul></li><li><p>串联文件定义、结构、特点</p><ul><li><p>串联文件结构是按顺序由串联的块组成的，即文件的信息存于若干块物理块中，每个物理块的最末一个字作为链接字，它指出后继块的物理地址。文件的最后一块的链接字为结束标记“Ù”，它表示文件至本块结束。</p></li><li><p>结构</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105234949459.png" alt="image-20220105234949459" style="zoom:50%;">、</p></li><li><p>串联文件的特点</p><ul><li>能较好地利用辅存空间，提高利用率</li><li>不必事先知道文件长度，易于对文件进行修改和扩充</li><li>连续存取时速度较快，随机存取效率太低</li><li>连接指针占用一定空间</li><li>可靠性问题，指针容易出错</li></ul></li></ul></li></ul><p>  串联文件的变形：文件分配表FAT</p><ul><li><p>整个磁盘设置一张FAT表，每个盘块对应一个表目，存放连接文件各物理块的指针。</p></li><li><p>链接指针按顺序集中存放，构成盘文件映照表/文件分配表（FAT）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220105235759796.png" alt="image-20220105235759796" style="zoom:50%;"></li><li><p>索引文件定义、结构、特点、一级简介索引结构、二级简介索引结构</p><ul><li><p>系统为每个文件建立逻辑块号与物理块号的对照表。这张表称为该文件的索引表。文件由数据文件和索引表构成。这种文件称为索引文件。</p></li><li><p>结构</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106000019945.png" alt="image-20220106000019945" style="zoom: 50%;"></li><li><p>特点</p><ul><li>易于文件的增删</li><li>直接读写任意记录</li><li>没有碎片</li><li>索引表带来的开销</li></ul></li><li><p>直接索引</p><p>文件目录项中有一组表项用于索引。每一个表项登记的是逻辑记录所在的磁盘块号。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106000302210.png" alt="image-20220106000302210" style="zoom:50%;"></li><li><p>一级间接索引</p><p>文件目录项中有一组表项，其内容登记的是第一级索引表块的块号。第一级索引表块中的索引表项登记的是文件逻辑记录所在的磁盘块号。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106000503883.png" alt="image-20220106000503883" style="zoom: 50%;"></li><li><p>二级简介索引</p><p>文件目录项中有一组表项，其内容登记的是第二级索引表块的块号。第二级索引表块中的索引表项登记的第一级索引表块的块号，第一级索引表项中登记的是文件逻辑记录所在的磁盘块号。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106000542437.png" alt="image-20220106000542437" style="zoom:50%;"></li></ul></li><li><p>物理结构比较</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106000625488.png" alt="image-20220106000625488" style="zoom:50%;"></li></ul><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><p>文件目录是记录文件的名字、存放地址以及其他有关文件的说明信息和控制信息的数据结构</p><h5 id="文件目录项内容"><a href="#文件目录项内容" class="headerlink" title="文件目录项内容"></a>文件目录项内容</h5><p>​    <strong>①</strong> <strong>文件名</strong></p><p>​    <strong>②</strong> <strong>文件逻辑结构</strong></p><p>​       说明该文件的记录是否定长、记录长度及记录个数等。 </p><p>​    <strong>③</strong> <strong>文件物理结构：记录文件的物理结构形式</strong></p><p>​           连续文件——指出文件第一块的物理地址、文件所占块数</p><p>​           串联文件——指出该文件第一块的物理地址 </p><p>​           索引文件——指出索引表地址</p><p>​    <strong>④</strong> <strong>存取控制信息</strong></p><p>​        文件主具有的存取权限、核准的其他用户及其相应的存取权限 </p><p>​    <strong>⑤</strong> <strong>管理信息</strong></p><p>​        文件建立日期、时间，上一次存取时间、要求文件保留的时间等</p><p>​    <strong>⑥</strong> <strong>文件类型</strong></p><p>​        文件的类型，例如可分为数据文件、目录文件、块存储设备文件、 字符设备文件</p><h5 id="重名问题，解决办法"><a href="#重名问题，解决办法" class="headerlink" title="重名问题，解决办法"></a>重名问题，解决办法</h5><p>所谓重名，是指不同用户对不同文件起了相同的名字，即两个或多个文件只有一个相同的符号名，又称为命名冲突</p><p>为了解决命名冲突，获得更灵活的命名能力，文件系统必须采用多级目录结构（如果一级文件目录结构，按名存取，很容易命名冲突）</p><h5 id="树形文件目录"><a href="#树形文件目录" class="headerlink" title="树形文件目录"></a>树形文件目录</h5><p>在多级目录系统中（除最末一级外），任何一级目录的目录项可以描述一个目录文件，也可以描述一个非目录文件（数据文件），而数据文件一定在树叶上。这样，就构成了一个树形层次结构。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106162926455.png" alt="image-20220106162926455" style="zoom:50%;"><p>上述的文件目录结构中，就有a目录中还有a目录，别的目录中也有称为a的文件，树形文件目录中，只有同级的文件不可以重名</p><p>使用文件路径名就可以解决重名问题，比如id为13的文件与id为20的文件有相同的文件名，都是a</p><p>id为13的文件的文件路径名是 /a/a/a</p><p>id为20的文件的文件路径名是  /b/d/a</p><h5 id="文件路径名，当前目录"><a href="#文件路径名，当前目录" class="headerlink" title="文件路径名，当前目录"></a>文件路径名，当前目录</h5><p>多级目录中，文件的路径名是由根目录到该文件的通路上所有目录文件符号名和该文件的符号名组成的字符串，相互之间用分隔符分隔。 </p><h4 id="文件共享与安全"><a href="#文件共享与安全" class="headerlink" title="文件共享与安全"></a>文件共享与安全</h4><h5 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h5><ul><li><p>文件共享定义</p><p>文件共享是指某一个或某一部分文件可以让事先规定的某些用户共同使用。</p><p>共享的目的：节省存储空间、进程间交换信息</p></li><li><p>存取权限验证方法</p><p>ⅰ 访问控制矩阵</p><p>ⅱ 存取控制表</p><p>ⅲ 用户权限表</p><p>ⅳ 口令</p><p>ⅴ 密码（编解码）</p></li></ul><h5 id="文件安全的定义"><a href="#文件安全的定义" class="headerlink" title="文件安全的定义"></a>文件安全的定义</h5><p>所谓文件安全，就是文件的保护问题。文件的保护是指文件本身不得被未经文件主授权的任何用户存取，而对于授权用户也只能在允许的存取权限内使用文件。</p><h5 id="用文件名加快文件的查找"><a href="#用文件名加快文件的查找" class="headerlink" title="用文件名加快文件的查找"></a>用文件名加快文件的查找</h5><ul><li><p>建立当前目录（值班目录）</p><p>当前目录是当前用户正在使用的文件所在的目录。当指定当前目录后，用户对文件的所有访问都是相对于 “当前目录”进行的。这时，文件路径名是由“当前目录”到信息文件的通路上所有各级目录的符号名加上该信息文件的符号名组成。</p></li><li><p>链接技术</p><p>所谓“链接”，就是在相应目录表目之间进行链接，即一个目录中的表目直接指向另一个目录表目所在的物理位置。</p><p>注意，这种链接不是直接指向文件，而是指向相应的目录表目。这种办法也称为连访，被共享的文件称为连访文件。</p></li></ul><p>​        </p><h4 id="文件操作与文件备份⭐"><a href="#文件操作与文件备份⭐" class="headerlink" title="文件操作与文件备份⭐"></a>文件操作与文件备份⭐</h4><h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><ul><li>常用的文件操作命令</li><li>打开文件与关闭文件定义、目录</li></ul><h5 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h5><ul><li>文件备份的必要性</li><li>常用的两种文件备份方法：周期性备份、增量存储</li></ul><h4 id="UNIX文件系统的主要结构及实现"><a href="#UNIX文件系统的主要结构及实现" class="headerlink" title="UNIX文件系统的主要结构及实现"></a>UNIX文件系统的主要结构及实现</h4><h5 id="UNIX文件系统的特点"><a href="#UNIX文件系统的特点" class="headerlink" title="UNIX文件系统的特点"></a>UNIX文件系统的特点</h5><ol><li>树型文件目录结构</li><li>可安装拆卸的文件系统</li><li>文件是无结构的字符流式文件</li><li>将外部设备与文件一样对待</li></ol><h5 id="UNIX文件系统的索引文件结构"><a href="#UNIX文件系统的索引文件结构" class="headerlink" title="UNIX文件系统的索引文件结构"></a>UNIX文件系统的索引文件结构</h5><ul><li><p>文件目录项组成</p><p>在<strong>目录项</strong>中只有<strong>文件的名字</strong>和<strong>对应i节点的编号</strong>。</p><p>UNIX系统把文件目录项中除了名字以外的信息全部存放到一个磁盘的数据块上，这种数据块就是文件索引节点(indexnode)，简称i节点，又称为磁盘索引节点。</p><p>两个不同的文件不可能由相同的i节点编号</p></li><li><p>文件索引节点（磁盘索引节点）的结构</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106001909270.png" alt="image-20220106001909270" style="zoom: 33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106001932154.png" alt="image-20220106001932154" style="zoom:33%;"></li><li><p>UNIX7版本文件索引结构⭐⭐⭐⭐</p><ul><li><p>小型文件结构、大型文件结构、巨型文件结构</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106002117456.png" alt="image-20220106002117456" style="zoom:33%;"><p>文件 &lt;= 4KB</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106002347598.png" alt="image-20220106002347598" style="zoom:33%;"><p>一个磁盘块号两字节，一个块512B，因此可以放256个地址块 </p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106002544609.png" alt="image-20220106002544609" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106002619685.png" alt="image-20220106002619685" style="zoom:33%;"></li><li><p>在此三种结构下，系统能支持的文件最大的字节数的计算</p></li></ul></li><li><p>UNIX system V的文件索引结构⭐⭐⭐⭐</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106002735985.png" alt="image-20220106002735985" style="zoom:50%;"><p>UNIX系统采用多级间接索引结构，对小型文件采用直接索引，对大型文件采用间接索引，从而，既保证绝大多数的文件有高的存取效率，又能适应存取一些大型文件（既保证了文件系统的高效率，又使其有很宽的适应面）。</p></li></ul><h5 id="UNIX系统文件目录结构"><a href="#UNIX系统文件目录结构" class="headerlink" title="UNIX系统文件目录结构"></a>UNIX系统文件目录结构</h5><p>每个目录表为一个目录文件，目录文件由目录项组成</p><p>每个目录项包含16个字节（UNIX系统老版本），在目录项中，第1、2字节为相应文件的辅存i节点号，后14个字节为文件名，一个辅存磁盘块（512B）包含32个目录项。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106164330015.png" alt="image-20220106164330015" style="zoom:50%;"><ul><li><p>UNIX属树形目录结构</p><p><strong>①</strong> 每个文件系统都有一个根目录文件，它的辅存i节点是相应文件存储设备上辅存索引区中的第一个。</p><p><strong>②</strong> 打开某个文件时，从根目录的i节点可以找到根目录文件的索引结构，得到根目录文件的每个数据块。</p><p><strong>③</strong> 将待打开文件的路径信息与目录文件中的目录项逐一比较，可以得到下级目录的i节点号，并最终得到目标文件的i节点号。从i节点号中的索引表，得到数据文件的存储块号，实现对目标文件的随机存取。 </p></li><li><p>便于随机存取的文件目录结构</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106165004716.png" alt="image-20220106165004716" style="zoom: 50%;"><p>目录文件对应磁盘中的一个文件，只是用户看不到。</p><p>目录文件一旦建立，就有.(当前目录)和..(上一级文件)</p><p>如果要访问/A0/B31</p><p>先获取/根目录的i节点，读出/的目录文件找到A0，读出A0的i节点，读A0的目录文件找B31，读B31的i节点，访问i_addr对应的磁盘块</p></li><li><p>目录结构中的勾链，支持不同文件目录名共享一个文件</p><p>UNIX文件目录结构中带有交叉勾链。用户可以用不同的文件路径名共享一个文件。</p><p>文件勾链在用户看来是为一个已存在的文件另起一个路径名。</p><p>文件勾链的结果表现为一个文件由多个目录项所指向。</p><p>UNIX只允许对非目录文件实行勾链。</p><ul><li><p>例：一个文件有两个名字</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106170129532.png" alt="image-20220106170129532" style="zoom: 50%;"></li></ul></li></ul><h5 id="UNIX系统的打开文件结构"><a href="#UNIX系统的打开文件结构" class="headerlink" title="UNIX系统的打开文件结构"></a>UNIX系统的打开文件结构</h5><ul><li><p>设置打开文件机构的必要性</p><p>为了提高系统效率，减少主存空间的占用，系统设置了打开文件和关闭文件操作。当打开一个文件时，建立用户与该文件的联系。</p></li><li><p>打开文件机构的组成</p><p>活动i节点表、系统打开文件表、用户文件描述符表</p></li></ul><h5 id="文件存储器空闲块的管理"><a href="#文件存储器空闲块的管理" class="headerlink" title="文件存储器空闲块的管理"></a>文件存储器空闲块的管理</h5><ul><li><p>UNIX文件系统磁盘存储区（文件卷）的结构</p><p>一个文件系统就是逻辑设备，每个逻辑设备占用一片连续的磁盘存储空间。 文件卷上存放UNIX文件系统。文件卷结构图如下。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106172428907.png" alt="image-20220106172428907" style="zoom:50%;"><ol><li>引导块 大小为一个磁盘块，包含引导程序</li><li>索引节点区 索引节点结构组成</li><li>数据区 数据文件占用的区域</li></ol></li><li><p>空闲磁盘块的管理：成组链接法</p><p>即将空闲表和空闲链两种方法相结合。系统初启时，文件存储区是空闲。将空闲块从尾倒向前，每100块分为一组 (注：最后一组为99块)，每一组的最后一块作为索引表，用来登记下一组100块的物理块号和块数。那么，最前面的一组可能不足100块，这一组的物理块号和块数存放在管理块的s_free[100]和s_nfree中。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220106172641925.png" alt="image-20220106172641925" style="zoom:50%;"></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>随便记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网复习</title>
    <link href="/2021/11/18/%E8%AE%A1%E7%BD%91/"/>
    <url>/2021/11/18/%E8%AE%A1%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h3 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h3><ol><li><p><strong>网络构成：端系统 通信链路 分组交换设备</strong></p></li><li><p><strong>通信链路：点到点链路、广播链路</strong></p><p>点对点信道。这种信道使用一对一的点对点通信方式。</p><p>广播信道。这种信道使用一对多的广播通信方式</p></li><li><p><strong>分组交换机：路由器，以太网交换机</strong></p></li><li><p><strong>路径和跳</strong></p><p>过一个路由器算一跳</p></li><li><p><strong>ICP和ISP</strong></p><p>因特网服务提供者ISP，比如中国电信联通移动 </p><p>ISP三层结构</p><p>ICP 内容服务商</p></li><li><p><strong>因特网提供的服务</strong></p><p>因特网是为应用程序提供网络服务的基础设施。</p><p>为网络应用提供应用程序接口。</p></li><li><p><strong>协议三要素：语法 语义 同步</strong></p></li><li><p><strong>C/S和P2P</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129212143197.png" alt="image-20211129212143197" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129212308611.png" alt="image-20211129212308611" style="zoom:50%;"></li><li><p><strong>DSL HFC FTTH 以太网 无线局域网 无线广域网 个域网</strong></p><p>广域网 WAN 城域网 MAN 局域网 LAN 个域网 PAN</p></li><li><p><strong>物理介质：导向和非导向</strong></p><p>导引型传输媒体 双绞线 同轴电缆 光纤</p><p>非导引型传输媒体 微波通信（2~40GHz）比如2.4GHz和5.8Ghz频段的WiFi</p><p>物理层 解决各种传输媒体上传输比特0和1的问题，进而给数据链路层提供透明传输比特流的服务</p></li><li><p><strong>双绞线 同轴电缆 光纤 无线电</strong></p></li><li><p><strong>电路交换 报文交换 分组交换</strong></p><p>按交换技术分类，将网络分成这三种</p><p>电路交换</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114161831591.png" alt="image-20211114161831591" style="zoom:33%;"><p>分组交换</p><p>通信双方以分组为单位，使用存储-转发机制实现数据交互的通信方式，被称为分组交换</p><p>存储转发机制：指交换机在能开始向输出链路传输分组的第一个比特之前，必须结受到整个分组</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114161917984.png" alt="image-20211114161917984" style="zoom:67%;"></li><li><p><strong>TDM FDM 虚电路 数据报</strong></p><p>时分复用 频分复用</p></li><li><p><strong>时延、吞吐量、流量强度</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114162746326.png" alt="image-20211114162746326" style="zoom: 50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114162836365.png" alt="image-20211114162836365" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114163544530.png" alt="image-20211114163544530" style="zoom: 50%;"></li><li><p><strong>传输时延 传播时延 处理时延 排队时延 往返时延（RTT）</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114163106443.png" alt="image-20211114163106443" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114163221608.png" alt="image-20211114163221608" style="zoom: 50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114163331887.png" alt="image-20211114163331887" style="zoom: 50%;"><p>排队时延：一个特定分组的排队时延将取决于先期到达的、正在排队等待向链路传输的分组的数量。如果该队列是空的，并且当前没有其他分组在传输，则该分组的排队时延为0。另一方面，如果流量很大，并且许多其他分组也在等待传输，该排队时延将很大。到达组的分组数量是到达该队列的流量强度和性质的函数。实际的排队时延通常在毫秒到微秒级。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114163432168.png" alt="image-20211114163432168" style="zoom: 50%;"></li><li><p><strong>丢包和排队时延产生的原因</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114163655800.png" alt="image-20211114163655800" style="zoom: 50%;"></li><li><p><strong>协议的层次结构：ISO OSI/RM七层模型、TCP/IP四层模型、Internet五层模型</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114170557547.png" alt="image-20211114170557547" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114171127244.png" alt="image-20211114171127244" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116124000487.png" alt="image-20211116124000487" style="zoom:50%;"></li><li><p><strong>对等层、对等体、服务、协议、服务访问点、服务原语、SDU、PDU、网络体系结构、协议栈</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114172309810.png" alt="image-20211114172309810" style="zoom:67%;"></li><li><p><strong>报文、报文段、数据报、帧、比特流</strong></p><p>应用层 运输层 网络层 数据链路层 物理层</p></li><li><p><strong>封装、解封装</strong></p></li></ol><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114162622859.png" alt="image-20211114162622859" style="zoom: 50%;"><h3 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h3><ol><li><p><strong>套接字</strong></p></li><li><p><strong>应用层协议</strong></p><p>(1)域名系统(Domain Name System，<a href="https://baike.baidu.com/item/DNS/427444">DNS</a>)：用于实现网络设备名字到IP地址映射的网络服务。</p><p>(2)文件传输协议(File Transfer Protocol，FTP)：用于实现交互式文件传输功能。</p><p>(3)简单邮件传送协议(Simple Mail Transfer Protocol, SMTP)：用于实现电子邮箱传送功能</p><p>(4)超文本传输协议(HyperText Transfer Protocol，<a href="https://baike.baidu.com/item/HTTP">HTTP</a>)：用于实现WWW服务。</p><p>(5)简单网络管理协议(simple Network Management Protocol，SNMP)：用于管理与监视网络设备。</p><p>(6)远程登录协议(Telnet)：用于实现远程登录功能。</p></li><li><p><strong>Web构成:浏览器 web服务器 协议</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130155405340.png" alt="image-20211130155405340" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130155548129.png" alt="image-20211130155548129" style="zoom:50%;"></li><li><p><strong>HTML、HTTP</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130184726814.png" alt="image-20211130184726814" style="zoom:50%;"><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130184834473.png" alt="image-20211130184834473"></p></li><li><p><strong>web对象 URL</strong></p><p>上</p></li><li><p><strong>非持续连接（HTTP1.0） 持续连接（HTTP1.1）</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130184941906.png" alt="image-20211130184941906" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130185123906.png" alt="image-20211130185123906" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130190952533.png" alt="image-20211130190952533" style="zoom:50%;"></li><li><p><strong>HTTP请求报文 响应报文格式</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130185603628.png" alt="image-20211130185603628" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130185803910.png" alt="image-20211130185803910" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130185849370.png" alt="image-20211130185849370" style="zoom:50%;"></li><li><p><strong>HTTP命令：Get、Post、Head、Put、Delete</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130185631654.png" alt="image-20211130185631654" style="zoom:50%;"></li><li><p><strong>Cookie、web缓存工作原理、条件Get</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130190052710.png" alt="image-20211130190052710" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130190115810.png" alt="image-20211130190115810" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130190245779.png" alt="image-20211130190245779" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130190531131.png" alt="image-20211130190531131" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130190742392.png" alt="image-20211130190742392" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130190753149.png" alt="image-20211130190753149" style="zoom:50%;"></li><li><p><strong>邮件系统构成:用户代理、邮件服务器、SMTP协议</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130152836538.png" alt="image-20211130152836538" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130152952873.png" alt="image-20211130152952873" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130153622245.png" alt="image-20211130153622245" style="zoom:50%;"></li><li><p><strong>SMTP工作原理(7位ASCII码) MIME</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130153741708.png" alt="image-20211130153741708" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130153840851.png" alt="image-20211130153840851" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130153916517.png" alt="image-20211130153916517" style="zoom:50%;"></li><li><p><strong>POP3 IMAP</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130154735840.png" alt="image-20211130154735840" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130154649172.png" alt="image-20211130154649172" style="zoom:50%;"></li><li><p><strong>域名系统的层次结构</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130123953594.png" alt="image-20211130123953594" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130124032699.png" alt="image-20211130124032699" style="zoom:50%;"></li><li><p><strong>根域名服务器、顶级域服务器、权威域名服务器</strong></p></li><li><p><strong>两种DNS解析方法</strong></p><p>上图，递归查询，迭代查询</p></li><li><p><strong>四种DNS资源记录</strong></p><p>A (host)，即是A记录，也称为主机记录，是DNS名称到IP地址的映射，用于正向解析。<br>CNAME：CNAME记录，也是别名记录，用于定义A记录的别名。<br>MX （mail exchange）： 邮件交换器记录，用于告知邮件服务器进程将邮件发送到指定的另一台邮件服务器。（该服务器知道如何将邮件传送到最终目的地）。</p><p>NS ：NS记录，用于标识区域的DNS服务器，即是说负责此DNS区域的权威名称服务器，用哪一台DNS服务器来解析该区域。一个区域有可能有多条ns记录，例如zz.com有可能有一个主服务器和多个辅助服务器。</p></li><li><p><strong>P2P文件分发的基本原理(与C/S对比)</strong></p><p>P2P技术正是为了解决这些问题而提出来的一种对等网络结构。在P2P网络中，每个节点既可以从其他节点得到服务，也可以向其他节点提供服务。这样，庞大的终端资源被利用起来，一举解决了C/S模式中的两个弊端。</p></li><li><p><strong>BitTorrent的工作原理 最稀缺优先 4+1</strong></p></li></ol><p>而BT下载致力于解决这些问题：</p><table><thead><tr><th align="left"><strong>Client-Server</strong></th><th align="left"><strong>BitTorrent</strong></th></tr></thead><tbody><tr><td align="left">中心化</td><td align="left">去中心化</td></tr><tr><td align="left">热门资源限制服务器性能</td><td align="left">热门资源无性能限制</td></tr><tr><td align="left">设备费用昂贵；资源热门程度决定了设备开销</td><td align="left">设备开销不会随着资源热门而变化</td></tr></tbody></table><p>BT下载是通过对等网实现的(peer-to-peer，P2P)；而在对等网络中，每个对等点都连接到网络中的每个其他对等点。</p><p>而半中心化的对等网络是：拥有一个或多个权限比其他大多数对等点更高的对等网络。</p><p><strong>对等方：</strong>成对间歇连接的主机</p><p><strong>邻近对等方：</strong>成功创建一个TCP连接的对等方</p><p><strong>洪流（torrent）：</strong>参与一个特定文件分发的所有对等方的集合</p><p><strong>追踪器（tracker）：</strong>每个洪流具有一个基础设施结点</p><h2 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h2><p>当一个对等方加入某洪流时，它向追踪器注册自己，并周期性地通知追踪器它仍在该洪流中。</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>假设有一个新的对等方Alice加入一个洪流</p><ol><li>追踪器随机地从参与对等方的集合中选择对等方的一个子集（比如50个）并将这50个对等方的IP地址发送给Alice，Alice拥有了一个IP地址的列表</li><li>Alice与列表上的所有对等方创建TCP连接，成为邻近对等方</li><li>Alice周期性的询问每个邻近对等方他们所具有的块列表。</li><li>对当前自身没有的块信息，Alice发送请求获取（最稀缺的块，优先级最高请求）</li><li>向哪些向她请求的块的邻居发送邻居没有的而自己有的块信息。如何决定响应哪个邻居的请求？BitTorrent使用了一种对换算法。</li></ol><p>该对换算法的基本思想是Alice根据当前能够以最高速率向她提供数据的邻居，给出其优先权。</p><p>操作过程如下：</p><ol><li>Alice对于她的每个邻居持续的测试接收到比特的速率，并确定以最高速率流入的4个邻居</li><li>每过10秒，她重新计算该速率并可能修改这4个对等方的集合</li><li>每隔30秒，Alice要随机选择另外一个邻居并向其发送块，也即Alie随机选择一名新的对换伴侣。</li></ol><p>这种效果是对等方能够趋于找到彼此的协调的速率上载。随机选择邻居也允许新的对等方得到块，因此他们能够具有对换的东西，除了上诉5个对等方，其它对等方均被阻塞。</p><h3 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129183223761.png" alt="image-20211129183223761" style="zoom:50%;"><ol><li><p><strong>运输层和网络层的功能对比</strong></p><p> 传输层提供端到端通信服务层次,提供可靠及非可靠连接。</p><p>网络层负责ip数据报的产生以及ip数据报在逻辑网络上的路由转发。</p></li><li><p><strong>多路复用和多路分解</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129184105048.png" alt="image-20211129184105048" style="zoom: 33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129184128714.png" alt="image-20211129184128714" style="zoom:50%;"></li><li><p><strong>端口和套接字</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129184042028.png" alt="image-20211129184042028" style="zoom:50%;"><p>应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序提供并发服务的问题。 多个TCP连接或多个应用程序程序可能需要通过同一个TCP协议端口传输数据。 为了区别不同的应用程序程序和连线，许多计算机操作系统为应用程序与TCP/IP协议互动提供了称为套接字（Socket）的接口，区分不同应用程序程序间的网络通讯和连线。</p></li><li><p><strong>UDP数据包结构</strong></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129184805070.png" alt="image-20211129184805070"></p></li><li><p><strong>检查和的计算</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130220312989.png" alt="image-20211130220312989" style="zoom:50%;"></li><li><p><strong>数据可靠传输的基本要求：不丢包、不出错</strong></p></li><li><p><strong>差错检测、响应（ACK）、序号、检错重传、超时重传</strong></p></li><li><p>   <strong>流水线技术、滑动窗口 GBN SR</strong></p></li><li><p><strong>序号位数k和滑动窗口大小两者之间的关系公式</strong></p></li><li><p><strong>累计确认、选择确认、稍待确认</strong></p></li><li><p><strong>TCP报文段首部结构</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129194728280.png" alt="image-20211129194728280" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129195949676.png" alt="image-20211129195949676" style="zoom:80%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129204227245.png" alt="image-20211129204227245" style="zoom: 80%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129210308416.png" alt="image-20211129210308416" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129210412904.png" alt="image-20211129210412904" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129210557423.png" alt="image-20211129210557423" style="zoom:50%;"><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129210718032.png" alt="image-20211129210718032"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129210735850.png" alt="image-20211129210735850"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129210801355.png" alt="image-20211129210801355" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129210823222.png" alt="image-20211129210823222" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129210929153.png" alt="image-20211129210929153" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129211006557.png" alt="image-20211129211006557" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129211030270.png" alt="image-20211129211030270" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129211128640.png" alt="image-20211129211128640" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129211145013.png" alt="image-20211129211145013" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129211157666.png" alt="image-20211129211157666" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129211228336.png" alt="image-20211129211228336" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129211242181.png" alt="image-20211129211242181" style="zoom:50%;"></li><li><p><strong>TCP序号、确认号</strong></p></li><li><p><strong>TCP流量控制—— 通知窗口、可变滑动窗口</strong></p><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129184850293.png" alt="image-20211129184850293"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129190030921.png" alt="image-20211129190030921" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129190053338.png" alt="image-20211129190053338" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129190115885.png" alt="image-20211129190115885" style="zoom:50%;"></li><li><p><strong>TCP三次握手、四步连接撤销机制</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129201127166.png" alt="image-20211129201127166" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129201504906.png" alt="image-20211129201504906" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129201044691.png" alt="image-20211129201044691" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129201400707.png" alt="image-20211129201400707" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129204001677.png" alt="image-20211129204001677" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129204025038.png" alt="image-20211129204025038" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129204044894.png" alt="image-20211129204044894" style="zoom:50%;"></li><li><p><strong>TCP超时时间间隔计算公式——卡恩公式 及其修正公式</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129193620829.png" alt="image-20211129193620829" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129193823104.png" alt="image-20211129193823104" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129194011285.png" alt="image-20211129194011285" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129194200515.png" alt="image-20211129194200515" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129194337832.png" alt="image-20211129194337832" style="zoom:50%;"></li><li><p><strong>拥塞、拥塞控制的方法</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129190310531.png" alt="image-20211129190310531" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129190444035.png" alt="image-20211129190444035" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129190613574.png" alt="image-20211129190613574" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129191302607.png" alt="image-20211129191302607" style="zoom:50%;"><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129191502210.png" alt="image-20211129191502210"></p></li><li><p><strong>Reno算法和Tahoe算法</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129191727325.png" alt="image-20211129191727325" style="zoom:50%;"><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129191847824.png" alt="image-20211129191847824"></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129191953894.png" alt="image-20211129191953894" style="zoom:67%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129192146533.png" alt="image-20211129192146533" style="zoom:50%;"></li><li><p><strong>TCP的公平性</strong></p></li></ol><h3 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h3><ol><li><p><strong>网络层的功能：转发、路由</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211117231618864.png" alt="image-20211117231618864" style="zoom:50%;"></li><li><p><strong>虚电路 vs 数据报</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211117235125078.png" alt="image-20211117235125078" style="zoom:50%;"></li><li><p><strong>路由器结构：输入端口、交换结构、路由选择处理机、输出端口</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130195838488.png" alt="image-20211130195838488" style="zoom: 67%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130200111303.png" alt="image-20211130200111303" style="zoom:67%;"></li><li><p><strong>线头阻塞</strong></p>  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130200304412.png" alt="image-20211130200304412" style="zoom:50%;"></li><li><p><strong>三种交换结构</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130214243708.png" alt="image-20211130214243708" style="zoom: 50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130214354623.png" alt="image-20211130214354623" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130214411229.png" alt="image-20211130214411229" style="zoom:50%;"></li><li><p><strong>输出端口分组调度策略和丢包策略</strong></p>  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130214511092.png" alt="image-20211130214511092" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130214929128.png" alt="image-20211130214929128" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130215122054.png" alt="image-20211130215122054" style="zoom:50%;"></li><li><p><strong>IPv4、IPv6数据报首部结构</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120090715576.png" alt="image-20211120090715576" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120090820275.png" alt="image-20211120090820275" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120090848242.png" alt="image-20211120090848242" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120090938164.png" alt="image-20211120090938164" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120091055706.png" alt="image-20211120091055706" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120091124412.png" alt="image-20211120091124412" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120091150400.png" alt="image-20211120091150400" style="zoom:50%;"></li><li><p><strong>IP分片与重组</strong></p></li><li><p><strong>IPv4、IPv6地址</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211117235919995.png" alt="image-20211117235919995" style="zoom:50%;"></li><li><p><strong>IPv4地址的传统分类法：ABCDE</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118000020832.png" alt="image-20211118000020832" style="zoom:50%;"></li><li><p><strong>子网划分、CIDR</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118000107048.png" alt="image-20211118000107048" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118000141664.png" alt="image-20211118000141664" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118201459909.png" alt="image-20211118201459909" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118201524086.png" alt="image-20211118201524086" style="zoom: 50%;"></li><li><p><strong>网络号 子网号 主机号 网络前缀 子网掩码</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118201717540.png" alt="image-20211118201717540" style="zoom:50%;">  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118202708191.png" alt="image-20211118202708191" style="zoom:50%;"><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118202754801.png" alt="image-20211118202754801"></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118203047260.png" alt="image-20211118203047260" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118205912632.png" alt="image-20211118205912632" style="zoom:50%;"></li><li><p><strong>DHCP</strong></p>  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129212507591.png" alt="image-20211129212507591" style="zoom: 25%;">  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211129212626120.png" alt="image-20211129212626120" style="zoom:25%;">  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130121908864.png" alt="image-20211130121908864" style="zoom:50%;"><p>​    </p></li><li><p><strong>NAT</strong></p><p> VPN</p><p> 逻辑上看，R1R2之间像一条直通的点对点链路</p><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120092233235.png" alt="image-20211120092233235"></p><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120092313114.png" alt="image-20211120092313114"></p><p> NAT</p><p>  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120092844652.png" alt="image-20211120092844652"></p><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120092901027.png" alt="image-20211120092901027"></p><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120092919333.png" alt="image-20211120092919333"></p><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120092802935.png" alt="image-20211120092802935"></p></li><li><p><strong>ICMP</strong></p><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120091826592.png" alt="image-20211120091826592"></p></li><li><p><strong>IPv4向IPv6迁移的方法</strong></p></li><li><p><strong>层次路由、AS、IGP、EGP</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118210352767.png" alt="image-20211118210352767" style="zoom:50%;"></li><li><p><strong>链路状态选路算法 OSFP 层次OSPF</strong></p>  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120084025448.png" alt="image-20211120084025448" style="zoom:50%;">  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120084343867.png" alt="image-20211120084343867" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120084514007.png" alt="image-20211120084514007" style="zoom:50%;">  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120084539791.png" alt="image-20211120084539791" style="zoom:50%;"><p>  迪杰斯特拉算法</p></li><li><p><strong>距离向量选路算法 RIP</strong></p>  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211118212032619.png" alt="image-20211118212032619" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120082710619.png" alt="image-20211120082710619" style="zoom:50%;"></li><li><p><strong>BGP-4 边界路由器 热土豆选路 路由选择策略</strong></p></li></ol><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120085140016.png" alt="image-20211120085140016" style="zoom:50%;"><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120085205379.png" alt="image-20211120085205379"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211120085238579.png" alt="image-20211120085238579"></p><h3 id="第五章-链路层：链路-接入网-局域网"><a href="#第五章-链路层：链路-接入网-局域网" class="headerlink" title="第五章 链路层：链路 接入网 局域网"></a>第五章 链路层：链路 接入网 局域网</h3><ol><li><p><strong>结点，链路，数据链路，网络适配器</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114215345365.png" alt="image-20211114215345365" style="zoom:50%;"></li><li><p><strong>奇偶校验 检查和 CRC</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114220608060.png" alt="image-20211114220608060" style="zoom: 50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114220628236.png" alt="image-20211114220628236" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114220655459.png" alt="image-20211114220655459" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114220749209.png" alt="image-20211114220749209" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114220807178.png" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114221703096.png" alt="image-20211114221703096" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114222028875.png" alt="image-20211114222028875" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114222130522.png" alt="image-20211114222130522" style="zoom:50%;"><p>停止—等待协议</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114223605615.png" alt="image-20211114223605615"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114223623661.png" alt="image-20211114223623661"></p><p>回退N帧协议GBN</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114225038800.png" alt="image-20211114225038800"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114225012109.png" alt="image-20211114225012109" style="zoom:50%;"><p>选择重传协议</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114231058988.png" alt="image-20211114231058988" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114231050974.png" alt="image-20211114231050974" style="zoom:50%;"></li><li><p><strong>点到点链路 广播链路</strong></p><p><img src="C:/Users/Trent/AppData/Roaming/Typora/typora-user-images/image-20211114232000494.png" alt="image-20211114232000494"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115110945687.png" alt="image-20211115110945687" style="zoom: 50%;"><img src="C:/Users/Trent/AppData/Roaming/Typora/typora-user-images/image-20211114232335476.png" alt="image-20211114232335476" style="zoom:50%;"></li><li><p><strong>信道划分协议:TDM FDM CDMA</strong></p>  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115111708667.png" alt="image-20211115111708667" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115111748826.png" alt="image-20211115111748826" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115111823433.png" alt="image-20211115111823433" style="zoom:50%;"><p> 波分复用就是光的频分复用</p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115112116071.png" alt="image-20211115112116071" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115112210721.png" alt="image-20211115112210721" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115112318566.png" alt="image-20211115112318566" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115112822479.png" alt="image-20211115112822479" style="zoom:67%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115112913965.png" alt="image-20211115112913965" style="zoom:67%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115113037779.png" alt="image-20211115113037779" style="zoom:50%;"></li><li><p><strong>随机接入协议 Aloha CSMA CSMA/CD</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115114617072.png" alt="image-20211115114617072" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115114724172.png" alt="image-20211115114724172" style="zoom: 50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115115112358.png" alt="image-20211115115112358" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115115316848.png" alt="image-20211115115316848" style="zoom:50%;"><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115115421357.png" alt="image-20211115115421357" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115132408418.png" alt="image-20211115132408418" style="zoom:50%;"></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115132512618.png" alt="image-20211115132512618" style="zoom:50%;"><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115132647385.png" alt="image-20211115132647385"></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115132854063.png" alt="image-20211115132854063" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115133038231.png" alt="image-20211115133038231" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115133534252.png" alt="image-20211115133534252" style="zoom:50%;"><p> 指数退避算法**（见5)</p></li><li><p><strong>征用期</strong></p></li><li><p><strong>MAC地址，ARP</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116112734267.png" alt="image-20211116112734267" style="zoom:50%;">  <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116112939365.png" alt="image-20211116112939365" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116113025702.png" alt="image-20211116113025702" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116113112064.png" alt="image-20211116113112064" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116113157136.png" alt="image-20211116113157136" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116113950948.png" alt="image-20211116113950948" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116114201473.png" alt="image-20211116114201473" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116114751018.png" alt="image-20211116114751018" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116114828040.png" alt="image-20211116114828040" style="zoom:50%;"><p> <img src="C:/Users/Trent/AppData/Roaming/Typora/typora-user-images/image-20211116115223870.png" alt="image-20211116115223870"></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116115257768.png" alt="image-20211116115257768" style="zoom: 50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116124257198.png" alt="image-20211116124257198" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116124334305.png" alt="image-20211116124334305" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116125920277.png" alt="image-20211116125920277" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116130030923.png" alt="image-20211116130030923" style="zoom:50%;"><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116130459501.png" alt="image-20211116130459501"></p></li><li><p><strong>以太网帧结构</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114215847274.png" alt="image-20211114215847274" style="zoom: 33%;"></li><li><p><strong>MTU vs MSS</strong></p><p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/F4(S$MCQQOGM%7B%7DU%5B)%60YSPAI.png" alt="img"></p><p> MTU： Maximum Transmit Unit，最大传输单元，即物理接口（数据链路层）提供给其上层（通常是IP层）最大一次传输数据的大小；以普遍使用的以太网接口为例，缺省MTU=1500 Byte，这是以太网接口对IP层的约束，如果IP层有&lt;=1500 byte 需要发送，只需要一个IP包就可以完成发送任务；如果IP层有&gt; 1500 byte 数据需要发送，需要分片才能完成发送，这些分片有一个共同点，即IP Header ID相同。</p><p> MSS： Maximum  Segment Size ，TCP提交给IP层最大分段大小，不包含TCP Header和 TCP Option，只包含TCP Payload ，MSS是TCP用来限制application层最大的发送字节数。如果底层物理接口MTU= 1500 byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte，如果application 有2000 byte发送，需要两个segment才可以完成发送，第一个TCP segment = 1460，第二个TCP segment = 540。</p></li><li><p><strong>以太网的物理层</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114205609678.png" alt="image-20211114205609678" style="zoom:50%;"></li><li><p><strong>链路层交换机工作原理</strong></p><p>  交换机原理：<br> 1.收到数据帧后，学习帧中的源MAC地址，记录MAC表。<br> 2.交换机查询MAC地址表，若无相应母大MAC对应端口，进行广播。<br> 3.交换机MAC地址默认老化时间是300s，更新MAC地址表。<br> 4.若MAC地址表中有对应地址记录，进行转发。</p></li><li><p><strong>集线器 vs 交换机 vs 路由器</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116165832967.png" alt="image-20211116165832967" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116171214292.png" alt="image-20211116171214292" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116171634889.png" alt="image-20211116171634889" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116171432683.png" alt="image-20211116171432683" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116172531640.png" alt="image-20211116172531640" style="zoom:50%;"></li><li><p><strong>VLAN</strong></p> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116172750447.png" alt="image-20211116172750447" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116173601147.png" alt="image-20211116173601147" style="zoom:50%;"></li></ol><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114211830050.png" alt="image-20211114211830050" style="zoom:67%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114211841469.png" alt="image-20211114211841469" style="zoom:67%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114211857338.png" alt="image-20211114211857338" style="zoom:67%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114211907684.png" alt="image-20211114211907684" style="zoom:67%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114212942133.png" alt="image-20211114212942133" style="zoom: 50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114212949530.png" alt="image-20211114212949530" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114212544633.png" alt="image-20211114212544633" style="zoom: 50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114212629073.png" alt="image-20211114212629073" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114212725253.png" alt="image-20211114212725253" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114212809269.png" alt="image-20211114212809269" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211114212923433.png" alt="image-20211114212923433" style="zoom:50%;"><h3 id="第六章-无线网络和移动网络"><a href="#第六章-无线网络和移动网络" class="headerlink" title="第六章 无线网络和移动网络"></a>第六章 无线网络和移动网络</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130230526203.png" alt="image-20211130230526203" style="zoom: 50%;"><ol><li><p><strong>无线网构件: 无线主机、无线链路、基站</strong></p></li><li><p><strong>有基础设施无线网、无基础设施无线网（AdHoc）</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130230921859.png" alt="image-20211130230921859" style="zoom:50%;"></li><li><p><strong>无线链路特征</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130231019555.png" alt="image-20211130231019555" style="zoom:50%;"></li><li><p><strong>比特差错率 传输率和信噪比</strong></p><p>差错处理：采用CRC进行帧校验</p><p>采用ARQ协议（停止等待协议）进行重传</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130231311271.png" alt="image-20211130231311271" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130231425654.png" alt="image-20211130231425654" style="zoom:50%;"><p> 信噪比越高，比特差错率就越低</p><p>给定一个信噪比，传送速率越快，差错率越高 </p></li><li><p><strong>隐蔽站问题 暴露站问题</strong></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115232710094.png" alt="image-20211115232710094"></p></li><li><p><strong>CDMA</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115232620196.png" alt="image-20211115232620196" style="zoom:50%;"></li><li><p><strong>802.11系列协议</strong></p><p>WiFi就是执行802.11协议的无线LAN</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130232507671.png" alt="image-20211130232507671" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130232546943.png" alt="image-20211130232546943" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130232613876.png" alt="image-20211130232613876" style="zoom:50%;"></li><li><p><strong>CSMA/CA 帧间间隔 CTS RTS</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115232800793.png" alt="image-20211115232800793" style="zoom:50%;"><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115232900173.png" alt="image-20211115232900173"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115233024877.png" alt="image-20211115233024877" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115234726659.png" alt="image-20211115234726659" style="zoom:50%;"> <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115234849987.png" alt="image-20211115234849987" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115234950207.png" alt="image-20211115234950207" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115235258354.png" alt="image-20211115235258354" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115235706556.png" alt="image-20211115235706556" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115235803756.png" alt="image-20211115235803756" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115235855648.png" alt="image-20211115235855648" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211115235955234.png" alt="image-20211115235955234" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116000032330.png" alt="image-20211116000032330" style="zoom:50%;"><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211116000045462.png" alt="image-20211116000045462"></p></li><li><p><strong>BSS</strong></p><p>一个基本服务集 BSS（Basic Service Set） 包括<strong>一个基站</strong>和<strong>若干个移动站</strong></p><p>所有的站在本 BSS 以内都可以直接通信，但要和本 BSS 以外的站通信时，都要通过本 BSS 的基站。</p><p>可以理解为在一个网段的计算机可以直接通信，和其他网段的计算机通信需要过网关。</p><p>基本服务集 BSS 内的基站叫做 <strong>接入点 AP（Access Point）</strong></p><p>当网络管理员安装 AP 时，必须为该 AP 分配一个不超过 32 字节的<strong>服务集标识符 SSID</strong> 和一个<strong>信道</strong>。</p><p>一个基本服务集可以是孤立的，也可通过接入点 AP 连接到一个主干<strong>分配系统</strong> DS（Distribution System），然后再接入到另一个基本服务集，构成<strong>扩展的服务集</strong> ESS（Extended Service Set）</p></li><li><p><strong>信道 关联</strong></p></li><li><p><strong>802.11速率自适应</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130233057153.png" alt="image-20211130233057153" style="zoom:50%;"></li><li><p><strong>归属网络 归属代理 外部网络 外部代理 锚代理 永久地址 转交地址</strong></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130234034436.png" alt="image-20211130234034436"></p><p>移动节点会不断改变连接，连接到不同的有线基础设施</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130234249994.png" alt="image-20211130234249994" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130234358329.png" alt="image-20211130234358329" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130234525059.png" alt="image-20211130234525059" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130234615054.png" alt="image-20211130234615054" style="zoom:50%;"></li><li><p><strong>移动节点的路由选择方法</strong></p></li></ol><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20211130234719585.png" alt="image-20211130234719585"></p><p><img src="C:/Users/Trent/AppData/Roaming/Typora/typora-user-images/image-20211130234754914.png" alt="image-20211130234754914"></p><p>考试范围</p><p>见公告</p><p>题型： 全部为大题， 8——10题</p><p>第二层 以太网交换机  Mac地址 栈表  自学习</p><p> 第一层 hub集线器</p><p>  第三层 路由器  IP 转发表， 路由表  选路算法</p><p>每经过一个路由器称为一跳</p><p>ICP 网络内容提供商 ISP 网络服务提供商</p><p>缩写要背</p><p>因特网提供的服务  </p><p>SDK 供应用程序调用，使用服务,以协议的形式存在 ，语法语义同步 </p><p>提供运行平台，供应用程序运行</p><p>因特网构成</p><p>边缘  应用进程通信的模型</p><p>家庭接入 DSL HFC FTTH</p><p>企业接入 以太网</p><p>无线接入  局域网，城域网 广域网 个域网</p><p>电路交换（多路复用TDM FDM CDM，面向连接，可靠性高，独占电路）    报文交换   分组交换（虚电路（引入电路级交换的能力）） 数据报）</p><p>四种时延的计算   往返时延RTT</p><p>绝大多数丢包，缓冲区溢出，流量强度大于1</p><p>层次模型  三大模型，  要知道TCP/IP 四层模型</p><p>浏览器没有过多的care，服务器讲了html，web对象，url</p><p>重点Http协议  1.0版本 客户机服务器通信非持久连接 事先建立连接才可传输，2RTT，性能较差，断开连接   三种不同模式</p><p>请求报文 GET POST ……五个命令 </p><p>请求状态， 404等</p><p>SMTP协议工作原理  7位ASCII码， base64拓展</p><p>接受邮件的两种方法，POP3，IMAP</p><p>P2P与CS对比</p><p>BitTorrent的工作原理 最缺优先，4+1</p><p>网络层运输层的题占50%</p><p>多路复用 多路分解   最基本的原理和方法，从整本书整个体系来考虑，很多层都有</p><p>Rdt的多个版本</p><p>引入各种机制</p><p>RDT3.0性能很差，引入滑动窗口，进一步GBN　SR  序号位数和滑动窗口大小的关系公式</p><p>三种确认方式</p><p>TCP报文段首部结构，20字节必选，………………面向字节流的可变滑动窗口机制</p><p>滑动窗口基于通知窗口，拥塞窗口……用通知窗口进行流量控制</p><p>三次握手，四次连接撤销</p><p>拥塞、拥塞控制的方法</p><p>Reno算法，Tahoe算法</p><p>TCP重传机制两种，timeout，快速重传</p><p>第六版就没这个话题了，TCP拥塞对时延的影响</p><p>网络层，转发，路由</p><p>网络地址，广播地址，IP地址</p><p>IP地址分配时这两个地址不能分给主机使用</p><p>层次路由</p><p>AS 自治系统的概念</p><p>路由选择策略</p><p>路由器结构</p><p>路由选择处理机</p><p>大法官高峰时段反倒是敢死队风格豆腐干广告过后vvvv  版本的手动阀实打实大大的热热饿顶顶谢谢 踩踩踩 v给vv刚刚   b’j’k’j’l’k’j’l’k’j</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>随便记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的多线程</title>
    <link href="/2021/10/12/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/10/12/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><p>并发： 两个或者多个独立的活动同时进行</p><p>并发假象：单核CPU，上下文切换的方式实现并发</p><p>目前都是多核电脑，就不太需要并发假象</p><p>进程：计算机中的程序关于某个数据集合上的一次运行活动（exe等应用程序的运行状态）</p><p>线程：每一个进程都有一个主线程（并且只有一个）</p><p>vs编译器中ctrl + F5运行程序的时候，实际上是主线程调用main函数编译后的代码，仅此而已。线程可以为一个运行代码的通道，路径。我们可以自己创建多个线程</p><p>山东 – 背景</p><p>山东 – 天津 – 北京</p><p>并发的实现：</p><ol><li><p>多进程实现并发</p><p>主要解决的问题是进程间通信的问题</p><ol><li>同一台电脑上，管道，文件，消息队列，内存共享</li><li>不同电脑上通过Socket网络通信实现。</li></ol></li><li><p>单个进程，多个线程实现并发，就是一个主线程多个子线程实现并发。</p><p>一个进程中的所有线程共享的内存空间，例如：全局变量，指针引用。</p></li></ol><h3 id="线程的多种创建方式"><a href="#线程的多种创建方式" class="headerlink" title="线程的多种创建方式"></a>线程的多种创建方式</h3><h4 id="C-创建的过程"><a href="#C-创建的过程" class="headerlink" title="C++创建的过程"></a>C++创建的过程</h4><h5 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br></code></pre></div></td></tr></table></figure><h5 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h5><p>调用thread类去创建一个线程对象</p><p>注意点： 当创建一个线程，不做处理，会调用abort函数中止程序</p><h5 id="join函数"><a href="#join函数" class="headerlink" title="join函数"></a>join函数</h5><p>加入，汇合线程，阻塞主线程，等待子线程执行结束，才会回到主线程中</p><p>一个线程只能join一次，不能多次join</p><h5 id="detach函数"><a href="#detach函数" class="headerlink" title="detach函数"></a>detach函数</h5><p>分离，打破依赖关系，不管主线程，主线程结束，子线程后台挂起状态（驻留后台），与主线程无关</p><p>线程detach后，就不能再join了。</p><ul><li>joinable()判断当前线程是否可以做join或者detach过程，可以则返回true，不可以则返回false</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">//线程处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;子线程运行...&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//创建线程</span><br>    <span class="hljs-function">thread <span class="hljs-title">test1</span><span class="hljs-params">(print)</span></span>;<br>    test1.detach();<br>    <span class="hljs-comment">//阻塞</span><br>    test1.join(); <span class="hljs-comment">//子线程不结束，主线程不会进行</span><br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;主线程.....&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">if</span> (test1.joinable()) &#123;<br>        test1.detach();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;子线程已被处理&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="其他创建线程的方法"><a href="#其他创建线程的方法" class="headerlink" title="其他创建线程的方法"></a>其他创建线程的方法</h4><h5 id="普通函数方式"><a href="#普通函数方式" class="headerlink" title="普通函数方式"></a>普通函数方式</h5><p>如上</p><h5 id="通过类和对象"><a href="#通过类和对象" class="headerlink" title="通过类和对象"></a>通过类和对象</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MM</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//STL仿函数</span><br>    <span class="hljs-comment">//重载括号，让类名模仿函数的行为</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;子线程启动...&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-comment">//MM();  //MM 无名对象()</span><br> <br>    <span class="hljs-comment">//正常写法:对象充当线程处理函数</span><br>    MM mm;<br>    <span class="hljs-function">thread <span class="hljs-title">test1</span><span class="hljs-params">(mm)</span></span>;<br>    test1.join();<br><br>    <br>    <span class="hljs-function">thread <span class="hljs-title">test2</span><span class="hljs-params">( (MM()) )</span></span>; <span class="hljs-comment">//加一层括号，否则直接把MM()解析成函数，MM构造无名对象，()构成一个函数</span><br>    test2.join();<br>    <span class="hljs-built_in">cout</span> &lt;&lt;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="lambda表达式创建线程"><a href="#lambda表达式创建线程" class="headerlink" title="lambda表达式创建线程"></a>lambda表达式创建线程</h5><p>lambda表达式</p><p>创建线程需要一个线程处理函数的函数指针，因此直接使用lambda表达式充当线程处理的函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">//返回大值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//lambda表达式就是将上面的函数定义写成一个表达式，返回的就是一个函数指针</span><br>    <span class="hljs-comment">//[]()-&gt;    捕获数据 函数参数 是否存在异常 函数返回值 函数体</span><br>    <span class="hljs-comment">//函数的定义和实现写在一起</span><br>    <span class="hljs-keyword">int</span> (*pMax)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) = <span class="hljs-literal">nullptr</span>;<br>    pMax = [](<span class="hljs-keyword">int</span> a, intb) -&gt; <span class="hljs-keyword">int</span> &#123;<span class="hljs-keyword">return</span> a &gt; b ? a : b;&#125;;<br>    <br>    <span class="hljs-function">thread <span class="hljs-title">test1</span><span class="hljs-params">([] &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;子线程运行...&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;)</span></span>;<br>    test1.join();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;主线程运行...&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; pMax(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//一个简单的lambda表达式</span><br><span class="hljs-comment">//直接定义加调用</span><br>[]() &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;HelloWorld&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;();<br></code></pre></div></td></tr></table></figure><h5 id="带参的方式创建线程"><a href="#带参的方式创建线程" class="headerlink" title="带参的方式创建线程"></a>带参的方式创建线程</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">//传引用</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp; num)</span> </span>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;子线程\t&quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//std::ref 用于包装引用传递值</span><br>    <span class="hljs-function">thread <span class="hljs-title">test1</span><span class="hljs-params">(printInfo, <span class="hljs-built_in">std</span>::ref(num))</span></span>;<br>    test1.join();<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;主线程....&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="带智能指针创建线程"><a href="#带智能指针创建线程" class="headerlink" title="带智能指针创建线程"></a>带智能指针创建线程</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">//以智能指针为参数的一个函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr)</span>  </span>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;子线程...&quot;</span> &lt;&lt; ptr.get() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    new，一段空间</span><br><span class="hljs-comment">    int *p = new int(100);</span><br><span class="hljs-comment">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-comment">//智能指针管理，不需要我们做手动释放</span><br>    <span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1000</span>))</span></span>;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;主线程：&quot;</span> &lt;&lt; ptr.get() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//移动语义后，主函数new出的智能指针就无了，移动到子线程中。</span><br>    <span class="hljs-function">thread <span class="hljs-title">test1</span><span class="hljs-params">(print, move(ptr))</span></span>;<br>    test1.join();<br>  <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;主线程...&quot;</span> &lt;&lt; ptr.get() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>打印出 </p></blockquote><p>this_thread::get_id()获取当前进程的id</p><h5 id="通过类的成员函数创建线程"><a href="#通过类的成员函数创建线程" class="headerlink" title="通过类的成员函数创建线程"></a>通过类的成员函数创建线程</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MM</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        num = <span class="hljs-number">1001</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;子线程：&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="hljs-built_in">endl</span>; <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MM mm;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1007</span>;<br>    <span class="hljs-comment">//需要告诉是哪个对象</span><br>    thread.join();<br>    <span class="hljs-built_in">cout</span>  &lt;&lt; <span class="hljs-string">&quot;主线程：&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的regex类</title>
    <link href="/2021/10/10/C++%E7%9A%84regex%E7%B1%BB/"/>
    <url>/2021/10/10/C++%E7%9A%84regex%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>C++11将正则表达式纳入了新标准的一部分</p><p> #include&lt;regex&gt;   需要包含的头文件</p><h3 id="常用的组件"><a href="#常用的组件" class="headerlink" title="常用的组件"></a>常用的组件</h3><h4 id="regex"><a href="#regex" class="headerlink" title="regex"></a>regex</h4><p>表示有一个正则表达式，比如regex pattern(“(.{3})(.{2})_(\d{4})!”)</p><p>使用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;regex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br>smatch results;  <span class="hljs-comment">//一种存储方式</span><br><br><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;华中科技大学计算机科学与技术学院&quot;</span>;<br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">pattern</span><span class="hljs-params">(<span class="hljs-string">&quot;(大学|学院)&quot;</span>)</span></span>;<br><span class="hljs-function">regex <span class="hljs-title">r</span><span class="hljs-params">(pattern)</span></span>;    <br></code></pre></div></td></tr></table></figure><h4 id="regex-match"><a href="#regex-match" class="headerlink" title="regex_match"></a>regex_match</h4><p>全文匹配，要求整个字符串符合正则表达式的匹配规则，用来判断一个字符串和一个正则表达式是否模式匹配，返回bool值。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">cout</span> &lt;&lt; regex_match(str, result, r) &lt;&lt; <span class="hljs-built_in">endl</span>; <br><span class="hljs-keyword">if</span> (regex_match(str, result, r))<br>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; results[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>匹配的含义是目标字符串必须完全和正则表达式相匹配，不能有多余的字符。</p><p>使用regex::icase表示匹配时忽略大小写</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//忽略了大小写，结果为1</span><br><span class="hljs-built_in">cout</span> &lt;&lt; regex_match(<span class="hljs-string">&quot;aaaAAA&quot;</span>, regex(<span class="hljs-string">&quot;a*&quot;</span>, regex::icase)) &lt;&lt; <span class="hljs-built_in">endl</span>; <br><span class="hljs-comment">//不忽略大小写，结果为0</span><br><span class="hljs-built_in">cout</span> &lt;&lt; regex_match(<span class="hljs-string">&quot;aaaAAA&quot;</span>, regex(<span class="hljs-string">&quot;a*&quot;</span>)) &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><h4 id="regex-search"><a href="#regex-search" class="headerlink" title="regex_search"></a>regex_search</h4><p>搜索匹配，根据正则表达式来搜索字符串中是否存在符合规则的字符串，能和正则表达式相匹配就返回true</p><p>输出<strong>第一个</strong>与正则表达式匹配的子序列结果</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">cout</span> &lt;&lt; regex_search(str, results, r) &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (regex_search(str, result, r))<br>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; result[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//输出学校</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; result.str() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>利用迭代器访问所有匹配的结果值</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span>::const_iterator iterStart = str.begin();<br><span class="hljs-built_in">string</span>::const_iterator iterEnd = str.end();<br><span class="hljs-built_in">string</span> temp;<br><br><span class="hljs-keyword">while</span> (regex_search(iterStart, iterEnd, results, r))&#123;<br>    temp = result[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-comment">//输出学校，学院</span><br>    iterStart = results[<span class="hljs-number">0</span>].second;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="regex-replace"><a href="#regex-replace" class="headerlink" title="regex_replace"></a>regex_replace</h4><p>替换匹配，将符合匹配规则的字符串替换为其他字符串</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">cout</span> &lt;&lt; regex_replace(str, r, <span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>可以使用regex_replace()函数调整字符串的内容和顺序</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;Hello_2021&quot;</span>;<br><span class="hljs-function">regex <span class="hljs-title">r2</span><span class="hljs-params">(<span class="hljs-string">&quot;(.&#123;3&#125;)(.&#123;2&#125;)_(\d&#123;4&#125;)!&quot;</span>)</span></span>;  <span class="hljs-comment">//匹配任意3个字符+任意2个字符+下划线+4个数字</span><br><span class="hljs-comment">//输出：Hel2019，将字符串替换为第一个和第三个表达式匹配的内容</span><br><span class="hljs-built_in">cout</span> &lt;&lt; regex_replace(str2, r2, <span class="hljs-string">&quot;$1$3&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//输出：Hel2019lo,交换位置顺序</span><br><span class="hljs-built_in">cout</span> &lt;&lt; regex_replace(str2, r2, <span class="hljs-string">&quot;$1$3$2&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;   <br></code></pre></div></td></tr></table></figure><h4 id="sregex——iterator"><a href="#sregex——iterator" class="headerlink" title="sregex——iterator"></a>sregex——iterator</h4><p>迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (sregex_iterator it(str.begin(), str.end(), r), end_it; it != emd_it; ++it) &#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;str() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>smatch/match_results</p><p>容器类，保存在string中搜索的结果，如果匹配成功，这些函数将成功匹配的相关信息保存在给定的smatch对象中。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式自学</title>
    <link href="/2021/10/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%87%AA%E5%AD%A6/"/>
    <url>/2021/10/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%87%AA%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://regex101.com/">regex101: build, test, and debug regex</a></p><p>一个测试正则表达式的网站</p><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><h4 id><a href="#" class="headerlink" title="?"></a>?</h4><p>?前面的字符 <strong>不出现</strong> 或 <strong>出现一次</strong>，</p><p>比如 Trent?  则会寻找Tren 和 Trent</p><h4 id="-1"><a href="#-1" class="headerlink" title="*"></a>*</h4><p>*前面的字符可以<strong>不出现</strong>，<strong>出现一次</strong>也可以<strong>出现多次</strong></p><p>比如 ab*c</p><p>可以匹配 ac abc  abbbc 但是不能匹配adc</p><h4 id="-2"><a href="#-2" class="headerlink" title="+"></a>+</h4><p>+前面的字符<strong>出现一次</strong>或<strong>多次</strong></p><h4 id="-3"><a href="#-3" class="headerlink" title="{}"></a>{}</h4><p>{范围}</p><p>ab{2,6}c    b出现2到6次</p><p>ab{2,}        b出现2次以上</p><p>如果要匹配多个字符，则用()括起来</p><p>(ab){2,6}c</p><h3 id="或运算符"><a href="#或运算符" class="headerlink" title="或运算符"></a>或运算符</h3><p>a （cat|dog)</p><p>匹配 a cat或者a dog，括号必不可少</p><p>如果a cat|dog</p><p>则匹配的是a cat或者dog</p><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>[abc]匹配a或b，与[a-c]等价</p><p>如果想匹配由abc这几个字母构成的单词，可以写作[abc]+</p><p>方括号内的内容要求匹配的字符只能取自于它们</p><p>如 abc   aabbcc   aaaaaabc等</p><p>[a-z]表示所有的小写英文字符</p><p>[a-zA-Z]代表所有的英文字符</p><p>[a-zA-Z0-9]代表所有的英文字符和数字</p><p>方括号内的内容前加一个尖号（脱字符），则要求匹配除了尖号后面列出的[以外]的字符</p><p>比如[^0-9]代表所有的非数字字符（包括换行）</p><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>大部分元字符都是以反斜杠开头</p><p>\d表示数字字符，等同于之前写的[0-9]</p><p>\w代表“单词”字符，也就是所有的英文字符，数字，下划线</p><p>\s代表空白符，同时包括Tab字符以及换行符</p><p>\D代表非数字字符</p><p>\W非单词字符</p><p>\S非空白字符</p><p>.代表除了换行符的任意字符</p><p>^ 匹配行首，$匹配行尾</p><p>^a匹配行首的a     a$匹配行尾的a</p><p>\b\bword 标注字符的边界（全字匹配）</p><h3 id="贪婪与懒惰匹配"><a href="#贪婪与懒惰匹配" class="headerlink" title="贪婪与懒惰匹配"></a>贪婪与懒惰匹配</h3><p>贪婪匹配，比如&lt;.+&gt;，.表示匹配所有字符，+表示匹配尽可能多的，因此代表匹配整个字符串</p><p><strong>&lt;span&gt;&lt;b&gt;This is a sample text&lt;/b&gt;&lt;/span&gt;</strong></p><p>&lt;.+?&gt;，加号后加一个?，将正则表达式中默认的贪婪匹配切换为懒惰匹配，这在实际使用中经常被用到</p><p><strong>&lt;span&gt;&lt;b&gt;<strong>This is a sample text</strong>&lt;/b&gt;&lt;/span&gt;</strong></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="十六进制RGB颜色值"><a href="#十六进制RGB颜色值" class="headerlink" title="十六进制RGB颜色值"></a>十六进制RGB颜色值</h4><p>#号开头，6个十六进制数</p><p>#[a-fA-F0-9]{6}\b</p><h4 id="IP地址的匹配"><a href="#IP地址的匹配" class="headerlink" title="IP地址的匹配"></a>IP地址的匹配</h4><p>四段数字，句点隔开</p><p>\d+\.\d+\.\d+\.\d+</p><p>但是要求匹配的每段数字都要小于等于255</p><p>\b((25[0-5] | 2[0-4]\d | [01]?\d\d?)\.){3}(25[0-5] | 2[0-4]\d | [01]?\d\d?)\b</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>随便记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-vim自学</title>
    <link href="/2021/10/04/vi%E8%87%AA%E5%AD%A6/"/>
    <url>/2021/10/04/vi%E8%87%AA%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="创建-打开文件"><a href="#创建-打开文件" class="headerlink" title="创建/打开文件"></a>创建/打开文件</h3><p>vi 文件名</p><p>打开一个文件，如果文件不存在，就创建它</p><p>比如 vi book.c</p><p>创建一个book.c文件</p><h3 id="vi的三种模式"><a href="#vi的三种模式" class="headerlink" title="vi的三种模式"></a>vi的三种模式</h3><p>命令行模式，插入模式，替换模式。</p><p>命令行模式下，键盘的输入都是命令</p><p>插入模式和替换模式下（统称为编辑模式），输入的才是字符</p><h3 id="vi的常用命令"><a href="#vi的常用命令" class="headerlink" title="vi的常用命令"></a>vi的常用命令</h3><p>Esc 从编辑模式切换到命令行模式</p><p>i ：在光标所在位置前面开始插入</p><p>a：在光标所在位置的后面开始插入</p><p>o：在光标所在位置行的下面插入空白行</p><p>O：在光标所在位置行的上面插入空白行</p><p>I：在光标所在位置行的行首开始插入</p><p>A：在光标所在位置行的行末开始插入</p><p>命令行模式下，移动光标位置使用</p><p>K 上 J 下  h 左 I 右</p><p>Ctrl+u 向上翻半页</p><p>Ctrl+d 向下翻页</p><p>Ctrl+g 显示光标所在位置的行号和文件的总行数</p><p>nG 光标跳到文件的第n行行首</p><p>G 光标跳到文件的最后一行</p><p>:5 + 回车 光标跳到第5行</p><p>:n + 回车 光标跳到第n行</p><p>0 光标跳到当前行的行首</p><p>$ 光标跳到当前行的行尾</p><p>w 光标跳到下个单词的开头</p><p>b 光标跳到上个单词的开头</p><p>e 光标跳到本单词的词尾</p><p>x 每按一次，删除光标所在位置的一个字符</p><p>nx 删除光标所在位置开始的3个字符</p><p>dw 删除光标所在位置到本单词结尾的字符</p><p>D 删除本行光标所在位置后面全部的内容</p><p>dd 删除光标所在位置的一行</p><p>ndd 删除光标所在位置开始的3行</p><p>yy 将光标所在位置的一行复制到缓冲区</p><p>nyy 将光标所在位置的n行复制到缓冲区</p><p>p 将缓冲区里的内容粘贴到光标所在位置</p><p>r 替换光标所在位置的一个字符</p><p>R 从光标所在位置开始替换，直到按下Esc</p><p>cw 从光标所在的位置开始替换单词，直到按下Esc</p><p><strong>u 撤销命令</strong></p><p>J 把当前行的下一行接到当前行的尾部</p><p>/abcd 在当前打开的文件中查找”abcd”文本内容</p><p>n 查找下一个</p><p>N 查找上一个</p><p>. 重复执行上一次执行的vi命令</p><p>~ 队光标所在位置的字符进行大小写转换。</p><p>:w 回车 存盘</p><p>:w! 回车 强制存盘</p><p>:wq 回车 存盘退出</p><p>:x 回车 存盘退出</p><p>:q 回车 不存盘退出</p><p>:q! 回车 不存盘强制退出</p><p>:g/aaaaaa/s//bbbbbb/g 回车 把文件中全部的aaaaaa替换成bbbbbb</p><p>Ctrl + insert 复制鼠标选中的文本，相当于Ctrl + c</p><p>Shift + insert 输出鼠标选中的文本，相当于Ctrl + v</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>随便记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux自学</title>
    <link href="/2021/09/30/Linux%E8%87%AA%E5%AD%A6/"/>
    <url>/2021/09/30/Linux%E8%87%AA%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h4 id="拷贝、粘贴"><a href="#拷贝、粘贴" class="headerlink" title="拷贝、粘贴"></a>拷贝、粘贴</h4><p>Ctrl + insert</p><p>Shift + insert</p><h4 id="重启-关机指令"><a href="#重启-关机指令" class="headerlink" title="重启/关机指令"></a>重启/关机指令</h4><ul><li><p>重启</p><p>init 6  或  reboot</p></li><li><p>关机</p><p>init 0  或  halt</p></li></ul><h4 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h4><p>清除屏幕上显示的内容</p><p>clear</p><h4 id="查看当前服务器的ip地址"><a href="#查看当前服务器的ip地址" class="headerlink" title="查看当前服务器的ip地址"></a>查看当前服务器的ip地址</h4><p>ip addr</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210930001616664.png" alt="image-20210930001616664" style="zoom: 33%;"><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><ul><li><p>查看时间</p><p>date</p></li><li><p>设置时区为中国上海时间</p><p>cp /usr/share/zoneinfo/Asia/Shanghai  /etc/locatime</p></li><li><p>设置时间</p><p>date -s”2020-01-02 12:35:28”</p></li></ul><h4 id="Linux的目录和文件"><a href="#Linux的目录和文件" class="headerlink" title="Linux的目录和文件"></a>Linux的目录和文件</h4><p>与Window的磁盘分区不同，Linux的文件系统更像一棵树，树枝是子目录，树枝后面还有树枝（子目录中还有子目录），树枝最后是树叶，目录的最后是文件。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210930002015768.png" alt="image-20210930002015768" style="zoom: 33%;"><p>严格的讲：文件名是由目录+文件名组成</p><p>以一个文件/usr/etc/readme.txt为例</p><ol><li>全路径文件名（绝对路径文件名），包含了完整的目录名和文件名，即/usr/etc/readme.txt</li><li>readme.txt是文件名，它在/usr/etc目录中</li><li>目录和文件的绝对路径是从根（/）算起，任何时候都没有歧义</li><li>登录Linux后，一定处在目录树的某个目录中，这个目录称之为当前工作目录，简称当前目录</li><li>目录和文件的相对路径是从当前工作目录算起，如果当前工作目录是/usr，etc/readme.txt等同于/usr/etc/readme.txt；如过当前工作目录是/usr/etc，readme.txt等同于/usr/etc/readme.txt</li><li>用Linux的命令操作目录和文件的时候，采用绝对路径和相对路径都可以。</li><li>一个圆点，表示当前工作目录</li><li>两个圆点，表示当前工作目录的上一级目录</li></ol><p>日常操作中，绝对路径和相对路径会同时使用，但是程序员在编写的程序中极少使用相对路径。</p><h4 id="查看当前工作目录"><a href="#查看当前工作目录" class="headerlink" title="查看当前工作目录"></a>查看当前工作目录</h4><p>pwd</p><h4 id="改变当前工作目录"><a href="#改变当前工作目录" class="headerlink" title="改变当前工作目录"></a>改变当前工作目录</h4><p>cd 目录名</p><ul><li><p>进入/tmp目录</p><p>cd /tmp</p></li><li><p>进入上一级目录</p><p>cd ..</p></li><li><p>进入用户的主目录</p><p>cd /</p></li></ul><h4 id="列出目录和文件信息"><a href="#列出目录和文件信息" class="headerlink" title="列出目录和文件信息"></a>列出目录和文件信息</h4><p>ls是list的缩写，通过ls命令不仅可以查看目录和文件信息，还可以目录和文件权限、大小、主人组等信息。</p><p>ls [-lt] 目录或文件名</p><ul><li>ls 列出当前目录下全部的目录和文件名信息</li><li>ls -l 列出当前工作目录下全部的目录和文件名信息</li><li>ls -lt按照时间降序，列出目录和文件的详细信息</li><li>ls /tmp 列出tmp目录下全部的目录和文件</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210930004520668.png" alt="image-20210930004520668" style="zoom:33%;"><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul><li>星号 “*” 匹配任意数量的字符</li><li>问号 “?” 匹配一个的字符</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210930004755975.png" alt="image-20210930004755975" style="zoom: 33%;"><p>比如说列出c目录下匹配 2*.cpp的目录和文件</p><p>ls /c/2*.cpp</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210930004839371.png" alt="image-20210930004839371" style="zoom:33%;"><p>列出c目录下匹配*.c的文件，按时间降序显示</p><p>ls /tmp/*.log</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210930004947894.png" alt="image-20210930004947894" style="zoom:33%;"><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><ul><li><p>在当前目录下创建test目录</p><p>mkdir test</p></li><li><p><strong>当前工作目录</strong>的<strong>test子目录</strong>下创建more目录</p><p>mkdir test/more</p></li><li><p>创建/tmp/test目录</p><p>mkdir /tmp/test</p></li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210930005706555.png" alt="image-20210930005706555" style="zoom:33%;"><h4 id="删除目录和文件"><a href="#删除目录和文件" class="headerlink" title="删除目录和文件"></a>删除目录和文件</h4><p>rm [-rf] 目录或者文件列表</p><p>选项 -r 可以删除目录，如果没有 -r 只能删除文件</p><p>选项 -f 表示强制删除，不需要确认</p><p>同样可以使用正则匹配</p><ul><li><p>删除当前工作目录下全部匹配*.c的文件</p><p>rm *.c</p></li><li><p>删除当前工作目录下全部匹配*.c的文件</p><p>rm -f *.log</p></li><li><p>删除/test/more目录和文件</p><p>rm -f /test/more</p></li><li><p>强制删除test目录下匹配20*的全部目录和文件</p><p>rm -rf /tmp/exp*</p></li><li><p>强制删除当前工作目录下的book和book.c文件</p><p>rm -rf book book.c</p></li></ul><h4 id="移动目录和文件"><a href="#移动目录和文件" class="headerlink" title="移动目录和文件"></a>移动目录和文件</h4><p>mv 旧目录或文件名 新目录或文件名</p><p>如果第二个参数是已存在的目录，则将第一个参数（旧目录或者文件名）移动到该目录中</p><ul><li><p>把当前工作目录中的book.c文件重命名为book1.c</p><p>mv book.c book1.c</p></li><li><p>如果/test/more是一个已存在的目录，以下命令将把当前工作目录下的book.c文件移动到/test/more目录中</p><p>mv book.c /test/more</p></li><li><p>如果/tmp/test3目录不存在，以下命令将把当前工作目录下的book.c文件改名为/tmp/test3</p><p>mv book.c /tmp/test3</p></li></ul><h4 id="复制目录和文件"><a href="#复制目录和文件" class="headerlink" title="复制目录和文件"></a>复制目录和文件</h4><p>cp [-r] 旧目录或文件名 新目录或文件名</p><p>选项-r可以复制目录，如果没有选项-r只能复制文件</p><ul><li><p>把当前工作目录下的book1.c文件复制为book2.c</p><p>cp book1.c book2.c</p></li><li><p>把当前工作目录下的aaa目录复制为bbb</p><p>cp -r aaa bbb</p></li><li><p>把当前工作目录下的book1.c文件复制为/tmp/book1.c</p><p>cp book1.c /tmp/book1.c</p><p>cp book1.c /tmp/.</p></li><li><p>把当前工作目录下的aaa目录复制为/tmp/aaa</p><p>cp -r aaa /tmp/aaa</p><p>cp -r aaa /tmp/.</p></li></ul><h4 id="打包压缩和解包解压"><a href="#打包压缩和解包解压" class="headerlink" title="打包压缩和解包解压"></a>打包压缩和解包解压</h4><p>tar命令用于打包压缩和解包压缩文件，类似windows的winrar工具</p><p>打包压缩的语法</p><p>tar zcvf 压缩包文件名 目录或文件名列表</p><ul><li><p>把当前工作目录的aaa、bbb和ccc目录打包压缩成123.tgz文件</p><p>tar zcvf 123.tgz aaa bbb ccc</p></li><li><p>把/home/oracle/aaa、/home/oracle/bbb和/home/oracle/ccc目录打包压缩成/tmp/123.tgz文件。</p><p>tar zcvf /tmp/123.tgz /home/oracle/aaa /home/oracle/bbb /home/oracle/ccc</p></li></ul><p>解包解压的语法</p><p>tar zxvf 压缩包文件名</p><ul><li><p>把/tmp/123.tgz压缩包文件在当前工作目录下解压</p><p>tar zxvf/tmp/123.tgz</p></li><li><p>把/tmp/123.tgz压缩包文件在/tmp/aaa目录下解压</p><p>cd /tmp/aaa</p><p>tar zxvf /tmp/123.tgz</p></li></ul><blockquote><p>1）用tar命令打包和解包的目录和文件没有绝对路径的说法，都成了相对的，在包中相对的。</p><p>2）用tar命令打包的文件，用winrar可以解开。</p><p>3）在Linux系统中，还有其它的打包压缩和解包解压命令，例如zip/unzip和gzip/gunzip。</p></blockquote><h4 id="判断网络连通情况"><a href="#判断网络连通情况" class="headerlink" title="判断网络连通情况"></a>判断网络连通情况</h4><p>Window系统</p><p>ping -n 包的个数 ip地址或域名</p><p>Linux系统</p><p>ping -c 包的个数 ip地址或域名</p><p>ping用于确定本地主机是否能于另一台主机成功交换数据包，判断网络是否通畅</p><h4 id="显示文本文件的内容"><a href="#显示文本文件的内容" class="headerlink" title="显示文本文件的内容"></a>显示文本文件的内容</h4><ul><li><p>cat 显示整个文件的内容</p><p>cat 文件名</p></li><li><p>more</p><p>为了方便阅读，more命令分页显示文件的内容，按空格键下一页，b键上一页，q键退出</p></li><li><p>tail</p><p>tail -f 文件名</p><p>用于显示文本的最后几行，如果文件的内容有增加就实时刷新。</p><p>程序员tail -f及其重要，可以动态显示后台服务程序的日志，用于调试和跟踪程序的运行。</p></li></ul><h4 id="搜索文件中的内容"><a href="#搜索文件中的内容" class="headerlink" title="搜索文件中的内容"></a>搜索文件中的内容</h4><p>grep “内容” 文件名</p><p>如果内容中没有空格等特殊字符，可以不用双引号括起来。</p><h4 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h4><p>find 目录名 -name 文件名 -print</p><p>目录名：待搜索的目录，搜索文件的时候，除了这个目录名，还包括它的各级子目录</p><p>文件名：待搜索的文件名匹配的规则。</p><p>1）从/tmp目录开始搜索，把全部的*.c文件显示出来。</p><p>find /tmp -name *.c -print</p><p>2）从当前工作目录开始搜索，把全部的*.c文件显示出来。</p><p>find . -name *.c -print</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>随便记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++编程整理</title>
    <link href="/2021/09/30/C++%E5%89%91%E6%8C%87offer1/"/>
    <url>/2021/09/30/C++%E5%89%91%E6%8C%87offer1/</url>
    
    <content type="html"><![CDATA[<h5 id="剑指offer-09-用两个栈实现队列"><a href="#剑指offer-09-用两个栈实现队列" class="headerlink" title="剑指offer 09 用两个栈实现队列"></a>剑指offer 09 用两个栈实现队列</h5><p>用两个栈实现队列，则将一个栈用来添加数据，另一个栈用来删除数据，</p><p>添加节点，只需要向in栈中push，</p><p>当删除节点时，若out栈中无元素，则将in栈中的所有结点依序弹入out栈，再删除out栈中的第一个结点，若out栈中有元素，则直接将out栈顶元素弹出。当in栈和out栈都为空时，则无元素，返回-1</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; in_st;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; out_st;<br><span class="hljs-keyword">public</span>:<br>    CQueue() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        in_st.push(value);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (out_st.empty()) &#123;<br>            <span class="hljs-keyword">if</span> (in_st.empty()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!in_st.empty()) &#123;<br>                <span class="hljs-keyword">int</span> tmp = in_st.top();<br>                in_st.pop();<br>                out_st.push(tmp);<br>            &#125;            <br>        &#125;<br>        <span class="hljs-keyword">int</span> res = out_st.top();<br>        out_st.pop();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue* obj = new CQueue();</span><br><span class="hljs-comment"> * obj-&gt;appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-30-包含min函数的栈"><a href="#剑指offer-30-包含min函数的栈" class="headerlink" title="剑指offer 30 包含min函数的栈"></a>剑指offer 30 包含min函数的栈</h5><p>设置一个专门存放最小值的栈，另一个是常规栈，只有每次入栈的元素小于最小栈的栈顶元素时，就将此元素入最小值栈，这样最小值栈的栈顶一定是当前常规栈中的最小元素。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; min_st;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    MinStack() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        st.push(x);<br>        <span class="hljs-keyword">if</span> (min_st.empty() || min_st.top() &gt;= x) &#123;<br>            min_st.push(x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (min_st.top() == st.top()) &#123;<br>            min_st.pop();<br>        &#125;<br>        st.pop();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.top();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_st.top();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;min();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-06-从尾到头打印链表"><a href="#剑指offer-06-从尾到头打印链表" class="headerlink" title="剑指offer 06 从尾到头打印链表"></a>剑指offer 06 从尾到头打印链表</h5><p>本来想直接遍历存入vector，最后再reverse，但是这道题用意是考察栈的应用，因此使用栈。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            st.push(head-&gt;val);<br>            head = head-&gt;next;<br>        &#125;<br><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            res.push_back(st.top());<br>            st.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-24-反转链表"><a href="#剑指offer-24-反转链表" class="headerlink" title="剑指offer 24 反转链表"></a>剑指offer 24 反转链表</h5><p>迭代做法</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode * prev = <span class="hljs-literal">nullptr</span>;<br>        ListNode * curr = head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode *next = curr-&gt;next;<br>            curr-&gt;next = prev;<br>            prev = curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>递归</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode * new_head = reverseList(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> new_head;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-35-复杂链表的复制"><a href="#剑指offer-35-复杂链表的复制" class="headerlink" title="剑指offer 35 复杂链表的复制"></a>剑指offer 35 复杂链表的复制</h5><p>使用哈希表保存已经初始化过的结点</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">unordered_map</span>&lt;Node*, Node*&gt; mp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!mp.count(head)) &#123;<br>            Node* newNode = <span class="hljs-keyword">new</span> Node(head-&gt;val);<br>            mp[head] = newNode;<br>            newNode-&gt;next = copyRandomList(head-&gt;next);<br>            newNode-&gt;random = copyRandomList(head-&gt;random);<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> mp[head];<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer 05 替换空格"></a>剑指offer 05 替换空格</h5><p>原地修改即可，找足够大的新数组方法浪费空间。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> length = s.size();<br>        s.resize(s.size() + count * <span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = length<span class="hljs-number">-1</span>, j = s.size()<span class="hljs-number">-1</span>; i &lt; j; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                s[j] = s[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                s[j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                s[j<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                s[j<span class="hljs-number">-2</span>] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                j -= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-58-左旋转字符串"><a href="#剑指offer-58-左旋转字符串" class="headerlink" title="剑指offer 58 左旋转字符串"></a>剑指offer 58 左旋转字符串</h5><p>翻转再翻转</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin, j = end; i &lt;= j; i++, j--) &#123;<br>            swap(s[i], s[j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        reverse(s, <span class="hljs-number">0</span>, s.size()<span class="hljs-number">-1</span>);<br>        reverse(s, <span class="hljs-number">0</span>, s.size()<span class="hljs-number">-1</span>-n);<br>        reverse(s, s.size()-n, s.size()<span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-03-数组中重复的数字"><a href="#剑指offer-03-数组中重复的数字" class="headerlink" title="剑指offer 03 数组中重复的数字"></a>剑指offer 03 数组中重复的数字</h5><p>哈希表很简单</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (mp.count(num)) &#123;<br>                <span class="hljs-keyword">return</span> num;<br>            &#125;<br>            mp[num]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-053-在排序数组中查找数字"><a href="#剑指offer-053-在排序数组中查找数字" class="headerlink" title="剑指offer 053 在排序数组中查找数字"></a>剑指offer 053 在排序数组中查找数字</h5><p>由于是排序好的数组，因此考虑使用二分查找法</p><p>当二分查找到target后，再左右遍历即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.empty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> mid;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = left - (left-right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            res++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid+<span class="hljs-number">1</span>; i &lt; nums.size() &amp;&amp; nums[i] == target; i++) &#123;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] == target; i--) &#123;<br>            res++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-053-0-n-1中缺失的数字"><a href="#剑指offer-053-0-n-1中缺失的数字" class="headerlink" title="剑指offer 053 0~n-1中缺失的数字"></a>剑指offer 053 0~n-1中缺失的数字</h5><p>二分查找法，返回left，很巧妙</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        if (nums.size() == 1) &#123;</span><br><span class="hljs-comment">            return nums[0] == 0 ? 1 : 0;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        if (nums.back() == nums.size()-1) &#123;</span><br><span class="hljs-comment">            return nums.size();</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left - (left - right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == mid) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[mid] == mid + <span class="hljs-number">1</span>) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  left;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-04-二维数组中的查找"><a href="#剑指offer-04-二维数组中的查找" class="headerlink" title="剑指offer 04 二维数组中的查找"></a>剑指offer 04 二维数组中的查找</h5><p>当然不能采用暴力，可以考虑线性查找</p><p>从右上角开始，当前元素小于查找元素，则向下移动，大于则向左移动</p><p>一定能查到查找元素</p><p>若没有则返回false</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (matrix.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>,col = matrix[<span class="hljs-number">0</span>].size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (row &lt; matrix.size() &amp;&amp; col &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[row][col] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target) &#123;<br>                col--;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                row++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-11-旋转数组的最小数字"><a href="#剑指offer-11-旋转数组的最小数字" class="headerlink" title="剑指offer 11 旋转数组的最小数字"></a>剑指offer 11 旋转数组的最小数字</h5><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/">旋转数组的最小数字 - 旋转数组的最小数字 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = numbers.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mid;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = left - (left - right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &lt; numbers[right])&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[left];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-50-第一个只出现一次的字符"><a href="#剑指offer-50-第一个只出现一次的字符" class="headerlink" title="剑指offer 50 第一个只出现一次的字符"></a>剑指offer 50 第一个只出现一次的字符</h5><p>使用队列，保存的是字符的先后出现次序，</p><p>使用哈希表，记录每个元素出现的次数</p><p>如果队列不为空，则看队列头的元素是否只出现一次，若出现一次，则返回这个队头元素</p><p>若出现大于一次，则将当前队头元素pop</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">char</span>&gt; que;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s) &#123;<br>            mp[c]++;<br>            que.push(c);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>            <span class="hljs-keyword">if</span> (mp[que.front()] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> que.front(); <br>            &#125;<br>            que.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>剑指offer32 从上到下打印二叉树</p><p>第一个是层序遍历即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        que.push(root);<br>        <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>            <span class="hljs-keyword">int</span> length = que.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>                TreeNode* node = que.front();<br>                que.pop();<br>                result.push_back(node-&gt;val);<br>                <br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    que.push(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    que.push(node-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>第二个同样是层序遍历，只不过需要修改答案保存方式</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> cur_lay = <span class="hljs-number">0</span>;<br>        que.push(root);<br>        <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>            <span class="hljs-keyword">int</span> length = que.size();<br>            res.push_back(&#123;&#125;);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>                TreeNode * node = que.front();<br>                que.pop();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    que.push(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    que.push(node-&gt;right);<br>                &#125;<br>                res[cur_lay].push_back(node-&gt;val);<br>            &#125;<br>            cur_lay++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>第三种根据奇偶，打印顺序不同</p><p>第一种想法是采用普通的层序遍历，根据层号进行reverse操作</p><p>可以采用双栈的操作，根据奇偶行，存储顺序不同</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st_odd, st_even;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        st_odd.push(root);<br>        <span class="hljs-keyword">while</span> (!st_odd.empty() || !st_even.empty()) &#123;<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>            <span class="hljs-keyword">if</span> (!st_odd.empty()) &#123;<br>                <span class="hljs-keyword">int</span> length = st_odd.size();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>                    TreeNode* node = st_odd.top();<br>                    tmp.push_back(node-&gt;val);<br>                    st_odd.pop();<br>                    <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                        st_even.push(node-&gt;left);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                        st_even.push(node-&gt;right);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">int</span> length = st_even.size();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>                    TreeNode* node = st_even.top();<br>                    tmp.push_back(node-&gt;val);<br>                    st_even.pop();<br>                    <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                        st_odd.push(node-&gt;right);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                        st_odd.push(node-&gt;left);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            res.push_back(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="26-树的子结构-27-二叉树的镜像-28-对称的二叉树"><a href="#26-树的子结构-27-二叉树的镜像-28-对称的二叉树" class="headerlink" title="26 树的子结构  27 二叉树的镜像  28 对称的二叉树"></a>26 树的子结构  27 二叉树的镜像  28 对称的二叉树</h5><p>参考文章，感谢</p><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">一篇文章带你吃透对称性递归(思路分析+解题模板+案例解读) - 树的子结构 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasSubStructure</span><span class="hljs-params">(TreeNode *A, TreeNode* B)</span> </span>&#123;<br>        <span class="hljs-comment">//只要B为nullptr，则一定为A的子结构</span><br>        <span class="hljs-keyword">if</span> (!B) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!A || A-&gt;val != B-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hasSubStructure(A-&gt;left, B-&gt;left) &amp;&amp; hasSubStructure(A-&gt;right, B-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!A || !B) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hasSubStructure(A, B) || hasSubStructure(A-&gt;left, B) || hasSubStructure(A-&gt;right, B);<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        TreeNode* left = mirrorTree(root-&gt;left);<br>        TreeNode* right = mirrorTree(root-&gt;right);<br>        root-&gt;left = right;<br>        root-&gt;right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isMirror(root, root);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMirror</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((root1 &amp;&amp; !root2) || (!root1 &amp;&amp; root2)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!root1 &amp;&amp; !root2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root1-&gt;val == root2-&gt;val &amp;&amp; isMirror(root1-&gt;left, root2-&gt;right) &amp;&amp; isMirror(root1-&gt;right, root2-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer10-斐波那契数列"><a href="#剑指offer10-斐波那契数列" class="headerlink" title="剑指offer10 斐波那契数列"></a>剑指offer10 斐波那契数列</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>, next = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            res = (pre + next) % <span class="hljs-number">1000000007</span>;<br>            pre = next;<br>            next = res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-10-青蛙跳台阶问题"><a href="#剑指offer-10-青蛙跳台阶问题" class="headerlink" title="剑指offer 10 青蛙跳台阶问题"></a>剑指offer 10 青蛙跳台阶问题</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> prev = <span class="hljs-number">1</span>, next = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            res = (prev + next) % <span class="hljs-number">1000000007</span>;<br>            prev = next;<br>            next = res;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-63-股票的最大利润"><a href="#剑指offer-63-股票的最大利润" class="headerlink" title="剑指offer 63 股票的最大利润"></a>剑指offer 63 股票的最大利润</h5><p>可以使用动态规划，使用一个数组保存当天天数的最大利润，</p><p>但是也可以优化，用两个变量，即可更新全部信息</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cur_min = INT_MAX;<br>        <span class="hljs-keyword">int</span> max_pro = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> price : prices) &#123;<br>            cur_min = min(cur_min, price);<br>            max_pro = max(max_pro, price - cur_min);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_pro;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-042连续子数组的最大和"><a href="#剑指offer-042连续子数组的最大和" class="headerlink" title="剑指offer 042连续子数组的最大和"></a>剑指offer 042连续子数组的最大和</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> * dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.size()];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i<span class="hljs-number">-1</span>] + nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i] = nums[i];<br>            &#125;<br>            res = max(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-47-礼物的最大价值"><a href="#剑指offer-47-礼物的最大价值" class="headerlink" title="剑指offer 47 礼物的最大价值"></a>剑指offer 47 礼物的最大价值</h5><p>动态规划的常规思想</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res(grid.size(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(grid[<span class="hljs-number">0</span>].size()));<br>        <span class="hljs-keyword">int</span> max_val = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; grid.size(); i++) &#123;<br>            res[i][<span class="hljs-number">0</span>] = res[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];    <br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; grid[<span class="hljs-number">0</span>].size(); i++) &#123;   <br>            res[<span class="hljs-number">0</span>][i] = res[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>] + grid[<span class="hljs-number">0</span>][i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; grid.size(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].size(); j++) &#123;<br>                res[i][j] = max(res[i<span class="hljs-number">-1</span>][j], res[i][j<span class="hljs-number">-1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res[grid.size()<span class="hljs-number">-1</span>][grid[<span class="hljs-number">0</span>].size()<span class="hljs-number">-1</span>];<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-46-把数字翻译成字符串"><a href="#剑指offer-46-把数字翻译成字符串" class="headerlink" title="剑指offer 46 把数字翻译成字符串"></a>剑指offer 46 把数字翻译成字符串</h5><p>同样是找规律。判断出新增字符是否可以与前一个字符组成一个新字符。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num/<span class="hljs-number">10</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">string</span> s = to_string(num);<br>        <span class="hljs-keyword">int</span> *dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.size()];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;1&#x27;</span> || (s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp; s[<span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;5&#x27;</span>)) &#123;<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; s.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;1&#x27;</span> ||  (s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;5&#x27;</span>)) &#123;<br>                dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i] = dp[i<span class="hljs-number">-1</span>];<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.size()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-48-最长不含重复字符的子字符串"><a href="#剑指offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指offer 48 最长不含重复字符的子字符串"></a>剑指offer 48 最长不含重复字符的子字符串</h5><p>可以使用滑动窗口，这里使用了动态规划</p><p>需要看下一个要添加的字符是否已经在哈希表种，如果在，则dp[i]的值取决于dp[i-1]与i-j的大小</p><p>否则dp[i] = dp[i-1] + 1</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size())</span></span>;<br>        <span class="hljs-keyword">if</span> (dp.empty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        mp[s[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> res = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp.count(s[i])) &#123;<br>                <span class="hljs-keyword">int</span> j = mp[s[i]]<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span> (dp[i<span class="hljs-number">-1</span>] &lt; i-j) &#123;<br>                    dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i] = i-j;<br>                &#125;<br>                mp[s[i]] = i + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mp[s[i]] = i+<span class="hljs-number">1</span>;<br>                dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br><br>            res = max(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-18-删除链表的节点"><a href="#剑指offer-18-删除链表的节点" class="headerlink" title="剑指offer 18 删除链表的节点"></a>剑指offer 18 删除链表的节点</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br><br>        ListNode* pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);<br>        ListNode* res = pre;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur-&gt;val != val) &#123;<br>            cur = cur-&gt;next;<br>            pre = pre-&gt;next;<br>        &#125;<br>        pre-&gt;next = cur-&gt;next;<br><br>        <span class="hljs-keyword">return</span> res-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-22-链表中倒数第k个节点"><a href="#剑指offer-22-链表中倒数第k个节点" class="headerlink" title="剑指offer 22 链表中倒数第k个节点"></a>剑指offer 22 链表中倒数第k个节点</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);<br>        ListNode* tmp = head;<br>        <span class="hljs-keyword">while</span> (k--) &#123;<br>            tmp = tmp-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (tmp) &#123;<br>            tmp = tmp-&gt;next;<br>            dummy = dummy-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指offer 21 调整数组顺序使奇数位于偶数前面"></a>剑指offer 21 调整数组顺序使奇数位于偶数前面</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (i&lt;j &amp;&amp; (nums[i]%<span class="hljs-number">2</span>)) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i&lt;j &amp;&amp; !(nums[j]%<span class="hljs-number">2</span>)) &#123;<br>                j--;<br>            &#125;<br>            swap(nums[i++],nums[j--]);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-057-和为s的两个数字"><a href="#剑指offer-057-和为s的两个数字" class="headerlink" title="剑指offer 057 和为s的两个数字"></a>剑指offer 057 和为s的两个数字</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (left &lt; right &amp;&amp; nums[left] + nums[right] &lt; target) &#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left &lt; right &amp;&amp; nums[left] + nums[right] &gt; target) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> &#123;nums[left], nums[right]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-12-矩阵中的路径"><a href="#剑指offer-12-矩阵中的路径" class="headerlink" title="剑指offer 12 矩阵中的路径"></a>剑指offer 12 矩阵中的路径</h5><p>典型的矩阵搜索问题，使用深度优先搜索DFS和剪枝解决。</p><p>深度优先搜索的思想是暴力遍历矩阵中所有字符串的可能性，通过递归，向一个方向搜索到底，再回溯到上一个节点。</p><p>剪枝用于提高效率，当一个方向当前字符与字符串不匹配的时候，则立即返回false</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> rows, cols;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-built_in">string</span> word, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= rows || j &lt; <span class="hljs-number">0</span> || j &gt;= cols || board[i][j] != word[k]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == word.size()<span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        board[i][j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">bool</span> res = dfs(board, word, i+<span class="hljs-number">1</span>, j, k+<span class="hljs-number">1</span>) || dfs(board, word, i<span class="hljs-number">-1</span>, j, k+<span class="hljs-number">1</span>) || dfs(board, word, i, j+<span class="hljs-number">1</span>, k+<span class="hljs-number">1</span>) || dfs(board, word, i, j<span class="hljs-number">-1</span>, k+<span class="hljs-number">1</span>);<br>        board[i][j] = word[k];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-built_in">string</span> word)</span> </span>&#123;<br>        rows = board.size();<br>        cols = board[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dfs(board, word, i, j, <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-13-机器人的运动范围"><a href="#剑指offer-13-机器人的运动范围" class="headerlink" title="剑指offer 13 机器人的运动范围"></a>剑指offer 13 机器人的运动范围</h5><p>广度优先搜索</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num1) &#123;<br>            sum += num1%<span class="hljs-number">10</span>;<br>            num1 = num1/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (num2) &#123;<br>            sum += num2%<span class="hljs-number">10</span>;<br>            num2 = num2/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//设置标记数组，用于判断当前的点是否已经被访问过</span><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; visited(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">//用于存储可以符合条件的点</span><br>        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; que;<br>        <span class="hljs-comment">//方向数组</span><br>        <span class="hljs-keyword">int</span> dx[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">int</span> dy[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><br>        <span class="hljs-comment">//初始化</span><br>        que.push(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>; <span class="hljs-comment">//&#123;0,0&#125;这个点一定满足</span><br><br>        <span class="hljs-keyword">while</span> (!que.empty()) &#123;<br>            <span class="hljs-comment">//取出队头的符合条件的这个点，走这个点的下或者右</span><br>            <span class="hljs-keyword">auto</span> [x, y] = que.front();<br>            que.pop();<br>            <span class="hljs-comment">//走右边或者下面</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;=<span class="hljs-number">1</span>; i++) &#123;<br>                <span class="hljs-keyword">int</span> tx = x + dx[i];<br>                <span class="hljs-keyword">int</span> ty = y + dy[i];<br>                <span class="hljs-comment">//边界判断，同时该点不可以被访问，并且要符合k的条件</span><br>                <span class="hljs-keyword">if</span> (tx &lt; <span class="hljs-number">0</span> || tx &gt;= m || ty &lt; <span class="hljs-number">0</span> || ty &gt;= n || visited[tx][ty] || getNum(tx, ty) &gt; k) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//符合条件且未被访问的点入队，标记为已被访问</span><br>                que.push(&#123;tx, ty&#125;);<br>                visited[tx][ty] = <span class="hljs-number">1</span>;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>深度优先搜索</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> rows;<br>    <span class="hljs-keyword">int</span> cols;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num1) &#123;<br>            sum += num1%<span class="hljs-number">10</span>;<br>            num1 = num1/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (num2) &#123;<br>            sum += num2%<span class="hljs-number">10</span>;<br>            num2 = num2/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;visited)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &gt;= rows || y &gt;= cols || visited[x][y] || getNum(x, y) &gt; k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        visited[x][y] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(x+<span class="hljs-number">1</span>, y, k, visited) + dfs(x, y+<span class="hljs-number">1</span>, k, visited);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        rows = m;<br>        cols = n;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; visited(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">//深度优先搜索</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k, visited);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-34-二叉树中和为某一值的路径"><a href="#剑指offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指offer 34 二叉树中和为某一值的路径"></a>剑指offer 34 二叉树中和为某一值的路径</h5><p>深度优先，回溯遍历</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; cur_path;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        target = target - root-&gt;val;<br>        cur_path.push_back(root-&gt;val);<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span> &amp;&amp; target == <span class="hljs-number">0</span>) &#123;<br>            res.push_back(cur_path);<br>        &#125;<br>        dfs(root-&gt;left, target);<br>        dfs(root-&gt;right, target);<br>        target += root-&gt;val;<br>        cur_path.pop_back();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="hljs-keyword">int</span> target) &#123;<br>        dfs(root, target);<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-36-二叉搜索树与双向链表"><a href="#剑指offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指offer 36 二叉搜索树与双向链表"></a>剑指offer 36 二叉搜索树与双向链表</h5><p>二叉搜索树的中序遍历</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = NULL;</span><br><span class="hljs-comment">        right = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;Node*&gt; res;<br>        <span class="hljs-built_in">stack</span>&lt;Node*&gt; st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        st.push(root);<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            Node* node = st.top();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.push(node-&gt;right);<br>                &#125;<br>                st.push(node);<br>                st.push(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.push(node-&gt;left);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.pop();<br>                node = st.top();<br>                res.push_back(node);<br>                st.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> length = res.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            res[(i+length)%length]-&gt;right =  res[(i+<span class="hljs-number">1</span>+length)%length];<br>            res[(i+length)%length]-&gt;left = res[(i<span class="hljs-number">-1</span>+length)%length];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-54-二叉搜索树的第k大节点"><a href="#剑指offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指offer 54 二叉搜索树的第k大节点"></a>剑指offer 54 二叉搜索树的第k大节点</h5><p>中序遍历即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <br>        st.push(root);<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>            TreeNode* node = st.top();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.pop();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.push(node-&gt;left);<br>                &#125;<br>                st.push(node);<br>                st.push(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.push(node-&gt;right);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.pop();<br>                node = st.top();<br>                st.pop();<br>                res.push_back(node-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-45-把数组排成最小的数"><a href="#剑指offer-45-把数组排成最小的数" class="headerlink" title="剑指offer 45 把数组排成最小的数"></a>剑指offer 45 把数组排成最小的数</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;strs;<br>        <span class="hljs-built_in">string</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i ++)&#123;<br>            strs.push_back(to_string(nums[i]));<br>        &#125;<br>        sort(strs.begin(), strs.end(), [](<span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">string</span>&amp; s2)&#123;<span class="hljs-keyword">return</span> s1 + s2 &lt; s2 + s1;&#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.size(); i ++)<br>            ans += strs[i];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-40-最小的k个数"><a href="#剑指offer-40-最小的k个数" class="headerlink" title="剑指offer 40 最小的k个数"></a>剑指offer 40 最小的k个数</h5><p>练习了一下快排</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ran = (rand()%(right-left+<span class="hljs-number">1</span>)) + left;<br>        swap(nums[left], nums[ran]);<br>        <span class="hljs-keyword">int</span> base = nums[left];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= base) &#123;<br>                right--;<br>            &#125;<br>            nums[left] = nums[right];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt; base) &#123;<br>                left++;<br>            &#125; <br>            nums[right] = nums[left];<br>        &#125;<br>        nums[left] = base;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> base = partition(nums, left, right);<br>            quickSort(nums, left, base<span class="hljs-number">-1</span>);<br>            quickSort(nums, base+<span class="hljs-number">1</span>, right);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        srand((<span class="hljs-keyword">int</span>)time(<span class="hljs-number">0</span>));<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(k, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = arr.size()<span class="hljs-number">-1</span>;<br>        quickSort(arr, left, right);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            vec[i] = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> vec;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-41-数据流中的中位数"><a href="#剑指offer-41-数据流中的中位数" class="headerlink" title="剑指offer 41  数据流中的中位数"></a>剑指offer 41  数据流中的中位数</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//大顶堆，里面存的是小一半的数，堆顶为左一半的最大值</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, less&lt;<span class="hljs-keyword">int</span>&gt;&gt; maxHeap;<br>    <span class="hljs-comment">//小顶堆，里面存的是大一半的数，堆顶为右一半的最大值</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; minHeap;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    MedianFinder() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (maxHeap.size() == minHeap.size()) &#123;<br>            minHeap.push(num);<br>            <span class="hljs-keyword">int</span> top = minHeap.top();<br>            minHeap.pop();<br>            maxHeap.push(top);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            maxHeap.push(num);<br>            <span class="hljs-keyword">int</span> top = maxHeap.top();<br>            maxHeap.pop();<br>            minHeap.push(top);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (maxHeap.size() == minHeap.size()) &#123;<br>            <span class="hljs-keyword">return</span> (minHeap.top() + maxHeap.top())*<span class="hljs-number">1.0</span>/<span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> maxHeap.top()*<span class="hljs-number">1.0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MedianFinder* obj = new MedianFinder();</span><br><span class="hljs-comment"> * obj-&gt;addNum(num);</span><br><span class="hljs-comment"> * double param_2 = obj-&gt;findMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-55-二叉树的深度"><a href="#剑指offer-55-二叉树的深度" class="headerlink" title="剑指offer 55 二叉树的深度"></a>剑指offer 55 二叉树的深度</h5><p>递归，没必要层序遍历记录深度</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-55-平衡二叉树"><a href="#剑指offer-55-平衡二叉树" class="headerlink" title="剑指offer 55 平衡二叉树"></a>剑指offer 55 平衡二叉树</h5><p>比较当前节点的左右子树最大深度是否小于1，再递归判断自己的左右子树是否为平衡二叉树</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(getHeight(root-&gt;left), getHeight(root-&gt;right));<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">abs</span>(getHeight(root-&gt;left) - getHeight(root-&gt;right)) &lt;= <span class="hljs-number">1</span>) &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-64-求1-2-…-n"><a href="#剑指offer-64-求1-2-…-n" class="headerlink" title="剑指offer 64 求1+2+…+n"></a>剑指offer 64 求1+2+…+n</h5><p>题目要求应该就是使用递归完成</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n + sumNums(n<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h5><p>遇见树不要轻易掉进递归陷阱，有的题即使不递归也可以简单完成，比如这道题</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        TreeNode * ancestor = root;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (ancestor-&gt;val &gt; p-&gt;val &amp;&amp; ancestor-&gt;val &gt; q-&gt;val) &#123;<br>                ancestor = ancestor-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ancestor-&gt;val &lt; p-&gt;val &amp;&amp; ancestor-&gt;val &lt; q-&gt;val) &#123;<br>                ancestor = ancestor-&gt;right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ancestor;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当然也可以递归</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);<br>        &#125; <br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-07-重建二叉树"><a href="#剑指offer-07-重建二叉树" class="headerlink" title="剑指offer 07 重建二叉树"></a>剑指offer 07 重建二叉树</h5><p>要了解二叉树的遍历形式，前序遍历是中左右，中序遍历是左中右</p><p>前序遍历的结果</p><p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</p><p>中序遍历的结果</p><p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p><p>因此思路是每次构造根节点，再左右递归构造左子树和右子树，根据遍历的性质，当前前序遍历数组中第一个即left位置为根节点，找到中序遍历的根节点对应位置，则中序遍历根节点左边长度为左子树节点数，右边长度为右子树节点数，</p><p>根据找到的节点数，我们就可以向递归传入左子树的前序遍历结果+左子树的中序遍历结果，右子树同理，递归即可完成</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-keyword">int</span> preleft, <span class="hljs-keyword">int</span> preright, <span class="hljs-keyword">int</span> inleft, <span class="hljs-keyword">int</span> inright)</span> </span>&#123;<br>        <span class="hljs-comment">//这种情况即为不存在左右子树</span><br>        <span class="hljs-keyword">if</span> (preleft &gt; preright) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-comment">//preorder[preleft]为当前树的根节点，root_pos为中序遍历中根节点的位置。</span><br>        <span class="hljs-keyword">int</span> root_pos = mp[preorder[preleft]];<br>        TreeNode* node = <span class="hljs-keyword">new</span> TreeNode(preorder[preleft]);<br>        <span class="hljs-comment">//根据中序遍历中根节点的位置可以得到当前节点左子树的大小</span><br>        <span class="hljs-keyword">int</span> size_leftTree = root_pos - inleft;<br>        <span class="hljs-comment">//递归调用左子树</span><br>        <span class="hljs-comment">//后面四个参数，为新一轮递归的位置了。</span><br>        node-&gt;left = build(preorder, inorder, preleft+<span class="hljs-number">1</span>, preleft+size_leftTree, inleft, root_pos<span class="hljs-number">-1</span>);<br>        node-&gt;right = build(preorder, inorder, preleft+size_leftTree+<span class="hljs-number">1</span>, preright, root_pos+<span class="hljs-number">1</span>, inright);<br><br>        <span class="hljs-keyword">return</span> node;<br><br>        <br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = preorder.size();<br>        <span class="hljs-comment">//为方便定位前序遍历的节点在中序遍历中的位置，使用哈希表存储中序遍历各节点位置。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            mp[inorder[i]] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> build(preorder, inorder, <span class="hljs-number">0</span>, length<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, length<span class="hljs-number">-1</span>); <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-16-数值的整数次方"><a href="#剑指offer-16-数值的整数次方" class="headerlink" title="剑指offer 16 数值的整数次方"></a>剑指offer 16 数值的整数次方</h5><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">double</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> p = n;<br>        <span class="hljs-keyword">if</span> (p &lt; <span class="hljs-number">0</span>) &#123;<br>            x = <span class="hljs-number">1</span>/x;<br>            p = -p;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>) &#123;<br>                ans *= x;<br>            &#125;<br>            p &gt;&gt;= <span class="hljs-number">1</span>;<br>            x *= x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-33-二叉搜索树的后序遍历序列"><a href="#剑指offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指offer 33 二叉搜索树的后序遍历序列"></a>剑指offer 33 二叉搜索树的后序遍历序列</h5><p>后续遍历的结果是</p><p>[ [左子树的前序遍历结果], [右子树的前序遍历结果] ,根节点]</p><p>由于是二叉搜索树，因此左子树的所有节点值都比根节点小，右子树的所有结点值都比根节点大</p><p>判断是否为后序遍历，可以判断其所有子树是否为二叉搜索后序遍历。</p><p>因此根据与根节点的比较，可以得到一个数组中左子树的结束位置，同样可以得到右子树的，递归遍历即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; postorder, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = left;<br>        <span class="hljs-keyword">while</span> (postorder[i] &lt; postorder[right]) &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> leftend = i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (postorder[i] &gt; postorder[right]) &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i==right &amp;&amp; judge(postorder, left, leftend) &amp;&amp; judge(postorder, leftend+<span class="hljs-number">1</span>, right<span class="hljs-number">-1</span>);<br><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> judge(postorder, <span class="hljs-number">0</span>, postorder.size()<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-15-二进制中1的个数"><a href="#剑指offer-15-二进制中1的个数" class="headerlink" title="剑指offer 15 二进制中1的个数"></a>剑指offer 15 二进制中1的个数</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>                res++;<br>            &#125;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offe-65-不用加减乘除做加法"><a href="#剑指offe-65-不用加减乘除做加法" class="headerlink" title="剑指offe 65 不用加减乘除做加法"></a>剑指offe 65 不用加减乘除做加法</h5><p>思想是每轮求本位和进位，更新相加的a为这轮得到的本位，b为这轮得到的进位，下一轮ab再相加，得到新的本位和进位，一直加到进位为0时，就得到结果</p><p>进位需要&lt;&lt; ，将数据类型强制转为unsigned</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (b) &#123;<br>            <span class="hljs-keyword">int</span> carry = a &amp; b;  <span class="hljs-comment">//所有进位</span><br>            a = a ^ b;          <span class="hljs-comment">//所有当前位</span><br><br>            b = (<span class="hljs-keyword">unsigned</span>)carry &lt;&lt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-56-数组中数字出现的次数"><a href="#剑指offer-56-数组中数字出现的次数" class="headerlink" title="剑指offer 56 数组中数字出现的次数"></a>剑指offer 56 数组中数字出现的次数</h5><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-by-leetcode/">Loading Question… - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">singleNumbers</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            ret ^= num;<br>        &#125;<br>        <span class="hljs-keyword">int</span> m = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!(m &amp; ret)) &#123;<br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res1 = <span class="hljs-number">0</span>, res2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num &amp; m) &#123;<br>                res1 ^= num;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res2 ^= num;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> &#123;res1, res2&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-56-数组中数字出现的次数-1"><a href="#剑指offer-56-数组中数字出现的次数-1" class="headerlink" title="剑指offer 56 数组中数字出现的次数"></a>剑指offer 56 数组中数字出现的次数</h5><p>余三，巧妙的方法</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> tmp_tool = <span class="hljs-number">1</span> &lt;&lt; i;<br>            <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>                tmp += (num &amp; tmp_tool) &gt;&gt; i;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tmp%<span class="hljs-number">3</span>) &#123;<br>                ans += <span class="hljs-number">1</span> &lt;&lt; i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-39-数组中出现次数超过一半的数字"><a href="#剑指offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指offer 39 数组中出现次数超过一半的数字"></a>剑指offer 39 数组中出现次数超过一半的数字</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            mp[num]++;<br>            <span class="hljs-keyword">if</span> (mp[num] &gt; max) &#123;<br>                max = mp[num];<br>                res = num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h5 id="剑指offer-66-构建乘积数组"><a href="#剑指offer-66-构建乘积数组" class="headerlink" title="剑指offer 66 构建乘积数组"></a>剑指offer 66 构建乘积数组</h5><p>很奇妙的方法，算是动态规划吧</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220311201552797.png" style="zoom: 33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20220311201654778.png" alt="image-20220311201654778" style="zoom: 33%;"><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">constructArr</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = a.size();<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(length, <span class="hljs-number">1</span>)</span></span>;<br>        b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            b[i] = b[i<span class="hljs-number">-1</span>] * a[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = length<span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            tmp *= a[i+<span class="hljs-number">1</span>];<br>            b[i] *= tmp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——文件操作</title>
    <link href="/2021/09/25/C++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/09/25/C++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>一般来说，文件可分为文本文件、视频文件、音频文件、图像文件、可执行文件等多种类别，这是从文件的功能进行分类的。</p><p>数据存储的角度上，所有文件的本质都一样，都是一个个字节组成，根本上都是0，1比特串。</p><p>文件格式是文件中的每一部分代表什么含义的一种约定，比如常见的纯文本文件(.txt)，指的是能够在Windows的“记事本程序”中打开，并且能看出来是一段有意义的文字的文件。文本文件的格式可以描述为：文件中每个字节都是一个可见字符的ASCII码。</p><p>图像、视频、可执行文件等一般被称作“二进制文件”，二进制文件如果用记事本打开就是一片乱码</p><p>实际上不管是文本文件还是二进制文件，都是二进制位组成，只是格式不同。</p><p>三个专门实现文件操作的类：</p><p>ifstream：专门从文件中读取数据</p><p>ofstream：专门用于向文件中写入数据</p><p>fstream：可读可写</p><blockquote><p>三个文件流都位于&lt;fstream&gt;头文件中，先引入。</p></blockquote><p>&lt;iostream&gt;头文件中定义有ostream和istream类的对象cin和cout，但是&lt;fstream&gt;头文件中没有可以直接使用的上述三类的对象，因此如果我们要使用这个类操作对象，要自己创建</p><p>因为计算机上文件众多，因此创建文件流对象的任务让用户完成。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210925180517116.png" alt="image-20210925180517116"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210925180535162.png" alt="image-20210925180535162"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210925180547135.png" alt="image-20210925180547135"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210925180555770.png" alt="image-20210925180555770"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *url = <span class="hljs-string">&quot;http://trentliu.cn/&quot;</span>;<br>    <br>    fstream fsl=;<br>    <br>    fs.open(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::out);<br>    <br>    fs.write(url,<span class="hljs-number">30</span>);<br>    fs.close();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行程序后，该文件的内容为</p><blockquote><p><a href="http://trentliu.cn/">http://trentliu.cn/</a></p></blockquote><p>不管文件操作要干什么，都要调用open()成员打开文件，同时操作文件结束后，必须调用close()成员方法关闭文件。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>文件操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——顺序容器</title>
    <link href="/2021/09/11/C++%E8%87%AA%E5%AD%A6%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <url>/2021/09/11/C++%E8%87%AA%E5%AD%A6%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><p>一个容器就是一些特定类型对象的集合</p><p>顺序容器为程序员提供了控制元素存储和访问顺序的能力。</p><p>这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</p><p>以下是一些顺序容器的类型</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210918195316626.png" alt="image-20210918195316626"></p><p>除了固定大小的array外，其他容器都提供高效、灵活的内存管理，我们可以添加和删除元素，扩张和收缩容器的大小。</p><p>关于底层实现导致的各种操作的效率问题，数据结构课程中已经系统学习。</p><h3 id="顺序容器的选择"><a href="#顺序容器的选择" class="headerlink" title="顺序容器的选择"></a>顺序容器的选择</h3><ul><li>除非有很好的理由选择其他容器，否则使用vector</li><li>如果程序有很多小元素，且空间的额外开销很重要，不要使用list或者forword_list，这两个容器的额外内存开销很大。</li><li>如果程序要求随机访问元素，则应使用vector或者deque</li><li>如果程序要求在容器中间插入或者删除元素，应该使用list或者forward_list</li><li>如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque</li><li>如果程序在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素<ul><li>可以很容易的向vector追加数据，然后再调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素。</li><li>如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector</li></ul></li></ul><p>一般来说，每个容器都定义在一个头文件中，文件名与类型名相同，即，deque定义在头文件deque中，list定义在头文件list中，以此类推。</p><p>容器均定义为模板类，例如对于vector，我们必须要提供额外信息来生成特定的容器类型，对大多数但不是所有容器，我们还需要额外提供元素信息。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">list</span>&lt;Sale_data&gt;  <span class="hljs-comment">//保存Sales_data对象的list</span><br><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">double</span>&gt;<span class="hljs-comment">//保存double的deque    </span><br></code></pre></div></td></tr></table></figure><h4 id="容器可以保存的元素类型的限制"><a href="#容器可以保存的元素类型的限制" class="headerlink" title="容器可以保存的元素类型的限制"></a>容器可以保存的元素类型的限制</h4><p>顺序容器几乎可以保存任意类型的元素，特别是我们可以定义一个容器，其容器类型是另一个容器，这种容器的定义与其他任何容器的类型完全一样，在尖括号中指定元素类型。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; lines;//<span class="hljs-built_in">vector</span>的<span class="hljs-built_in">vector</span><br></code></pre></div></td></tr></table></figure><p>此处lines是一个vector，其元素类型是string的vector</p><p>某些类型的有自己的特殊要求，比如有些类没有默认构造函数，我们定义一个保存这个类型对象的容器的时候，就不能只给容器一个元素数目参数，而是要给元素数目参数和初始值。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//假定noDefault是一个没有默认构造函数的类型</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;noDefault&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>,init)</span></span>;<span class="hljs-comment">//正确，提供了元素初始化器</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;noDefault&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//错误，必须提供一个元素初始化器</span><br></code></pre></div></td></tr></table></figure><h3 id="所有容器都提供的操作"><a href="#所有容器都提供的操作" class="headerlink" title="所有容器都提供的操作"></a>所有容器都提供的操作</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210918201511133.png" alt="image-20210918201511133" style="zoom:50%;"><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210918201530666.png" alt="image-20210918201530666" style="zoom:50%;"><h4 id="赋值与swap"><a href="#赋值与swap" class="headerlink" title="赋值与swap"></a>赋值与swap</h4><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210918201555118.png" alt="image-20210918201555118" style="zoom:50%;"><h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210918201616117.png" alt="image-20210918201616117" style="zoom:50%;"><h4 id="添加-删除元素（不适用于array）"><a href="#添加-删除元素（不适用于array）" class="headerlink" title="添加/删除元素（不适用于array）"></a>添加/删除元素（不适用于array）</h4><p>注：在不同容器中，这些操作的接口都不同</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210918201723700.png" alt="image-20210918201723700" style="zoom:50%;"><h4 id="获取迭代器"><a href="#获取迭代器" class="headerlink" title="获取迭代器"></a>获取迭代器</h4><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210918201806835.png" alt="image-20210918201806835" style="zoom:50%;"><h4 id="反向容器的额外成员（不支持forward-list）"><a href="#反向容器的额外成员（不支持forward-list）" class="headerlink" title="反向容器的额外成员（不支持forward_list）"></a>反向容器的额外成员（不支持forward_list）</h4><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210918201854382.png" alt="image-20210918201854382" style="zoom:50%;"><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器有着公共的接口，如果一个迭代器提供某种操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。</p><p>标准容器类型上的所有迭代器都允许我们访问容器中的元素，而所有迭代器都是通过解引用运算符来实现这个操作的</p><p>标准库容器的所有迭代器都定义了递增运算符，从当前元素移动到下一个元素。</p><h4 id="迭代器的通用操作"><a href="#迭代器的通用操作" class="headerlink" title="迭代器的通用操作"></a>迭代器的通用操作</h4><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210918202142784.png" alt="image-20210918202142784"></p><p>只有forward_list迭代器不支持递减运算符–。</p><p>以下运算只有string，vector，deque，array迭代器可以用。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210918202244817.png" alt="image-20210918202244817"></p><h4 id="迭代器范围"><a href="#迭代器范围" class="headerlink" title="迭代器范围"></a>迭代器范围</h4><p><strong>一个迭代器范围</strong>由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置。这两个迭代器通常被称为begin和end，或者first和last，它们标记了容器中元素的一个范围。</p><p>第二个迭代器被称为last或者end，但实际上它指向的是尾元素的下一个元素。</p><p>迭代器范围中的元素包含first所表示的元素以及从first开始直至last之间的所有元素。</p><p>这种元素区间被称为<strong>左闭合区间</strong></p><p>[begin, end)</p><p>迭代器begin和end必须指向相同的容器，end可以与begin指向相同的位置，但是不能指向begin之前的位置。</p><blockquote><p>begin与end指向同一个容器中的元素，或者是容器最后一个元素之后的位置</p><p>我们可以通过反复递增begin来到达end，换句话说，end不在begin之前。</p></blockquote><blockquote><p>编译器不会强制这些要求，确保程序符合这些约定是程序员的责任。</p></blockquote><p>使用这种左闭合有许多方便之处</p><ul><li>如果begin和end相等，则范围为空</li><li>如果begin和end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素</li><li>我们可以对begin递增若干次，使得begin=end</li></ul><p>可以通过迭代器来循环处理一个元素范围</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (begin != end) &#123;<br>    *begin = val;<span class="hljs-comment">//正确，，范围非空，因此begin指向一个元素</span><br>    ++begin;<span class="hljs-comment">//移动迭代器，获取下一个元素</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3><h4 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h4><p>每个容器都定义了多个类型，我们已经使用过其中的三种：size_type、iterator和const_iterator</p><p>除了已经使用过的迭代器类型，大多数容器还提供反向迭代器。</p><p>反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了<strong>颠倒</strong></p><p>例如，对一个反向迭代器执行++操作，就会得到上一个元素。</p><h4 id="类型别名-1"><a href="#类型别名-1" class="headerlink" title="类型别名"></a>类型别名</h4><p>通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。</p><p>如果需要元素类型，可以使用容器类型的value_type，</p><p>如果需要元素类型的一个引用，可以使用reference或者const_reference</p><p>为了使用这些类型，我们必须显式使用其类名、</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//iter是通过list&lt;string&gt;定义的一个迭代器类型</span><br><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt;::iterator iter;<br><span class="hljs-comment">//count是通过vector&lt;int&gt;定义的一个difference_type类型</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::difference_type count;<br></code></pre></div></td></tr></table></figure><p>这些声明语句使用了作用域运算符来说明我们希望使用list&lt;string&gt;类的iterator成员以及vector&lt;int&gt;类定义的difference_type</p><h4 id="begin和end成员"><a href="#begin和end成员" class="headerlink" title="begin和end成员"></a>begin和end成员</h4><p>begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器，这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围。</p><p>begin和end有多个版本，带r的版本返回反向迭代器，以c开头的版本则返回const迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; a = &#123;<span class="hljs-string">&quot;Milton&quot;</span>, <span class="hljs-string">&quot;Shakespeare&quot;</span>, <span class="hljs-string">&quot;Austen&quot;</span>&#125;;<br><span class="hljs-keyword">auto</span> it1 = a.begin();<span class="hljs-comment">//list&lt;string&gt;::iterator</span><br><span class="hljs-keyword">auto</span> it2 = a.rbegin();<span class="hljs-comment">//list&lt;string&gt;::reverse_iterator</span><br><span class="hljs-keyword">auto</span> it3 = a.cbegin();<span class="hljs-comment">//list&lt;string&gt;::const_iterator</span><br><span class="hljs-keyword">auto</span> it4 = a.crbegin();<span class="hljs-comment">//list&lt;string&gt;::const_reverse_iterator</span><br></code></pre></div></td></tr></table></figure><p>不以c开头的函数都是被重载过的，也就是说，实际上有两个名为begin的成员，一个是const，返回容器的const_iterator类型，另一个是非常量成员，返回容器的iterator类型，rbegin、end和rend的情况类似，当我们对一个非常量对象调用这些成员时，得到的是返回iterator的版本。只有在对一个const对象调用这些函数的时候，才会得到一个const版本，与const指针和引用类似，可以将一个普通的iterator转换为对应的const_iterator，但反之不行。</p><p>以c开头的版本是C++新标准引入，用于支持auto与begin和end的结合使用。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//显式指定类型</span><br><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt;::iterator it5 = a.begin();<br><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt;::const_iterator it6 = a.begin();<br><br><span class="hljs-comment">//是iterator还是const_iterator依赖于a的类型</span><br><span class="hljs-keyword">auto</span> it7 = a.begin();<span class="hljs-comment">//仅当a是const时，it7是const_iterator</span><br><span class="hljs-keyword">auto</span> it8 = a.cbegin();<span class="hljs-comment">//it8是const_iterator</span><br></code></pre></div></td></tr></table></figure><p>当auto与begin或end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相关，但是以c开头的版本还是可以获得const_iterator的，而不管容器的类型是什么</p><blockquote><p>当不需要写访问时，应使用cbegin和cend</p></blockquote><h3 id="容器的定义和初始化"><a href="#容器的定义和初始化" class="headerlink" title="容器的定义和初始化"></a>容器的定义和初始化</h3><p>每个容器类型都定义了一个默认构造函数，除array之外，其他容器的默认构造函数都会创建一个指定类型的容器，且都可以接受指定容器大小和元素初始值的参数</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210919140341718.png" alt="image-20210919140341718" style="zoom:50%;"><h4 id="将一个容器初始化为另一个容器的拷贝"><a href="#将一个容器初始化为另一个容器的拷贝" class="headerlink" title="将一个容器初始化为另一个容器的拷贝"></a>将一个容器初始化为另一个容器的拷贝</h4><p>将一个新容器创建为另一个容器的拷贝的方法有两种，可以直接拷贝整个容器，或者（array除外）拷贝由一个迭代器对指定的元素范围。</p><p>为了创建一个容器为另一个容器的拷贝，两个<strong>容器的类型</strong>以及其<strong>元素类型</strong>必须匹配</p><p>当传递<strong>迭代器参数</strong>来拷贝一个范围时，就<strong>不要求容器类型是相同的</strong>了，而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//每个容器有三个元素，用给定的初始化器进行初始化</span><br><span class="hljs-built_in">list</span>&lt;stirng&gt; authors = &#123;<span class="hljs-string">&quot;Milton&quot;</span>, <span class="hljs-string">&quot;Shakespeare&quot;</span>, <span class="hljs-string">&quot;Austen&quot;</span>&#125;;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; articles = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">list2</span><span class="hljs-params">(authors)</span></span>;<span class="hljs-comment">//正确，类型匹配。</span><br><span class="hljs-function"><span class="hljs-built_in">deque</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">authList</span><span class="hljs-params">(authors)</span></span>;<span class="hljs-comment">//错误，容器类型不匹配</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">authList</span><span class="hljs-params">(articles)</span></span>;<span class="hljs-comment">//错误，容器类型必须匹配</span><br><br><span class="hljs-comment">//正确，可以将const char*元素转换为string</span><br><span class="hljs-function">forword_list&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">words</span><span class="hljs-params">(articles.begin(), articles.end())</span></span>;<br></code></pre></div></td></tr></table></figure><blockquote><p>当一个容器初始化为另一个容器的拷贝时，两个容器的<strong>容器类型和元素类型</strong>都必须相同</p></blockquote><p>接受两个迭代器参数的构造函数想用这两个迭代器表示我们想要拷贝的一个元素范围，与以往一样，两个迭代器分别标记想要拷贝的第一个元素和尾元素之后的位置，新容器的大小与范围中元素的数目相同。新容器中的每个元素都用范围中对应元素的值进行初始化。</p><p>由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序列。</p><p>假定迭代器it表示authors中的一个元素，我们可以编写如下代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//拷贝元素，直到（但不包括）it指向的元素</span><br><span class="hljs-function"><span class="hljs-built_in">deque</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">authList</span><span class="hljs-params">(authors.begin(), it)</span></span>;<br></code></pre></div></td></tr></table></figure><h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>新标准中，我们可以对一个容器进行列表初始化</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//每个容器有三个元素，用给定的初始化器进行初始化</span><br><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; authors = &#123;<span class="hljs-string">&quot;Milton&quot;</span>, <span class="hljs-string">&quot;Shakeapeare&quot;</span>, <span class="hljs-string">&quot;Austen&quot;</span>&#125;;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; articles = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>&#125;;<br></code></pre></div></td></tr></table></figure><p>这样做时，我们就显式地指定了容器中每个元素地值，对于除了array之外的容器类型，初始化列表还隐含地指定了容器的大小：容器将包含与初始值一样多的元素。</p><h4 id="与顺序容器大小相关的构造函数"><a href="#与顺序容器大小相关的构造函数" class="headerlink" title="与顺序容器大小相关的构造函数"></a>与顺序容器大小相关的构造函数</h4><p>除了与关联容器相同的构造函数外，顺序容器（array除外）还提供另一个构造函数，它接受了一个容器大小和一个（可选的）元素初始值，如果我们不提供元素初始值，则标准库会创建一个值初始化器</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">-1</span>)</span></span>;<span class="hljs-comment">//10个int元素，每个都初始化为-1</span><br><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;hi!&quot;</span>)</span></span>;<span class="hljs-comment">//10个string元素，每个都初始化为“hi&quot;</span><br><span class="hljs-function">forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//10个元素，每个都初始化为0</span><br><span class="hljs-function"><span class="hljs-built_in">deque</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//10个元素，每个都是空string</span><br></code></pre></div></td></tr></table></figure><p>如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数，如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显式的元素初始值。</p><blockquote><p>只有顺序容器的构造函数才接受大小参数，关联容器并不支持</p></blockquote><h4 id="标准库array具有固定大小"><a href="#标准库array具有固定大小" class="headerlink" title="标准库array具有固定大小"></a>标准库array具有固定大小</h4><p>与内置数组一样，标准库array的大小也是类型的一部分，当定义一个array时，除了指定元素类型，还要指定容器大小。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 42&gt;;<span class="hljs-comment">//类型为：保存42个int的数组</span><br><span class="hljs-built_in">array</span>&lt;<span class="hljs-built_in">string</span>, 10&gt;;<span class="hljs-comment">//类型为：保存10个string的数组</span><br></code></pre></div></td></tr></table></figure><p>为了使用array类型，我们必须同时指定元素类型和大小。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt;::size_type i;<span class="hljs-comment">//数组类型包括元素类型和大小</span><br><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>&gt;::size_type j;<span class="hljs-comment">//错误：array&lt;int&gt;不是一个类型</span><br></code></pre></div></td></tr></table></figure><p>由于大小是array类型的一部分，array不支持普通的容器构造函数，这些构造函数都会确定容器的大小，要么隐式地，要么显式地。</p><p>array大小固定的特性也影响了它所定义的构造函数地行为，与其他容器不同，一个默认构造地array是非空的，它包含了与其大小一样多地元素，这些元素都被默认初始化，就像一个内置数组中的元素那样。</p><p>如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小，如果初始值数目小于array的大小，则它们被用来初始化array中靠前的元素，所有剩余元素都会进行值初始化，这两种情况下，如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; ial;<span class="hljs-comment">//10个默认初始化的int</span><br><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; ia2 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<span class="hljs-comment">//列表初始化</span><br><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; ia3 = &#123;<span class="hljs-number">42</span>&#125;;<span class="hljs-comment">//ia3[0]为42，剩余元素为0</span><br></code></pre></div></td></tr></table></figure><p>我们虽然不能对内置数组类型进行靠别或对象赋值操作，但是array并无此限制</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> digs[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">int</span> cpy[<span class="hljs-number">10</span>] = digs;<span class="hljs-comment">//错误，内置数组类型不支持拷贝或赋值</span><br><br><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; digits = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; copy = digits;<span class="hljs-comment">//正确，只要数组类型匹配即合法</span><br></code></pre></div></td></tr></table></figure><p>ayyay也要求初始值的类型必须与要创建的容器类型相同，此外array还要求元素类型和大小也都一样，因为大小是array类型的一部分</p><h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h3><p>赋值运算符将其左边容器中的全部元素替换成为右边容器中元素的拷贝（其他容器）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">c1 = c2;<span class="hljs-comment">//将c1的内容替换为c2中元素的拷贝</span><br>c1 = &#123;a, b, c&#125;;<span class="hljs-comment">//赋值后，c1的大小为3</span><br></code></pre></div></td></tr></table></figure><p>第一个赋值后，左边容器将与右边容器相等，如果两个容器原来大小不同，赋值运算后两者的大小都与右边容器的原大小相同。</p><p>第二个赋值运算后，c1的size变为3，即花括号列表中值的数目</p><p>与内置数组不同，标准库array类型允许赋值，赋值号左右两边的运算对象必须具有相同的类型。</p><p>以下array与上述的赋值规则有所区别</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; a1 = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; a2 = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//所有元素值均为0</span><br>a1 = a2;<span class="hljs-comment">//替换a1中的元素</span><br>a2 = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//错误，不能将一个花括号列表赋予数组。</span><br></code></pre></div></td></tr></table></figure><p>由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持assign，也不允许用花括号包围的值列表进行赋值。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210919153705370.png" alt="image-20210919153705370"></p><h4 id="使用assign"><a href="#使用assign" class="headerlink" title="!使用assign"></a>!使用assign</h4><p>上述赋值运算符要求左边和右边的运算对象具有相同的类型，将右边运算对象中的所有元素拷贝到左边运算对象中。</p><p>顺序容器（除array外）还定义了一个名为assign的成员，允许我们 从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。</p><p>assign的作用类似于强制转换，下面实现一个vector中的一段char*赋予一个list中的string</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; name;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; oldstyle;<br>name = oldstyle;<span class="hljs-comment">//错误，容器类型不匹配</span><br><span class="hljs-comment">//正确，可以将const char* 转换为string</span><br>name.assign(oldstyle.cbegin(), oldstyle.cend());<br></code></pre></div></td></tr></table></figure><p>该段代码中对assign的调用将name中的元素替换为迭代器指定的范围中的元素的拷贝，assign参数决定了容器中将有多少个元素，以及它们的值都是什么</p><blockquote><p>由于旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器</p></blockquote><p>assign的第二个版本接受一个整型值和一个元素值，它用指定数目且具有相同给定值的元素替换容器中原有的元素。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//等价于slist1.clear();</span><br><span class="hljs-comment">//后跟slist1.insert（slist1.begin(), 10, &quot;Hiya!&quot;);</span><br><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">slist1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//1个元素，为空string</span><br>slist1.assign(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;Hiya!&quot;</span>);<span class="hljs-comment">//10个元素，每个都是&quot;Hiya!&quot;</span><br></code></pre></div></td></tr></table></figure><h4 id="使用swap"><a href="#使用swap" class="headerlink" title="使用swap"></a>使用swap</h4><p>swap操作交换两个相同类型容器的内容，调用swap后，两个容器中的元素会交换。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//10个元素的vector</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec2</span><span class="hljs-params">(<span class="hljs-number">24</span>)</span></span>;<span class="hljs-comment">//24个元素的vector</span><br>swap(svec1, svec2);<br></code></pre></div></td></tr></table></figure><p>调用swap后，除array外，交换两个容器内容的操作保证会很快，元素本身并未交换，swap只是交换了两个容器内部数据结构</p><blockquote><p>除array外，swap不对任何元素进行拷贝，删除或插入操作，因此可以保证在常数时间内完成。</p></blockquote><p>元素不会被移动的事实意味着，除了string外，指向容器的迭代器，引用和指针在swap操作之后，都不会失效，它们仍然指向swap操作之前的那些元素，但是在swap之后，这些元素已经属于不同的容器了。</p><p>假定iter在swap前指向svec1[3]的string，那么swap后它指向svec2[3]的元素。</p><p>与其他容器不同，对一个string调用swap会导致迭代器，引用和指针失效。</p><p>与其他容器不同，swap两个array会真正交换它们的元素，因此，交换两个array所需的时间与array中的元素的数目成正比。</p><h4 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h4><p>成员函数size返回容器中元素的数目</p><p>empty当size为0时返回布尔值true，否则返回false</p><p>max_size返回一个大于等于该容器所能容纳的最大元素数的值。</p><p>forward_list支持max_size和empty，但不支持size。</p><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>关系运算符左右两边的运算对象必须是相同类型的容器，且保存相同类型的元素。</p><p>我们只能将一个vector&lt;int&gt;与另一个vector&lt;int&gt;进行比较，而不能将一个vector&lt;int&gt;与一个list&lt;int&gt;或一个vector&lt;double&gt;进行比较。</p><p>比较两个容器实际上是进行元素的逐对比较，这些运算符的工作方式与string的关系运算类似。</p><ul><li>如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等，否则两个容器不等。</li><li>如果两个容器大小不同，但较小容器中每两个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li><li>如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210919161001283.png" alt="image-20210919161001283" style="zoom:50%;"><p>容器的关系运算符实际上是使用元素的关系运算符完成比较，如果元素类型不支持所需的运算符，那么保存这种元素的容器就不能使用相应的关系运算。</p><h3 id="顺序容器的操作"><a href="#顺序容器的操作" class="headerlink" title="顺序容器的操作"></a>顺序容器的操作</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>除array外，所有标准容器都提供灵活的内存管理，在运行的时候可以动态添加或删除元素来改变容器大小。</p><p>添加元素的操作会改变容器的大小，array不支持这些操作。</p><p>forward_list不支持push_back和emplace_back，但有自己专属版本的insert和emplace</p><p>vector和string不支持push_front和emplace_front</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210920172607588.png" alt="image-20210920172607588"></p><p>不同的容器底层实现不同，vector和string尾部之外的任何位置或者deque的首位之外的任何位置添加元素都要移动元素，而且vector或string添加元素可能引起整个对象存储空间的重新分配，重新分配一个对象的存储空间要分配新的内存，并且从旧空间移动到新的空间中。</p><h4 id="使用push-back"><a href="#使用push-back" class="headerlink" title="使用push_back"></a>使用push_back</h4><p>将一个元素追加到一个容器的尾部，除了array和forward_list外，每个顺序容器都支持push_back</p><p>例如下面的循环每次读取一个string和word中，然后追加到容器尾部</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//从标准输入读取数据，将每个单词放到容器末尾</span><br><span class="hljs-built_in">string</span> word;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; word)<br>    container.push_back(word);<br></code></pre></div></td></tr></table></figure><p>对push_back的调用在container尾部创建了一个新的元素，将container的size增大了1，该元素的值为word的一个拷贝。container的类型可以是list、vector或deque</p><p>由于string是一个字符容器，我们也可以用push_back在stirng末尾添加字符</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pluralize</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> cnt, <span class="hljs-built_in">string</span> &amp;word)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">1</span>)<br>        word.push_back(<span class="hljs-string">&#x27;s&#x27;</span>);<span class="hljs-comment">//等价于word += &#x27;s&#x27;;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。</p></blockquote><h4 id="使用push-front"><a href="#使用push-front" class="headerlink" title="使用push_front"></a>使用push_front</h4><p>除了push_back</p><p>list、forword_list和deque容器还支持名为push_front的类似操作，此操作将元素插入到容器头部</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; ilist;<br><span class="hljs-comment">//将元素添加到ilist开头</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> ix = <span class="hljs-number">0</span>; ix!=<span class="hljs-number">4</span>; ++ix)<br>    ilist.push_front(ix);<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>顺序容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华科萌新生存指南</title>
    <link href="/2021/07/20/%E5%8D%8E%E7%A7%91%E8%90%8C%E6%96%B0%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/"/>
    <url>/2021/07/20/%E5%8D%8E%E7%A7%91%E8%90%8C%E6%96%B0%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>首先恭喜初入大学的新生</p><h3 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h3><p>学校分为紫菘，韵苑，沁苑三大住宿区</p><p>紫菘在学校最西边，西边地理位置最优，外出方便，其内有几栋是19年精装过的</p><p>韵苑在学校东区，容纳最多的人口，东区由曾经的武汉城市建筑学院改造，设施较老，树也没那么多，宿舍有几栋21年在精装。</p><p>沁苑内只生活计算机学院和网络安全学院的学生，位置在光谷体育馆附近，人口最少，住宿条件最差（还好，主要是水泥地面看上去破旧）。</p><hr><p>本科生宿舍确保了上床下桌四人间，独立阳台和独立卫浴</p><hr><p>在8月份新生会在班级内自由组队，选择宿舍，建议提前和同学聊聊天，找一些好商量事情，勤快一些的同学一起组宿舍。可以大一开学<strong>马上就买洗衣机</strong>，同时对于<strong>大扫除</strong>等事项也能一起干。（还有提前问清是否打呼噜，有不良癖好等）</p><p>关于南方的大蟑螂等，如果你勤打扫宿舍，就不会发生，很多很多从来不大扫除，清理厕所的宿舍蟑螂遍地能怪谁呢。</p><hr><p>8月份选择宿舍，是要<strong>抢</strong>的，<strong>奇数房号的宿舍是向阳</strong>，偶数房号的宿舍是背阳，因此奇数房号的宿舍要抢，建议抢宿舍的时候，找一个<strong>网速快</strong>（比如网吧）的地方，不要拖舍友或者被舍友拖后腿，抢不到。</p><p>其实不向阳也无所谓，至少我住了两年的偶数宿舍，没感觉有什么潮湿或者不方便的地方。</p><p>此外学校应该处理过蚊虫，蚊虫不算多。</p><hr><h3 id="军训"><a href="#军训" class="headerlink" title="军训"></a>军训</h3><p>如果不出意外，军训应该是海军工程大学大四的学长来带，教官还是很好相处的。</p><p>第一个周的军训会比较累，但是后边会逐渐变得<strong>划水</strong>，除非你进了那种持枪方阵等牌面方阵。</p><p>武汉的天气炎热，紫外线强烈，做好防晒就好。</p><p>每天的训练时间应该是早上8点到晚上9点半</p><hr><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>八月份的时候，会有让你选择是否花520购买学校提供的床上用品生活用品，建议<strong>不要买</strong>。</p><p>学校提供的床带被罩被子等都很一般，最好自己买好一些的，直接淘宝寄过来就可以，大学里收快递是靠各种<strong>驿站</strong>。</p><p>而且华科不会查寝查那种叠被子什么的，羽绒被空调被大胆买。</p><hr><p>建议开学<strong>尽快买电动车</strong>，真的很方便（毕业的时候可以卖，很好卖，回本轻松）。自行车骑起来太累了。</p><hr><p>不要轻易相信不熟的学长学姐，要不然是找你卖货，要不然是推销课程，还有更可恶的是编造不实信息骗你去什么教育机构，有什么问题询问高中的学长学姐。</p><hr><p>华科夏季作息是不断电，12点断网，冬季作息是11点断电（计算机学院除外），12点断网。</p><p>入学前需要微信里企业号<strong>华中大微校园</strong>，里面有各种你需要的，包括充值校园卡，交网费等。</p><p>校园网是大一只能一台设备无线连接。大二及以上是可以连接两台无线设备，或者一台有线设备（网线）</p><hr><h3 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h3><p>华科有<strong>35个食堂</strong>，当然大多数时候都吃自己宿舍附近的</p><p>西区紫菘：西一两层，西二两层，西华园一层，百惠园两层，百景园两层。<strong>西边的食堂，怎么都好吃</strong>！</p><p>中间沁苑：东一两层，东三一层（清真），紫荆园。我住在沁苑，对这三个很熟，东一中规中矩，紫荆园重油重盐，符合我山东人的胃，东三只有拉面好吃。</p><p>东区韵苑：韵苑食堂（韵苑大酒店），学一，学二，东园，东教工。东区人总是对自己的食堂及其不满意，但可能我吃得少，觉得还可以。</p><p>此外还有一些食堂分布在各处，宿舍区附近也会有很多苍蝇馆子（都在校内）。</p><hr><p>最后军训后期，所有人都要到中操场训练，即沁苑、光谷体育馆（开学典礼举行地）旁边的操场，到时候附近的食堂真的人满为患。（可以考虑骑车去集贸或者别的地方吃）</p><hr><p>华科校医院南，经管学院北那一片区域是<strong>集贸</strong>，有一些商铺（各种饭馆，麦当劳，蛋糕店，n多寿司等），还有一个<strong>菜市场</strong>，菜市场里有修衣服，卖空调遥控器，配钥匙等等</p><p>华科东边还有一个驾校，可以说，在华科，除了火葬场，你基本上能找到任何想要的</p><hr><h3 id="社团和机构"><a href="#社团和机构" class="headerlink" title="社团和机构"></a>社团和机构</h3><p>华科的社团文化一塌糊涂，像什么吉他社，动漫社，没什么意思，根本没什么活动，华科的人文气息十分微薄。</p><p>但是华科的学生团队很厉害，最出名的有dian，冰岩，联创，能进去的人都是大佬。其他也有一些很不错的，这种学生团队可以考虑。</p><p>关于学生会，我没加，但是感觉上也没什么意思。</p><hr><h3 id="假期准备"><a href="#假期准备" class="headerlink" title="假期准备"></a>假期准备</h3><p>华科开学有一个很难的英语考试（华科的英语考试都很难）</p><p>会通过这次考试选拔雅思班，托福班，这两个班在后续英语学习中是单独开课。</p><p>当然十分难考上，毕竟每年8000个新生，就选那么一点人。</p><hr><p>开学还有启明学院选拔，考英语和微积分，考进去可以转专业，有想法要提前做准备。</p><hr><p>各学科需要什么准备，可以询问本专业学长学姐。</p><p>对信息类感兴趣的萌新推荐两个网站</p><p><a href="https://hustport.com/">HUSTPORT | 综合交流平台</a></p><p><a href="https://github.com/recolic/awesome-hust">recolic/awesome-hust: HUST experiments, reports, and useful tools. (github.com)</a></p><p>进去看看，懂得都懂。</p>]]></content>
    
    
    <categories>
      
      <category>大学生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>华科</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——类</title>
    <link href="/2021/07/20/C++%E8%87%AA%E5%AD%A6%E7%B1%BB/"/>
    <url>/2021/07/20/C++%E8%87%AA%E5%AD%A6%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>C++中，通过定义一个类，来定义一个新的数据结构，一个类定义了一个类型，以及与其关联的一组操作。类机制是C++最重要的特性之一。</p><p><strong>类定义了行为</strong></p><p>某个类的作者定义了类对象可以执行的<strong>所有动作</strong>，即，类定义了创建一个此类对象时会发生什么事情，以及对此类对象进行赋值，加法或输入输出运算时会发生什么事情。</p><blockquote><p>对于来自标准库的头文件，应该使用尖括号&lt;&gt;包围头文件名，对于不属于标准库的头文件，则用双引号“”包围，比如自定义的类</p></blockquote><p>类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>，数据抽象是一种依赖于<strong>接口</strong>和<strong>实现</strong>分离的编程（以及设计）技术，类的<strong>接口包括用户所能执行的操作</strong>，类的<strong>实现则包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数</strong></p><p>封装实现了类的接口和实现的分离，封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分</p><p>类想要实现数据抽象和封装，需要首先定义一个<strong>抽象数据类型</strong>，在抽象数据类型中，由类的设计者负责考虑类的实现过程，使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。</p><p>学习C语言的时候，结构体的作用是把一些具有不同类型的变量组合在一起</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> _name[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">char</span> _gender[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">int</span> _age;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而在C++中，其结构体内不仅可以定义变量，还可以定义函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> _name[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">char</span> _gender[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">int</span> _age;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetStudentInfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* gender,<span class="hljs-keyword">int</span> age)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">strcpy</span>(_name,name);<br>        <span class="hljs-built_in">strcpy</span>(_gender,gender);<br>        _age=age;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Student s;<br>    s.SetStudentInfo(<span class="hljs-string">&quot;Bob&quot;</span>,<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-number">18</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>定义一个类，<strong>Struct可以换成Class</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">classname</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">//成员函数</span><br>    <span class="hljs-comment">//成员变量</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>简单说，类就是属性和方法的集合，属性就是类中的数据，方法就是调用这些数据进行操作的函数</p><h4 id="类的定义方式"><a href="#类的定义方式" class="headerlink" title="类的定义方式"></a>类的定义方式</h4><ol><li>全部放到一个文件中 Person.cpp</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>//人就是一个类</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<span class="hljs-comment">//成员函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showinfo</span><span class="hljs-params">()</span><span class="hljs-comment">//显示这个人的信息</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;_name&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;_gender&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;_age&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span>:<span class="hljs-comment">//成员变量</span><br>    <span class="hljs-keyword">char</span> *_name;<br>    <span class="hljs-keyword">char</span> *_gender;<br>    <span class="hljs-keyword">int</span> _age;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li>定义和声明分开放（推荐）</li></ol><p>Person.h</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">char</span> *_name;<br>    <span class="hljs-keyword">char</span> *_gender;<br>    <span class="hljs-keyword">int</span> _age;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Person.cpp</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Person.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Person::showinfo</span><span class="hljs-params">()</span><span class="hljs-comment">//显示这个人的信息</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;_name&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;_gender&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;_age&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>使用之前书店的例子，设计一个Sales_data类</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span>&#123;</span><br>    <span class="hljs-comment">//关于Sales_data对象的操作</span><br>    <span class="hljs-comment">//isbn定义在类内</span><br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br>    <span class="hljs-comment">//conbine,avg_price只声明在类内，定义在类外</span><br>    <span class="hljs-function">Sales_data&amp; <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <br>    <span class="hljs-comment">//数据成员</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;<br>    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;<br><span class="hljs-comment">//Sales_data的非成员接口函数</span><br><span class="hljs-function">Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;,<span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream&amp;,<span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::istream&amp;,Sales_data&amp;)</span></span>;<br></code></pre></div></td></tr></table></figure><p>所有的成员函数都必须在类的内部声明，但是成员函数可以定义在类内也可以定义在类外。</p><p>作为接口组成部分的非成员函数，例如上面的add，read，print，它们的定义都在类的外部</p><h4 id="引入this"><a href="#引入this" class="headerlink" title="引入this"></a>引入this</h4><p>如下创建了一个对象total，是Sales_data类</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Sales_data total;<br>    <span class="hljs-comment">//书店程序</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>Sales_data类的成员函数，返回值为Sales_data对象的bookNo数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br></code></pre></div></td></tr></table></figure><p>使用点运算符来访问total对象的isbn成员，然后调用它。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">total.isbn()<br></code></pre></div></td></tr></table></figure><p>调用成员函数的时候，实际上是替某个<strong>对象</strong>调用它，如果isbn指向Sales_data的成员（例如bookNo），它隐式地指向调用该函数的对象（total）的成员。</p><p>上面的调用，当isbn返回bookNo的时候，实际上它隐式地返回<strong>total</strong>.bookNo</p><p>成员函数通过<strong>this</strong>的额外隐式参数来访问调用它的那个对象，我们调用一个成员函数的时候，用请求该函数的对象地址初始化this</p><p>例如，如果调用</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">total.isbn()<br></code></pre></div></td></tr></table></figure><p>编译器负责把total的地址传递给isbn的隐式形参this，可以等价的认为编译器将该调用重写成了如下的形式</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//伪代码，用于说明调用成员函数的实际执行过程</span><br>Sales_data::isbn(&amp;total)<br></code></pre></div></td></tr></table></figure><p>调用Sales_data的isbn成员时传入了total的地址</p><p>在成员函数的<strong>内部</strong>，我们可以<strong>直接使用调用该函数的对象的成员</strong>，而无须通过成员访问符来做到这一点，因为this所指的就是这个对象，它<strong>隐式地使用this指向成员</strong>，就像我们书写了this-&gt;bookNo一样。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;bookNo;&#125;<br></code></pre></div></td></tr></table></figure><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><p>上面的isbn函数参数列表之后，紧跟着const关键字，const的作用是<strong>修改隐式this指针的类型</strong></p><p>默认情况下，this的类型是指向类类型的常量指针，指向的对象是非常量版本，例如Sales_data成员函数中，this的类型是Sales_data *const。   指针自身是常量，但是指向的内容不能是常量。</p><p>这意味着我们不能把this绑定到一个常量对象上，也就不能在一个常量对象上调用普通的成员函数。</p><p>如果isbn是一个普通函数，this是一个普通的指针参数，最好把this声明成const Sales_data *const，常量指针指向常量对象，因为isbn函数体内部不会改变this所指向的对象，所以把this设置为指向常量的指针有利于提高函数的灵活性（常量或者非常量对象都可以绑定）</p><p>C++允许把const关键字放在成员函数的参数列表之后，此时紧跟在参数列表后面的const表示this是一个指向常量的指针，像这样使用const的成员函数被称作常量成员函数。</p><p>此时isbn的函数体可以想象成如下的伪代码（非法，自己不能显示的定义this指针）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">Sales_data::isbn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data *<span class="hljs-keyword">const</span> <span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> -&gt; isbn;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>this是指向常量的指针，常量成员函数不能改变调用它的对象的内容，上例中，isbn可以读取它的对象的数据成员，但是不能写入新值</p><blockquote><p>常量对象，以及常量对象的引用和指针都只能调用常量成员函数</p></blockquote><h4 id="类的作用域和成员函数"><a href="#类的作用域和成员函数" class="headerlink" title="类的作用域和成员函数"></a>类的作用域和成员函数</h4><p>类本身就算一个作用域，类的成员函数的定义嵌套在类的作用域之内， </p><blockquote><p>由于编译器分两步处理类：先编译成员的声明，然后才轮到成员函数体，因此成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序</p></blockquote><h4 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h4><p>当我们在类的外部定义成员函数的时候，成员函数的<strong>定义必须与它的声明匹配</strong>，<strong>返回类型，参数列表和函数名都要与类内部的声明保持一致</strong></p><p><strong>成员函数被声明成常量成员函数</strong>（参数列表后加const，意思是这个成员函数不可以改变类的内容），<strong>定义的时候也必须在参数列表后明确指定const属性</strong></p><p>Person.h</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">char</span> *_name;<br>    <span class="hljs-keyword">char</span> *_gender;<br>    <span class="hljs-keyword">int</span> _age;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Person.cpp</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Person.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Person::showinfo</span><span class="hljs-params">()</span><span class="hljs-comment">//显示这个人的信息</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;_name&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;_gender&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;_age&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>在编译器看到Person::showinfo的时候，就能理解剩余的代码是位于类Person的作用域内，因此函数体内可以调用类的成员。</p><h4 id="返回this对象的函数"><a href="#返回this对象的函数" class="headerlink" title="返回this对象的函数"></a>返回this对象的函数</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">Sales_data&amp; <span class="hljs-title">Sales_data::combine</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    units_sold += rhs.units_sold;<br>    revenue += rhs.revenue;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">total.conbine(trans);<br></code></pre></div></td></tr></table></figure><p>total的地址被绑定到隐式的this参数，this绑定到了trans上</p><p>最后要返回一个引用类型，返回类型是Sales_data&amp;，因此把调用函数的对象当成一个整体来访问：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br></code></pre></div></td></tr></table></figure><p>其中，return语句解引用this指针以获得执行该函数的对象，也就是上面这个调用<strong>返回total的引用</strong></p><h4 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h4><p>类的作者常常需要定义一些<strong>辅助函数</strong>，比如add、read、print，这些函数定义的操作从概念上来说<strong>属于类的接口的组成部分</strong>，但是它们<strong>实际上不属于类本身</strong>。</p><p>定义非成员函数的方式与定义其他函数一样，通常声明和定义分开，如果函数在<strong>概念上属于类但是不定义在类中</strong>，则它一般<strong>应与类声明在同一个头文件内</strong>。</p><p>用户使用接口的任何部分都只需要引入一个文件。Person.h   Person.cpp</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制对象的<strong>初始化过程</strong>，这些函数叫<strong>构造函数</strong>。</p><p>构造函数的任务是<strong>初始化类对象的数据成员</strong>，无论何时只要类的<strong>对象被创建，就会执行构造函数</strong></p><p>构造函数名字和类名相同，与其他函数的区别是<strong>没有返回类型</strong>，不同的构造函数必须在<strong>参数数量或参数类型上有所不同</strong></p><p>构造函数不能被声明为const，创建类的一个const对象时，知道构造函数完成初始化过程，对象才能真正取得常量属性，构造函数在const对象的构造过程中可以向其写值。</p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Sales_data total;<br>Sales_data trans;<br></code></pre></div></td></tr></table></figure><p>没有为这些对象提供初始值，它们执行了<strong>默认初始化</strong>，类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数，<strong>默认构造函数无须任何实参</strong>。</p><p>如果我们的类<strong>没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数</strong>。</p><p>编译器创建地构造函数又被称为合成的默认构造函数。</p><ul><li>如果存在类内的初始值，用它来初始化成员</li><li>否则，默认初始化</li></ul><p>某些类不能依赖于合成的默认构造函数</p><ul><li><p>只有当类没有声明任何构造函数地时候，编译器才会自动地生成默认构造函数。</p></li><li><p>如果类包含有内置类型或者复合类型（数组和指针）的成员，则只有当这些成员<strong>全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。</strong></p></li><li><p>类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。</p></li></ul><h4 id="定义Sales-data的构造函数"><a href="#定义Sales-data的构造函数" class="headerlink" title="定义Sales_data的构造函数"></a>定义Sales_data的构造函数</h4><p>如下定义四个</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span>&#123;</span><br>    Sales_data() = <span class="hljs-keyword">default</span>;<br>    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s) : bookNo(s) &#123;&#125;<br>    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s,<span class="hljs-keyword">unsigned</span> n,<span class="hljs-keyword">double</span> p):bookNo(s),units_sold(n),revenue(p*n)&#123;&#125;<br>    Sales_data(<span class="hljs-built_in">std</span>::istream &amp;);<br>    <br>    <br><br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br>    <span class="hljs-function">Sales_data&amp; <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;<br>    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意到第一行代码Sales_data() = default;</p><h4 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h4><p>该构造函数不接受任何实参，所以是一个默认的构造函数.</p><p>加上=default后，<strong>要求编译器生成构造函数</strong>，=default可以和声明一起出现在类的内部，也可以作为定义出现在类的外部，</p><h4 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s) : <br>bookNo(s) <br>&#123;&#125;<br>Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s,<span class="hljs-keyword">unsigned</span> n,<span class="hljs-keyword">double</span> p):<br>bookNo(s),units_sold(n),revenue(p*n)<br>&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>冒号以及冒号和花括号之间的代码，其中花括号定义了空的函数体。</p><p>中间新出现的这部分称为构造函数初始值列表，负责为新创建的对象的一个或几个数据成员赋初始值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来（或者花括号内）的成员初始值。不同成员的初始化通过逗号分隔开。</p><p>上面的两个构造函数中函数体都是空的，这是因为这些构造函数的唯一目的就是为数据成员赋初值，一旦没有其他任务需要执行，函数体也就空了</p><h4 id="类的外部定义构造函数"><a href="#类的外部定义构造函数" class="headerlink" title="类的外部定义构造函数"></a>类的外部定义构造函数</h4><p>以istream为参数的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Sales_data(<span class="hljs-built_in">std</span>::istream &amp;);<br></code></pre></div></td></tr></table></figure><p>需要执行一些实际操作，在它的函数体内，调用了read函数给数据成员赋初值</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Sales_data::Sales_data(<span class="hljs-built_in">std</span>::istream &amp;is)<br>&#123;<br>    read(is,*<span class="hljs-keyword">this</span>);<span class="hljs-comment">//read函数的作用是从is中读取一条交易信息然后存入this对象中</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h3><p>为类定义了接口，但是没有机制强制用户使用这些接口，因为我们的类还没有封装，用户可以直接进入Sales_data对象的内部并且控制它的具体实现细节，因此C++中使用访问控制符来加强类的封装性</p><h4 id="访问说明符"><a href="#访问说明符" class="headerlink" title="访问说明符"></a>访问说明符</h4><ul><li>定义在<strong>public</strong>后的成员在<strong>整个程序内可以被访问</strong>，public成员定义类的接口</li><li>定义在<strong>private</strong>说明符后的成员<strong>可以被类的成员函数访问</strong>，但是不能被使用该类的代码访问，private部分封装了（隐藏了）类的实现细节。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span>&#123;</span><br>    <span class="hljs-keyword">public</span>:<span class="hljs-comment">//添加了访问说明符</span><br>    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s,<span class="hljs-keyword">unsigned</span> n,<span class="hljs-keyword">double</span> p):bookNo(s),units_sold(n),revenue(p*n)&#123;&#125;<br>    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s): bookNo(s)&#123;&#125;<br>    Sales_data(<span class="hljs-built_in">std</span>::istream&amp;);<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br>    <span class="hljs-function">Sales_data &amp;<span class="hljs-title">combine</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">const</span> Sales_data&amp;&#125;<br>    <span class="hljs-keyword">private</span>:<span class="hljs-comment">//添加了访问说明符</span><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> units_sold ? revenue/units_sold : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;<br>    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>构造函数和部分成员函数紧跟在public之后，而数据成员和作为实现部分的函数则紧跟在private说明符后面</p><h4 id="类的定义——class还是struct关键字"><a href="#类的定义——class还是struct关键字" class="headerlink" title="类的定义——class还是struct关键字"></a>类的定义——class还是struct关键字</h4><p><strong>唯一的区别</strong>是struct和class的<strong>默认访问权限</strong>不太一样</p><p>使用struct关键字，定义在第一个访问说明符之前的成员是public的</p><p>如果使用class关键字，则这些成员是private的</p><p>使用private关键字修饰后，成员只可以被类的成员函数访问，可是我们一开始在类的外面定义了三个非成员函数，那三个非成员函数调用了类中的private修饰的成员，因此现在read，print和add函数就无法正常编译了，尽管这几个函数是类的接口的一部分，但是它们不是类的成员</p><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的<strong>友元</strong>，需要增加一条friend关键字开始的函数声明语句</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span>&#123;</span><br>    <span class="hljs-comment">//为Sales_data的三个非成员函数做友元声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;,<span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream&amp;,<span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::istream&amp;,Sales_data&amp;)</span></span>;<br>    <br>     <span class="hljs-keyword">public</span>:<span class="hljs-comment">//添加了访问说明符</span><br>    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s,<span class="hljs-keyword">unsigned</span> n,<span class="hljs-keyword">double</span> p):bookNo(s),units_sold(n),revenue(p*n)&#123;&#125;<br>    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s): bookNo(s)&#123;&#125;<br>    Sales_data(<span class="hljs-built_in">std</span>::istream&amp;);<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br>    <span class="hljs-function">Sales_data &amp;<span class="hljs-title">combine</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">const</span> Sales_data&amp;&#125;<br>    <span class="hljs-keyword">private</span>:<span class="hljs-comment">//添加了访问说明符</span><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> units_sold ? revenue/units_sold : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;<br>    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;<br><span class="hljs-comment">//Sales_data接口的非成员组成部分的声明</span><br><span class="hljs-function">Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;,<span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream&amp;,<span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::istream&amp;,Sales_data&amp;)</span></span>;<br></code></pre></div></td></tr></table></figure><p>友元声明只能出现在类的内部，但是在类中出现的具体位置不限，友元不是类的成员，也不受它所在区域访问控制级别的约束</p><p>友元的声明<strong>仅仅制定了访问的权限</strong>，<strong>而非一个通常意义上的函数声明</strong>。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在<strong>友元声明之外再专门对函数进行一次声明</strong>。</p><p>为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中，因此，我们的Sales_data头文件应该为read，print，add提供独立的声明。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210914222205315.png" alt="image-20210914222205315"></p><p>构建一个新的类，用于探究类的一些特性。</p><p>定义一个新的类型成员</p><p>Screen表示一个显示器的窗口，每个Screen包含一个能用于保存Screen内容的string成员和三个string::size_type的类型的成员，它们分别表示光标的位置以及屏幕的高和宽</p><p>除了定义数据和函数成员之外，类还可以<strong>自定义某种类型在类中的别名</strong>，由类定义的类型名字和其他成员一样存在访问限制，可以说public或者private的一种。</p><h4 id="自定义类中的别名"><a href="#自定义类中的别名" class="headerlink" title="自定义类中的别名"></a>自定义类中的别名</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::size_type pos;<br>    <span class="hljs-comment">//等价于</span><br>    <span class="hljs-comment">//using pos = std::string::size_type;</span><br>    <span class="hljs-keyword">private</span>:<br>    pos curor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">std</span>::stirng contexts;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在Screen的public部分定义了pos，这样用户就可以使用这个名字。</p><p>Screen的用户不应该知道Screen使用了一个string对象来存放它的数据，因此通过把pos定义成public成员可以隐藏Screen实现的细节。</p><blockquote><p>用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别。</p></blockquote><p>为了使类更加实用，需要添加一个构造函数令用户能够定义屏幕的尺寸和内容，以及其他两个成员，分别负责移动光标和读取给定位置的字符</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::size_type pos;<br>    <br>    Screen() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//因为Screen有另一个构造函数，本函数是必需的</span><br>    Screen(pos ht, pos wd, <span class="hljs-keyword">char</span> c): height(ht), width(wd), contents(ht * wd, c) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">//读取光标处的字符</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> contents[cursor]; &#125;<span class="hljs-comment">//隐式内联</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht, pos wd)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">//显式内联</span><br>    <span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r,pos c)</span></span>;<span class="hljs-comment">//能在之后被设为内联</span><br>    <span class="hljs-keyword">private</span>:<br>    pos curor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">std</span>::stirng contexts;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>定义</strong>在类<strong>内部</strong>的成员函数是<strong>自动inline</strong>的，因此Screen的构造函数和返回光标所指字符的get函数默认是inline函数。</p><p>可以在类的<strong>内部</strong>把inline作为<strong>声明</strong>的一部分显式地声明成员函数，也能在类的<strong>外部</strong>用inline关键字修饰函数的定义</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span><span class="hljs-comment">//可以在函数的定义处指定inline</span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">Screen::move</span><span class="hljs-params">(pos r,pos c)</span></span><br><span class="hljs-function"></span>&#123;<br>    pos row = r * width;<span class="hljs-comment">//计算行的位置</span><br>    cursor = row + c;<span class="hljs-comment">//在行内将光标移动到指定的列</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//以左值的形式返回对象</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos r, pos c)</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">//在类的内部声明成inline</span></span><br><span class="hljs-function"></span>&#123;<br>    pos row = r * width;<span class="hljs-comment">//计算行的位置</span><br>    <span class="hljs-keyword">return</span> contents[row + c];<span class="hljs-comment">//返回给定列的字符</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然我们无须在声明和定义的地方同时说明inline，但是这么做其实是合法的，不过最好只在类的外部定义的地方说明inline，这样可以使类更容易理解。</p><h3 id="重载成员函数"><a href="#重载成员函数" class="headerlink" title="重载成员函数"></a>重载成员函数</h3><p>成员函数也可以被重载，同样只要函数之间参数的数量和/或类型上有所区别就行</p><p>成员函数的匹配过程，同样与非成员函数非常类似</p><h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><p>希望能修改类的某个数据成员，即使是在一个const成员函数内，可以通过在变量的声明中加入mutable关键字做到这一点。</p><p>可变数据成员 永远不会是const，即使它是const对象的成员，因此，一个const成员函数可以改变一个可变成员的指。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">size_t</span> access_ctr;<span class="hljs-comment">//即使在一个const对象内也能被修改。</span><br>    <span class="hljs-comment">//其他成员与之前的版本一致</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Screen::some_member</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    ++access_ctr;<span class="hljs-comment">//保存一个计数值，用于记录成员函数被调用的次数</span><br>    <span class="hljs-comment">//该成员需要完成的其他工作。</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>尽管some_memeber是一个const成员函数，它仍能够改变access_ctr的值。该成员是个可变成员，因此任何函数，包括const函数在内都能改变它的值。</p><h3 id="类数据成员的初始值"><a href="#类数据成员的初始值" class="headerlink" title="类数据成员的初始值"></a>类数据成员的初始值</h3><p>继续定义一个窗口管理类，并用它表示显示器上的一组Screen。这个类将包含一个Screen类型的vector，每个元素表示一个特定的Screen，默认情况下，我们希望Window_mgr类开始时总有一个默认初始化的Screen。</p><p>最好把这个默认值声明成一个类内初始值。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window_mgr</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//这个Window_mgr追踪的Screen</span><br>    <span class="hljs-comment">//默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen</span><br>    std::vector&lt;Screen&gt; screens&#123;Screen(24,80,&#x27;&#x27;)&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参</p><p>我们使用一个单独的元素值对vector成员执行了列表初始化，这个Screen的值被传递给vector&lt;Screen&gt;的构造函数，从而创建了一个单元素的vector对象。</p><blockquote><p>类内初始化必须使用 <strong>= 的初始化形式</strong>，<strong>或者花括号括起来的直接初始化形式</strong>。</p></blockquote><h4 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h4><p>继续添加一些函数，负责设置光标所在位置的字符或者其他任一给定位置的字符</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Screen &amp;<span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">char</span>)</span></span>;<br>    <span class="hljs-function">Screen &amp;<span class="hljs-title">set</span><span class="hljs-params">(pos,pos,<span class="hljs-keyword">char</span>)</span></span>;<br>    <span class="hljs-comment">//其他成员和之前的版本一致</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> Screen &amp;<span class="hljs-title">Screen::set</span><span class="hljs-params">(<span class="hljs-keyword">char</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    contents[cursor] = c;<span class="hljs-comment">//设置当前光标所在位置的新值</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//将this对象作为左值返回</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> Screen &amp;<span class="hljs-title">Screen::set</span><span class="hljs-params">(pos r, pos col, <span class="hljs-keyword">char</span> ch)</span></span><br><span class="hljs-function"></span>&#123;<br>    contents[r*width + col] = ch;<span class="hljs-comment">//设置给定位置的新值</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//将this对象作为左值返回</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>和move操作一样，set成员的返回值是调用set对象的引用。</p><p>返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本</p><p>将一系列这样的操作连接在一条表达式中的话</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//把光标移动到一个指定的位置，然后设置该位置的字符值</span><br>myScreen.move(<span class="hljs-number">4.0</span>).<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>这些操作都在一个对象上执行，上面的表达式中，首先移动myScreen内的光标，然后设置myScreen的contents成员，上述语句实际上等价于</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">myScreen.move(<span class="hljs-number">4.0</span>);<br>myScreen.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>如果令move和set返回Screen而非Screen&amp;，则上述语句的行为将大不相同</p><p>此例中等价</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//如果move返回Screen而非Screen&amp;</span><br>Screen temp = myScreen.move(<span class="hljs-number">4.0</span>);<span class="hljs-comment">//对返回值进行拷贝</span><br>temp.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<span class="hljs-comment">//不会改变myScreen的contents</span><br></code></pre></div></td></tr></table></figure><p>假如当初我们定义的返回类型不是引用，则move的返回值将是*this的副本，因此调用set只能改变临时副本，而不能改变myScreen的值</p><h4 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a>基于const的重载</h4><p>通过区分成员函数是否是const的，我们可以对其进行重载，其原因与我们之前根据指针参数是否指向const而重载函数的原因差不多</p><p>因为<strong>非常量版本的函数对于常量对象是不可用的</strong>，所以我们<strong>只能在一个常量对象上调用const成员函数</strong>，另一方面，虽然可以<strong>在非常量对象上</strong>调用常量版本或非常量版本，但显然此时<strong>非常量版本是一个更好的匹配。</strong></p><p>下面这个例子，定义一个名为do_display的私有成员，由它负责打印Screen的实际工作，所有的display操作都将调用这个函数，然后返回执行操作的对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//根据对象是否是const重载了display函数</span><br>    <span class="hljs-function">Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;os)</span></span><br><span class="hljs-function">    </span>&#123; do_display(os); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;os)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123; do_display(os); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//该函数负责显示Screen的内容</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;os)</span> <span class="hljs-keyword">const</span> </span>&#123;os &lt;&lt; contents;&#125;<br>    <span class="hljs-comment">//其他成员与之前的版本一致</span><br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>当一个成员调用另外一个成员的时候，this指针在其中隐式地传递，</p><p>因此display调用do_display地时候，它的this指针隐式地传递给do_display。</p><p>当display的非常量版本调用do_display的时候，它的this指针隐式的从指向非常量的指针转换成指向常量的指针。</p><p>do_display完成后，display函数各自返回解引用this所得的对象，在非常量版本中，this指向一个非常量对象，因此display返回一个普通的（非常量）引用，而const成员返回一个常量引用。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">Screen <span class="hljs-title">myScreen</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">const</span> Screen <span class="hljs-title">blank</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)</span></span>;<br>myScreen.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>).display(<span class="hljs-built_in">cout</span>);<span class="hljs-comment">//调用非常量版本</span><br>blank.display(<span class="hljs-built_in">cout</span>);<span class="hljs-comment">//调用常量版本</span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210916163905922.png" alt="image-20210916163905922"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210916163943402.png" alt="image-20210916163943402"></p><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>每个类定义了唯一的类型，对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">First</span> &#123;</span><br>    <span class="hljs-keyword">int</span> memi;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMem</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Second</span> &#123;</span><br>    <span class="hljs-keyword">int</span> memi;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMem</span><span class="hljs-params">()</span></span>;<br>&#125;;<br>First obj1;<br>Second obj2;<span class="hljs-comment">//错误：obj1和obj2的类型不同</span><br></code></pre></div></td></tr></table></figure><blockquote><p>即使两个类的成员列表完全一致，它们也是不同的类型，对于一个类来说，它的成员和任何其他类的成员都不是一回事。</p></blockquote><p>类可以只声明而不定义</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span>;</span><span class="hljs-comment">//Screen类的声明</span><br></code></pre></div></td></tr></table></figure><p>这种声明有时被称为 <strong>前向声明</strong>，它向程序中引入了名字Screen并指明Screen是一种类类型。</p><p>但是它在声明后，定义前，是一个<strong>不完全类型</strong>。只知道它是类，但是不知道它到底包含哪些成员。</p><p>这种不完全类型，只能定义这种类型的指针或引用，也可以声明 以不完全类型作为参数或者返回类型的函数。</p><h3 id="友元进阶"><a href="#友元进阶" class="headerlink" title="友元进阶"></a>友元进阶</h3><p>类还可以把其他的类定义成友元，也可以把其他类（已经定义过的）的成员函数定义成友元。</p><p>友元函数能定义在类的内部，这样的函数隐式内联。</p><h4 id="定义类为友元"><a href="#定义类为友元" class="headerlink" title="定义类为友元"></a>定义类为友元</h4><p>Window_mgr类的某些成员需要访问它管理的Screen类的内部数据，比如一个clear的新成员，负责把指定的Screen的内容设为空白。clear需要访问Screen的私有成员。</p><p>要令这种访问合法，Screen需要把Window_mgr指定成它的友元。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><br>    <span class="hljs-comment">//Window_mgr的成员可以访问Screen类的私有部分</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window_mgr</span>;</span><br>    <span class="hljs-comment">//Screen类的剩余部分</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>一旦一个类制定了友元类，友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p><p>此时Window_mgr的clear成员就能写成如下形式。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window_mgr</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//窗口中每个屏幕的编号</span><br>    <span class="hljs-keyword">using</span> ScreenIndex = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Screen&gt;::size_type;<br>    <span class="hljs-comment">//按照编号将指定的Screen重置为空白</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(ScreenIndex)</span></span>;<br>    <br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;Screen&gt; screens&#123;Screen(24,80,&#x27;&#x27;)&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Window_mgr::clear</span><span class="hljs-params">(ScreenIndex i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//s是一个Screen的引用，指向我们想清空的那个屏幕</span><br>    Screen &amp;s = screen[i];<br>    <span class="hljs-comment">//将那个选定的Screen重置为空白</span><br>    s.contents = string(s.height * s.width, &#x27;&#x27;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果clear不是Screen的友元，上面的代码将无法通过编译，因为此时clear将不能访问Screen的height、width和contents成员。</p><p>友元关系不存在传递性，Window_mgr有自己的友元，这些友元不能理所当然地访问Screen</p><h4 id="成员函数作为友元"><a href="#成员函数作为友元" class="headerlink" title="成员函数作为友元"></a>成员函数作为友元</h4><p>除了令整个Window_mgr作为友元之外，Screen还可以只为clear提供访问权限。</p><p>当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><br>    <span class="hljs-comment">//Window_mgr::clear必须在Screen类之前被声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Window_mgr::clear</span><span class="hljs-params">(ScreenIndex)</span></span>;<br>    <span class="hljs-comment">//Screen类的剩余部分</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>要令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。</p><p>这个例子我们要按照如下方式</p><ul><li>首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须线声明Screen。</li><li>接下来定义Screen，包括对于clear的友元声明</li><li>最后定义clear，此时它才可以使用Screen成员</li></ul><h4 id="函数重载和友元"><a href="#函数重载和友元" class="headerlink" title="函数重载和友元"></a>函数重载和友元</h4><p>尽管函数重载的名字相同，但它们仍然是不同的函数，因此如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//重载的storeOn函数</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-built_in">std</span>::ostream&amp; <span class="hljs-title">storeOn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;, Screen &amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> BigMap&amp; <span class="hljs-title">storeOn</span><span class="hljs-params">(BitMap &amp;, Screen &amp;)</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><br>    <span class="hljs-comment">//storeOn的ostream版本能访问Screen对象的私有部分</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream&amp; <span class="hljs-title">storeOn</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::ostream &amp;, Screen &amp;)</span></span>;<br>    <span class="hljs-comment">//</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>Screen类把接收ostream&amp;的storeOn函数声明成它的友元，但是接收BitMap&amp;作为参数的版本仍然不能访问Screen</p><h4 id="友元声明和作用域"><a href="#友元声明和作用域" class="headerlink" title="友元声明和作用域"></a>友元声明和作用域</h4><p>类和非成员函数的声明不是必须在它们的友元声明之前。</p><p>当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的，然而友元本身并不一定真的声明在当前作用域中。</p><p>就算是再类的内部定义该函数，我们也必须再类的外部提供相应地声明从而使得函数可见。</p><p>即使我们仅仅用声明友元地类的成员调用该友元函数，它也必须是被声明过的</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">/*友元函数可以定义在类的内部*/</span>&#125;<br>    <br>    X() &#123;f();&#125;<span class="hljs-comment">//错误，f还没被声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">X::g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> f(); &#125;<span class="hljs-comment">//错误，f还没被声明</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//声明那个定义在X中的函数。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">X::h</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> f(); &#125;<span class="hljs-comment">//正确，现在f的声明在作用域中了</span><br></code></pre></div></td></tr></table></figure><h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h3><p>每个类都定义它自己的作用域，一个类就是一个作用域</p><p>类的作用域之外，类的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问，对于类类型的成员则使用作用域运算符访问。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Screen::pos ht = <span class="hljs-number">24</span>, wd = <span class="hljs-number">80</span>;<span class="hljs-comment">//使用Screen定义的pos类型</span><br><span class="hljs-function">Screen <span class="hljs-title">scr</span><span class="hljs-params">(ht, wd, <span class="hljs-string">&#x27; &#x27;</span>)</span></span>;<br>Screen *p = &amp;scr;<br><span class="hljs-keyword">char</span> c = scr.get();<span class="hljs-comment">//访问scr对象的get成员</span><br>c = p -&gt; get();<span class="hljs-comment">//访问p所指对象的get成员</span><br></code></pre></div></td></tr></table></figure><p>一旦遇到类名，定义的剩余部分就在类的作用域之内，剩余部分指的是参数列表和函数体。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Window_mgr::clear</span><span class="hljs-params">(ScreenIndex i)</span></span><br><span class="hljs-function"></span>&#123;<br>    Screen &amp;s = screen[i];<br>    s.contents = <span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在参数列表前，由一个Window_mgr::，让编译器知道函数在Window_mgr作用域中，因此参数列表和函数体可以调用类中的内容</p><p>但是返回类型是出现在函数名之前，返回类型中使用的名字位于类的作用域之外，这时返回类型就必须指明它是哪个类的成员。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window_mgr</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//向窗口添加一个Screen，返回它的编号</span><br>    <span class="hljs-function">ScreenIndex <span class="hljs-title">addScreen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Screen&amp;)</span></span>;<br>    <span class="hljs-comment">//其他成员与之前的版本一致</span><br>&#125;;<br><span class="hljs-comment">//首先处理返回类型，之后我们才进入Window_mgr的作用域</span><br><span class="hljs-function">Window_mgr::ScreenIndex    <span class="hljs-title">Window_mgr::addScreen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Screen &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>    screen.push_back(s);<br>    <span class="hljs-keyword">return</span> screen.size() - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="构造函数进阶"><a href="#构造函数进阶" class="headerlink" title="构造函数进阶"></a>构造函数进阶</h3><h4 id="构造函数的初始值有时候必不可少"><a href="#构造函数的初始值有时候必不可少" class="headerlink" title="构造函数的初始值有时候必不可少"></a>构造函数的初始值有时候必不可少</h4><p>如果没有在<strong>构造函数的初始值列表中显式地初始化成员</strong>（相当于定义就赋值），则该成员将在构造函数体<strong>之前进行默认初始化</strong>（构造函数中的已经是初始化之后的了）</p><p>如果成员是const或者是引用，必须将其初始化，类似的，当成员属于某种类类型且该类没有定义构造函数时，也必须将这个成员初始化。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstRef</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    ConstRef(<span class="hljs-keyword">int</span> li);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci;<br>    <span class="hljs-keyword">int</span> &amp;ri;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>ci是常量，ri是引用，都必须被初始化</p><p>如果我们没有为它们提供构造函数初始值的话将报错</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//错误：ci和ri必须被初始化</span><br>ConstRef::ConstRef(<span class="hljs-keyword">int</span> li)<br>&#123;<br>    i = ii;<span class="hljs-comment">//正确</span><br>    ci = ii;<span class="hljs-comment">//错误，不能给const赋值</span><br>    ri = ii;<span class="hljs-comment">//错误，ri没被初始化</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>随着构造函数体一开始执行，初始化就完成了，我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此该构造函数的正确形式应该是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//正确，显式地初始化引用和const成员</span><br>ConstRef::ConstRef(<span class="hljs-keyword">int</span> ii): i(ii), ci(ii), ri(i) &#123;&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>如果成员是const，引用，或者属于某种未提供默认构造函数地类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。</p></blockquote><blockquote><p>很多类中，初始化和赋值的区别事关底层效率：初始化直接初始化数据成员，赋值则是先初始化再赋值。</p><p>一些数据成员必须被初始化，因此要养成使用构造函数初始值的习惯。</p></blockquote><h4 id="成员初始化的顺序"><a href="#成员初始化的顺序" class="headerlink" title="成员初始化的顺序"></a>成员初始化的顺序</h4><p>构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序</p><p>成员的初始化顺序与它们在<strong>类定义中出现的顺序一致</strong>，第一个成员先被初始化，然后第二个，以此类推，构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p><p>只有一个成员是用另一个成员初始化额情况，两个成员的初始化顺序才比较重要</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> &#123;</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> j;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//未定义的，i在j之前被初始化</span><br>    X(<span class="hljs-keyword">int</span> val) : j(val), i(j) &#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>上述例子其实是错误的，从构造函数初始值的形式上看仿佛是先用val初始化了j，再用j初始化i，但实际上由于定义顺序，i先被未定义的j初始化。</p><blockquote><p>最好令构造函数初始值的顺序与成员声明的顺序保持一致，如果可能的话，尽量避免使用某些成员初始化其他成员。</p></blockquote><p>Sales_data的成员中有一个string类型的bookNo，下面两个构造函数，实际上的结果等价。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Sales_data() = <span class="hljs-keyword">default</span>;<br><br>Sales_data(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;&quot;</span>): bookNo(s) &#123;&#125;<br></code></pre></div></td></tr></table></figure><p>默认构造函数隐式地使用string的默认构造函数初始化bookNo，接收string实参的构造函数使用这个实参初始化bookNo</p><p>所以实际上，构造函数为我们的类提供了默认构造函数。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11新标准扩展了函数初始值的功能，是我们可以自定义<strong>委托构造函数</strong></p><p>一个委托构造函数也有一个成员初始值的列表和一个函数体，其他构造函数使用它的时候参数列表一定要匹配</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//非委托构造函数使用对应的实参初始化成员</span><br>    Sales_data(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">unsigned</span> cnt, <span class="hljs-keyword">double</span> price): bookNo(s), units_sold(cnt), revenue(cnt*price) &#123; &#125;<br>    <br>    <br>    <span class="hljs-comment">//其余构造函数全部委托给另一个构造函数</span><br>    Sales_data() : Sales_data(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123;&#125;<br>    Sales_data() : Sales_data(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123;&#125;<br>    Sales_data(<span class="hljs-built_in">std</span>::istream &amp;is) : Sales_data()<br>    &#123; read(is, *<span class="hljs-keyword">this</span>);&#125;<br>    <br>    <span class="hljs-comment">//其他成员与之前的版本一致。</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>三个构造函数都委托了工作。</p><p>第三个接受istream&amp;的构造函数也是委托构造函数，它委托给了默认的构造函数，默认构造函数又接着委托给三参数的构造函数，当这些受委托的构造函数执行完后，接着执行istream&amp;构造函数体的内容。</p><p>一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值和函数体被依次执行。</p><h4 id="使用默认构造函数"><a href="#使用默认构造函数" class="headerlink" title="使用默认构造函数"></a>使用默认构造函数</h4><p>下面能正常编译通过</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">Sales_data <span class="hljs-title">obj</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//正确，定义了一个函数而非对象</span><br><span class="hljs-keyword">if</span>(obj.isbn() == Primer_5th_ed.isbn())   <span class="hljs-comment">//错误，obj是个函数</span><br></code></pre></div></td></tr></table></figure><p>如果想定义一个使用默认构造函数进行初始化的对象，正确的方法是去掉对象名之后的空括号对</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//正确，obj是一个默认初始化对象</span><br>Sales_data obj;<br></code></pre></div></td></tr></table></figure><h4 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h4><p>比如Sales_data类，有两个构造函数，分别接受string实参和istream实参</p><p>在需要使用Sales_data的地方，我们可以直接使用String或者istream代替。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> null_book = <span class="hljs-string">&quot;9-999-99999-9&quot;</span>;<br><span class="hljs-comment">//构造一个临时的Sales_data对象</span><br><span class="hljs-comment">//该对象的units_sold和revenue等于0，bookNo等于null_book</span><br>item.combine(null_book);<br></code></pre></div></td></tr></table></figure><p>编译器用给定的string自动创建了一个Sales_data对象，新生成的这个临时的Sales_data对象被传递给了combine。combine的参数是一个常量引用，所以我们可以给该参数传递一个临时量。</p><p>隐式地类类型转换只允许一步</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//错误，需要用户定义的两种转换</span><br><span class="hljs-comment">//1.把&quot;9-999-99999-9&quot;转换为string</span><br><span class="hljs-comment">//2.把临时的string转换成Sales_data</span><br>item.combine(<span class="hljs-string">&quot;9-999-99999-9&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>如果想完成如上的调用，可以显式地把字符串转换成string或者Sales_data对象</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//正确：显式地转换成string，隐式地转换成Sales_data</span><br>item.combine(<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;9-999-99999-9&quot;</span>));<br><span class="hljs-comment">//正确：隐式地转换成string，显式地转换成Sales_data</span><br>item.combine(Sales_data(<span class="hljs-string">&quot;9-999-99999-9&quot;</span>));<br></code></pre></div></td></tr></table></figure><h5 id="抑制构造函数定义的隐式转换"><a href="#抑制构造函数定义的隐式转换" class="headerlink" title="抑制构造函数定义的隐式转换"></a>抑制构造函数定义的隐式转换</h5><p>可以将构造函数声明为explicit来阻止</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    Sales_data = <span class="hljs-keyword">default</span>;<br>    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">unsigned</span> n, <span class="hljs-keyword">double</span> p): bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Sales_data</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s)</span> : <span class="hljs-title">bookNo</span><span class="hljs-params">(s)</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Sales_data</span><span class="hljs-params">(istream&amp; is)</span></span><br><span class="hljs-function">    <span class="hljs-comment">//其他成员与之前地版本一致。</span></span><br><span class="hljs-function">    </span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样，之前的两种用法就都不对了，直接无法通过编译。</p><ul><li><p>explicit只对一个实参的构造函数有效，多个实参的构造函数也不能进行隐式转换。</p></li><li><p>只能在类内声明函数的时候使用，不能在类外定义的时候出现。</p></li></ul><ul><li><p>explicit构造函数只能用于直接初始化</p><p>发生隐式转换的一种情况是拷贝初始化（=），因此若类被限定explicit，就只能直接初始化而不能拷贝初始化</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">Sales_data <span class="hljs-title">item1</span><span class="hljs-params">(null_book)</span></span>;<span class="hljs-comment">//正确，直接初始化</span><br><span class="hljs-comment">//错误，不能将explicit的构造函数用于拷贝形式的初始化</span><br>Sales_data item2 = null_book;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="强制转换，显式使用构造函数"><a href="#强制转换，显式使用构造函数" class="headerlink" title="强制转换，显式使用构造函数"></a>强制转换，显式使用构造函数</h4><p>如果构造函数被explicit限定了，可以使用显式地强制进行转换</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//正确，实参是一个显式构造的Sales_data对象</span><br>item.combine(Sales_data(null_book));<br><span class="hljs-comment">//正确，static_cast可以使用explicit的构造函数</span><br>item.combine(<span class="hljs-keyword">static_cast</span>&lt;Sales_data&gt;(<span class="hljs-built_in">cin</span>));<br></code></pre></div></td></tr></table></figure><p>接受单参数的const char* 的string的构造函数不是explicit</p><p>接受一个容量参数的vector的构造函数，是explicit的</p><h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类，用户可以直接访问其成员，并且具有特殊的初始化语法形式。</p><p>特征如下</p><ul><li>所有的成员都是public</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类和vritual函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ival;<br>    <span class="hljs-built_in">string</span> a;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化形式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//vali.ival = 0; vali.s = stirng(&quot;Anna&quot;);</span><br>Data vali = &#123; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Anna&quot;</span>&#125;;<br></code></pre></div></td></tr></table></figure><p>初始值的顺序必须与声明的顺序一致，第一个成员的初始值要放在第一个，然后是第二个，依次类推。</p><p>存在三个明显的缺点</p><ol><li>要求类的所有成员都是public</li><li>将正确初始化每个对象每个成员的重任交给了类的用户，而不是类的作者。</li><li>添加或删除一个成员之后，所有初始化语句都要重新更新</li></ol><h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p>constexptr函数的参数和返回值必须是字面值类型，除了算术类型，引用和指针外，某些类也是字面值类型，和其他类不同，字面值类型的类可能含有constexptr函数成员，这样的成员必须符合constexptr函数的所有要求，它们是隐式const的。</p><p>。。。。。</p><h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>有时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。</p><p>比如银行账户类的基准利率。</p><h4 id="声明静态成员"><a href="#声明静态成员" class="headerlink" title="声明静态成员"></a>声明静态成员</h4><p>成员的声明之前加上关键字static，就可以将成员与类关联在一起。</p><p>和其他成员一样，静态成员可以是public或者private的，静态数据成员的类型可以是常量，引用，指针，类等等。</p><p>举个例子，定义银行的账户类。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> &#123;</span><br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123; amount += amount * interserRate; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">rate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> interesRate; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> owner;<br>    <span class="hljs-keyword">double</span> amount;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> interestRate;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">initRate</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。</p><p>因此每个Account对象将包含两个数据成员：owner和amount</p><p>只存在一个interestRate对象，并且它被所有Account对象共享。</p><p>静态成员也不与任何对象绑定在一起，它们不包含this指针，</p><p>作为结果，静态成员函数不能声明成const的，</p><p>而且我们也不能在static函数体内使用this指针，这一限制既使用用于this的显式使用，也对调用非静态成员的隐式使用有效。</p><h4 id="使用类的静态成员"><a href="#使用类的静态成员" class="headerlink" title="使用类的静态成员"></a>使用类的静态成员</h4><p>使用作用域符，直接访问静态成员</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">double</span> r;<br>r = Account::rate();<span class="hljs-comment">//使用作用域运算符访问静态成员</span><br></code></pre></div></td></tr></table></figure><p>使用对象访问</p><p>虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Account ac1;<br>Account *ac2 = &amp;ac1;<br><span class="hljs-comment">//调用静态成员函数rate的等价形式</span><br>r = ac1.rate();<span class="hljs-comment">//通过Account的对象或引用</span><br>r = ac2-&gt;rate();<span class="hljs-comment">//通过指向Account对象的指针</span><br></code></pre></div></td></tr></table></figure><p>成员函数不通过作用域运算符就能直接使用静态成员：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123; amount += amount * interestRate; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> interestRate;<br>    <span class="hljs-comment">//其他成员与之前的版本一致。</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="定义静态成员"><a href="#定义静态成员" class="headerlink" title="定义静态成员"></a>定义静态成员</h4><p>和其他成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数，当在类的外部定义静态成员时，不能重复static关键字，<strong>该关键字只能出现在类内部的声明语句</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Account::rate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newRate)</span></span><br><span class="hljs-function"></span>&#123;<br>    interestRate = newRate;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。</p><p>也就是说它们不是由类的构造函数初始化。</p><p>一般来说，不能在类的内部初始化静态成员，相反，必须在类的外部定义和初始化每个静态成员，和其他对象一样，一个静态数据成员只能定义一次。</p><p>类似于全局变量，静态数据成员定义在任何函数之外，因为它一旦被定义，就将一致存在于程序的整个生命周期中。</p><p>我们定义静态数据成员的方式和在类的外部定义成员函数差不多，我们需要指定对象的类型名，然后是类名，作用域运算符以及成员自己的名字。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//定义并初始化一个静态成员</span><br><span class="hljs-keyword">double</span> Account::interestRate = initRate();<br></code></pre></div></td></tr></table></figure><p>这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。</p><h4 id="静态成员的类内初始化"><a href="#静态成员的类内初始化" class="headerlink" title="静态成员的类内初始化"></a>静态成员的类内初始化</h4><p>通常情况下，类的静态成员不应该在类的内部初始化，然而我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr，初始值必须是常量表达式</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">rate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> interestRate; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> period = <span class="hljs-number">30</span>;<span class="hljs-comment">//period是常量表达式</span><br>    <span class="hljs-keyword">double</span> daily_tbl[period];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>period的唯一用途就是定义daily_tbl的维度，不需要在Account外面专门定义period，此时如果忽略了这条定义，那么对程序非常微小的改动也可能造成编译错误，因为程序找不到该成员的定义语句</p><p>比如把Account::period传递给一个接受一个const int&amp;的函数的时候，必须定义period</p><blockquote><p>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员</p></blockquote><p>如果在类的内部提供了一个初始值，那么成员的定义不能再指定一个初始值了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">constexptr <span class="hljs-keyword">int</span> Account::period;<span class="hljs-comment">//初始值在类的定义内提供</span><br></code></pre></div></td></tr></table></figure><p>类声明之后定义之前是一个<strong>不完全类型</strong>，也就是说，此时A是一个类类型，但是不清楚它到底包含哪些成员。</p><p><strong>不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针和或引用，也可以声明（但不是定义）以不完全类型作为参数或者返回类型的函数。</strong></p><p>类的成员：</p><p>因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是它自己，然而，一旦一个类的名字出现后，它就被认为是声明过了（但未定义），因此类允许包含指向自身类型的引用或指针。</p><p>静态数据成员可以是不完全类型,特别的，静态数据成员的类型可以是它所属的类类型，而非静态数据成员则受到限制，只能声明它所属类的指针或引用</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> Bar mem1;<span class="hljs-comment">//正确，静态成员可以是不完全类型</span><br>    Bar *mem2;<span class="hljs-comment">//正确，指针成员可以是不完全类型</span><br>    Bar mem3;<span class="hljs-comment">//错误，数据成员必须是完全类型</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以使用静态成员作为默认实参，但是非静态成员不行</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//bkground表示一个在类中稍后定义的静态成员</span><br>    <span class="hljs-function">Screen&amp; <span class="hljs-title">clear</span><span class="hljs-params">(<span class="hljs-keyword">char</span> = bkground)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> bkground;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>非静态成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从总获取成员的值。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——内敛函数以及constexpr函数</title>
    <link href="/2021/07/19/C++%E8%87%AA%E5%AD%A6%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8Aconstexpr%E5%87%BD%E6%95%B0/"/>
    <url>/2021/07/19/C++%E8%87%AA%E5%AD%A6%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8Aconstexpr%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>一段简单的代码，比较两个string形参的长度并返回长度较小的string的引用。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>把这种规模较小的操作定义成函数有很多好处</p><ul><li>阅读和理解shorterString函数的调用要比读懂等价的条件表达式容易得多</li><li>使用函数可以确保行为的统一，每次相关操作都能保证按照同样的方式进行</li><li>如果我们需要修改计算过程，显然修改函数要比先找到等价表达式所有出现的地方再逐一修改更容易</li><li>函数可以被其他应用重复利用，省去了程序员重新编写的代价</li></ul><p>但是，使用这个函数也存在一个潜在的缺点：调用函数一般比求等价表达式的值要慢，学习汇编语言我们知道调用函数要保存寄存器，拷贝实参等等操作</p><p>将函数指定为内联函数，可以让函数在每个调用点上“内联地”展开，</p><p>调用</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">cout</span> &lt;&lt; shorterstring(s1, s2) &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p>编译过程中展开成类似于下面的形式</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">cout</span> &lt;&lt; (s1.size() &lt; s2.size() ? s1 : s2) &lt;&lt; <span class="hljs-built_in">endl</span><br></code></pre></div></td></tr></table></figure><p>从而消除了shorterString函数的运行时开销</p><p>只要在shorterString函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//内联版本：寻找两个string对象中较短的那个</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;<br>shorterString(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2)<br>&#123;<br>    <span class="hljs-keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p></blockquote><p>一般来说，内联机制由于优化规模较小，频繁调用的函数，很多编译器都不支持内敛的递归函数。</p><h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h3><p>constexptr函数是指能用于常量表达式的函数，定义constexpr函数的方法与其他函数类似，不过要遵循几项规定：函数的<strong>返回类型及所有形参类型都得是字面值类型</strong>，而且函数体中必须有且<strong>只有一条retrun语句</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> foo = new_sz(); <span class="hljs-comment">//正确：foo是一个常量表达式</span><br></code></pre></div></td></tr></table></figure><p>new_sz定义成无参数的constexpr函数，因为编译器能在程序编译时验证new_sz函数返回的是常量表达式，所以可以用new_sz函数初始化contexpr类型的变量foo</p><p>执行初始化任务时，编译器把对constexpr函数的调用替换成其结果值，为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</p><p>constexpr函数体也可以包含其他语句，只要这些语句运行时不执行任何操作就行，比如空语句，类型别名，using声明。</p><p>我们也允许一个constexpr函数地返回值不是一个常量</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//如果arg是常量表达式，则scale(arg)也是一个常量表达式</span><br><span class="hljs-function">contexpr <span class="hljs-keyword">size_t</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> cnt)</span> </span>&#123; <span class="hljs-keyword">return</span> new_sz() * cnt;&#125;<br></code></pre></div></td></tr></table></figure><p>当scale的实参是常量表达式时，它的返回值也是常量表达式。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> arr[scale(<span class="hljs-number">2</span>)];<span class="hljs-comment">//正确，scale(2)是常量表达式</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<span class="hljs-comment">//i不是常量表达式</span><br><span class="hljs-keyword">int</span> a2[scale(i)];<span class="hljs-comment">//错误，scale(i)不是常量表达式</span><br></code></pre></div></td></tr></table></figure><h3 id="内联函数和constexpr函数应该放在头文件内"><a href="#内联函数和constexpr函数应该放在头文件内" class="headerlink" title="内联函数和constexpr函数应该放在头文件内"></a>内联函数和constexpr函数应该放在头文件内</h3><p>内联函数和constexpr函数可以在程序中多次定义，</p><p>不过对于某个给定的内联函数或者constexpr函数，它的多个定义必须完全一致，因此内联函数和constexpr函数通常定义在头文件。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>内联函数</tag>
      
      <tag>constexpr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——函数重载及默认实参</title>
    <link href="/2021/07/18/C++%E8%87%AA%E5%AD%A6%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <url>/2021/07/18/C++%E8%87%AA%E5%AD%A6%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一作用域内的几个<strong>函数名字相同但是形参列表不同</strong>，我们称之为重载函数</p><p>比如定义几个print函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *beg,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *end)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[],<span class="hljs-keyword">size_t</span> size)</span></span>;<br></code></pre></div></td></tr></table></figure><p>调用这些函数时，编译器会<strong>根据传递的实参类型推断</strong>想要的时哪个函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> j[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>print(<span class="hljs-string">&quot;Hello World&quot;</span>);<span class="hljs-comment">//调用print(const char*)</span><br>pirnt(j,end(j)-begin(j));<span class="hljs-comment">//调用print(const int*,size_t)</span><br>print(begin(j),end(j));<span class="hljs-comment">//调用print(const int*,const int*)</span><br></code></pre></div></td></tr></table></figure><p>函数重载在一定程度上可以减轻程序员起名字，记名字的负担</p><p>注意重载的定义，重载的函数应该在<strong>形参</strong>数量或者类型上有所不同，而与<strong>返回类型</strong>无关</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>;<br><span class="hljs-comment">//错误，与上一个函数相比只有返回类型不同</span><br></code></pre></div></td></tr></table></figure><p>有时候两个形参列表看起来不一样，实际上是相同的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account &amp;acct)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>;<br><span class="hljs-comment">//形参的名字仅仅起到帮助记忆的作用，有没有它并不影响形参列表的内容</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> Phone Telno;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Phone&amp;)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Telno&amp;)</span></span>;<br><span class="hljs-comment">//仅仅是别名，形参还是一样</span><br></code></pre></div></td></tr></table></figure><p>同样，顶层的const不影响传入函数的对象，一个拥有顶层const的形参无法与一个没有顶层const的形参区分开来</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Phone)</span></span>;<br></code></pre></div></td></tr></table></figure><p>但是如果形参是某种类型的指针或者引用，通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account&amp;)</span></span>;<span class="hljs-comment">//函数作用与Account的引用</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>;<span class="hljs-comment">//新函数，作用于常量引用</span><br><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account*)</span></span>;<span class="hljs-comment">//函数作用于指向Account的指针</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account*)</span></span>;<span class="hljs-comment">//新函数，作用于指向常量的指针</span><br></code></pre></div></td></tr></table></figure><p>编译器会<strong>优先选用非常量版本的函数</strong></p><h4 id="const-cast在重载中的作用"><a href="#const-cast在重载中的作用" class="headerlink" title="const_cast在重载中的作用"></a>const_cast在重载中的作用</h4><p>比如之前的函数shortString</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.size()&lt;= s2.size()?s1:s2;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string的引用，因此我们需要一种新的shorterString函数，<strong>当它的实参不是常量时，得到的结果是一个普通的引用</strong>，使用const_cast可以做到这一点</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">string</span> &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s1,<span class="hljs-built_in">string</span> &amp;s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> &amp;r = shorterString(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;&gt;(s1),<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;&gt;(s2));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-built_in">string</span>&amp;&gt;(r);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>先将<strong>实参强制转换为const，再将返回的const转换为普通的</strong>，显然很安全</p><h4 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h4><p>内层作用域中声明名字，将隐藏外层作用域中声明的 同名实体。在不同的作用域中无法重载函数名</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>; <span class="hljs-comment">//重载print函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foobar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ival)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span> read = fasle;<span class="hljs-comment">//新作用域，隐藏了外层的read</span><br>    <span class="hljs-built_in">string</span> s = read();<span class="hljs-comment">//错误，read是一个布尔值，不是一个函数，read将外面的read()覆盖了</span><br>    <br>    <span class="hljs-comment">//下面是不好的习惯，通常来说，在局部作用域中声明函数不是一个好的选择</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-comment">//新作用域，隐藏了之前的print</span><br>    print(<span class="hljs-string">&quot;Value: &quot;</span>);<span class="hljs-comment">//错误，print(const string &amp;)被隐藏掉了</span><br>    print(ival);<span class="hljs-comment">//正确：当前print(int)可见</span><br>    print(<span class="hljs-number">3.14</span>);<span class="hljs-comment">//正确，调用print(int);print(double)被隐藏掉了</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>调用read的时候，找到的是定义在局部作用域中的read，这个名字是布尔变量，我们无法调用一个布尔值</p><p>调用print同样，编译器首先寻找对该函数名的声明，找到的是接受int的那个局部声明，一旦当前作用域中找到了所需的名字，编译器就会忽略外层作用域中的同名实体，剩下的工作就是检查函数调用是否有效。</p><p>第一个调用传入一个字符串字面值，但是当前作用域内的print函数唯一声明要求参数是int，字符串无法转换为int类型，外层作用域的那个函数被隐藏，不会被考虑</p><p>传入double，重复上述过程，编译器发现当前作用域的print(int)函数，double类型被转换为int类型，因此调用合法。</p><p>如果把这三个print放到一个作用域，则成为另一种形式，三种调用都合法。</p><h3 id="函数的默认实参"><a href="#函数的默认实参" class="headerlink" title="函数的默认实参"></a>函数的默认实参</h3><p>调用含有默认实参的函数，可以包含该实参，也可以忽略该实参</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">string</span>::size_type sz;<br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz ht = <span class="hljs-number">24</span>,sz wid = <span class="hljs-number">80</span>,<span class="hljs-keyword">char</span> backgrnd = <span class="hljs-string">&#x27; &#x27;</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>希望使用默认值，但是也允许用户对参数指定任意不同数值。</p><p>为每一个形参都提供了默认实参，默认实参作为形参的初始值出现在形参列表中，我们可以为一个或多个形参定义默认值，不过需要注意，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值（定义的时候）</p><p>调用的时候，由于screen函数为它所有的形参都提供了默认实参，所以可以使用0，1，2，3个实参调用该函数。</p><p>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的<strong>尾部实参(靠右侧位置）</strong>。即只能省略尾部的实参</p><figure class="highlight sas"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sas"><span class="hljs-meta">window</span> = scre<span class="hljs-meta">en(</span>);//等价于scre<span class="hljs-meta">en(</span>24,80,<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-meta">window</span> = scre<span class="hljs-meta">en(</span>66);//等价于scre<span class="hljs-meta">en(</span>66,80,<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-meta">window</span> = scre<span class="hljs-meta">en(</span>66,256);//等价于scre<span class="hljs-meta">en(</span>66,256,<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-meta">window</span> = scre<span class="hljs-meta">en(</span>,,<span class="hljs-string">&#x27;?&#x27;</span>);//错误，只能省略尾部实参<br><span class="hljs-meta">window</span> = scre<span class="hljs-meta">en(</span><span class="hljs-string">&#x27;?&#x27;</span>);//调用scre<span class="hljs-meta">en(</span><span class="hljs-string">&#x27;?&#x27;</span>,80,<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>函数重载，默认实参</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——函数传参之传引用参数</title>
    <link href="/2021/07/15/C++%E8%87%AA%E5%AD%A6%E4%BC%A0%E5%8F%82%E5%BC%95%E7%94%A8/"/>
    <url>/2021/07/15/C++%E8%87%AA%E5%AD%A6%E4%BC%A0%E5%8F%82%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="函数参数传递之传引用参数"><a href="#函数参数传递之传引用参数" class="headerlink" title="函数参数传递之传引用参数"></a>函数参数传递之传引用参数</h3><p>C语言中想要改变传入的值，只能传指针，十分麻烦。</p><p>C++中提供了引用，可以直接对实参修改。</p><h4 id="使用引用避免拷贝"><a href="#使用引用避免拷贝" class="headerlink" title="使用引用避免拷贝"></a>使用引用避免拷贝</h4><p>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用参数访问该类型 的对象</p><p>编写函数比较两个string对象的长度，因为string对象可能会非常长，避免尽量直接拷贝它们，使用引用形参比较明确，因为比较长度无须改变string对象的内容，所以把形参定义成对常量的引用</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//比较两个string对象的长度</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.size() &lt; s2.size();<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>如果函数无须改变引用形参的值，最好将其声明为常量引用</p></blockquote><h4 id="使用引用形参返回额外信息"><a href="#使用引用形参返回额外信息" class="headerlink" title="使用引用形参返回额外信息"></a>使用引用形参返回额外信息</h4><p>一个函数只能返回一个值，然而有时函数<strong>需要同时返回多个值</strong>，引用形参为我们一次返回多个结果提供了有效的途径。</p><p>下面的函数返回string对象中某个指定字符第一次出现的位置。同时，我们也希望函数能返回该字符出现的总次数</p><p>既返回位置也返回出现次数，<strong>一种方式是定义一个新的数据类型，让它包含位置和数据两个成员。</strong>还有另一种更简单的方法，我们可以<strong>给函数传入一个额外的引用实参，令其保存字符出现的次数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//返回s中c第一次出现的位置索引</span><br><span class="hljs-comment">//引用形参occurs负责统计c出现的总次数</span><br><span class="hljs-function"><span class="hljs-built_in">string</span>::size_type <span class="hljs-title">find_char</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">char</span> c, <span class="hljs-built_in">string</span>::size_type &amp;occurs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> ret = s.size();<span class="hljs-comment">//第一次出现的位置（如果有的话）</span><br>    occurs = <span class="hljs-number">0</span>;<span class="hljs-comment">//设置表示出现次数的形参的值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">decltype</span>(ret) i = <span class="hljs-number">0</span>;i!=s.size();++i)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == c)&#123;<br>            <span class="hljs-keyword">if</span>(ret == s.size())<br>                ret = i;<span class="hljs-comment">//记录c第一次出现的位置</span><br>            ++occurs;<span class="hljs-comment">//将出现的次数加一</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<span class="hljs-comment">//出现次数通过occurs隐式地返回</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>主函数中调用如下</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> index = find_char(s,<span class="hljs-string">&#x27;o&#x27;</span>,ctr);<br></code></pre></div></td></tr></table></figure><p>调用完成后，如果string对象中确实存在o，那么ctr的值就是o出现的次数，index指向o第一次出现的位置。</p><p>否则如果string对象中没有o，index等于s.size()而ctr等于0。</p><ul><li><p>尽量使用常量引用，原因有以下两点</p><p><strong>把函数不会改变的形参定义成普通的引用是一种比较常见的错误</strong>，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。</p></li><li><p>使用非常量引用会<strong>极大地限制函数所能接受的实参类型</strong>，我们不能把const对象，字面值或者需要类型转换的对象传递给普通的引用形参。</p><p>如果上面的find_char，string类型形参定义成普通的string&amp;</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//如下是不良设计，第一个形参的类型应该是const string&amp;</span><br><span class="hljs-function"><span class="hljs-built_in">string</span>::size_type <span class="hljs-title">find_char</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s,<span class="hljs-keyword">char</span> c,<span class="hljs-built_in">string</span>::size_type &amp;occurs)</span></span>;<br></code></pre></div></td></tr></table></figure><p>​        只能将find_char函数作用于string对象，类似下面这样调用**”Hello world”这个常量**将在编译时发生错误</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">find_char(<span class="hljs-string">&quot;Hello World&quot;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,ctr);<br></code></pre></div></td></tr></table></figure><p>​        还有一个错误是，其他函数将形参定义成常量引用，在这个函数中无法正确调用find_char，因为find_char无法调用常量</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_sentence</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//如果在s的末尾有且只有一个句号，则s是一个句号</span><br>    <span class="hljs-built_in">string</span>::size_type ctr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> find_char(s,<span class="hljs-string">&#x27;.&#x27;</span>,ctr) == s.size() <span class="hljs-number">-1</span> &amp;&amp; ctr == <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>参数传递时顶层const会被忽略</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">/*fcn能读取i，但是不能向i写值*/</span>&#125;<br></code></pre></div></td></tr></table></figure><p>调用fcn函数时，既可以传入const int，也可以传入int</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">/*fcn能读取i，但是不能向i写值*/</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">/*……*/</span>&#125;   <span class="hljs-comment">//错误，重复定义了fcn(int)</span><br></code></pre></div></td></tr></table></figure><p>C++中，允许我们定义有若干相同名字的函数，但是前提是不同函数的形参列表应该有明显的区别，因为顶层const被忽略掉了，所以在上面的代码中传入两个fcn函数的参数可以完全一样。因此第二个fcn是错误的</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>传引用参数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——头文件保护符</title>
    <link href="/2021/07/15/C++%E8%87%AA%E5%AD%A6%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E7%AC%A6/"/>
    <url>/2021/07/15/C++%E8%87%AA%E5%AD%A6%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>大一的时候C语言程序设计实验中因为不添加头文件保护符扣了不少分</p><p>头文件保护符十分重要，可以防止include的库被多次include等</p><h4 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h4><p>为了确保各个文件中类的定义一致，<strong>类通常被定义在头文件中</strong>，而<strong>类所在头文件的名字应与类的名字一致</strong>。</p><p>例如 库类型String在名为string的头文件中定义，Sales_data类定义在名为Sales_data.h的头文件中</p><p>头文件通常包含那些只能被定义一次的实体，例如类，const和constexptr变量，头文件也可以用到别的头文件。</p><ul><li><strong>头文件保护符</strong></li></ul><p>依赖于预处理变量，预处理变量由两种状态：已定义和未定义。</p><p>#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定处的预处理变量是否已经定义</p><p>#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真</p><p><strong>一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。</strong></p><p>有效防止重复包含的发生</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SALES_DATA_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SALES_DATA_H</span><br><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span>&#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;<br>    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;<br><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p>整个程序中的预处理变量包括<strong>头文件保护符必须唯一</strong>，通常的做法是基于<strong>头文件中类的名字来构建保护符的名字，以确保其唯一性。</strong>为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字<strong>全部大写。</strong></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210707144807485.png" alt="image-20210707144807485"></p><p><strong>头文件中不能使用using声明</strong>，这是因为头文件的内容会拷贝到引用它的文件中，如果头文件里有某个using声明，那么每个使用了该头文件的文件都会有这个声明，对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>头文件保护符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——main处理命令行以及含有可变参数的函数</title>
    <link href="/2021/07/14/C++%E8%87%AA%E5%AD%A6main%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A5%E5%8F%8A%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    <url>/2021/07/14/C++%E8%87%AA%E5%AD%A6main%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A5%E5%8F%8A%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="main处理命令行选项"><a href="#main处理命令行选项" class="headerlink" title="main处理命令行选项"></a>main处理命令行选项</h3><p>假定main函数在可执行文件prog之内，可以向程序传递下面的选项：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">prog -d -o ofile data0<br></code></pre></div></td></tr></table></figure><p>这些命令行选项通过两个可选的形参传递给main函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>根据上面命令行的输入</p><blockquote><p>argc = 5；</p><p>argv[0] = “prog”;</p><p>argv[1] = “-d”;</p><p>argv[2] = “-o”;</p><p>argv[3] = “ofile”;</p><p>argv[4] = “data0”;</p><p>argv[5] = “0”;</p></blockquote><p>第一个一定为程序名，最后一个为0</p><h3 id="含有可变参数的函数"><a href="#含有可变参数的函数" class="headerlink" title="含有可变参数的函数"></a>含有可变参数的函数</h3><p>C++11有两种主要的方法</p><ol><li>所有实参类型相同，可以传递一个名为initializer_list的标准库类型。</li><li>实参的类型不同，我们可以编写一种特殊的函数。可变参数模板</li></ol><p>initializer_list形参</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210712150241433.png" alt="image-20210712150241433"></p><p>与vector一样，initializer_list也是一种模板类型，定义initializer_list对象时，必须说明列表中所含元素的类型</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-built_in">string</span>&gt; ls;<br><span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-keyword">int</span>&gt; li;<br></code></pre></div></td></tr></table></figure><p>与vector不一样，initializer_list对象中的元素永远是常量值，无法改变initializer_list对象中元素的值。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_msg</span><span class="hljs-params">(<span class="hljs-built_in">initializer_list</span>&lt;<span class="hljs-built_in">string</span>&gt; il)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> beg = il.begin();beg != il.end(); ++beg)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>调用时若想传递一个值的序列，就必须把序列放在一对花括号内</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(expected!=actual)<br>    error_msg(&#123;<span class="hljs-string">&quot;functionX&quot;</span>,expected,actual&#125;);<br><span class="hljs-keyword">else</span><br>    error_msg(&#123;<span class="hljs-string">&quot;functionX&quot;</span>,<span class="hljs-string">&quot;okay&quot;</span>&#125;);<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>main命令行</tag>
      
      <tag>可变参数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——vector</title>
    <link href="/2021/07/14/C++%E8%87%AA%E5%AD%A6vector/"/>
    <url>/2021/07/14/C++%E8%87%AA%E5%AD%A6vector/</url>
    
    <content type="html"><![CDATA[<h3 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>;<br></code></pre></div></td></tr></table></figure><p>标准库类型vector表示<strong>对象的集合</strong>，其中<strong>所有对象的类型都相同</strong>。集合中的每个对象都有一个与之对应的索引，索引用于访问对象，因为<strong>vector容纳着其他对象</strong>，所以也经常被称为<strong>容器。</strong></p><p>C++中有<strong>类模板和函数模板</strong>，其中vector是类模板，模板本身不是类或者函数，但是可以将模板看作为编译器生成类或函数编写的一份说明，编译器根据模板创建类或函数的过程称为实例化。使用模板的时候，需要指出编译器应该把类或函数实例化成何种类型。</p><p>类模板，需要提供额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定，提供信息在模板名字后面跟一对尖括号</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ivec;<span class="hljs-comment">//ivec保存int类型的对象</span><br><span class="hljs-built_in">vector</span>&lt;Sales_item&gt; Sales_vec;<span class="hljs-comment">//保存Sales_item类型的对象</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; file;<span class="hljs-comment">//该向量的元素是vector对象</span><br></code></pre></div></td></tr></table></figure><p>上面，编译器根据模板生成了三种不同的类型。</p><blockquote><p>vector是模板而不是类型，vector生成的类型必须包括vector中元素的类型，如vector&lt;int&gt;</p></blockquote><p>vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，因此不存在包含引用的vector</p><p>除此之外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector</p><h3 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;T&gt; v1;<span class="hljs-comment">//v1是一个空vector，它潜在的元素是T类型的，执行默认初始化</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1)</span></span>;<span class="hljs-comment">//v2中包含v1所有元素的副本</span><br><span class="hljs-built_in">vector</span>&lt;T&gt; v2 = v1;<span class="hljs-comment">//等价于v2(v1),v2包含有v1所有元素的副本</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">v3</span><span class="hljs-params">(n,val)</span></span>;<span class="hljs-comment">//v3包含了n个重复的元素，每个元素的值都是val</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">v4</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">//v4包含了n个重复地执行了值初始化的对象</span><br><span class="hljs-built_in">vector</span>&lt;T&gt; v5&#123;a,b,c...&#125;;<span class="hljs-comment">//v5包含了初始值个数的元素，每个元素被赋予相应的初始值。</span><br><span class="hljs-built_in">vector</span>&lt;T&gt; v5=&#123;a,b,c...&#125;<span class="hljs-comment">//等价于v5&#123;a,b,c...&#125;</span><br></code></pre></div></td></tr></table></figure><ul><li><p>默认值，如果vector的对象为内置类型，设为0，若是某种类型比如string，则默认初始化</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec; <span class="hljs-comment">//默认初始化，svec不含任何元素</span><br></code></pre></div></td></tr></table></figure><p>空vector可以高效地往vector对象中添加元素，可以先定义一个空的vector，然后当运行时获取到元素的值后再逐一添加</p><p>值初始化</p><p>可以<strong>只提供vector对象容纳的元素数量</strong>而不用略去初始值，此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素，这个值由vector对象中的元素类型决定</p><p>比如如果是int这样的内置类型，则元素初始值自动设为0，如果元素是某种类型，比如string，则元素由类默认初始化</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//10个元素，每个都初始化为0</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//10个元素，每个都是空string对象</span><br></code></pre></div></td></tr></table></figure><p>如果vector对象中元素的不支持默认初始化，我们就必须提供初始的元素值，对这种类型的元素来说，只提供元素的数量而不设定初始值无法完成初始化工作。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vi = <span class="hljs-number">10</span>;<span class="hljs-comment">//错误，必须使用直接初始化的形式指定向量大小</span><br></code></pre></div></td></tr></table></figure><p>这里的10是用来说明如何初始化vector对象的，我们用它的本意是想创建含有10个值初始化了的元素的vector对象，而非把数字10拷贝到vector中。因此此时不宜使用拷贝初始化</p></li><li><p>相同类型的vector才可以互相赋值</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ivec;<span class="hljs-comment">//初始状态为空</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec2</span><span class="hljs-params">(ivec1)</span></span>;<span class="hljs-comment">//把ivec的元素拷贝给ivec2</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ivec3 = ivec;<span class="hljs-comment">//把ivec的元素拷贝给ivec3</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">svec</span><span class="hljs-params">(ivec2)</span></span>;<span class="hljs-comment">//错误，svec的元素是string对象，不是int</span><br></code></pre></div></td></tr></table></figure></li></ul><ul><li><p>初始化的真实含义依赖于传递初始值时用的花括号还是圆括号</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//v1有10个元素，每个值都是0</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2&#123;<span class="hljs-number">10</span>&#125;;<span class="hljs-comment">//v2有1个元素，该元素的值是10</span><br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//v3有10个元素，每个的值都是1</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v4&#123;<span class="hljs-number">10</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//v4有2个元素，值分别是10和1</span><br></code></pre></div></td></tr></table></figure><p>圆括号，说明是用来构造vector对象</p><p>花括号，则是列表初始化</p><p>但是，若使用了花括号的形式，但是提供的值不能用来列表初始化，那么根据<strong>值的类型</strong>是否与<strong>元素类型</strong>相同来判断。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; v5&#123;<span class="hljs-string">&quot;hi&quot;</span>&#125;;   <span class="hljs-comment">//列表初始化，v5有一个元素</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">v6</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>)</span></span>;<span class="hljs-comment">//错误，不能使用字符串字面值构建vector对象</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; v7&#123;<span class="hljs-number">10</span>&#125;;<span class="hljs-comment">//v7有10个默认初始化的元素</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; v8&#123;<span class="hljs-number">10</span>,<span class="hljs-string">&quot;hi&quot;</span>&#125;;<span class="hljs-comment">//v8有10个值为“hi”的元素</span><br></code></pre></div></td></tr></table></figure></li></ul><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>使用成员函数 push_back</p><p>比如想要构造一个0到99的vector对象</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i!= <span class="hljs-number">100</span>; ++i)<br>    v2.push_back(i);<br></code></pre></div></td></tr></table></figure><p>或者运行时才知道要输入的数量</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> word;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; text;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;word)&#123;<br>    text.push_back(word);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210708175119686.png" alt="image-20210708175119686"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210708175130256.png" alt="image-20210708175130256"></p><blockquote><p>如果在循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。</p></blockquote><h4 id="vector的一些其他操作"><a href="#vector的一些其他操作" class="headerlink" title="vector的一些其他操作"></a>vector的一些其他操作</h4><ul><li>与string大致差不多</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210708175343943.png" alt="image-20210708175343943"></p><ul><li>访问方法也差不多，可以使用范围for语句处理vector对象中的所有元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">//求每个元素的平方</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i : v)<br>    i *= i;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : v)<br>    <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><ul><li>vector的size的返回值类型为vector定义的size_type，要使用size_type，首先指定它是由哪种类型定义的。<strong>vector对象的类型总是包含着元素的类型</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::size_type;   <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">vector</span>::size_type;<span class="hljs-comment">//错误</span><br></code></pre></div></td></tr></table></figure><ul><li>vector的比较也是字典序，但是要求里面元素的值可以比较。</li></ul><ul><li>vector的索引，也是从0开始计下标</li></ul><p>比如以10分为一个分数段统计成绩的数量：0<del>9，10</del>19，……90~99，100</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span>&gt; <span class="hljs-title">scores</span><span class="hljs-params">(<span class="hljs-number">11</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//11个分数段，全都初始化为0</span><br><span class="hljs-keyword">unsigned</span> grade;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; grade)&#123;<br>    <span class="hljs-keyword">if</span>(grade &lt;= <span class="hljs-number">100</span>)<br>        ++scores[grade/<span class="hljs-number">10</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>添加元素一定要用push_back，而不要用下标直接添加，是不对的，一个空的vector是根本不包含任何元素的。</li></ul><p>vector对象（以及string对象）的下标运算符可以用于访问已经存在的元素，而不能用于添加元素</p><p>只能对明确已存在的元素执行下标操作</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ivec;<span class="hljs-comment">//空vector对象</span><br><span class="hljs-built_in">cout</span> &lt;&lt; ivec[<span class="hljs-number">0</span>];<span class="hljs-comment">//错误，invc不包含任何元素</span><br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//含有10个元素的vector对象</span><br><span class="hljs-built_in">cout</span> &lt;&lt; ivec2[<span class="hljs-number">10</span>];<span class="hljs-comment">//错误，ivec元素的合法索引是从0到9</span><br></code></pre></div></td></tr></table></figure><p>以下的代码试图为vector对象ivec添加10个元素</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ivec;<span class="hljs-comment">//空vector对象</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">decltype</span>(ivec.size()) ix = <span class="hljs-number">0</span>; ix != <span class="hljs-number">10</span>; ++ix)<br>    ivec[ix] = ix;<span class="hljs-comment">//严重错误，ivec不包含任何元素</span><br></code></pre></div></td></tr></table></figure><p>ivec是一个空vector，根本不包含任何元素，当然也就不能通过下标去访问任何元素，正确的方法是使用push_bak</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">decltype</span>(ivec.size()) ix = <span class="hljs-number">0</span>; ix != <span class="hljs-number">10</span>; ++ix)<br>    ivec.push_back(ix);<span class="hljs-comment">//正确，添加一个新元素，该元素是ix</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——标准库类型String以及cctype头文件</title>
    <link href="/2021/07/14/C++%E8%87%AA%E5%AD%A6string/"/>
    <url>/2021/07/14/C++%E8%87%AA%E5%AD%A6string/</url>
    
    <content type="html"><![CDATA[<h3 id="标准库类型String"><a href="#标准库类型String" class="headerlink" title="标准库类型String"></a>标准库类型String</h3><p>学习C语言的时候，对于字符串的处理只能使用字符数组，十分麻烦，C++中有了标准库类型String，对于字符串的处理就简单了很多</p><p>使用前提</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>;<br></code></pre></div></td></tr></table></figure><p>初始化字符串的方式</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> s1;<span class="hljs-comment">//默认初始化，s1是一个空串</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<span class="hljs-comment">//s2是s1的副本</span><br><span class="hljs-built_in">string</span> s2 = s1;<span class="hljs-comment">//等价于s2(s1),s2是s1的副本</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>;<span class="hljs-comment">//s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符外。</span><br><span class="hljs-built_in">string</span> s3 = <span class="hljs-string">&quot;value&quot;</span>;<span class="hljs-comment">//等价于s3(&quot;value&quot;)，s3是字面值&quot;value”的副本</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s4</span><span class="hljs-params">(n,<span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;<span class="hljs-comment">//把s4初始化为连续n个字符c组成的串</span><br></code></pre></div></td></tr></table></figure><h4 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h4><p>拷贝初始化，直接用=初始化，编译器将等号右侧的初始值拷贝到新创建的对象</p><p>直接初始化，不使用=</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> s5 = <span class="hljs-string">&quot;hiya&quot;</span>;<span class="hljs-comment">//拷贝初始化</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s6</span><span class="hljs-params">(<span class="hljs-string">&quot;hiya&quot;</span>)</span></span>;<span class="hljs-comment">//直接初始化</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s7</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;<span class="hljs-comment">//直接初始化，s7的内容是cccccccccc</span><br></code></pre></div></td></tr></table></figure><p>如果一定要用拷贝初始化，需要显式地创建一个临时对象用于拷贝</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> s8 = <span class="hljs-built_in">string</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br><span class="hljs-comment">//等价于先使用数字10和字符c两个参数创建出一个string对象，然后这个string对象又拷贝给了s8，实质上等价于下面的两条语句</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;<br><span class="hljs-built_in">string</span> s8 = temp;<br></code></pre></div></td></tr></table></figure><h4 id="string的基本操作"><a href="#string的基本操作" class="headerlink" title="string的基本操作"></a>string的基本操作</h4><ol><li><p><strong>os &lt;&lt; s</strong></p><p>将s写到输出流os中，返回os</p></li><li><p><strong>is &gt;&gt; s</strong></p><p>从is中读取字符串赋给s，字符串以空白分隔，返回is</p></li><li><p><strong>getline(is, s)</strong></p><p>从is中读取一行，赋给s，并返回is</p></li><li><p><strong>s.empty()</strong></p><p>s为空返回true，否则返回false</p></li><li><p><strong>s.size()</strong></p><p>返回s中字符的个数</p></li><li><p><strong>s[n]</strong></p><p>返回s中第n个字符的引用，位置n从0计起，类似C中的字符数组</p></li><li><p><strong>s1+s2</strong></p><p>返回s1和s2连接后的结果</p></li><li><p><strong>s1=s2</strong></p><p>用s2的<strong>副本</strong>代替s1中原来的字符</p></li><li><p>s1==s2（s1！=s2）</p><p>如果s1和s2中所含的字符<strong>完全一样</strong>，则它们相等，string对象的相等性判断，对字母的<strong>大小写敏感</strong></p></li><li><p>&lt; &lt;= &gt; &gt;=</p><p>利用字符在<strong>字典中的顺序</strong>进行比较，且对字母的<strong>大小写敏感</strong></p></li></ol><h4 id="string的读写"><a href="#string的读写" class="headerlink" title="string的读写"></a>string的读写</h4><p>string的读写很简单，同样可以使用标准库iostream来读写</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> s;<span class="hljs-comment">//空字符串</span><br><span class="hljs-built_in">cin</span> &gt;&gt; s;<br></code></pre></div></td></tr></table></figure><p>若输入”Hello World!”，那么s的内容是”Hello”，不存在后面的部分，在空格部分截断了</p><p>因为在执行<strong>读取操作的时候</strong>，string会<strong>自动忽略开头的空白</strong>(空格符，换行符，制表符)，并从第一个真正的字符开始读起，直到<strong>遇见下一处空白为止</strong>。</p><p>因此若是输入”               Hello World!”，结果还是Hello</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> s1,s2;<br><span class="hljs-built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;<span class="hljs-comment">//把第一个输入读到s1中，第二个输入读到s2中</span><br><span class="hljs-built_in">cout</span> &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出两个string的对象</span><br></code></pre></div></td></tr></table></figure><p>若还是输入Hello World！</p><p>s1为”Hello”,s2为”World!”，s2之前的空格忽略</p><p>因此输出为HelloWorld!</p><p>当string当作while的判断条件，比如</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;word)<br></code></pre></div></td></tr></table></figure><p>可以读取未知数量的string对象，只有读入文件结束符的时候，才能结束</p><p>getline可以<strong>读取一整行</strong>，<strong>保留输入时的空白符</strong>，直到<strong>遇到换行符</strong>才停止读入内容（换行符也被读取，但是读取的内容存入string的时候，string不保存换行符）。</p><p>getline一遇到换行符就结束，哪怕输入的一开始就是换行符也是这样，只不过这样得到的是空string</p><p>如下是一个每次输出一整行的程序</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> line;<br><span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>,line))<br>    <span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><p>getline中不包含换行，因此要手动地加上换行操作符，使用endl结束当前行并刷新显示缓冲区</p><h4 id="empty和size"><a href="#empty和size" class="headerlink" title="empty和size"></a>empty和size</h4><p>empty用于判断是否为空字符串，size是返回字符串地长度</p><p>如下程序，只有line不为空地时候才输出，因此可以做到只输出非空的行。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>,line))<br>    <span class="hljs-keyword">if</span>(!line.empty())<br>        <span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p>只有不为空的时候才输出，若为空行则跳过</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>,line))<br>    <span class="hljs-keyword">if</span>(line.size() &gt; <span class="hljs-number">80</span>)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p>每次读入一整行，输出超过80个字符的行</p><ul><li><p>size函数返回的是一个string::size_type类型的值</p><p>stirng类及其他的大多数标准库类型都定义了几种配套的类型，这些配套类型体现了标准库类型与机器无关的特性，size_type就是一种。</p><p>所有用于存放string类的size函数返回值的变量，都应该是string::size_type类型的。</p></li><li><p>可以使用auto和decltype来推断变量的类型、</p></li></ul><blockquote><p>如果一条表达式中已经有了size()的函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题</p><p>比如</p><p>s.size() &lt; n;</p><p>n若是一个负值的int，则上述表达式就为true，负值n会自动地转换成一个较大的无符号值。</p></blockquote><h4 id="比较，赋值，相加"><a href="#比较，赋值，相加" class="headerlink" title="比较，赋值，相加"></a>比较，赋值，相加</h4><ul><li><p>比较是按照字典序排序</p></li><li><p>string的赋值向内置类型看齐，允许把一个对象的值赋给另一个对象</p><p>s1=s2，将s2的副本替换s1的内容</p></li><li><p>相加</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">&quot;hello,&quot;</span>,s2 = <span class="hljs-string">&quot;world\n&quot;</span>;<br><span class="hljs-built_in">string</span> s3 = s1 + s2;<span class="hljs-comment">//s3的内容是hello，world\n</span><br>s1 += s2;<span class="hljs-comment">//等价于s1 = s1 + s2</span><br></code></pre></div></td></tr></table></figure></li><li><p>字面值与string相加</p><p>字面值 + string -&gt; string</p><p>但是字面值不能与字面值相加</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">&quot;hello&quot;</span> , s2 = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-built_in">string</span> s3 = s1 + <span class="hljs-string">&quot;,&quot;</span> + s2 + <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br><span class="hljs-built_in">string</span> s4 = s1 + <span class="hljs-string">&quot;,&quot;</span>;   <span class="hljs-comment">//正确，string和字面量相加</span><br><span class="hljs-built_in">string</span> s5 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;,&quot;</span>;<span class="hljs-comment">//错误，两个运算对象都不是string</span><br><br><span class="hljs-built_in">string</span> s6 = s1 + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-built_in">string</span> s7 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;,&quot;</span> + s2;<span class="hljs-comment">//错误，不能将字面量直接相加</span><br><span class="hljs-comment">//s7这个语句等价于下面</span><br><span class="hljs-built_in">string</span> s7 = (<span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;,&quot;</span>) + s2;<br></code></pre></div></td></tr></table></figure><p>上述标准与Java十分类似。</p></li></ul><h3 id="cctype头文件"><a href="#cctype头文件" class="headerlink" title="cctype头文件"></a>cctype头文件</h3><p>上述头文件中的函数可以用于处理string对象中的字符</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210708163020776.png" alt="image-20210708163020776"></p><p>C++版本的C标准库头文件，兼容了C语言的，</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210708164313086.png" alt="image-20210708164313086"></p><h4 id="范围for语句修改sting全部字符"><a href="#范围for语句修改sting全部字符" class="headerlink" title="范围for语句修改sting全部字符"></a>范围for语句修改sting全部字符</h4><p>类似java中的增强for语句，处理全部字符的时候，就用基于范围的for语句</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(declaration : expression)<br>    statement<br></code></pre></div></td></tr></table></figure><p>expression是一个对象，表示一个序列，declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素，每次迭代，declaration部分的变量会被初始化为expression的下一个元素值</p><p>下面一个简单例子，范围for语句把string对象中的字符每行一个的输出出来</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<br><span class="hljs-comment">//每行输出str中的一个字符</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : str)<span class="hljs-comment">//对于str中的每个字符</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出当前字符，后面紧跟一个换行符</span><br></code></pre></div></td></tr></table></figure><p>上述c的类型是char，通过auto类型让编译器来决定c的类型。</p><p>每次迭代，str的下一个字符被拷贝给c</p><p>统计string对象中标点符号的个数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World!!!&quot;</span>)</span></span>;<br><span class="hljs-comment">//punct_cnt的类型和s.size的返回类型一样</span><br><span class="hljs-keyword">decltype</span>（s.size()) punct_cnt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//统计s中标点符号的数量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : s)<span class="hljs-comment">//对于s中的每一个字符</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ispunct</span>(c))<span class="hljs-comment">//如果该字符是标点符号</span><br>        ++punct_cnt;<span class="hljs-comment">//将标点符号的计数值加一</span><br><span class="hljs-built_in">cout</span> &lt;&lt; punct_cnt<br>     &lt;&lt; <span class="hljs-string">&quot; punctuation characters in &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p>程序的输出结果是</p><blockquote><p>3 punctuation characters in Hello World!!!</p></blockquote><p>如果想<strong>改变string对象</strong>中字符的值，需要把循环变量定义成<strong>引用类型</strong>（如果不是引用类型，则值为复制，不能改变string自身的值）</p><p>使用引用作为循环控制变量，这个变量实际上被依次绑定到了序列的每个元素上，使用这个引用，我们就能改变它绑定的字符</p><p>比如下面的让字符串中所有字符都变为大写的程序</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello Woeld!!!&quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c : s)<br>    c = <span class="hljs-built_in">toupper</span>(c);<br><span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p>上述结果输出</p><p>HELLO WORLD!!!</p><h4 id="修改string部分字符"><a href="#修改string部分字符" class="headerlink" title="修改string部分字符"></a>修改string部分字符</h4><p>如果要处理string对象中的每一个字符，使用范围for语句是个好主意，然而有时候我们需要访问的只是其中一个字符，或者访问多个字符，但是遇到某个条件就要停下来。</p><p>两种方法，下标运算符或者迭代器</p><ol><li><p>下标运算符</p><p>[]，接收的输入参数是string::size_type类型</p><p>下列程序为将s中的第一个词改成大写形式</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">sting s = <span class="hljs-string">&quot;some string&quot;</span>;<br><span class="hljs-keyword">for</span>(<br>    <span class="hljs-keyword">decltype</span>(s.size()) index = <span class="hljs-number">0</span>;<br>    index != s.size() &amp;&amp; !<span class="hljs-built_in">isspace</span>(s[index]);<br>    ++index;<br>   )<br></code></pre></div></td></tr></table></figure><p>输出结果为SOME string</p></li></ol><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210708165736966.png" alt="image-20210708165736966"></p><p>下列程序是将0——15之间的十进制数转换成对应的十六进制形式</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> hexdigits = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>;<span class="hljs-comment">//可能的十六进制数字</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Enter a series of numbers between 0 and 15&quot;</span><br>     &lt;&lt; <span class="hljs-string">&quot; separated by spaces. Hit ENTER when finished: &quot;</span><br>     &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">string</span> result;<span class="hljs-comment">//用于保存十六进制的字符串</span><br><span class="hljs-built_in">string</span>::size_type n;<span class="hljs-comment">//用于保存从输入流读取的数</span><br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; n)<br>    <span class="hljs-keyword">if</span>(n &lt; hexdigits.size()) <span class="hljs-comment">//忽略无效输入</span><br>        result += hexdigits[n];<span class="hljs-comment">//得到对应的十六进制数字</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Your hex number is: &quot;</span>&lt;&lt;result &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p>输入12 0 5 15 8 15</p><p>输出</p><p>Your hex number is: C05F8F</p><p>无论何时用到字符串的下标，都应该注意检查其合法性，在上面的程序中，下标n是string::size_type类型，也就是无符号类型，所以n可以确保大于或等于0，在实际使用时，还需检查n是否小于hexdigits的长度</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>string</tag>
      
      <tag>cctype</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——异常</title>
    <link href="/2021/07/14/C++%E8%87%AA%E5%AD%A6%E5%BC%82%E5%B8%B8/"/>
    <url>/2021/07/14/C++%E8%87%AA%E5%AD%A6%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h3 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h3><p>异常是指<strong>存在于运行时的反常行为</strong>，这些行为超出了函数正常功能的范围，典型的异常包括失去数据库连接以及遇到意外输入等。</p><p>当程序的某部分检测到一个它无法处理的问题时，需要用到<strong>异常处理</strong>。</p><p>如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。例如：如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据；如果丢失了数据库连接，会发出报警信息。</p><p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持，在C++语言中，异常处理包括</p><ul><li><p><strong>throw表达式</strong>：异常检测部分使用throw表达式来表示它遇到了无法处理的问题，我们说throw<strong>引发（raise）</strong>了异常</p></li><li><p><strong>try语句块</strong>：异常处理部分使用try语句块处理异常，try语句块以关键字try开始，并以一个或多个catch字句结束，try语句块中代码抛出的异常通常会被某个<strong>catch子句处理</strong>。因为catch字句“处理”异常，所以它们也被称作<strong>异常处理代码。</strong></p></li><li><p><strong>一套异常类</strong>：用于在throw表达式和相关的catch字句之间传递异常的具体信息</p></li></ul><h4 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h4><p>throw表达式包含关键字throw和紧随其后的一个表达式，其中<strong>表达式的类型就是抛出的异常类型。</strong>throw表达式后面通常跟一个分号，从而构成一条表达式语句</p><p>一个检验读入的记录是否是同一种书籍的程序</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Sales_item item1,item2;<br><span class="hljs-built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2;<br><span class="hljs-keyword">if</span>(item1.isbn()==item2.isbn())&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//表示成功</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Data must refer to same ISBN&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在真实的程序中，应该把<strong>对象相加的代码和用户交互的代码分离开</strong>，此例中，我们改写程序使得检查完成后不再直接输出一条信息，而是抛出一个异常。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//首先检查两条数据是否是关于同一种书籍的</span><br><span class="hljs-keyword">if</span>(item1.isbn()!=item2.isbn())<br>    <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">&quot;Data must refer to same ISBN&quot;</span>);<br><span class="hljs-comment">//如果程序执行到这里，表示两个ISBN是相同的</span><br><span class="hljs-built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p>如果ISBN不一样就抛出一个异常，该异常是类型runtime_error的对象，抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。</p><h4 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">try</span>&#123;<br>    program-statements<br>&#125;<span class="hljs-keyword">catch</span>(exception-declaration)&#123;<br>    handler-statements<br>&#125;<span class="hljs-keyword">catch</span>(exception-declaration)&#123;<br>    handler-statements<br>&#125;<br></code></pre></div></td></tr></table></figure><p>关键字try，之后紧跟着一个块，这个块就像大多数时候那样是花括号括起来的语句序列</p><p>跟在try块之后的是一个或多个catch字句，catch字句包括三部分：关键字catch，括号内一个异常声明，以及一个块</p><p>如下编写一个异常处理代码，使用throw表达式以避免把两个代表不同数据的Sales_items相加</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//执行添加两个Sales_item对象的代码</span><br>        <span class="hljs-comment">//如果添加失败，代码抛出一个runtime_error异常</span><br>    &#125;<span class="hljs-keyword">catch</span>(runtime_error err)&#123;<br>        <span class="hljs-comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span><br>        <span class="hljs-built_in">cout</span>&lt;&lt;err.what()<br>            &lt;&lt;<span class="hljs-string">&quot;\nTry Again? Enter y or n&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">char</span> c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; c;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">cin</span>||c==<span class="hljs-string">&#x27;n&#x27;</span>)<br>            <span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出while循环</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序本来要执行的任务出现在try语句块中，因为这段代码可能会抛出一个runtime_error类型的异常。</p><p>try语句块对应一个catch子句，该字句负责处理类型为runtime_error的异常，如果try语句块的代码抛出了runtime_error异常，接下来执行catch块内的语句。</p><p>如果用户输入n，执行break语句并跳出while循环，否则，直接执行while循环的右侧花括号，意味着程序控制权跳回到while条件部分准备下一次迭代。</p><h4 id="函数在寻找处理代码过程中退出"><a href="#函数在寻找处理代码过程中退出" class="headerlink" title="函数在寻找处理代码过程中退出"></a>函数在寻找处理代码过程中退出</h4><p>在复杂的系统中，程序遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含有一个tru语句块的新函数，层层递进，向下包裹。</p><p>寻找处理代码的过程与函数调用链刚好相反，当异常被抛出的时候，首先搜索出该异常的函数，如果没有匹配的catch字句，终止该函数，并在调用该函数的函数中继续寻找，如果一直没找到匹配的catch子句，这个新的函数也被终止。继续搜索调用它的函数，以此类推，直到找到适当类型的catch字句为止</p><p>如果最终没能找到任何匹配的catch字句，程序转到名为terminate的标准库函数，该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出</p><p>对于那些没有任何try语句块定义的异常，也按照类似的方式处理，毕竟没有try语句块也就意味着没有匹配的catch子句，如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——数组</title>
    <link href="/2021/07/14/C++%E8%87%AA%E5%AD%A6%E6%95%B0%E7%BB%84/"/>
    <url>/2021/07/14/C++%E8%87%AA%E5%AD%A6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>与C相同的部分不过做赘述，比如多维数组等</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上与vector不同，与vector相似的是，数组也是存放类型相同的对象的容器，这些对象没有名字，<strong>需要通过其所在位置访问</strong>。与vector不同的地方是，<strong>数组的大小确定不变</strong>，<strong>不能随意向数组中添加元素</strong>，因为数组的<strong>大小固定</strong>，因此对某些特殊应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性</p><p>数组<strong>不允许拷贝和赋值</strong>，不能用一个数组初始化另一个数组，也不能把一个数组直接赋值给另一个数组</p><p>其他与c大致相同，数组方面不多赘述</p><h4 id="理解复杂的数组声明"><a href="#理解复杂的数组声明" class="headerlink" title="理解复杂的数组声明"></a>理解复杂的数组声明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *ptrs[<span class="hljs-number">10</span>]; <span class="hljs-comment">//ptrs是含有10个整型指针的数组</span><br><span class="hljs-keyword">int</span> &amp;refs[<span class="hljs-number">10</span>] = <span class="hljs-comment">/*？*/</span>;<span class="hljs-comment">//错误，不存在引用的数组</span><br><span class="hljs-keyword">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr; <span class="hljs-comment">//Parray指向一个含有十个整数的数组</span><br><span class="hljs-keyword">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr; <span class="hljs-comment">//arrRef引用一个含有10个整数的数组</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-comment">//ia是一个含有10个整数的数组</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>;<span class="hljs-comment">//ia2是一个整型指针，指向ia的第一个元素</span><br>ia2 = <span class="hljs-number">42</span>;<span class="hljs-comment">//错误，ia2是一个指针，不能用int值给指针赋值</span><br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(&amp;ia[<span class="hljs-number">0</span>])</span></span>;<br><br><span class="hljs-comment">//但是当使用decltype关键字的时候，上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组</span><br><span class="hljs-keyword">decltype</span>(ia) ia3 = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>ia3 = p;   <span class="hljs-comment">//错误，不能用整型指针给数组赋值</span><br>ia3[<span class="hljs-number">4</span>] = i;<span class="hljs-comment">//正确，把i的值赋给ia3的一个元素</span><br></code></pre></div></td></tr></table></figure><h4 id="标准库函数begin，end"><a href="#标准库函数begin，end" class="headerlink" title="标准库函数begin，end"></a>标准库函数begin，end</h4><p>为了让指针的使用更简单，更安全，C++11新标准引入了两个名为begin和end的函数，这两个函数与容器中的两个同名成员<strong>功能类似</strong></p><p>数组不是类类型，因此这两个函数不是成员函数，正确的使用形式是将数组作为它们的参数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-comment">///ia是一个含有10个整数的数组</span><br><span class="hljs-keyword">int</span> *beg = begin(ia);<span class="hljs-comment">//指向ia首元素的指针</span><br><span class="hljs-keyword">int</span> *last = end(ia);<span class="hljs-comment">//指向arr尾元素的下一位置的指针</span><br></code></pre></div></td></tr></table></figure><p>寻找数组中的第一个整数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> *pbeg = begin[arr],*pend = end(arr);<br><span class="hljs-keyword">while</span>(pbeg != pend &amp;&amp; *pbeg &gt;= <span class="hljs-number">0</span>)<br>    ++pbeg;<br></code></pre></div></td></tr></table></figure><blockquote><p>size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。</p></blockquote><blockquote><p>两个指针相减的结果类型是一种名为ptrdiff_t的标准类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型，因为差值可能为负值，所以ptrdiff_t是一种带符号类型</p></blockquote><h3 id="数组长度问题"><a href="#数组长度问题" class="headerlink" title="数组长度问题"></a>数组长度问题</h3><p><strong>C风格的字符串</strong>，通过字符串末尾的空字符判断是否结束，这种方法就是<strong>数组本身包含一个结束标记</strong>。仅仅适用于含有明显标记且不会与普通数据混淆的情况，但是对于像int这样所有取值都是合法的数据就无效</p><p>C++中可以使用标准库规范，传入两个指针，一个指向要输出的首元素，另一个指向尾元素的下一个位置。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *beg,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//输出beg到end之间（不含end）的所有元素</span><br>    <span class="hljs-keyword">while</span>(beg != end)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; *beg++ &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">//输出当前元素并将指针向前移动一个位置。</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>C和C++都可以通过直接传入数组大小的形参来进行运算</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[], <span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i != size; ++i) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; ia[i] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (&amp;arr)[<span class="hljs-number">10</span>])</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem :arr)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>&amp;arr 两端的括号必不可少</p><p>f (int &amp;arr[10])                //错误，arr声明是引用的数组</p><p>f(int (&amp;arr)[10])                //正确，arr是具有10个整数的整型数组的引用</p></blockquote><p>数组大小是构成数组类型的一部分，只要不超过维度，在函数体内就可以放心地使用数组，但是这一用法也限制了此函数的可用性，我们只能将函数作用于大小为10的数组</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">int</span> k[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>print(&amp;i);<span class="hljs-comment">//错误，实参不是含有10个整数的数组</span><br>print(j);<span class="hljs-comment">//错误，实参不是含有10个整数的数组</span><br>print(k);<span class="hljs-comment">//正确，实参是含有10个整数的数组</span><br></code></pre></div></td></tr></table></figure><p>void print(int (&amp;arr)[10]) 限定了大小必须为10，但是如下三种声明完全等价</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>])</span></span>;<br></code></pre></div></td></tr></table></figure><h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>尽管C++支持C风格字符串，但是在C++程序中最好不要使用它们。</p><p>C风格字符串是存放在字符数组中并以空字符结束</p><p>cstring头文件是C语言头文件string.h的C++版本</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210711161049105.png" alt="image-20210711161049105"></p><p>C++中的string类型，使用普通的关系运算符和相等性运算符的时候，比较的是字符串</p><p>但是C风格字符串，实际上比较的是指针而非字符串本身，因此要使用strcmp()。</p><blockquote><p>对大多数应用来说，使用标准库string要比使用C风格字符串更安全，更高效</p></blockquote><p>string转成C风格字符串</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World&quot;</span>)</span></span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str = s.c_str();   <span class="hljs-comment">//正确</span><br></code></pre></div></td></tr></table></figure><p>c_str()函数，返回一个C风格的字符串，但是无法保证c_str函数返回的数组一直有效，事实上如果后续的操作改变了s的值就可能让之前返回的数组失去效用，因此如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</p><p>数组初始化vector</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> int_arr[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//ivec有6个元素，分别是int_arr中对应元素的副本</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(begin(int_arr),end(int_arr))</span></span>;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——迭代器</title>
    <link href="/2021/07/14/C++%E8%87%AA%E5%AD%A6%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2021/07/14/C++%E8%87%AA%E5%AD%A6%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。</p><p><strong>类似于指针类型</strong>，迭代器也提供了对对象的间接访问，使用迭代器可以访问容器中的某个元素，也可以从一个元素移动到另一个元素。</p><p>有效迭代器<strong>指向某个元素或者指向容器中尾元素的下一位置</strong>，其他所有情况都属于无效。</p><p>与指针不一样，获取迭代器不是使用取地址符，<strong>拥有迭代器</strong>的类型<strong>同时拥有返回迭代器的成员</strong>，比如，这些类型都拥有名为<strong>begin和end的成员</strong>，其中<strong>begin成员负责返回指向第一个元素的迭代器</strong>，</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//由编译器决定b和e的类型</span><br><span class="hljs-comment">//b表示v的第一个元素，e表示v尾元素的下一个位置</span><br><span class="hljs-keyword">auto</span> b = v.begin() , e = v.end();  <span class="hljs-comment">//b和e的类型相同</span><br></code></pre></div></td></tr></table></figure><p>end成员负责返回指向容器<strong>尾元素的下一个位置的迭代器</strong>，是容器一个本不存在的<strong>尾后</strong>，没什么实际含义，仅仅是个标记。end成员返回的迭代器常被称作<strong>尾后迭代器</strong>（尾迭代器）</p><p>若容器为空，begin和end返回的是同一个迭代器</p><h4 id="标准容器迭代器的运算符"><a href="#标准容器迭代器的运算符" class="headerlink" title="标准容器迭代器的运算符"></a>标准容器迭代器的运算符</h4><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210711142836715.png" alt="image-20210711142836715"></p><p>和指针类似，也能通过<strong>解引用迭代器</strong>（-&gt;）来获取它所指示的元素，执行解引用的迭代器必须合法并确实指示某个元素。</p><p>如下程序将string对象的第一个字母改成了大写</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<br><span class="hljs-keyword">if</span>(s.begin()!= s.end())&#123;<span class="hljs-comment">//非空</span><br>    <span class="hljs-keyword">auto</span> it = s.begin();<span class="hljs-comment">//it表示s的第一个字符</span><br>    *it = <span class="hljs-built_in">toupper</span>(*it);<span class="hljs-comment">//将当前字符改为大写形式</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>本例和原来的程序一样，首先<strong>检查s是否为空</strong>，显然<strong>通过检查begin和end返回的结果是否一致</strong>就能做到这一点。</p><blockquote><p>输出： Some string</p></blockquote><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210711143627127.png" alt="image-20210711143627127"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210711143618835.png"></p><p>迭代器使用<strong>递增（++）运算符</strong>来<strong>从一个元素移动到下一个元素</strong>，从逻辑上来说，迭代器的递增和整数的递增类似，整数的递增是在数值上”加1“，迭代器的递增是将迭代器向前移动一个位置</p><blockquote><p>end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用操作。</p></blockquote><p>使用迭代器将第一个单词全部变为大写</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.begin(); it != s.end() &amp;&amp; !<span class="hljs-built_in">isspace</span>(*it); ++it)<br>    *it = <span class="hljs-built_in">toupper</span>(*it);<span class="hljs-comment">//将当前字符改为大写形式</span><br></code></pre></div></td></tr></table></figure><h4 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h4><p>就像不知道string和vector的size_type成员到底是什么类型一样，一般我们也不知道（无需知道）迭代器的精确类型</p><p><strong>拥有迭代器的标准库类型</strong>使用<strong>iterator和const_iterator</strong>来表示迭代器的类型</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vector">vector&lt;int&gt;::iterator it;&#x2F;&#x2F;it能读写vector&lt;int&gt;的元素<br>string::iterator it2;&#x2F;&#x2F;it2能读写string对象中的字符<br><br>vector&lt;int&gt;::const_iterator it3;&#x2F;&#x2F;it3只能读元素，不能写元素<br>string::const_iterator it4;&#x2F;&#x2F;it4只能读字符，不能写字符<br></code></pre></div></td></tr></table></figure><blockquote><p>如果vector或string对象<strong>是一个常量</strong>，<strong>只能使用const_iterator</strong></p></blockquote><h4 id="begin-end"><a href="#begin-end" class="headerlink" title="begin end"></a>begin end</h4><p>begin和end的返回的具体类型由对象是否为常量决定，如果对象是常量，begin和end返回const_iterator。如果对象不是常量，返回iterator。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; cv;<br><span class="hljs-keyword">auto</span> it1 = v.begin();<span class="hljs-comment">//it1的类型是vector&lt;int&gt;::iterator</span><br><span class="hljs-keyword">auto</span> it2 = cv.begin();<span class="hljs-comment">//it2的类型是vector&lt;int&gt;::const_iterator</span><br></code></pre></div></td></tr></table></figure><p>专门得到const_iterator类型的返回值，使用cbegin，cend</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> it3 = v.cbegin();<span class="hljs-comment">//it3的类型是vector&lt;int&gt;::const_iterator</span><br></code></pre></div></td></tr></table></figure><h4 id="结合解引用和成员访问操作"><a href="#结合解引用和成员访问操作" class="headerlink" title="结合解引用和成员访问操作"></a>结合解引用和成员访问操作</h4><p>解引用迭代器可以获得迭代器所指向的对象，如果该对象的类型恰好是类，就可以进一步访问它的成员。</p><p>对于一个字符串组成的vector对象</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">(*it).empty();<span class="hljs-comment">//解引用it，然后调用结果对象的empty成员</span><br>*it.empty();<span class="hljs-comment">//错误，试图访问it的名为empty的成员，但it是个迭代器，没有empty成员</span><br></code></pre></div></td></tr></table></figure><p>简化上式，可以使用箭头运算符-&gt;</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//以下两个式子等价</span><br>it-&gt;menu;<br>(*it).menu;<br></code></pre></div></td></tr></table></figure><p>text字符串向量存放文本文件中的数据，其中的元素或者一句话或者是以一个用于表示段落分隔的空字符串，以下程序输出text中第一段的内容。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//依次输出text的每一行直到遇到第一个空白行为止</span><br><span class="hljs-keyword">for</span>(<br>    <span class="hljs-keyword">auto</span> it = text.cbegin();<br>    it != text.cend() &amp;&amp; !it-&gt;empty();<br>    ++it<br>   )<br>    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p>初始化it指向text的第一个元素，循环重复执行直至处理完了text的所有元素或者发现某个元素为空，循环从头到尾只是读取text的元素而未向其中写值，所以使用了cbegin和cend来控制整个迭代过程。</p><blockquote><p>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素</p><p>任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效</p><p>无穷增加，迭代器增加指向下一个，尾部又添加新元素</p></blockquote><h4 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h4><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210711151859743.png" alt="image-20210711151859743"></p><h4 id="迭代器的算术运算"><a href="#迭代器的算术运算" class="headerlink" title="迭代器的算术运算"></a>迭代器的算术运算</h4><p>迭代器和整数值加减，返回值是向前向后移动了若干位置的迭代器</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//计算得到最接近vi中间元素的一个迭代器</span><br><span class="hljs-keyword">auto</span> mid = vi.begin() + vi.size()/<span class="hljs-number">2</span>;<br><span class="hljs-comment">//迭代器的&lt;,&lt;=,&gt;=,&gt;，参与比较的两个迭代器必须合法而且指向的是同一个容器的元素。</span><br><span class="hljs-comment">//比较的是位置的孰前孰后</span><br><span class="hljs-keyword">if</span>(it&lt;mid)<br>    <span class="hljs-comment">//处理vi前半部分的元素</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//使用迭代器完成二分搜索</span><br><span class="hljs-comment">//text必须是有序的，，beg和end表示我们搜索的范围</span><br><span class="hljs-keyword">auto</span> beg = text.begin(),end = text.end();<br><span class="hljs-keyword">auto</span> mid = text.begin() + (end-beg)/<span class="hljs-number">2</span>;<span class="hljs-comment">//初始状态下的中间点</span><br><span class="hljs-comment">//当还有元素尚未检查并且我们还没有找到sought时执行循环</span><br><span class="hljs-keyword">while</span>(mid != end &amp;&amp; *mid != sought)&#123;<br>    <span class="hljs-keyword">if</span>(sought &lt; *mid)<span class="hljs-comment">//我们要找的元素在前半部分吗？</span><br>        end = mid;<span class="hljs-comment">//如果是，调整搜索范围使得忽略掉后半部分</span><br>    <span class="hljs-keyword">else</span><br>        beg = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//我们要找到元素在后半部分，在mid后寻找</span><br>    mid = beg + (end-beg)/<span class="hljs-number">2</span>;<span class="hljs-comment">//新的中间点</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>迭代器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——C++类型较C的补充，引用指针常量表达式等</title>
    <link href="/2021/07/14/C++%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%A1%A5%E5%85%85/"/>
    <url>/2021/07/14/C++%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h3 id="C-的基本内置类型"><a href="#C-的基本内置类型" class="headerlink" title="C++的基本内置类型"></a>C++的基本内置类型</h3><p>C++的基本内置类型：算术类型，空类型</p><p>关于字符，整数型，浮点型等类型与C大同小异，不做多赘述</p><p>算术类型：字符、整型数、布尔值、浮点数</p><p>空类型不对应具体的值，仅用于一些特殊的场合</p><p>以下为C++ primer上关于如何选择类型的建议</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210707093310511.png" alt="image-20210707093310511"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210707093325521.png" alt="image-20210707093325521"></p><p>字面值的类型（前后缀指定）</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210707093909683.png" alt="image-20210707093909683"></p><h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>C++11，初始化的方法</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> units_sold = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> units_sold = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> units_sold&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">units_sold</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>若使用<strong>列表初始化{}，初始值存在丢失的风险时，编译器报错</strong></p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> ld=<span class="hljs-number">3.1415926536</span>;<br><span class="hljs-keyword">int</span> a&#123;ld&#125;,b=&#123;ld&#125;;    <span class="hljs-comment">//错误，转换未执行，因为存在丢失信息的风险</span><br>int c(ld),d=ld;      //正确，转换执行，且确实丢失了部分值<br></code></pre></div></td></tr></table></figure><p>使用long double的值初始化int变量时可能丢失数据，所以编译器拒绝了a和b的初始化请求，其中，至少ld的小数部分会丢失掉，并且int可能也存不下ld的整数部分</p><blockquote><p>C++内置类型的默认初始化与Java基本类型相同，内置类型的变量未被显式初始化，值由定义的位置决定，<strong>定义于函数体外的变量被初始化为0</strong>。定义在<strong>函数体内部的内置类型变量将不被初始化。</strong></p><p>C++中每个类各自决定其初始化对象的方式，而且是否允许不经初始化就定义对象也由类自己决定，如果类允许这种行为，将决定对象的初始值到底是什么</p></blockquote><h4 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h4><p>声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明</p><p>定义负责创建与名字关联的实体 （定义声明都规定了变量的类型和名字，但是<strong>定义还申请存储空间</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i;    <span class="hljs-comment">//声明i而非定义i</span><br><span class="hljs-keyword">int</span> j;<span class="hljs-comment">//声明并定义j</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.1416</span>;<span class="hljs-comment">//赋值，就抵消了extern的作用，变成了定义</span><br></code></pre></div></td></tr></table></figure><p>定义只有一次，但是声明可以多次</p><blockquote><p><strong>函数体内部</strong>，试图初始化一个extern关键字标记的变量，将引发错误</p></blockquote><h4 id="引用（左值引用）"><a href="#引用（左值引用）" class="headerlink" title="引用（左值引用）"></a>引用（左值引用）</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">int</span> &amp;refVal = ival;  <span class="hljs-comment">//refVal指向ival（是ival的另一个名字）</span><br><span class="hljs-keyword">int</span> &amp;refVal2;<span class="hljs-comment">//报错，引用必须初始化</span><br></code></pre></div></td></tr></table></figure><ul><li><p>引用是<strong>为对象起了另一个名字</strong>，引用类型引用另外一种类型，通过将声明符写成&amp;d的形式来定义引用类型，d是声明的变量名。</p></li><li><p>定义引用时，程序把引用和初始值<strong>绑定</strong>在一起，而不是初始值拷贝给引用。初始化完成，引用就和它的初始值对象一直绑定在一起。因为<strong>无法令引用重新绑定到另外一个对象</strong>，因此<strong>引用必须初始化</strong></p></li><li><p>引用即<strong>别名</strong>，引用后一切操作都是在与之绑定的对象上进行的，为引用赋值，其实是赋值给了与引用绑定的对象，获取引用的值，实际上是获取引用绑定对象的值，以引用作为初始值，实际上是以与引用绑定的对象作为初始值。</p></li><li><p>引用本身不是一个对象，不能定义引用的引用。</p></li><li><p>一条语句可以定义多个引用，每个引用标识符以&amp;开头</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> &amp;r1=i1,&amp;r2=i2;<br></code></pre></div></td></tr></table></figure></li><li><p>引用不能与<strong>字面值</strong>或<strong>某个表达式的计算结果</strong>绑定在一起。</p></li></ul><h4 id="指针（与C大致相同）"><a href="#指针（与C大致相同）" class="headerlink" title="指针（与C大致相同）"></a>指针（与C大致相同）</h4><p>定义，通过*号，获取对象的地址用取地址符&amp;</p><p>定义指针的方法将声明符写成*d，d为变量名，不可以是引用，引用不是对象，没有实际地址。</p><p>指针的值的四种状态：</p><ol><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，指针没有指向任何对象</li><li>无效指针，上述情况以外的其他值</li></ol><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> *p1 = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//等价于int *p1=0；</span><br><span class="hljs-keyword">int</span> *p2 = <span class="hljs-number">0</span>;<span class="hljs-comment">//直接将p2初始化为字面常量0</span><br><span class="hljs-comment">//需要先#include cstdlib</span><br><span class="hljs-keyword">int</span> *p3 = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//等价于int *p3=0;</span><br></code></pre></div></td></tr></table></figure><p>C++11新标准引入，得到空指针最直接的方法就是使用字面值nullptr。</p><p>过去的程序用到名为NULL的预处理变量给指针赋值，这个变量在头文件cstdlib中定义，值就是0。</p><p>现在的C++最好使用nullptr，尽量避免使用NULL。</p><p>同样把值为0的变量赋给指针是错误的操作。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> zero=<span class="hljs-number">0</span>;<br>pi=zero;    <span class="hljs-comment">//错误，不能把int变量直接赋给指针。</span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210707102856005.png" alt="image-20210707102856005"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210707102903719.png" alt="image-20210707102903719"></p><h4 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h4><p>可用于存放<strong>任意对象的地址</strong>，但是对该地址中到底是个什么类型的对象并不了解。</p><p>void* 能做的事情有限，比如和其他指针比较，作为函数的输入输出，或者赋给另一个void*指针，<strong>不能直接操作void*指针所指的对象</strong>，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ul><li><p>const类型能参加不改变其内容的操作，如算术运算，转化为布尔值等，同样还有初始化赋值。</p></li><li><p>默认情况下，const对象仅在文件内有效，编译器在编译过程中把用到该变量的地方都替换成对应的值，若程序包含多个文件，每个用了const对象的文件都不许能访问到它的初始值才行。</p></li><li><p>要做到上述，必须在每个用到变量的文件中都有对它的定义，为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，<strong>const对象被设为仅在文件内有效</strong>。当多个文件中出现了同名的const变量，其实<strong>等同于在不同文件中分别定义了独立的变量</strong>。</p></li><li><p>若真的想有这样一种const变量，初始值不是一个常量表达式，但是又确实要在文件间共享，不希望每个文件分别生成独立的变量，<strong>只在一个文件中定义const，在多个文件中声明并使用它</strong>。</p></li><li><p>解决方法：对于const变量<strong>不管声明还是定义都添加extern</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = fcn();<br><span class="hljs-comment">//file_1.h头文件</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize;  <span class="hljs-comment">//与file_1.cc中定义的bufSize是同一个,声明bufSize</span><br></code></pre></div></td></tr></table></figure></li></ul><h5 id="引用和常量"><a href="#引用和常量" class="headerlink" title="引用和常量"></a>引用和常量</h5><ul><li><p>对常量的引用</p><p>可以把引用绑定到const对象上，对<strong>常量的引用不能修改它所绑定的对象</strong>。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = ci;     <span class="hljs-comment">//正确，引用及其对应的对象都是常量</span><br>r1 = <span class="hljs-number">42</span>;   <span class="hljs-comment">//错误，r1是对常量的引用</span><br><span class="hljs-keyword">int</span> &amp;r2 = ci;<span class="hljs-comment">//错误，试图让一个非常量引用指向一个常量对象</span><br></code></pre></div></td></tr></table></figure><p>非常量引用，普通引用不能指向一个常量对象</p><p>但是常量引用能指向一个非常量对象</p><p><strong>初始化常量引用</strong>时允许<strong>任意表达式</strong>作为初始值，只要该表达式的结果能<strong>转换成引用的类型</strong>即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = i;   <span class="hljs-comment">//允许将const int&amp;绑定到一个普通int对象上。</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = <span class="hljs-number">42</span>;<span class="hljs-comment">//正确，r1是一个常量引用</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r3 = r1*<span class="hljs-number">2</span>; <span class="hljs-comment">//正确，r3是一个常量引用</span><br><span class="hljs-keyword">int</span> &amp;r4 = r1*<span class="hljs-number">2</span>;<span class="hljs-comment">//错误，r4是一个普通的非常量引用</span><br></code></pre></div></td></tr></table></figure><p>当一个常量引用被绑定到另外一种类型上时</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ri = dval;<br></code></pre></div></td></tr></table></figure><p>为了让ri绑定一个整数，编译器：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> temp = dval;<span class="hljs-comment">//由双精度浮点数生成一个临时的整型常量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ri = temp;  <span class="hljs-comment">//让ri绑定这个临时量</span><br></code></pre></div></td></tr></table></figure><p>ri绑定生成了<strong>临时量</strong>，临时量对象是编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名对象。上面的ri若不是常量，则非法。</p><ul><li>const引用引用一个非const</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> &amp;r1 = i;  <span class="hljs-comment">//引用ri绑定对象i</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = i;<span class="hljs-comment">//r2也绑定对象i，但是不允许通过r2修改i的值</span><br>r1 = <span class="hljs-number">0</span>;<span class="hljs-comment">//r1并非常量，i的值修改为0</span><br>r2 = <span class="hljs-number">0</span>;<span class="hljs-comment">//错误，r2是一个常量引用</span><br></code></pre></div></td></tr></table></figure><p>r2（常量引用）绑定（非常量）整数i合法，只是<strong>不允许通过r2修改i</strong>，但是i仍然<strong>允许通过其他途径修改。</strong></p><h4 id="指针和常量"><a href="#指针和常量" class="headerlink" title="指针和常量"></a>指针和常量</h4><p>普通指针不能指向常量，指向常量的<strong>常量指针不能用于修改</strong>其所指向对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14</span>;<span class="hljs-comment">//pi是个常量，值不能变</span><br><br><span class="hljs-comment">//普通指针不能指向常量</span><br><span class="hljs-keyword">double</span> *ptr = &amp;pi;<span class="hljs-comment">//错误，ptr是个普通指针</span><br><br><span class="hljs-comment">//指向常量的常量指针不能用于修改其所指向对象的值</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *cptr = &amp;pi;<span class="hljs-comment">//正确，cptr可以指向一个双精度常量</span><br>*cptr = <span class="hljs-number">42</span>;<span class="hljs-comment">//错误，不能给*cptr赋值</span><br></code></pre></div></td></tr></table></figure><p>若const修饰的指针指向变量</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;<span class="hljs-comment">//dval是一个双精度浮点数，它的值可以改变</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *cptr = &amp;dval;<span class="hljs-comment">//正确，但是不能通过cptr改变dval的值</span><br></code></pre></div></td></tr></table></figure><p>指向常量的指针<strong>仅仅要求不能通过该指针改变对象的值，但是那个值可以通过其他途径改变</strong>。</p><ul><li><p>const指针</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> errNumb = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> curErr = &amp; errNumb;<span class="hljs-comment">//curErr将一直指向errNumb</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14159</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *<span class="hljs-keyword">const</span> pip = &amp;pi;<span class="hljs-comment">//pip是一个指向常量对象的常量指针</span><br></code></pre></div></td></tr></table></figure><p>从右向左阅读</p><p>常量指针，指针的值不能修改，但是指针指向的变量可以修改</p><p>指向常量的指针，指向的内容不可修改，指针自己可以改。</p></li></ul><p>顶层const，表示指针本身是个常量</p><p>底层const，表示指针所指的对象是一个常量</p><h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p><strong>值不会改变</strong>，并且<strong>编译过程中就能得到计算结果</strong>的表达式</p><ol><li>字面值</li><li>常量表达式初始化的const对象</li></ol><p>一个对象/表达式是不是常量表达式，由它的数据类型和初始值共同决定</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max_files = <span class="hljs-number">20</span>;<span class="hljs-comment">//max_files是常量表达式</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> limit = max_files+<span class="hljs-number">1</span>;<span class="hljs-comment">//limit是常量表达式</span><br><br><span class="hljs-keyword">int</span> staff_size = <span class="hljs-number">27</span>;<span class="hljs-comment">//staff_size不是常量表达式</span><br><span class="hljs-comment">//staff_size的初始值是个字面值常量，但是它的数据类型只是个普通的int，不是const int。</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = get_size();<span class="hljs-comment">//sz不是常量表达式</span><br><span class="hljs-comment">//sz本身是个常量，但是具体值运行时才能得到</span><br></code></pre></div></td></tr></table></figure><p>使用constexpr，编译器来验证变量的值是否为一个常量表达式。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">constexptr <span class="hljs-keyword">int</span> mf = <span class="hljs-number">20</span>;<span class="hljs-comment">//20是常量表达式</span><br>constexptr <span class="hljs-keyword">int</span> limit = mf+<span class="hljs-number">1</span>;<span class="hljs-comment">//mf+1是常量表达式</span><br>constemptr <span class="hljs-keyword">int</span> sz = size();<br><span class="hljs-comment">//只有size是一个constexpr函数时，才是一条正确的声明语句</span><br></code></pre></div></td></tr></table></figure><p>新标准允许定义一个<strong>constexpr函数</strong>，<strong>足够简单到编译时就能得到计算结果</strong></p><p>常量表达式的值要在编译时就计算，因此对声明contexpr时用到的类型必须有限制，是较为简单的类型，叫做字面值类型</p><p>算术类型，引用和指针都属于字面值类型，自定义类，IO库，string类型不属于字面值类型。</p><p>指针和引用定义为constexpr时初始值受到严格限制，一个constexpr指针的初始值必须是nullptr或者0，或者存于某个固定地址中的对象</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = <span class="hljs-literal">nullptr</span>;   <span class="hljs-comment">//p是一个指向整型常量的指针</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *q =<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//q是一个指向整数的常量指针</span><br></code></pre></div></td></tr></table></figure><p>p和q的类型完全不同，<strong>constexpr把q置为了顶层const</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">constexptr <span class="hljs-keyword">int</span> *np = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//np是一个指向整数的常量指针，值为空</span><br><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-comment">//i的类型是整型常量</span><br><span class="hljs-comment">//i和j都不洗定义在函数体外</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = &amp;i;<span class="hljs-comment">//p是常量指针，指向整型常量i</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *pl = &amp;j;<span class="hljs-comment">//p是常量指针，指向整数j</span><br></code></pre></div></td></tr></table></figure><h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名是一个名字，是<strong>某种类型的同义词</strong>，使用类型别名可以使复杂的名字简单明了，易于理解和使用，有助于程序员清楚地知道使用该类型的真实目的</p><ol><li><p>传统定义方法 <strong>typedef</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> wages;<span class="hljs-comment">//wages是double的同义词</span><br><span class="hljs-keyword">typedef</span> wages base,*p;<span class="hljs-comment">//base是double的同义词，p是double*的同义词</span><br></code></pre></div></td></tr></table></figure></li><li><p>新标准规定的一种新的方法，使用<strong>别名声明</strong>来定义类型的别名</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> SI = Sales_items;  <span class="hljs-comment">//SI是Sales_item的同义词</span><br></code></pre></div></td></tr></table></figure></li></ol><p>类型别名不可以简单替换</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> *pstring;<br><br><span class="hljs-keyword">const</span> pstring cstr = <span class="hljs-number">0</span>;<span class="hljs-comment">//cstr是指向char的常量指针，指针本身为常量</span><br><span class="hljs-comment">//不等价于简单替换的句子</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cstr = <span class="hljs-number">0</span>;  <span class="hljs-comment">//指向const char的指针，指向的内容是常量</span><br><br><span class="hljs-keyword">const</span> pstring *ps;<span class="hljs-comment">//ps是一个指针，它的对象是指向char的常量指针</span><br></code></pre></div></td></tr></table></figure><h4 id="auto语句"><a href="#auto语句" class="headerlink" title="auto语句"></a>auto语句</h4><p>自动判断类型，<strong>编译器</strong>代替程序员去分析表达式所属的类型。</p><p>auto让编译器通过初始值来推算变量的类型，因此auto定义的变量<strong>必须有初始值</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//由a1和a2相加的结果来推断出item的类型</span><br><span class="hljs-keyword">auto</span> b =  a1 + a2;<br></code></pre></div></td></tr></table></figure><p>使用auto也可以在一条语句中声明多个变量，因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i;<span class="hljs-comment">//正确，i是整数，p是整型指针</span><br><span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>， pi = <span class="hljs-number">3.14</span>;<span class="hljs-comment">//错误，sz和pi的类型不一样。</span><br></code></pre></div></td></tr></table></figure><p>忽略顶层的const，即若常量赋给auto，编译器会将其当成变量，但是底层const保留，若指针指向了常量，auto定义的指针还是指向常量</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i, &amp;cr = ci;<br><span class="hljs-keyword">auto</span> b = ci;<span class="hljs-comment">//b是一个整数（ci的顶层const特性被忽略掉了）</span><br><span class="hljs-keyword">auto</span> c = cr;<span class="hljs-comment">//c是一个整数（cr是ci的别名，ci本身是一个顶层cosnt，</span><br><span class="hljs-comment">//即引用被当作初始值的时候，真正参与初始化的是引用对象的值。</span><br><span class="hljs-keyword">auto</span> d = &amp;i;<span class="hljs-comment">//d是一个整型指针，指向一个整数</span><br><span class="hljs-keyword">auto</span> e =  &amp;ci;<span class="hljs-comment">//e是一个指向整数常量的指针，&amp;ci是取了一个整数常量的地址。</span><br></code></pre></div></td></tr></table></figure><p>若想得到的auto是一个顶层const，需要明确指出</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> f = ci;<span class="hljs-comment">//ci的推演类型是in，添加const后就是const int了。</span><br></code></pre></div></td></tr></table></figure><p>也可以将引用的类型设为auto，此时原来的初始化规则仍然适用</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> &amp;g = ci;<span class="hljs-comment">//g是一个整型常量引用，绑定到ci</span><br><span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>;<span class="hljs-comment">//错误，不能为非常量引用绑定字面值</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;j = <span class="hljs-number">42</span>;<span class="hljs-comment">//正确，可以为常量引用绑定字面值</span><br></code></pre></div></td></tr></table></figure><p>要在一条语句中定义多个变量，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> k = ci, &amp;l = i;<span class="hljs-comment">//忽略顶层const，因此都是整数，k是整数，l是整型引用</span><br><span class="hljs-keyword">auto</span> &amp;m = ci, *p = &amp;ci;<span class="hljs-comment">//不能忽略底层const，因此m是整形常量的引用，p是指向整型常量的指针。</span><br><br><span class="hljs-comment">//如下错误，一个是整型，一个是不能忽略底层的const，类型不同</span><br><span class="hljs-keyword">auto</span> &amp;n = i, *p2 = &amp;ci;<br></code></pre></div></td></tr></table></figure><h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h4><p>若希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量（auto能自动判断类型,，但是auto需要用该表达式的值初始化变量）</p><p>编译器分析表达式，得到它的类型，但是不实际计算表达式的值。</p><p>如下，编译器不实际调用函数f，而是使用当调用发生时f的返回值类型当作sum的类型。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">decltype</span>(f()) sum = x;<span class="hljs-comment">//sum的类型是函数f的返回类型</span><br></code></pre></div></td></tr></table></figure><p>decltype能保留顶层const和引用，上面的auto却不行。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci =<span class="hljs-number">0</span>, &amp;cj=ci;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>;<span class="hljs-comment">//x的类型是const int</span><br><span class="hljs-keyword">decltype</span>(cj) y = x;<span class="hljs-comment">//y的类型是const int&amp;，y绑定到变量x</span><br><span class="hljs-keyword">decltype</span>(cj) z;<span class="hljs-comment">//错误，z是个引用，必须初始化</span><br><span class="hljs-comment">//cj是一个引用，decltype(cj)的结果就是引用类型</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++类型补充</tag>
      
      <tag>引用</tag>
      
      <tag>常量表达式</tag>
      
      <tag>decltype</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——强制类型转换</title>
    <link href="/2021/07/14/C++%E8%87%AA%E5%AD%A6%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2021/07/14/C++%E8%87%AA%E5%AD%A6%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="C-的强制类型转换"><a href="#C-的强制类型转换" class="headerlink" title="C++的强制类型转换"></a>C++的强制类型转换</h3><p>形式</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">cast-name&lt;type&gt;(expression);<br></code></pre></div></td></tr></table></figure><p>cast-name是static_cast, dynamic_cast, const_cast, reinterpret_cast中的一种</p><ul><li><p>static_cast</p><p><strong>任何具有明确定义的类型转换</strong>，<strong>只要不包含底层const，都可以使用static_cast</strong></p><ul><li>基本类型的转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">double</span> slope = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(j)/i;<br></code></pre></div></td></tr></table></figure><p>将一个较大的算术类型赋值给较小的类型，static_cast非常有用。强制类型转换告诉程序的读者和编译器，<strong>不在乎潜在的精度损失。</strong></p><ul><li>不能用于基本类型指针之间的类型转换，但是void指针和基本指针之间可以</li></ul><p>也可以执行编译器无法自动执行的类型转换</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">void</span>* p = &amp;d;<br><span class="hljs-keyword">double</span> *dp = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>*&gt;(p);<br></code></pre></div></td></tr></table></figure><p>指针存在<strong>void</strong>* 中，并且使用static_cast将其强制转换为原来的类型。</p></li><li><p>const_cast</p><p>const_cast只改变常量属性，即<strong>只能改变运算对象的底层const</strong></p><p>可以将一个常量指针转化成非常量指针，转换后指针指向原来的变量</p><p>也可以将常量引用转为非常量引用</p><p>const_cast做到的并不是将常量对象（基本类型）转换为非常量对象（基本类型）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pc;<br><span class="hljs-keyword">char</span> *p = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(pc);<span class="hljs-comment">//正确，但是pc没有初始化，通过p写值未定义</span><br></code></pre></div></td></tr></table></figure><p>常量对象转换为非常量对象，我们一般称其为“去掉const性质”，一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作。</p><p>只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样，也不能使用const_cast改变表达式的类型</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp;<br><span class="hljs-keyword">char</span> *q = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(cp);<span class="hljs-comment">//错误，static_cast不能转换掉const性质</span><br><span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">string</span>&gt;(cp);<span class="hljs-comment">//正确，字符串字面值转换成string类型</span><br><span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-built_in">string</span>&gt;(cp);<span class="hljs-comment">//错误，const_cast只改变常量属性</span><br></code></pre></div></td></tr></table></figure></li><li><p>reinterpret_cast</p><p>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释，假设有如下转换</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> *ip;<br><span class="hljs-keyword">char</span> *pc = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(ip);<br></code></pre></div></td></tr></table></figure><p>但是我们要牢记pc所指向的真实对象是一个int而非字符。</p><p>接下来在使用pc时就会认定它的值是char*类型，编译器没法知道它实际存放的是指向int的指针。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>强制类型转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——输入输出以及命名空间</title>
    <link href="/2021/07/13/C++%E8%87%AA%E5%AD%A6%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BB%A5%E5%8F%8A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <url>/2021/07/13/C++%E8%87%AA%E5%AD%A6%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BB%A5%E5%8F%8A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>C大体可以看作C++的一小部分，之前没有选C++的课，因此趁着暑假笔者想自学一下C++，重点在比较C和C++的不同之处。</p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>C语言中往往使用习惯printf，scanf，但是C++的输入输出没有定义任何输入输出（IO）语句，而是包含了一个全面的标准库来提供IO机制。</p><ul><li>iostream库</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br></code></pre></div></td></tr></table></figure><p>两个基本类型：istream和ostream，分别表示输入流和输出流。</p><p>cin 标准输入</p><p>cout 标准输出</p><p>cerr 标准错误</p><p>clog 输出一般性信息</p><h4 id="输出时使用输出运算符（-lt-lt-）"><a href="#输出时使用输出运算符（-lt-lt-）" class="headerlink" title="输出时使用输出运算符（&lt;&lt;）"></a>输出时使用输出运算符（&lt;&lt;）</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;xxx&quot;</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p>&lt;&lt;运算符接受两个运算对象，左侧的运算对象必须是一个ostream（cout，cerr，clog），右侧的运算对象是要打印的值。此运算符将给定的值写到给定的的ostream对象中。</p><p>输出运算符的计算结果为<strong>左侧的运算对象</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;XXX&quot;</span>&lt;&lt;<span class="hljs-string">&quot;YYY&quot;</span>;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;XXX&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;YYY&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>输出的运算对象并不一定都要是相同类型的值，某些运算对象是字符串字面值常量，有的是int等，标准库定义了不同版本的输入输出运算符，来处理这些不同类型的运算对象。</p><h4 id="endl"><a href="#endl" class="headerlink" title="endl"></a>endl</h4><p>是一个被称为操纵符的特殊值，写入endl的效果是结束当前行，并将与设备关联的缓冲区的内容刷到设备中。</p><p>保证目前为止程序产生的输出都真正写入输出流中，而不是停留在内存中等待写入流。</p><h4 id="输入时使用输入运算符（-gt-gt-）"><a href="#输入时使用输入运算符（-gt-gt-）" class="headerlink" title="输入时使用输入运算符（&gt;&gt;）"></a>输入时使用输入运算符（&gt;&gt;）</h4><p>需要定义变量来保存输入</p><p>输入运算符左侧为istream，右侧为一个对象，从给定的istream读入数据，并存入给定对象中。返回<strong>左侧运算对象作为计算结果</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;v1&gt;&gt;v2;<br><span class="hljs-comment">//等价于</span><br>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;v1)&gt;&gt;v2;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;v1;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;v2;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>&gt;&gt;value)<br><span class="hljs-comment">//这条循环语句条件的求值就是表达式的结果</span><br></code></pre></div></td></tr></table></figure><p>此表达式从标准输入读取下一个数，保存在value中。</p><p>使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到<strong>文件结束符</strong>（Windows Ctrl+Z，然后Enter/Return；Unix系统，包括Mac OS X系统，为Ctrl+D），或者遇到一个无效的输入（输入与变量类型不匹配）的时候，istream对象的状态会变为无效。处于无效状态的istream对象会使条件变<strong>为假</strong></p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><h4 id="标准库中的名字"><a href="#标准库中的名字" class="headerlink" title="标准库中的名字"></a>标准库中的名字</h4><p>上面的语句中使用了std::cout和std::endl等，而不是直接的cout和endl，前缀std::是为了指出名字cout和endl是定义在名为std的命名空间中。</p><p>命名空间是为了帮助我们<strong>避免名字定义冲突</strong>（在C中不能有相同命名的变量），以及使用库中相同名字导致的冲突。</p><p>XX::YY是作用域运算符，来指出我们想使用定义在命名空间XX中的名字YY</p><p>用到的简单库函数基本都属于命名空间std，但是总是std::太麻烦了些，通过更简单的途径也能使用到命名空间中的成员，一种最安全的方法是使用<strong>using声明。</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> namesapce::name;<br></code></pre></div></td></tr></table></figure><p>一旦声明了上述语句，就可以直接访问命名空间中的名字</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>;    <span class="hljs-comment">//之后的语句中调用cin就直接使用cin即可</span><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>;  <span class="hljs-comment">//之后的语句中调用cout就直接使用cout即可</span><br></code></pre></div></td></tr></table></figure><p>要注意，用到的每个名字都必须有自己的声明语句，而且每句话都以分号结束</p><p><strong>头文件中不能使用using声明</strong>，这是因为头文件的内容会拷贝到引用它的文件中，如果头文件里有某个using声明，那么每个使用了该头文件的文件都会有这个声明，对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p><h3 id="编译中可能发生的错误"><a href="#编译中可能发生的错误" class="headerlink" title="编译中可能发生的错误"></a>编译中可能发生的错误</h3><p>与C语言一样，可能发生的错误有</p><ol><li>语法错误，比如;分号错误，字符串引号错误等</li><li>类型错误，C和C++对类型的要求比较严格</li><li>声明错误   C++中两种常见的声明错误是：对<strong>来自标准库的名字忘记使用std::<strong>、</strong>标识符名字拼写错误</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>输入输出</tag>
      
      <tag>命名空间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自学——范围for循环</title>
    <link href="/2021/07/13/C++%E8%87%AA%E5%AD%A6%E8%8C%83%E5%9B%B4for%E5%BE%AA%E7%8E%AF/"/>
    <url>/2021/07/13/C++%E8%87%AA%E5%AD%A6%E8%8C%83%E5%9B%B4for%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="范围for循环"><a href="#范围for循环" class="headerlink" title="范围for循环"></a>范围for循环</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(declaration : expression)<br>    statement<br></code></pre></div></td></tr></table></figure><p>expression表示的必须是一个序列，比如用花括号括起来的初始值列表，或者vector或string等类型的对象，这些类型的共同点是拥有能返回迭代器的begin和end成员</p><p>如果要修改元素，则使用引用，如下程序将vector中的每一个整数值翻倍。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">//范围变量必须是引用类型，这样才能对元素执行写操作</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;r : v)<span class="hljs-comment">//对于v中的每一个元素</span><br>    r *=<span class="hljs-number">2</span>;<span class="hljs-comment">//将v中每个元素的值翻倍</span><br></code></pre></div></td></tr></table></figure><p>等价于传统的for语句</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> beg = v.begin(),end = v.end();beg != end;++beg)&#123;<br>    <span class="hljs-keyword">auto</span> &amp;r = *beg;<br>    r *= <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>范围for循环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java装饰者、迭代器模式</title>
    <link href="/2021/05/27/JAVA%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/05/27/JAVA%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>多用组合，少用继承。利用组合，委托同样可以达到继承的目的</p><p>如果有两个类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>若需要实现一个类，同时具有A和B的行为，但是不能继承（JAVA）。</p><p>可以采用对象组合方式，继承一个类，另一个类的对象作为数据成员。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;<br>    B b=<span class="hljs-keyword">new</span> B();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<br>        b.g();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>继承了A，获得A的方法f()，同时有委托对象b，通过调用b.g();得到方法g().</p><p>如此，C就具有了A的行为和B的行为，达到了多重继承的效果</p><h3 id="装饰（Decorator）模式的由来"><a href="#装饰（Decorator）模式的由来" class="headerlink" title="装饰（Decorator）模式的由来"></a>装饰（Decorator）模式的由来</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527162832473.png" alt="image-20210527162832473" style="zoom: 33%;"><p>购买咖啡时，可以在其中加入调料，例如牛奶（Milk），豆浆（Soy），摩卡（Mocha）.星巴兹会根据加入的调料收取不同的费用口</p><p>第一个尝试：每加入一种新的调料，就派生一个新的子类，每个子类根据加入的调料实现cost方法<br>很明显，星巴兹为自己制造了一个维护的噩梦</p><ul><li>根据加入调料的不同组合，派生子类的数目呈<strong>组合爆炸</strong></li><li>如果调料价格变化，必须修改每个派生类的cost方法</li></ul><p>若从基类下手，利用实例变量+继承来追踪这些调料</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527163127659.png" alt="image-20210527163127659" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527163142237.png" alt="image-20210527163142237" style="zoom:33%;"><p>改进后的Beverage实现</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-comment">//为milkCost，soyCost，mochaCost声明实例变量</span><br>    <span class="hljs-comment">//为milk，soy，mocha声明getter、setter方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> cost（）&#123;<br>        <span class="hljs-keyword">float</span> condimentCost=<span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">if</span>(hasmilk()) condimentCost+=milkCost;<br>        <span class="hljs-keyword">if</span>(hasSoy()) condimentCost+=soyCost;<br>        <span class="hljs-keyword">if</span>(hasMocha()) condimentCost+=mochaCost;<br>        <span class="hljs-keyword">return</span> condimentCost;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FarkRoast</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DarkRoast</span><span class="hljs-params">()</span></span>&#123; description = <span class="hljs-string">&quot;Most execllent Dark Roast&quot;</span>;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.99</span>+<span class="hljs-keyword">super</span>.cost;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>改进的Beverage实现存在的问题<ol><li>调料价钱改变会使我们更改现有Beverage代码</li><li>一旦出现新的调料，我们就需要在超类里加上新的实例变量来记录该调料的布尔值及价格，同时要修改cost实现</li><li>万一客户想要双倍mocha怎么办？</li><li>以后会出现新的饮料（如茶Tea）。作为Beverage的子类，某些调料可能并不适合（比如milk）。但是现在的设计方式中，Tea类仍将继承那些不适合的方法如hasMilk</li><li><strong>这就是继承带来的问题：利用继承来设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为</strong></li><li>如果利用对象组合的做法扩展对象的行为，就可以在运行时动态扩展。</li><li>装饰者模式就是利用这个技巧把多个新的职责、甚至是涉及超类时还没有想到的职责加到对象上</li></ol></li></ul><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>类继承带来许多问题：类数量爆炸，设计死板，基类加入新的功能不适合所有子类</p><p>现在采用不一样的做法：以饮料为主题，在运行时以调料来“装饰”饮料，具体步骤为</p><ul><li>拿一个饮料对象，如深焙咖啡（DarkRoast）</li><li>以摩卡（Mocha）对象装饰它</li><li>以牛奶（Milk）对象装饰它</li><li>调用cost方法，并依赖委托（delegate）将调料的价钱加上去</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527164034854.png" alt="image-20210527164034854" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527164112284.png" alt="image-20210527164112284" style="zoom:33%;"><ul><li>装饰者和被装饰者有相同的超类型</li><li>可以用一个或多个装饰者装饰一个对象</li><li>既然装饰者和被装饰者有相同的超类型，所以在任何需要原始对象（被装饰的）场合，可以用装饰过的对象代替它</li><li>装饰者可以在所委托被装饰者的行为之前/之后，加上自己的行为</li><li>对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527164239616.png" alt="image-20210527164239616"></p><p>放到咖啡店的举例</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527164323382.png" alt="image-20210527164323382"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>被装饰对象的超类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    String description = <span class="hljs-string">&quot;Unknown Beverage&quot;</span>;<br>    <br>    <span class="hljs-comment">//给出描述</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br>    <span class="hljs-comment">//cost必须在子类实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>装饰者的超类，继承了被装饰对象的超类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CondimentDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-comment">//必须在具体装饰者对象实现子类实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>具体的饮料类(被装饰对象)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DarkRoast</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DarkRoast</span><span class="hljs-params">()</span></span>&#123;<br>        description = <span class="hljs-string">&quot;Dark Roast Coffee&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.99</span>; <span class="hljs-comment">//返回饮料的价格</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseBlend</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DarkRoast</span><span class="hljs-params">()</span></span>&#123;<br>        description = <span class="hljs-string">&quot;House Blend Coffee&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.89</span>; <span class="hljs-comment">//返回饮料的价格</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>具体的调料装饰者</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mocha</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CondimentDecorator</span></span>&#123;<br>    <br>    Beverage beverage;  <span class="hljs-comment">//beverage实例变量记录被装饰对象</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mocha</span><span class="hljs-params">(Beverage beverage)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.beverage=beverage;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription()+<span class="hljs-string">&quot;,Mocha&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.20</span>+beverage.cost();<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Milk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CondimentDecorator</span></span>&#123;<br>    <br>    Beverage beverage;  <span class="hljs-comment">//beverage实例变量记录被装饰对象</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Milk</span><span class="hljs-params">(Beverage beverage)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.beverage=beverage;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription()+<span class="hljs-string">&quot;,Milk&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.2</span>+beverage.cost();<br>    &#125;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>综合实例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartBuzzCoffee</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>        Beverage beverage=<span class="hljs-keyword">new</span> DarkRoast();<span class="hljs-comment">//订一杯咖啡，不叫调料</span><br>  System.out.println(beverage.getDescription()+<span class="hljs-string">&quot;$&quot;</span>+beverage.cost());<br>        beverage=<span class="hljs-keyword">new</span> Mocha(beverage); <span class="hljs-comment">//加调料Mocha</span><br>        beverage=<span class="hljs-keyword">new</span> Milk(beverage); <span class="hljs-comment">//加调料Milk</span><br>        beverage=<span class="hljs-keyword">new</span> Soy(beverage); <span class="hljs-comment">//加调料Soy</span><br>        <br>        System.out.printlf(beverage.getDescription()+<span class="hljs-string">&quot;$&quot;</span>+beverage.cost());<br>        <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果为</p><p>Dark Roast Coffee $0.99</p><p>Dark Roast Coffee,Mocha,Milk,Soy $1.49</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>使用Decorator模式可以很容易地向对象添加职责。</li><li>使用Decorator模式可以很容易地重复添加一个特性，而两次继承则极容易出错</li><li>避免在层次结构高层的类有太多的特征：可以从简单的部件组合出复杂的功能。具有低依赖性和低复杂性缺点：Decorator与Component不一样；有许多小对象</li></ul><p>实验中用到装饰者模式对数据流过滤</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527170058585.png" alt="image-20210527170058585" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527170058585.png" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527170136179.png" alt="image-20210527170136179" style="zoom:33%;"><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>将对象职责分离，最大限度减少彼此之间的耦合程度，从而建立一个松散耦合的对象网络</p><p>集合对象拥有两个职责，一是存储内部数据，二是遍历内部数据，从依赖性看，前者为对象的根本属性，后者既可以是变化的，又是可分离的。可将遍历行为分离出来，抽象为一个迭代器，专门提供遍历集合内部数据对象行为。这是迭代模式的本质</p><p>若有两家店，煎饼屋（PancakeHouse）和餐厅（Diner）的菜单</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuItem</span></span>&#123;<br>    Sting name;<br>    String description;<br>    <span class="hljs-keyword">boolean</span> vegetarian;<br>    <span class="hljs-keyword">double</span> price;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MenuItem</span><span class="hljs-params">(String name,String description,<span class="hljs-keyword">boolean</span> vegetarian,<span class="hljs-keyword">double</span> price)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>        <span class="hljs-keyword">this</span>.description=description;<br>        <span class="hljs-keyword">this</span>.vegetarian=vegetarian;<br>        <span class="hljs-keyword">this</span>.price=price;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> description;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> price;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isVegetarian</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> vegetarian;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>煎饼屋菜单用ArrayList</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PancakeHouseMenu</span></span>&#123;<br>    ArrayList menuItems;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PancakeHouseMenu</span><span class="hljs-params">()</span></span>&#123;<br>        menuItems = <span class="hljs-keyword">new</span> AyyayList();<br>        addItem(<span class="hljs-string">&quot;Pancake1&quot;</span>,<span class="hljs-string">&quot;Pancake1&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">2.99</span>);<br>        addItem(<span class="hljs-string">&quot;Pancake2&quot;</span>,<span class="hljs-string">&quot;Pancake2&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-number">2.99</span>);<br>        addItem(<span class="hljs-string">&quot;Pancake3&quot;</span>,<span class="hljs-string">&quot;Pancake3&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">3.49</span>);<br>        addItem(<span class="hljs-string">&quot;Pancake4&quot;</span>,<span class="hljs-string">&quot;Pancake4&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">3.59</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(String name,String description,<span class="hljs-keyword">boolean</span> vegatarian,<span class="hljs-keyword">double</span> price)</span></span>&#123;<br>        MenuItem item = <span class="hljs-keyword">new</span> MenuItem(name,description,vegetarian,price);<br>        menuItems.add(item);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList <span class="hljs-title">getMenuItems</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> menuItems;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>餐厅菜单</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DinerMenu</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ITEMS = <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">int</span> numberOfItems = <span class="hljs-number">0</span>;<br>    MenuItem[] menuItems;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DinerMenu</span><span class="hljs-params">()</span></span>&#123;<br>        menuItems = <span class="hljs-keyword">new</span> MenuItem[MAX_ITEMS];<br>        addItem(<span class="hljs-string">&quot;Diner1&quot;</span>,<span class="hljs-string">&quot;Diner1&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">2.99</span>);<br>        addItem(<span class="hljs-string">&quot;Diner2&quot;</span>,<span class="hljs-string">&quot;Diner2&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-number">2.99</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(Sting name,String description,<span class="hljs-keyword">boolean</span> vegetarian,<span class="hljs-keyword">double</span> price)</span></span>&#123;<br>        MenuItem item = <span class="hljs-keyword">new</span> MenuItem(name,description,vegetarian,price);<br>        <span class="hljs-keyword">if</span>(numberOfItems&lt;=MAX_ITEMS)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Sorry,menu is full!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            menuItems[numberOfItems]=item;<br>            numberOfItems++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> MenuItem[] getMenuItems()&#123;<span class="hljs-keyword">return</span> menuItems;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在煎饼屋和餐厅合并了，存在两种菜单，如果女服务员想打印菜单怎么办</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitress</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">()</span></span>&#123;<br>        PancakeHouseMenu pancakeHouseMenu = <span class="hljs-keyword">new</span> PancakeHouseMenu();<br>        ArrayList breakfastItems = pancakeHouseMenuItems.getMenuItems();<br>        <br>        DinerMenu dinerMenu = <span class="hljs-keyword">new</span> DinerMenu();<br>        MenuItem[] lunchItems = dinerMenu.getMenuItems();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;breakfastItems.size();i++)&#123;<br>            MenuItem menuItem = (MenuItem)breakfastItems.get(i);<br>            System.out.print(menuItem.getName()+<span class="hljs-string">&quot;&quot;</span>);<br>            System.out.println(menuItem.getPrice()+<span class="hljs-string">&quot;&quot;</span>);<br>            System.out.println(menuItem.getDescription());<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lunchItems.length;i++)&#123;<br>            MenuItem menuItem = lunchItems[i];<br>            System.out.print(menuItem.getName()+<span class="hljs-string">&quot;&quot;</span>);<br>            System.out.println(menuItem.getPrice()+<span class="hljs-string">&quot;&quot;</span>);<br>            System.out.println(menuItem.getDescription());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>由于两种菜单存储在不同的集合里，因此必须写两个循环，分别打印</p><p>如果增加一个菜单，放在第三种集合里，还得增加一个循环</p></blockquote><ul><li><p>这种实现的问题</p><ul><li><p>针对具体类编程，不是针对接口</p></li><li><p>女招待需要知道每种菜单如何表达内部菜单项的集合，<strong>违反了封装</strong></p></li><li><p>如果增加新的菜单，而且新菜单用别的集合来保存菜单项，我们又要修改女招待的代码</p></li><li><p>由于这二种集合遍历元素以及取元素的方法不同，导致必须写二个循环。但二个循环代码有重复</p></li></ul></li></ul><p>能不能找到一种统一的方式来遍历集合中的元素，使得只要一个循环就可以打印不同的菜单</p><h3 id="迭代器模式-1"><a href="#迭代器模式-1" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>关于迭代器模式，第一件事情：它依赖于一个名为迭代器的接口</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527182524724.png" alt="image-20210527182524724"></p><p>一旦我们有了迭代器接口，就可以为各种对象集合实现迭代器：数组，链表，Hash表等</p><p>DinerMenu的迭代器</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DinerMenuIerator</span> <span class="hljs-title">impements</span> <span class="hljs-title">Iterator</span></span>&#123;<br>    <span class="hljs-comment">//position记录当前遍历的位置，items是集合对象</span><br>    MenuItem[] items;<br>    <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//通过构造函数，传递集合对象给迭代器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DinerMenuIterator</span><span class="hljs-params">(MenuItem[] items)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.items = items;<br>    &#125;<br>    <br>    <span class="hljs-comment">//因为使用数组（长度固定），所以不仅要检查position是否超出数组长度，还必须检查下一项是否为null，如果为null，表示没有下一项了</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(position&gt;=items.length||items[position]==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//返回数组内的下一项，并递增当前遍历的位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;<br>        MenuItems = items[position];<br>        position++;<br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>PancakeHouseMenu的迭代器</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PancakeHouseMenuIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span></span>&#123;<br>    ArrayList items;<br>    <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PancakeHOuseMenuIterator</span><span class="hljs-params">(ArrayList items)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.items = items;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(position&lt;=items.size())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;<br>        MenuItem item = (MenuItem)items.get(position);<br>        position++;<br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在改写餐厅菜单</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DinerMenu</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ITEMS=<span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">int</span> numberOfItems = <span class="hljs-number">0</span>;<br>    MenuItem[] menuItems;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DinerMenu</span><span class="hljs-params">()</span></span>&#123;<br>        ...<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">additem</span><span class="hljs-params">(String name,String description,<span class="hljs-keyword">boolean</span> vegetarian,<span class="hljs-keyword">double</span> price)</span></span>&#123;<br>        ...<br>    &#125;<br>    <br>   <span class="hljs-comment">//将以前的getMenuItems更换成迭代器</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DinerMenuIterator(menuItems);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>返回迭代器接口，客户不需要知道餐厅菜单如何维护菜单项，也不需要知道迭代器如何实现，只需直接使用迭代器遍历菜单项。</p></blockquote><p>改写煎饼屋菜单</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PancakeHouseMenu</span></span>&#123;<br>    ArrayList menuItems;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PancakeHouseMenu</span><span class="hljs-params">()</span></span>&#123;<br>        ...<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(String name,String description,<span class="hljs-keyword">boolean</span> vegetarian,<span class="hljs-keyword">double</span> price)</span></span>&#123;<br>        ...<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PancakeHouseMenuIterator(menuItems);<br>    &#125;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>改写女招待代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitress</span></span>&#123;<br>    PancakeHouseMenu pancakeHouseMenu;<br>    DinerMenu dinerMenu;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Waitress</span><span class="hljs-params">(PancakeHouseMenu pm,DinerMenu dm)</span></span>&#123;<br>        pancakeHouseMenu = pm; dinerMenu = dm;<br>    &#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-comment">//分别得到两个菜单的迭代器</span><br>       Iterator pancakeIt = pancakeHouseMenu.createIterator();<br>       Iterator dinerIt = dinerMenu.createIterator();<br>       <br>       printMenu(pancakeIt);<br>       printMenu(dinerIt);<br>   &#125;<br>    <span class="hljs-comment">//现在的printMenu函数利用迭代器来遍历集合中的元素，而不用关心集合是如何组织元素的</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">(Iteratorit)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            MenuItem menuItem = (MenuItem)it.next();<br>            System.out.print(menuItem.getName()+<span class="hljs-string">&quot;&quot;</span>);<br>            System.out.print(menuItem.getPrice+<span class="hljs-string">&quot;&quot;</span>);<br>            System.out.println(menuuItem.getDescription());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>目前为止</p><ul><li>菜单的实现已经被封装起来了，女招待不知道每种菜单如何存储内部菜单项的</li><li>只要实现迭代器，我们只需要一个循环，就可以多态地处理任何项的集合</li><li>女招待现在只使用一个接口（迭代器）</li><li>但女招待仍然捆绑于两个具体的菜单类，需要修改下。</li></ul><p>定义Menu接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Menu</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DinerMenu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Menu</span></span>&#123;<br>    <span class="hljs-comment">//其他不变</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIteraor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DinerMenuIterator(menuItems);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PancakeHouseMenu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Menu</span></span>&#123;<br>    <span class="hljs-comment">//其他不变</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIteraor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PancakeHouseMenuIterator(menuItems);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在女招待不再捆绑到具体类了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitress</span></span>&#123;<br>    Menu pancakeHouseMenu;<br>    Menu dinerMenu;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Waitress</span><span class="hljs-params">(Menu pm,Menu dm)</span></span>&#123;<br>        pancakeHouseMenu = pm; dinerMenu = dm;<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-comment">//分别得到两个菜单的迭代器</span><br>       Iterator pancakeIt = pancakeHouseMenu.createIterator();<br>       Iterator dinerIt = dinerMenu.createIterator();<br>       <br>       printMenu(pancakeIt);<br>       printMenu(dinerIt);<br>   &#125;<br>    <span class="hljs-comment">//现在的printMenu函数利用迭代器来遍历集合中的元素，而不用关心集合是如何组织元素的</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">(Iteratorit)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            MenuItem menuItem = (MenuItem)it.next();<br>            System.out.print(menuItem.getName()+<span class="hljs-string">&quot;&quot;</span>);<br>            System.out.print(menuItem.getPrice+<span class="hljs-string">&quot;&quot;</span>);<br>            System.out.println(menuuItem.getDescription());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527194943682.png" alt="image-20210527194943682"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示*</li><li>把遍历元素的任务从聚合对象剥离出来，放到迭代器上。这样简化了聚合的接口和实现。也让任务各得其所口职责分离！<ul><li>一个类一个职责</li><li>一个职责意味着一个变化的可能</li><li>类的职责多了，意味着变化的可能多了，类被修改的可能性就大</li></ul></li></ul><ul><li>意图<ul><li>迭代器模式的目的是设计一个迭代器，提供一种可顺序访问聚合对象中各个元素的方法，但不暴露该对象内部表示</li></ul></li><li>适用场合<ul><li>访问一个聚合对象的内容而无需暴露其内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个统一接口（支持多态迭代）</li></ul></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527195238651.png" alt="image-20210527195238651"></p><p><strong>迭代器模式的参与者</strong></p><ul><li><p>Iterator</p><ul><li>定义访问和遍历元素的接口</li></ul></li><li><p>Concrete Iterator</p><ul><li>实现迭代器接口</li></ul></li><li><p>Aggregate</p><ul><li>定义创建迭代器对象的接口</li></ul></li><li><p>Concrete Aggregate</p><ul><li>实现创建迭代器的接口，返回具体迭代器的一个实例</li></ul></li><li><p>简化了聚集的行为，迭代器具备遍历接口的功能，聚集不必具备遍历接口</p></li><li><p>每一个聚集对象都可以有一个或者更多的迭代器对象，每一个迭代器的迭代状态可以彼此独立</p></li><li><p>遍历算法被封装到迭代器对象中，迭代算法可以独立于聚集对象变化。客户端不必知道聚集对象的类型，通过迭代器就可以读取和遍历聚集对象。聚集内部数据发生变化不影响客户端程序</p></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527195544234.png" alt="image-20210527195544234"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>装饰者模式</tag>
      
      <tag>迭代器模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机Ubuntu共享文件夹不显示问题</title>
    <link href="/2021/05/24/Ubuntu%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <url>/2021/05/24/Ubuntu%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="一个奇葩的问题"><a href="#一个奇葩的问题" class="headerlink" title="一个奇葩的问题"></a>一个奇葩的问题</h2><p>为了课程要求，下载了VM 16pro，安装了Ubuntu 16.04 32位。</p><p>要设置一个共享文件夹，但是始终不显示，试过了网上的所有方法，都没有用</p><p>最后找到了一个解决方式：</p><p>安装VMware Tools的时候，在最后的询问填no，再回车就可以解决。</p><p>sudo ./wmware-install.pl后，一路回车，直到提示：</p><p>would you like to revover the wasted disk space by uninstalling VMware Tools at this time?(yes/no) [yes] <strong>no</strong></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210524171118278.png" alt="image-20210524171118278"></p><p>设置的共享文件夹，终于出现了</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>随便记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长沙游记</title>
    <link href="/2021/05/13/%E9%95%BF%E6%B2%99%E6%B8%B8%E8%AE%B0/"/>
    <url>/2021/05/13/%E9%95%BF%E6%B2%99%E6%B8%B8%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>为何男大学生频频咕咕</p><p>为何拿曾经立志写技术类的小博客写恋爱日记</p><p>为何计算机专业不修边幅的肥宅也能拥有女朋友</p><p>之反正也没人看就爱写着玩嘿嘿嘿</p></blockquote><span id="more"></span><p>换了个主题感觉好看了很多，但是由于不懂前端很多想添加的功能没有教程就不了了之，甚至有了学前端的想法，但是就我这审美能力……算了</p><h3 id="五一不宅家，路途两行泪"><a href="#五一不宅家，路途两行泪" class="headerlink" title="五一不宅家，路途两行泪"></a><em><strong>五一不宅家，路途两行泪</strong></em></h3><p>抢票抢不到候补了好几天，发现抢成了学生票用不了，只能重新抢票却抢到了早上六点多开的高铁</p><p>4.30号一整天都预约不上早上去武汉站的车的我做出了大胆的决定——通宵火车站</p><p>曾经以为会用通宵的时间来复习数电，却忽略了嘈杂的环境以及很不舒服的长椅——我认为我可以系列再添新成员。</p><p>期间不慎误入夜间不营业A区，成为纳闷为何堂堂武汉站竟没有人的憨批</p><p>建议如果火车站通宵属实不如就近找个网吧，还舒服点😪</p><hr><h3 id="宅家哪有见npy香"><a href="#宅家哪有见npy香" class="headerlink" title="宅家哪有见npy香"></a><em><strong>宅家哪有见npy香</strong></em></h3><p>头一次感觉高铁的二等座睡觉这么香，虽然感觉自己肾透支，但是！见女朋友就是要支楞起来！</p><p>一见面就得到一束红豆，感觉学到了什么新的东西——红豆竟然是种花而不是吃的！！😂</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204220.jpg" style="zoom: 20%;"><p>终于可以坐地铁直接到中南大学了，而不是像以前一样被npy领着坐<strong>反方向</strong>的公交了（yysy长沙的公交车老师太狂野了）</p><hr><h3 id="心心念念的杀猪粉"><a href="#心心念念的杀猪粉" class="headerlink" title="心心念念的杀猪粉"></a><em><strong>心心念念的杀猪粉</strong></em></h3><p>第一次来长沙的第一顿饭就是杀猪粉，对其有莫名的情感，在一年的时间不停的叨扰npy表示想吃，终于实现了这个愿望！</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204249.jpg" style="zoom: 25%;"><p>过程中穿过了整个升华，非常羡慕中南学子们多个校区能每天出校玩。</p><p>五一期间华科梧桐（<strong>絮</strong>）雨风头正盛，来到了没有梧桐絮的学校感到泪目</p><p>杀猪粉店内的小猪表示很开心🤣</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204251.jpg" style="zoom: 20%;"><p>麓山南路上好吃的很多，去买了传说中的麻薯</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204301.jpg" style="zoom: 20%;"><p>本想中午南门口晚上码头，但是</p><p>男朋友实在支楞不起来了🤕</p><p>但是时间太早还不能去旅馆，先去喝一下茶颜，没有点幽兰拿铁，尝试抹茶菩提与少年时，茶颜悦色yyds！（经过其后两天观察发现长沙的茶颜比武汉的茶颜队伍都长，旅游城市，恐怖如斯）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204305.jpg" style="zoom: 20%;"><hr><h3 id="与舍友的事情最终还是被发现了"><a href="#与舍友的事情最终还是被发现了" class="headerlink" title="与舍友的事情最终还是被发现了"></a><em><strong>与舍友的事情最终还是被发现了</strong></em></h3><p>由于太困下午好好睡了两个多小时，但是睡梦中的男人往往很容易祸从口出</p><p>据说我在睡眠时喊了数次yan yan</p><p>噢yanyan是我可爱的重庆舍友</p><p>洗不清了🤥</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210513213857790.png" style="zoom: 25%;"><hr><h3 id="山东老乡：“你们为什么能吃那么多”"><a href="#山东老乡：“你们为什么能吃那么多”" class="headerlink" title="山东老乡：“你们为什么能吃那么多”"></a><em><strong>山东老乡：“你们为什么能吃那么多”</strong></em></h3><p>长沙，没啥好解释的</p><p>虽然南门口——黄兴步行街——五一广场——太平老街人山人海，但是不影响想吃的人。</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204311.jpg" style="zoom: 25%;"></figure></center><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204308.jpg" style="zoom:22%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204314.jpg" style="zoom:17%;"></figure></center><p>上图为导致了山东大汉三天拉肚子的罪魁祸首——有点淡（指咸度而不是辣度），但是拌上晚上买的泡菜烤冷面以后莫名好吃的很😌</p><p>如下分别为：某不知名臭豆腐，炸鲜奶和炸串以及长沙经典紫苏桃子和杨梅荔枝</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204316.jpg" style="zoom:18%;">    <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204321.jpg" style="zoom:18%;">    <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204327.jpg" style="zoom:18%;"></figure></center><p>在南门口这边逛完了，直接走就能到五一广场，非常惊奇长郡中学就坐落在如此热闹的地方。</p><p>经过许多次比较还是黑色经典的臭豆腐最好吃</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204335.jpg" style="zoom: 17%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204338.jpg" style="zoom:17%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204342.jpg" style="zoom:13%;"></figure></center><hr><h3 id="实现心愿之看羊驼"><a href="#实现心愿之看羊驼" class="headerlink" title="实现心愿之看羊驼"></a><em><strong>实现心愿之看羊驼</strong></em></h3><p>五一广场有个看动物的小店</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204407.jpg" style="zoom:19%;"><img src="/.cn//Users/liuYIkang/Desktop/%E7%85%A7%E7%89%87/QQ%E5%9B%BE%E7%89%8720210513204606.jpg" style="zoom:10%;"></figure></center><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204359.jpg" style="zoom:20%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204352.jpg" style="zoom:20%;"></figure></center><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204348.jpg" style="zoom:33%;"></figure></center><p>到处拱人的小香猪</p><p>很能吃的胖兔子</p><p>接客一天十分疲劳看上去很委屈的狗勾</p><p>满屋的猫猫中的两只长得很凶的无毛猫</p><p>一只猪和一只羊驼快乐的玩耍😛</p><p>还有浣熊和刺猬，但是拍的照片有粑粑不是很想贴上来</p><hr><h3 id="吃了那么多，我还能吃"><a href="#吃了那么多，我还能吃" class="headerlink" title="吃了那么多，我还能吃"></a><em><strong>吃了那么多，我还能吃</strong></em></h3><p>虽然吃了很多东西，但是打消我们吃烤肉念头的是十一点多了，还要排队四十桌。</p><p>回到后湖，买了半个大西瓜和泡菜烤冷面以及我认为的长沙全场MVP——梅菜扣肉饼！！😍</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/12.jpg" style="zoom:25%;"><p>晚上看了一直没看过的唐人街探案。</p><hr><h3 id="来了长沙却吃东北馆子是什么操作"><a href="#来了长沙却吃东北馆子是什么操作" class="headerlink" title="来了长沙却吃东北馆子是什么操作"></a><em><strong>来了长沙却吃东北馆子是什么操作</strong></em></h3><p>当然是因为北方人对肉和碳水爱的深沉</p><p>第二天中午去中南新校旁的东北馆子吃的，个人觉得口味非常非常不错</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204428.jpg" style="zoom:18%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204421.jpg" style="zoom:18%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204426.jpg" style="zoom:18%;"></figure></center><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ图片20210513204423.jpg" style="zoom:20%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204418.jpg" style="zoom:27%;"></figure></center><hr><h3 id="长沙太热了之白天睡一天理直气壮"><a href="#长沙太热了之白天睡一天理直气壮" class="headerlink" title="长沙太热了之白天睡一天理直气壮"></a><em><strong>长沙太热了之白天睡一天理直气壮</strong></em></h3><p>第一次在南方经历夏天，四月末五月初就34度了🥵………………太恐怖了，青岛最热的时候也才33度左右</p><p>祝愿能活着度过武汉的第一个夏天</p><p>傍晚黄昏去吃了螺xi粉</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204430.jpg" style="zoom:25%;"></figure></center><p>上图是豆干而不是肉，不要被骗</p><p>我发誓这是微辣，但是我吃完以后嗓子哑了半个多小时（也许我将在家吃饭的习惯带了过来导致的——吃面一定要喝汤😅）</p><p>然后开始今天最重要的一个事项</p><p>做戒指！</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204612.jpg" style="zoom:8%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204618.jpg" style="zoom:10%;"></figure></center><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204621.jpg" alt="QQ图片20210513204621" style="zoom:8%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204630.jpg" alt="QQ图片20210513204630" style="zoom:10%;"></figure></center><p>指纹爱心款纪念日戒指🤩</p><hr><h3 id="反正就是能一直吃"><a href="#反正就是能一直吃" class="headerlink" title="反正就是能一直吃"></a><em><strong>反正就是能一直吃</strong></em></h3><p>夜晚的太平老街……人真的多</p><p>时隔一年第二次来这里有不一样的体验（主要是第一次在这里买到了 50一点点的坑爹水果捞，心有余悸）</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204433.jpg" style="zoom:25%;"></figure></center><p>罗记臭豆腐，店也很多，但是感觉不如黑色经典好吃</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204438.jpg" style="zoom:20%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204441.jpg" style="zoom:20%;"></figure></center><p>经典臭豆腐博物馆，里面挺有意思的</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204550.jpg" style="zoom:13%;"><p>想着今晚一定能吃么子烤肉，但是很不巧的是没赶上叫号……但是就算再等，也一定要吃</p><p>十一点吃到一点的烤肉</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204446.jpg" style="zoom:25%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204451.jpg" style="zoom:19%;"></figure></center><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204501.jpg" style="zoom:12%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204453.jpg" style="zoom:16%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204458.jpg" style="zoom:16%;"></figure></center><p>虽然这么晚了但是仍然可以吃烤五花肉，烤牛舌，烤虾滑（赞），烤地瓜，烤桂花年糕，猪油拌面以及若干水果泡菜</p><p>不愧是我（们）</p><hr><h3 id="未曾设想的道路：叫不到车试图凌晨一点骑车回旅馆"><a href="#未曾设想的道路：叫不到车试图凌晨一点骑车回旅馆" class="headerlink" title="未曾设想的道路：叫不到车试图凌晨一点骑车回旅馆"></a><em><strong>未曾设想的道路：叫不到车试图凌晨一点骑车回旅馆</strong></em></h3><p>倒也理解吧，节假日游客量这么多，打车软件叫不上车，但是景区门口多了不少几倍价格的络绎不绝的私家车</p><p>毕竟五一，都是劳动人民，理解万岁</p><p>最后花了80RMB回了后湖，倒也不算太贵。</p><p>此时段重点：手掌画</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204503.jpg" style="zoom:20%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204506.jpg" style="zoom:20%;"></figure></center><hr><h3 id="后湖太香了为什么华科的铁皮屋要拆掉呜呜"><a href="#后湖太香了为什么华科的铁皮屋要拆掉呜呜" class="headerlink" title="后湖太香了为什么华科的铁皮屋要拆掉呜呜"></a><em><strong>后湖太香了为什么华科的铁皮屋要拆掉呜呜</strong></em></h3><p>yysy，便宜又好吃，这样的街谁不想有呢</p><p>可惜了没买到梅菜扣肉饼，真的好吃</p><p>后湖的一个食社和npy一起吃了最后一顿饭</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204513.jpg" style="zoom:19%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204510.jpg" style="zoom:25%;"></figure></center><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204625.jpg" style="zoom:36%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204515.jpg" style="zoom:18%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204517.jpg" style="zoom:18%;"></figure></center><p>水果燕麦杯，墨西哥薄饼，金枪鱼沙拉，照烧鸡腿饭（可惜没有什么汁）</p><p>有时候时常会想要是和npy一个学校就好了，但是也许吧，距离带来思念与美感。</p><p>我会享受在你学校中漫步的每一秒时光，体验在一个校园中生活的那一丝感觉。</p><p>最后一点时间去了宜家，第一次去宜家感觉，太容易迷路了吧</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204531.jpg" style="zoom:25%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204526.jpg" style="zoom:19%;"></figure></center><hr><h3 id="做一个不太那么残忍的男朋友系列"><a href="#做一个不太那么残忍的男朋友系列" class="headerlink" title="做一个不太那么残忍的男朋友系列"></a><em><strong>做一个不太那么残忍的男朋友系列</strong></em></h3><p>本想贴一张小猪狂哭的照片，算liao算liao🤔</p><p>显得我不那么心狠手辣</p><p>附一张合照吧，一定减肥一定减肥别骂了别骂了</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204528.jpg" style="zoom:25%;"><p>文末日常附女朋友的精修图，虽然可能压缩后清晰度……</p><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204602.jpg" style="zoom:15%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204555.jpg" style="zoom:14%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204557.jpg" style="zoom:13%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204640.jpg" style="zoom:9%;"></figure></center><center><figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204642.jpg" alt="QQ图片20210513204642" style="zoom:23%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204655.jpg" alt="QQ图片20210513204655" style="zoom:25%;"></figure></center><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/QQ%E5%9B%BE%E7%89%8720210513204652.jpg" style="zoom:33%;"><hr><h3 id="当然，我们的故事会绿水长流，这些不过是逐渐填充的日记本中的几页而已。"><a href="#当然，我们的故事会绿水长流，这些不过是逐渐填充的日记本中的几页而已。" class="headerlink" title="当然，我们的故事会绿水长流，这些不过是逐渐填充的日记本中的几页而已。"></a><strong>当然，我们的故事会绿水长流，这些不过是逐渐填充的日记本中的几页而已。</strong></h3><p>🤜🤛</p><p>end</p>]]></content>
    
    
    <categories>
      
      <category>大学生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog一些简单电路</title>
    <link href="/2021/05/11/verilog%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%94%B5%E8%B7%AF/"/>
    <url>/2021/05/11/verilog%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="七段数码管"><a href="#七段数码管" class="headerlink" title="七段数码管"></a>七段数码管</h2><p>模块定义</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> <span class="hljs-number">_7</span>Seg_Driver_Decode(SW, SEG, AN, LED);<br><span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] SW;   <span class="hljs-comment">// 16位拨动开关</span><br><span class="hljs-keyword">output</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] SEG;  <span class="hljs-comment">// 7段数码管驱动，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;<span class="hljs-comment">// 7段数码管片选信号，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] LED;   <span class="hljs-comment">// 16位LED显示</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="直接驱动7段数码管（7-SegDisplay）"><a href="#直接驱动7段数码管（7-SegDisplay）" class="headerlink" title="直接驱动7段数码管（7-SegDisplay）"></a>直接驱动7段数码管（7-SegDisplay）</h3><p>使用“数据流描述”设计“7段数码管直接驱动”模块。</p><ul><li><p>用SW[7:0]直接驱动7段数码管的CA-CG、DP显示单元。</p></li><li><p>用SW[15:8]选择被驱动的7段数码管。</p></li><li><p>用LED[15:0]显示SW的状态。</p></li></ul><p>拨动开关与7-SegDisplay对应关系</p><table><thead><tr><th><strong>拨动开关编号</strong></th><th><strong>7-SegDisplay</strong></th></tr></thead><tbody><tr><td>SW7</td><td>CA</td></tr><tr><td>SW6</td><td>CB</td></tr><tr><td>SW5</td><td>CC</td></tr><tr><td>SW4</td><td>CD</td></tr><tr><td>SW3</td><td>CE</td></tr><tr><td>SW2</td><td>CF</td></tr><tr><td>SW1</td><td>CG</td></tr><tr><td>SW0</td><td>DP</td></tr></tbody></table><p>代码如下</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> <span class="hljs-number">_7</span>Seg_Driver_Direct(SW, CA, CB, CC, CD, CE, CF, CG, DP, AN, LED);<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] SW;                          <span class="hljs-comment">// 16位拨动开关</span><br><span class="hljs-keyword">output</span> CA, CB, CC, CD, CE, CF, CG, DP;    <span class="hljs-comment">// 7段数码管驱动，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;                          <span class="hljs-comment">// 7段数码管片选信号，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] LED;                        <span class="hljs-comment">// 16位LED显示，高电平有效</span><br><br><span class="hljs-keyword">assign</span> &#123;CA, CB, CC, CD, CE, CF, CG, DP&#125; = SW[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> AN[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = SW[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br><span class="hljs-keyword">assign</span> LED[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] = SW[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="译码驱动七段数码管"><a href="#译码驱动七段数码管" class="headerlink" title="译码驱动七段数码管"></a>译码驱动七段数码管</h3><ul><li><p>添加<strong>译码器</strong>，<strong>用SW[3:0]输入待显示的单个数字</strong>,转换成对应的数码管应该亮的位置，而不是之前通过[7:0] SEG直接控制LED亮。</p></li><li><p>输入数字与显示对应表如表3-2。</p></li><li><p>用SW[15:8]选择被驱动的7段数码管。</p></li><li><p>用LED[15:0]显示SW的状态。</p></li></ul><p>输入与7-SegDisplay对应关系及显示码</p><table><thead><tr><th><strong>输入数字</strong></th><th><strong>7-SegDisplay</strong></th><th><strong>显示码</strong></th></tr></thead><tbody><tr><td>0000</td><td>0</td><td>11000000</td></tr><tr><td>0001</td><td>1</td><td>11111001</td></tr><tr><td>0010</td><td>2</td><td>10100100</td></tr><tr><td>0011</td><td>3</td><td>10110000</td></tr><tr><td>0100</td><td>4</td><td>10011001</td></tr><tr><td>0101</td><td>5</td><td>10010010</td></tr><tr><td>0110</td><td>6</td><td>10000010</td></tr><tr><td>0111</td><td>7</td><td>11111000</td></tr><tr><td>1000</td><td>8</td><td>10000000</td></tr><tr><td>1001</td><td>9</td><td>10011000</td></tr><tr><td>1010</td><td>A</td><td>10001000</td></tr><tr><td>1011</td><td>b</td><td>10000011</td></tr><tr><td>1100</td><td>C</td><td>11000110</td></tr><tr><td>1101</td><td>d</td><td>10100001</td></tr><tr><td>1110</td><td>E</td><td>10000110</td></tr><tr><td>1111</td><td>F</td><td>10001110</td></tr></tbody></table><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210511112315620.png" style="zoom: 50%;"><h4 id="四位转16位译码器"><a href="#四位转16位译码器" class="headerlink" title="四位转16位译码器"></a>四位转16位译码器</h4><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> decoder_4to16(in, out);<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] in;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out;<br><br>    <span class="hljs-keyword">always</span>@(in)<br>        <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">case</span>(in)<br>                <span class="hljs-number">4&#x27;b0000</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11000000</span>;<br>                <span class="hljs-number">4&#x27;b0001</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11111001</span>;<br>                <span class="hljs-number">4&#x27;b0010</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10100100</span>;<br>                <span class="hljs-number">4&#x27;b0011</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10110000</span>;<br>                <span class="hljs-number">4&#x27;b0100</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10011001</span>;<br>                <span class="hljs-number">4&#x27;b0101</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10010010</span>;<br>                <span class="hljs-number">4&#x27;b0110</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10000010</span>;<br>                <span class="hljs-number">4&#x27;b0111</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11111000</span>;<br>                <span class="hljs-number">4&#x27;b1000</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10000000</span>;<br>                <span class="hljs-number">4&#x27;b1001</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10011000</span>;<br>                <span class="hljs-number">4&#x27;b1010</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10001000</span>;<br>                <span class="hljs-number">4&#x27;b1011</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10000011</span>;<br>                <span class="hljs-number">4&#x27;b1100</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11000110</span>;<br>                <span class="hljs-number">4&#x27;b1101</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10100001</span>;<br>                <span class="hljs-number">4&#x27;b1110</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10000110</span>;<br>                <span class="hljs-keyword">default</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10001110</span>;<br>            <span class="hljs-keyword">endcase</span><br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p>译码驱动七段数码管</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> <span class="hljs-number">_7</span>Seg_Driver_Decode(SW, SEG, AN, LED);<br><span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] SW;           <span class="hljs-comment">// 16位拨动开关</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] SEG;      <span class="hljs-comment">// 7段数码管驱动，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;           <span class="hljs-comment">// 7段数码管片选信号，低电平有效</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] LED;         <span class="hljs-comment">// 16位LED显示</span><br><br>decoder_4to16(<span class="hljs-variable">.in</span>(SW[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.out</span>(SEG[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]));<br>    <br>    <span class="hljs-keyword">assign</span> AN[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]   = SW[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">assign</span> LED[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] = SW[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="译码选择7段数码管"><a href="#译码选择7段数码管" class="headerlink" title="译码选择7段数码管"></a>译码选择7段数码管</h3><p>不仅数码管显示的数字直接通过译码器显示，对于哪个数码管亮的选择，采用选择器，三位的开关选择8个数码管谁亮。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210511113303265.png" style="zoom:50%;"><h4 id="三转八选择器"><a href="#三转八选择器" class="headerlink" title="三转八选择器"></a>三转八选择器</h4><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> selector_3to8(in, out);<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] in;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out;<br>    <br>    <span class="hljs-keyword">always</span>@(in)  <br>        <span class="hljs-keyword">case</span>(in)  <br>            <span class="hljs-number">3&#x27;b000</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11111110</span>;<br>            <span class="hljs-number">3&#x27;b001</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11111101</span>;<br>            <span class="hljs-number">3&#x27;b010</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11111011</span>;<br>            <span class="hljs-number">3&#x27;b011</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11110111</span>;<br>            <span class="hljs-number">3&#x27;b100</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11101111</span>;<br>            <span class="hljs-number">3&#x27;b101</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b11011111</span>;<br>            <span class="hljs-number">3&#x27;b110</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b10111111</span>;<br>            <span class="hljs-keyword">default</span> : out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = <span class="hljs-number">8&#x27;b01111111</span>;<br>        <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p>用译码器和选择器组成的译码选择七段数码管</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> <span class="hljs-number">_7</span>Seg_Driver_Choice(SW, SEG, AN, LED);<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] SW;       <span class="hljs-comment">// 16位拨动开关</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] SEG;      <span class="hljs-comment">// 7段数码管驱动，低电平有效</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;       <span class="hljs-comment">// 7段数码管片选信号，低电平有效</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] LED;     <span class="hljs-comment">// 16位LED显示</span><br><br>    selector_3to8(<span class="hljs-variable">.in</span>(SW[<span class="hljs-number">15</span>:<span class="hljs-number">13</span>]), <span class="hljs-variable">.out</span>(AN[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]));<br>    decoder_4to16(<span class="hljs-variable">.in</span>(SW[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.out</span>(SEG[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]));<br>    <br>    <span class="hljs-keyword">assign</span> LED[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] = SW[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="简单时序电路-数码管动态显示"><a href="#简单时序电路-数码管动态显示" class="headerlink" title="简单时序电路 数码管动态显示"></a>简单时序电路 数码管动态显示</h3><h4 id="分频器"><a href="#分频器" class="headerlink" title="分频器"></a>分频器</h4><ul><li><p>nexys4ddr实验板的系统时钟信号由E3引脚提供，频率100MHz，周期10ns。</p></li><li><p>设计一个频率为1Hz（周期为1s）的分频器divider，可在模块中用parameter定义一个参数delay，值为50,000,000，同时定义一个变量cnt对系统时钟clk的上升沿进行计数。每当cnt计数到delay（50,000,000×10ns=500,000,000ns=0.5s）时，将分频时钟信号CK的电平反转，即可得到周期为1s的分频时钟信号。在上层模块中实例化divider模块时，可传递新的参数来调整delay的值，得到合适频率的分频时钟信号。</p></li><li><p>设计上层模块lab3_1，实例化分频器模块divider，用分频器模块的输出信号控制led[0]闪亮。</p></li><li><p>在上层模块中修改分频器模块的参数delay，观察led[0]闪亮快慢的变化。</p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> divider(clk, clk_N);<br>    <span class="hljs-keyword">input</span> clk;                      <span class="hljs-comment">// 系统时钟</span><br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> clk_N;                   <span class="hljs-comment">// 分频后的时钟</span><br>    <span class="hljs-keyword">parameter</span> N = <span class="hljs-number">50_000_000</span>;     <span class="hljs-comment">// 1Hz的时钟,N=fclk/fclk_N</span><br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] counter;             <span class="hljs-comment">/* 计数器变量，通过计数实现分频。当计数器从0计数到50_000_000时，输出时钟翻转，计数器清零 */</span><br><br>    <span class="hljs-keyword">initial</span><br>    <span class="hljs-keyword">begin</span>                           <span class="hljs-comment">// 赋初始值</span><br>        counter = <span class="hljs-number">0</span>;<br>        clk_N = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)           <span class="hljs-comment">// 时钟上升</span><br>    <span class="hljs-keyword">begin</span><br>        counter &lt;= counter + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (counter &gt; N )   <span class="hljs-comment">//每次初始时钟记满50_000_000次后，即每0.5s，新的时钟信号翻转一次，就得到了周期为1s的时钟。</span><br>            <span class="hljs-keyword">begin</span><br>                clk_N &lt;= ~clk_N;<br>                counter &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h4 id="三位计数器"><a href="#三位计数器" class="headerlink" title="三位计数器"></a>三位计数器</h4><ul><li>所谓计数器就是在时钟信号沿的控制下能够进行自动加或减（通常是+1或-1）的时序电路。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> counter(clk, out);<br>    <span class="hljs-keyword">input</span> clk;                    <span class="hljs-comment">// 计数时钟</span><br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] out;         <span class="hljs-comment">// 计数值</span><br><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)         <span class="hljs-comment">// 在时钟上升沿计数器加1</span><br>    <span class="hljs-keyword">begin</span><br>        out &lt;= out + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h4 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h4><ul><li>设计一个容量为8单元的4位只读存储器，里面存放待显示数字0、2、4、6、8、A、C、E 的4位二进制编码，可在initial语句中对存储器进行初始化。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> rom8x4(addr, data);<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] addr;               <span class="hljs-comment">// 地址</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] data;              <span class="hljs-comment">// 地址addr处存储的数据 </span><br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>: <span class="hljs-number">0</span>] mem [<span class="hljs-number">7</span>: <span class="hljs-number">0</span>];          <span class="hljs-comment">//  8个4位的存储器</span><br><br>    <span class="hljs-keyword">initial</span>                         <span class="hljs-comment">// 初始化存储器</span><br>        <span class="hljs-keyword">begin</span><br>            mem[<span class="hljs-number">0</span>]=<span class="hljs-number">4&#x27;b0000</span>;<br>            mem[<span class="hljs-number">1</span>]=<span class="hljs-number">4&#x27;b0010</span>;<br>            mem[<span class="hljs-number">2</span>]=<span class="hljs-number">4&#x27;b0100</span>;<br>            mem[<span class="hljs-number">3</span>]=<span class="hljs-number">4&#x27;b0110</span>;<br>            mem[<span class="hljs-number">4</span>]=<span class="hljs-number">4&#x27;b1000</span>;<br>            mem[<span class="hljs-number">5</span>]=<span class="hljs-number">4&#x27;b1010</span>;<br>            mem[<span class="hljs-number">6</span>]=<span class="hljs-number">4&#x27;b1100</span>;<br>            mem[<span class="hljs-number">7</span>]=<span class="hljs-number">4&#x27;b1110</span>;<br>        <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">assign</span> data[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] = mem[addr];   <span class="hljs-comment">// 读取addr单元的值输出</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h4 id="数码管动态显示"><a href="#数码管动态显示" class="headerlink" title="数码管动态显示"></a>数码管动态显示</h4><p>顶层模块</p><p>实现八个数码管从右至左“分时”显示存储器中的数据，即mem[0]值在AN0显示，mem[1]值在AN1显示，……</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> dynamic <span class="hljs-number">_</span>scan(clk,  SEG, AN);<br><span class="hljs-keyword">input</span> clk;              <span class="hljs-comment">// 系统时钟</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] SEG;  <span class="hljs-comment">// 分别对应CA、CB、CC、CD、CE、CF、CG和DP</span><br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;        <span class="hljs-comment">// 8位数码管片选信号</span><br><br>┋                      <span class="hljs-comment">// 功能实现</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210511120547376.png" style="zoom: 33%;"><p>信号进来以后，先通过分频器得到人眼可以识别的信号频率</p><p>新的信号频率通过计数器得到八位不同状态</p><p>计数器得到的数据分别用来选择数码管和显示数字</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> dynamic_scan(clk, SEG, AN);<br>    <span class="hljs-keyword">input</span> clk;              <span class="hljs-comment">// 系统时钟</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] SEG;  <span class="hljs-comment">// 分别对应CA、CB、CC、CD、CE、CF、CG和DP</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] AN;        <span class="hljs-comment">// 8位数码管片选信</span><br>    <span class="hljs-keyword">wire</span> clk_tmp;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] num;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] code;<br><br>    divider d1(<span class="hljs-variable">.clk</span>(clk), <span class="hljs-variable">.clk_N</span>(clk_tmp));<br>    counter c1(<span class="hljs-variable">.clk</span>(clk_tmp), <span class="hljs-variable">.out</span>(num[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]));<br>    selector_3to8(<span class="hljs-variable">.in</span>(num[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.out</span>(AN[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]));<br>    rom8x4(<span class="hljs-variable">.addr</span>(num[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.data</span>(code[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]));<br>    decoder_4to16(<span class="hljs-variable">.in</span>(code[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]), <span class="hljs-variable">.out</span>(SEG[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]));<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Verilog及常见电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>常见电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10常用快捷键</title>
    <link href="/2021/05/08/win10%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/05/08/win10%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="win10常用快捷键"><a href="#win10常用快捷键" class="headerlink" title="win10常用快捷键"></a>win10常用快捷键</h3><p>作为一名鼠标重度依赖者，没有鼠标的时候感觉做什么都很别扭</p><p>实际上触控板和键盘快捷键用熟练之后还是很方便的（主要是很装b</p><p>整理一些win10常用的快捷键。</p><span id="more"></span><ul><li><p><strong>win+D</strong> 切换到桌面，显示桌面，速成老板键，摸鱼专用</p></li><li><p><strong>win+E</strong> 打开快速访问，当然如果想要打开的是我的电脑，可以设置</p><hr><p>点击<strong>查看</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210508173836402.png" style="zoom:33%;"><p>点击选项</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/20210508174058.png" alt="image-20210508174035591" style="zoom:33%;"><p>将快速访问改为此电脑。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/20210508175332.png" style="zoom:33%;"><hr></li><li><p><strong>win+I</strong> 打开设置界面（系统、设备等）</p></li><li><p><strong>win+L</strong> 快速锁屏，相当于默认的睡眠</p></li><li><p><strong>win+M</strong> 最小化所有窗口</p></li><li><p><strong>win+shift+M</strong> 还原最小化的窗口</p></li><li><p><strong>win+R</strong> 打开电脑的运行，输入指令，文末附常用的指令</p></li><li><p><strong>win+V</strong> 多重剪切板，即记录之前所有的复制记录</p></li><li><p><strong>win+W</strong> 打开ink工作区，非常好用</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/20210508175219.png" alt="image-20210508175105242" style="zoom:33%;"></li><li><p><strong>win+方向</strong>，电脑分屏，二分三分四分，很常用。</p></li><li><p><strong>win+tab</strong>，新建一个虚拟桌面，可以在不同的虚拟桌面中打开不同的程序。一个用来办公，一个用来游戏等等。</p></li><li><p><strong>win+数字</strong>，打开任务栏的第N个程序（装b用，没什么太大的作用）</p></li><li><p><strong>win+ +/-</strong>  缩放屏幕，没什么用</p></li><li><p><strong>win+ctrl+方向左右</strong> 切换虚拟桌面</p></li></ul><ul><li><strong>ctrl+X</strong> 剪切</li><li><strong>ctrl+C</strong> 复制</li><li><strong>ctrl+V</strong> 粘贴</li><li><strong>ctrl+Z</strong> 撤销</li><li><strong>ctrl+Y</strong> 恢复</li><li><strong>ctrl+shift+T</strong> 恢复被关闭的网页</li><li><strong>ctrl+N</strong> 创建同级界面，即若当前界面为word，ctrl+N就新建一个word</li><li><strong>ctrl+shift+N</strong> 新建文件夹</li><li><strong>ctrl+W</strong> 关闭当前界面</li><li><strong>ctrl+shift+esc</strong> 打开任务管理器</li><li><strong>ctrl+shift+F</strong> 切换到繁体输入</li></ul><ul><li><strong>shift+delete</strong> 永久删除文件，即包括回收站也无法留存。</li><li><strong>Alt+鼠标双击/Enter</strong> 查看文件的属性</li><li><strong>Alt+Tab</strong> 切换应用窗口 很常用</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>随便记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>win10快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——JavaFx</title>
    <link href="/2021/04/28/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94JAVAFX/"/>
    <url>/2021/04/28/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94JAVAFX/</url>
    
    <content type="html"><![CDATA[<h2 id="JAVA-UI编程经历的三个阶段"><a href="#JAVA-UI编程经历的三个阶段" class="headerlink" title="JAVA UI编程经历的三个阶段"></a>JAVA UI编程经历的三个阶段</h2><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428001620727.png" alt="image-20210428001620727"></p><span id="more"></span><h2 id="JavaFx程序的基本结构"><a href="#JavaFx程序的基本结构" class="headerlink" title="JavaFx程序的基本结构"></a>JavaFx程序的基本结构</h2><p><strong>Java FX工程结构图如下所示</strong></p><p><strong>Java FX采用MVC（Model-View-Control）设计模式：</strong></p><p><strong>降低了界面展现、应用逻辑、用户对视图的操作控制三部分的耦合度。</strong></p><p>（UI的程序都是基于事件驱动，用户点击按钮，触发事件，事件处理函数中写逻辑。如果不采用MVC，导致逻辑被写进事件处理函数，界面展示和应用逻辑搅在一起，可维护性很差）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428001634383.png" alt="image-20210428001634383" style="zoom: 67%;"><ol><li>不管播放器的UI怎么设计，先设计一个Model，里面有状态、数据、方法。</li><li>专门负责界面展现 视图</li><li>控制器</li></ol><p>以上三部分相对独立，用户对视图的操作转到控制器，控制器解读操作含义，来操作模型。如操作player，控制器向模型请求player模型放歌，模型告诉视图状态已经改变，视图显示位用户更新。</p><p>使用IDEA创建工程，工程要选择Java FX，就产生如下的工程文件</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428002247404.png" alt="image-20210428002247404"></p><p>设计一个网页的时候，网页的视图就是html描述，如上xml与网页联系起来。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>要实现如下页面，一个编辑框和一个按钮</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428003306682.png" alt="image-20210428003306682"></p><p>对应的配置文件：语法基于xml，可扩展的标记语言。JavaFx UI的开发和设计网页是完全一致，设计网页用html，html实际上是xml的一个实例，开发方式与web开发统一起来。</p><p>如下为sample.fxml</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428003543633.png" alt="image-20210428003543633"></p><blockquote><p> pane为根节点，第二行fx:controller是很重要的属性，指定了视图的控制器，引入类名</p><p>里面两个组件Button和TextField，如果需要在Java程序里访问空间，需要在xml里指定控件的fx:id属性</p></blockquote><p>Java中通过如下语句加载</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">// Main.java里加载sample.fxml</span><br>FXMLLoader loader = <span class="hljs-keyword">new</span> FXMLLoader(getClass().getResource(“sample.fxml<span class="hljs-string">&quot;));</span><br><span class="hljs-string">Pane root = loader.load(); //返回一个对象，对象的类型就是根节点的类型Pane，将整个视图加载进来</span><br></code></pre></div></td></tr></table></figure><h3 id="Main类的实现"><a href="#Main类的实现" class="headerlink" title="Main类的实现"></a>Main类的实现</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Main必须继承Application(JavaFx定义好的),并覆盖start方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br><span class="hljs-meta">@Override</span>  <span class="hljs-comment">//覆盖Application中的start方法</span><br>    <span class="hljs-comment">//Stage就是舞台（窗体），可以随时切换场景</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Stage primaryStage)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.加载sample.fxml</span><br>FXMLLoader loader = <span class="hljs-keyword">new</span> FXMLLoader(getClass().getResource(“sample.fxml<span class="hljs-string">&quot;));</span><br><span class="hljs-string">                                                                         //2.加载视图的根节点（fxml里根节点），自动加载根节点下面所有的UI控件</span><br><span class="hljs-string">Pane root = loader.load();</span><br><span class="hljs-string"></span><br><span class="hljs-string">//3.得到控制器实例</span><br><span class="hljs-string">Controller controller = loader.getController();</span><br><span class="hljs-string"></span><br><span class="hljs-string">            //4.将Main对象传进控制器，这样控制器就可以访问Main对象的成员</span><br><span class="hljs-string">            controller.setMyApp(this);</span><br><span class="hljs-string"></span><br><span class="hljs-string">//5.Scene构造函数第一个参数指定了场景里的根节点对象root（前面已加载）</span><br><span class="hljs-string">//root是视图的根结点，将整个视图加载进scene中了</span><br><span class="hljs-string">Scene scene = new Scene(root,400,600);</span><br><span class="hljs-string">                                                                      //6.切换了舞台的场景</span><br><span class="hljs-string">primaryStage.setScene(scene);</span><br><span class="hljs-string">primaryStage.show();</span><br><span class="hljs-string">&#125; catch(Exception e) &#123;</span><br><span class="hljs-string">e.printStackTrace();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">public static void main(String[] args) &#123;</span><br><span class="hljs-string">//静态方法，Application里已经定义好了</span><br><span class="hljs-string">        launch(args);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></div></td></tr></table></figure><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controller</span> </span>&#123;<br><span class="hljs-meta">@FXML</span>    <br>    <span class="hljs-keyword">private</span> TextField text;<br><br>    <span class="hljs-comment">//Main对象引用，引用Main的实例，这样控制器就可以访问Main对象的成员</span><br><span class="hljs-keyword">private</span> Main myApp;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyApp</span><span class="hljs-params">(Main myApp)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.myApp = myApp;<br>&#125;<br><br><span class="hljs-meta">@FXML</span>    <span class="hljs-comment">//ActionEvent e用户点击按钮的事件处理函数</span><br>    <span class="hljs-comment">//@FXML标注将onClick函数与xml中定义的onAction=“#onClick” 绑定</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;<br>text.setText(<span class="hljs-string">&quot;Button Cliked&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>@FXML标注很重要，将实例变量名与xml中fx:id属性值相同的控件绑定起来，</p><p>在Java程序里通过text引用，可以控制TextField对象（读写），比如onClick方法里的text.setText方法</p></blockquote><hr><p>视图 控制器 model Main(仅仅是启动类)如何关联</p><p>@FXML标注，controller就可以得到视图文件中任何一个UI组件的实例</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428003543633.png" alt="image-20210428003543633"></p><p>如下，控制器中的</p><p>private TextField text    对应fxml中的TextField fx:id=”text”</p><p>public void onclick(ActionEvent e){}   对应onAction=”#onClick”</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@FXML</span>    <br>    <span class="hljs-keyword">private</span> TextField text;<br><span class="hljs-meta">@FXML</span>    <br><span class="hljs-comment">//@FXML标注将onClick函数与xml中定义的onAction=“#onClick” 绑定</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;<br>text.setText(<span class="hljs-string">&quot;Button Cliked&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><p>controller和main联系起来，如下属性和方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Main对象引用，引用Main的实例，这样控制器就可以访问Main对象的成员</span><br><span class="hljs-keyword">private</span> Main myApp;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyApp</span><span class="hljs-params">(Main myApp)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.myApp = myApp;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>我们讨论了Controller（控制器）、fxml配置文件（视图）。那么Model呢？Main不要作为模型类，应该在工程里添加Model类。Main只是JavaFX应用的启动类。控制器如何拿到Model的对象？定义一个类似于setMyApp的方法，例如：</p><p>  public void setModel(Model model)。</p><p>然后在Main类里实例化Model对象，通过拿到的Controller实例（Main类中），controller调用setModel方法。Model就传到Controller里</p></blockquote><h3 id="也可以完全用Java程序创建UI"><a href="#也可以完全用Java程序创建UI" class="headerlink" title="也可以完全用Java程序创建UI"></a>也可以完全用Java程序创建UI</h3><p>start中直接new了Button，再创建scene，将btOK入scene第一个参数，就是UI的根结点，scene中只有一个button，占满整个scene。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> javafx.application.Application ;<br><span class="hljs-keyword">import</span> javafx.scene.Scene;<br><span class="hljs-keyword">import</span> javafx.scene.control .Button;<br><span class="hljs-keyword">import</span> javafx.stage.Stage;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJavaFX</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Stage primaryStage)</span> </span>&#123;<br>    Button btOK = <span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;OK&quot;</span>);<br>    Scene scene = <span class="hljs-keyword">new</span> Scene(btOK, <span class="hljs-number">200</span>, <span class="hljs-number">250</span>);<br>    primaryStage.setTitle(<span class="hljs-string">&quot;MyJavaFX&quot;</span>); <br>    primaryStage.setScene(scene); <br>    primaryStage.show(); <br>  &#125;<span class="hljs-comment">//注意按钮占满了了整个场景  </span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Application.launch(args);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>需从Application类派生</strong></p><p><strong>重写start方法：用于启动主窗体(Stage类型)。</strong></p></blockquote><blockquote><p><strong>如果想启动两个窗体（Stage），可在start中创建新的Stage对象。</strong></p></blockquote><blockquote><p><strong>Stage就像一个舞台，由场景Scene组成。场景可以切换（Stage的setScene方法）</strong></p></blockquote><blockquote><p><strong>launch 方法是一个定义在Application 类中的静态方法，用于启动一个独立的JavaFX 应用：激活start方法。</strong></p></blockquote><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428010018119.png" alt="image-20210428010018119"></p><p><strong>注意也可以完全脱离fxml，完全在Java程序里定义视图的内容，这个例子就是如此。但不推荐这样做，用fxml定义视图，可以将代码与视图定义分离。有的同学担心fxml写起来太麻烦，不用担心。利用UI设计工具SceneBuilder，用拖拽控件的方式设计好UI后，会自动产生fxml配置文件。</strong></p><h2 id="面板、UI组件以及形状"><a href="#面板、UI组件以及形状" class="headerlink" title="面板、UI组件以及形状"></a>面板、UI组件以及形状</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210429002126467.png" style="zoom:67%;"><blockquote><p> 一个Stage就是一个窗口，在<strong>Stage中包含了多个Scene</strong>，Stage可以通过setScene切换场景</p></blockquote><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210429003434137.png" style="zoom:50%;"><blockquote><p><strong>Scene包含多个Parent</strong>（Pane或者Control），但其中只<strong>有一个根节点root，根节点的类型可以是Parent，Pane，Control</strong>(Parent或其子类，但Scene里不能包含Shape，ImageView，因为这两个不是Parent的子类，不能直接放在Scene)，根节点里面可以有很多UI的具体组件，UI组件都是Node类型，Node是所有可视化组件的祖先类</p></blockquote><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210429003704742.png" style="zoom:33%;"><blockquote><p>Node有多个子类， </p><ul><li><p>其中第一个子类Parant，凡是Parant派生的，都有子节点。其两个子类</p><ol><li><p>Control：子类为各种UI组件</p></li><li><p>面板Pane，子类为许多具体面板。</p></li></ol></li><li><p>Node可以直接派生子类</p><div class="hljs code-wrapper"><pre><code>  1. Shape：各种形状，  2. ImageView：图像。</code></pre></div><p>  Node直接派生的，而不是Parant派生的，这些类没有子节点，这些类的对象只能加载到Parant。</p></li></ul></blockquote><blockquote><p>面板Pane</p><p>通常是作为一个容器，面板Pane里面可以包含很多Node，Node是所有可视化UI组件的祖先类，因此Pane里还可以嵌套Pane，也可以放UI组件。面板的主要作用是布局。</p></blockquote><p>界面元素的包含关系</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210429003347993.png" style="zoom: 67%;"><blockquote><p>注意:</p><p>(1)派生：Node-&gt;Parent-&gt;Pane，</p><p>  故Pane可包含Node的任何子类。</p><p>(2)Pane由Node构成-&gt;故可由Pane构成，</p><p>  故Pane可包含多个Pane。</p><p>(3)Scene可包含Control或Pane, 但不能</p><p>  包含Shape和ImageView。</p></blockquote><hr><p>通过最开始的例子进行解释</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210429005012890.png"></p><blockquote><p>注意Pane作为容器，负责里面UI组件的布局(Layout). Pane可以相互嵌套，实现任意复杂的布局。</p></blockquote><blockquote><p>如果需要在Pane里加入更多UI组件</p><p>在fxml文件的Pane节点里添加子节点</p></blockquote><hr><p>可以通过Java程序动态地向UI界面添加新的UI组件</p><p><strong>pane.getChi1dren().add(构造好的UI组件对象);是将一个UI组件加入面板的方法。</strong></p><p>这个代码<strong>不需要fxml文件可以运行</strong>。因此，我们可以不依赖于fxml，直接在程序里创建UI并布局（当然比较麻烦）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"> <span class="hljs-keyword">import</span> javafx.application.Application;<br> <span class="hljs-keyword">import</span> javafx.scene.Scene;<br> <span class="hljs-keyword">import</span> javafx.scene.control.Button;<br> <span class="hljs-keyword">import</span> javafx.stage.Stage;<br> <span class="hljs-keyword">import</span> javafx.scene.1ayout.StackPane;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ButtonlnPane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(Stage primaryStage)</span></span>&#123;<br> <span class="hljs-comment">/*StackPane：Pane的子类，</span><br><span class="hljs-comment"> 它实现的布局方式是：控件在同一中央位置堆叠存放，</span><br><span class="hljs-comment"> 一个控件可能覆盖其它控件。</span><br><span class="hljs-comment">*/</span><br>        StackPane pane = <span class="hljs-keyword">new</span> StackPane();<br><span class="hljs-comment">/*程序将Button控件加入StackPane。</span><br><span class="hljs-comment">getChildren返回javafx.collections.ObservableList 的一个实例。子节点列表</span><br><span class="hljs-comment">*/</span><br>        <span class="hljs-comment">/*ObservableList类似于ArrayList, 用于存储元素集合。</span><br><span class="hljs-comment">        调用add(e)可将一个元素加入集合的列表。</span><br><span class="hljs-comment">*/</span><br>        pane.getChildren().add(<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;OK&quot;</span>));<br><br>        Scene scene = <span class="hljs-keyword">new</span> Scene(pane, <span class="hljs-number">200</span>,<span class="hljs-number">50</span>);<br><br>        primaryStage.setTitle(<span class="hljs-string">&quot;Button in a pane&quot;</span>); <br><br>        primaryStage.setScene(scene);     <br><br>        primaryStage.show(); <span class="hljs-comment">// Display the stage</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JavaFx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog常见电路</title>
    <link href="/2021/04/25/verilog%E5%B8%B8%E7%94%A8%E7%94%B5%E8%B7%AF/"/>
    <url>/2021/04/25/verilog%E5%B8%B8%E7%94%A8%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="2-1选择器"><a href="#2-1选择器" class="headerlink" title="2-1选择器"></a>2-1选择器</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 2-1 选择器</span><br><br><span class="hljs-keyword">module</span> mux_21(a, b, sel, out);<br>    <span class="hljs-keyword">parameter</span> WIDTH = <span class="hljs-number">8</span>;<br>    <br>    <span class="hljs-keyword">input</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a, b;<br>    <span class="hljs-keyword">input</span> sel;<br>    <span class="hljs-keyword">output</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] out;<br>    <br>    <span class="hljs-comment">// 三元运算符</span><br>    <span class="hljs-keyword">assign</span> out = sel == <span class="hljs-number">0</span> ? a : b;<br>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></div></td></tr></table></figure><span id="more"></span><h3 id="4-1选择器"><a href="#4-1选择器" class="headerlink" title="4-1选择器"></a>4-1选择器</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 4-1 1 bit 选择器设计方案I</span><br><span class="hljs-keyword">module</span> mux_41(a, b, c, d, <br>  sel, out);<br><br>  <span class="hljs-keyword">input</span> a, b, c, d;<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out;<br><br>  <span class="hljs-keyword">always</span> @(a, b, c, d, sel)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (sel == <span class="hljs-number">2&#x27;b00</span>)<br>      out = a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sel == <span class="hljs-number">2&#x27;b01</span>)<br>      out = b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sel == <span class="hljs-number">2&#x27;b10</span>)<br>      out = c;<br>    <span class="hljs-keyword">else</span> out = d;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 4-1 1 bit 选择器设计方案II</span><br><span class="hljs-keyword">module</span> mux_41(a, b, c, d, <br>  sel, out);<br><br>  <span class="hljs-keyword">input</span> a, b, c, d;<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out;<br><br>  <span class="hljs-keyword">always</span> @(a, b, c, d, sel)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(sel)<br>      <span class="hljs-number">2&#x27;b00</span>: out = a;<br>      <span class="hljs-number">2&#x27;b01</span>: out = b;<br>      <span class="hljs-number">2&#x27;b10</span>: out = c;<br>      <span class="hljs-keyword">default</span>: out = d;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 4-1 选择器设计方案 III</span><br><br><span class="hljs-keyword">module</span> mux_41(a, sel, out);<br>    <span class="hljs-keyword">parameter</span> WIDTH = <span class="hljs-number">8</span>;<br>    <br>    <span class="hljs-keyword">input</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>    <span class="hljs-keyword">output</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] out;<br>    <br>    <span class="hljs-comment">// 利用数组</span><br>    <span class="hljs-keyword">assign</span> out = a[sel];<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h2 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h2><ul><li><p><strong>译码器：将具有特定含义的二进制代码转换成控制信号的器件。</strong></p></li><li><p><strong>地址译码器</strong></p></li><li><p><strong>显示译码器</strong></p></li><li><p><strong>指令译码器</strong></p></li><li><p><strong>…</strong></p></li></ul><p><strong>通过二进制编码来选择当前占用总线的设备。</strong></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210427202403937.png" alt="image-20210427202403937"></p><h3 id="38译码器"><a href="#38译码器" class="headerlink" title="38译码器"></a>38译码器</h3><p>最常见的地址译码器 3比特构成8个设备的地址的地址译码器</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 3-8 译码器 行为描述方法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">要点：</span><br><span class="hljs-comment">1、输出（被赋值的对象必须被声明为寄存器类型）</span><br><span class="hljs-comment">2. 用always做关键词,后面跟@():trigger list,包含所有影响输出的变量，如果变化，就执行always</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">module</span> decoder_38(A, Y);<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] A;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] Y;<br><br>  <span class="hljs-keyword">always</span> @(A)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(A)<br>      <span class="hljs-number">3&#x27;d0</span>: Y = <span class="hljs-number">8&#x27;b1111_1110</span>;<br>      <span class="hljs-number">3&#x27;d1</span>: Y = <span class="hljs-number">8&#x27;b1111_1101</span>;<br>      <span class="hljs-number">3&#x27;d2</span>: Y = <span class="hljs-number">8&#x27;b1111_1011</span>;<br>      <span class="hljs-number">3&#x27;d3</span>: Y = <span class="hljs-number">8&#x27;b1111_0111</span>;<br>      <span class="hljs-number">3&#x27;d4</span>: Y = <span class="hljs-number">8&#x27;b1110_1111</span>;<br>      <span class="hljs-number">3&#x27;d5</span>: Y = <span class="hljs-number">8&#x27;b1101_1111</span>;<br>      <span class="hljs-number">3&#x27;d6</span>: Y = <span class="hljs-number">8&#x27;b1011_1111</span>;<br>      <span class="hljs-number">3&#x27;d7</span>: Y = <span class="hljs-number">8&#x27;b0111_1111</span>;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><blockquote><p>常数的声明方法:</p><p>[宽度]‘[进制][值]</p><p>硬件中，不能赋没有位宽的值，没有位宽的值在硬件中通常为32位的值，通常又用不到，浪费资源。所以通常要指定位宽</p><p>为了更好的阅读二进制串，允许中间用_连接，verilog会自动去掉_</p></blockquote><p>负值逻辑：enable逻辑信号是为了让选中的信号有效，其他的信号无效。</p><p>硬件中对于enable信号通常采用负逻辑，0有效，1无效，因为负逻辑不容易被误触发。通常无效的时候是1，被干扰的可能性较小，使得设备不会被误触发。</p><p>通常enable，reset，控制信号写允许读允许都用负值逻辑</p><h2 id="分频器"><a href="#分频器" class="headerlink" title="分频器"></a>分频器</h2><p>分频是指将时钟信号的频率进行降低的时序电路，例如：如果要将频率降低为原来的1/N，就叫N分频。为便于高层模块改变分频系数N，将N定义为参数。实例化时可以把参数传递进去：  </p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> divider(clk, clk_N);<br>    <span class="hljs-keyword">input</span> clk;                      <span class="hljs-comment">// 系统时钟</span><br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> clk_N;                   <span class="hljs-comment">// 分频后的时钟</span><br>    <span class="hljs-keyword">parameter</span> N = <span class="hljs-number">100_000_000</span>;     <span class="hljs-comment">// 1Hz的时钟,N=fclk/fclk_N</span><br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] counter;             <span class="hljs-comment">/* 计数器变量，通过计数实现分频。当计数器从0计数到(N/2-1)时，输出时钟翻转，计数器清零 */</span><br><br>    <span class="hljs-keyword">initial</span><br>    <span class="hljs-keyword">begin</span>                           <span class="hljs-comment">// 赋初始值</span><br>        counter = <span class="hljs-number">0</span>;<br>        clk_N = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)           <span class="hljs-comment">// 时钟上升</span><br>    <span class="hljs-keyword">begin</span><br>        counter &lt;= counter + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (counter &gt; N / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">begin</span><br>                clk_N &lt;= ~clk_N;<br>                counter &lt;= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p>如上，1Hz的时钟，分频后将其变成每N/2=0.5Hz，时钟翻转一次，这样就对时钟进行分频</p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="简单加法计数器"><a href="#简单加法计数器" class="headerlink" title="简单加法计数器"></a>简单加法计数器</h3><p>时钟脉冲来的时候，就+1，四位，将记到f的时候再+1就溢出，归0</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> CNT4 (CLK,Q);<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] Q;<br>    <span class="hljs-keyword">input</span> CLK;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] Q;<br>    <span class="hljs-keyword">always</span>@(posegde CLK)<br>        Q&lt;=Q+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210427203236919.png" alt="image-20210427203236919"></p><h3 id="实用加法计数器"><a href="#实用加法计数器" class="headerlink" title="实用加法计数器"></a>实用加法计数器</h3><ul><li><p><strong>异步复位</strong> <strong>rst_n</strong> 优先级最高</p></li><li><p><strong>使能</strong> **en ** 当使能信号有效时，加法计数器才执行加法，无效时，即使有时钟脉冲，值保持不变</p></li><li><p><strong>同步预置</strong> <strong>load/data</strong>：可以预置一个计数的初始值  通过load控制信号，和预置的数data，预置初始值。load为负值逻辑，当时钟上升沿时，检测到load信号，就把data赋到计数输出</p></li><li><p><strong>计数输出</strong> **dout ** 设定记满的上限</p></li><li><p><strong>计数溢出</strong> <strong>cout</strong>：计数满时的输出信号</p><h3 id="实用模10计数器"><a href="#实用模10计数器" class="headerlink" title="实用模10计数器"></a>实用模10计数器</h3></li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 实用模 10 计数器</span><br><span class="hljs-keyword">module</span> cnt10(clk, rst_n, en, load_n, data, cout, dout);<br>    <span class="hljs-keyword">input</span> clk, rst_n, en, load_n;  <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] data;<br>    <span class="hljs-keyword">output</span> cout;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] dout;<br>    <br>    <span class="hljs-comment">//行为描述</span><br>    <span class="hljs-comment">//不能混合边沿和电平，所以两个边沿触发。rst_n为负值逻辑</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk, <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (!rst_n) dout &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">//优先级最高</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (en) <span class="hljs-keyword">begin</span>  <span class="hljs-comment">//使能en高于load，使能无效则load无效。</span><br>            <span class="hljs-keyword">if</span> (!load_n) dout &lt;= data;  <span class="hljs-comment">//load有效，赋值。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dout &lt; <span class="hljs-number">4&#x27;d9</span>) dout &lt;= dout + <span class="hljs-number">1</span>; <span class="hljs-comment">//没记满，则+1</span><br>            <span class="hljs-keyword">else</span> dout &lt;= <span class="hljs-number">4&#x27;d0</span>;  <span class="hljs-comment">//计数值记满（9）或大于9（预置了&gt;10的数，如此写避免了bug），复位到0</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">//计数到9，输出记满1信号，否则输出0</span><br>    <span class="hljs-keyword">assign</span> cout = (dout == <span class="hljs-number">4&#x27;d9</span>) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/newimg/image-20210429013238264.png" alt="image-20210429013238264"></p><h3 id="tb的写法"><a href="#tb的写法" class="headerlink" title="tb的写法"></a>tb的写法</h3><p>对于上述较为复杂的电路，用tb验证，模拟了上述的信号</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-meta-keyword">timescale</span> 1ns / 1ps;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">必须声明timescale，tb除了做行为仿真，还要做综合后时序仿真，因为综合后会引入器件延时和布线延时，即使在行为仿真后正确，也可能在综合仿真后产生尖峰和毛刺，导致逻辑失败。</span><br><span class="hljs-comment">因此必须考虑延时。延时要声明timescale，过大，则低频电路，器件延时被忽略，若过小，则高频电路，则器件延时布线延时不可忽略，产生不可预期的后果。</span><br><span class="hljs-comment">所以tb首先要声明实在哪一个频率点上进行仿真，不可或缺。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">module</span> cnt10_tb( );<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  输入信号赋值，来模拟信号源，观测输出信号，看是否满足输出要求，既然要赋值，则通常为initial或always，因此输入信号要为reg类型</span><br><span class="hljs-comment">  输出信号只观测，则wire型。</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">reg</span> clk,rst_n,en,load_n;<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] data;<br>  <span class="hljs-keyword">wire</span> cout;<br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] dout;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    tb的第一条语句一定是调用待检测的模块，输入信号输出信号连上模块，待检测模块的一头接信号源，另一头接示波器，第一条语句始终引入待检测模块</span><br><span class="hljs-comment">    */</span><br>  cnt10 dut(clk,rst_n,en,<br>    load_n,data,cout,dout);<br><br>  <span class="hljs-comment">// 产生 10ns 周期的时钟信号，每5ns反相一次</span><br>  <span class="hljs-keyword">initial</span> clk = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">切记，做任何仿真之前，需要对该信号进行初始化，凡是没有初始化的信号，vivado认为是个x，未知状态信号，任何操作逻辑都是未知状态。</span><br><span class="hljs-comment">对输入信号操作前，要赋初值。</span><br><span class="hljs-comment">*/</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// #100 </span><br>    rst_n = <span class="hljs-number">1</span>;<br>    en = <span class="hljs-number">1</span>;<br>    load_n = <span class="hljs-number">1</span>;<br>    data = <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// 使能为0期间，不计数</span><br>    #<span class="hljs-number">10</span> en = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">15</span> en = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 异步复位，不受时钟影响</span><br>    #<span class="hljs-number">6</span> rst_n = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">2</span> rst_n = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 预置数改变不影响计数</span><br>    #<span class="hljs-number">10</span> data = <span class="hljs-number">7</span>;<br>    <span class="hljs-comment">// 直到预置数被装载</span><br>    #<span class="hljs-number">20</span> load_n = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">10</span> load_n = <span class="hljs-number">1</span>; <br>    <span class="hljs-comment">// 大于10的预置数</span><br>    #<span class="hljs-number">30</span> data = <span class="hljs-number">11</span>;<br>    #<span class="hljs-number">30</span> load_n = <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">10</span> load_n = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>总是使用</strong> <strong>timescale</strong> <strong>规定时间</strong>,对后续综合后时间仿真产生影响</p><p>在全局置位、复位脉冲释放之前就确保 <em><strong>时钟源</strong></em> 已经开始工作。时钟源写在最前。</p><p><strong>在仿真时间的</strong> <strong>0</strong> <strong>时刻，将所有的设计输入初始化位为一个确定的值；</strong></p><p>**在综合后和实现后的时序仿真中，会自动触发全局置位/复位脉冲（GSR），这会让所有的寄存器在仿真的前100ns **内锁定其值。因此在100ns 之后再赋值激励数据；如果对一个带复位的时序电路仿真，而且希望做综合后实现后的时序仿真，则第一条语句要写延时100ns，保证后续所有输入在100ns后输入才能得到正确的仿真结果。</p></blockquote><h2 id="触发器和锁存器"><a href="#触发器和锁存器" class="headerlink" title="触发器和锁存器"></a>触发器和锁存器</h2><ul><li><p>触发器（Flip-flop）和锁存器（Latch）都是具有记忆功能的二进制存储器件。</p></li><li><p>触发器和锁存器的实现形式很多，在ASIC中通常使用 D 触发器和 D 锁存器。</p></li><li><p>触发器和锁存器的功能区别：</p><ul><li>触发器由时钟信号的跳边沿触发“存储”</li><li>锁存器由电平信号触发“存储”</li></ul><h3 id="基本D触发器"><a href="#基本D触发器" class="headerlink" title="基本D触发器"></a>基本D触发器</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428010431170.png" alt="image-20210428010431170" style="zoom:50%;"></li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> DFF1(CLK,D,Q)<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK) <span class="hljs-comment">//时钟上升沿才会引起赋值，非阻塞式赋值（上一个时刻存储的内容赋值给当前时刻）</span><br>        Q&lt;=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p>D触发器在时钟的边沿执行存储（写入功能），设定上升沿，每遇到上升沿，就把D的内容写入Q，随后D变化（变化中没有碰到时钟上升沿），D的变化不会写入Q。</p><p>输出存储了上一个时钟时候的写入，起到了存储的功能，每遇到时钟上升沿，就将D写入Q</p><blockquote><p>非阻塞式赋值：上一个时刻存储的内容赋给当前时刻</p><p>阻塞式赋值：执行上一次赋值后面执行出的计算出的值赋值给当前内容</p><p>时序电路使用非阻塞式赋值，非阻塞式赋值可以，但写法比较麻烦</p></blockquote><h3 id="含异步复位和使能的D触发器"><a href="#含异步复位和使能的D触发器" class="headerlink" title="含异步复位和使能的D触发器"></a>含异步复位和使能的D触发器</h3><ul><li><strong>异步</strong>复位：复位信号不受时钟控制，时钟不管是上升沿下降沿不变</li><li>复位信号通常都是<strong>负值逻辑</strong>的，抗干扰能力强，不容易被误触发</li><li>使能：使能信号有效时，触发器才工作</li><li>使能优先级低于复位信号</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428011405545.png" alt="image-20210428011405545" style="zoom:50%;"><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> DFF2(CLK,D,Q,RST,EN);<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D,RST,EN;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> RST)<br>        <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">if</span>(!RST) Q&lt;=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(EN) Q&lt;=D;<br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="含同步复位的D触发器"><a href="#含同步复位的D触发器" class="headerlink" title="含同步复位的D触发器"></a>含同步复位的D触发器</h3><ul><li>同步复位：在时钟信号跳变沿检测复位信号</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428011748095.png" alt="image-20210428011748095" style="zoom:50%;"><p>复位信号为1时若时钟为上升沿，则复位</p><p>时钟上升沿时检测到复位信号。</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> DFF3(CLK,D,Q,RST);<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D,RST;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK)<br>        <span class="hljs-keyword">if</span>(RST==<span class="hljs-number">1</span>) Q=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (RST==<span class="hljs-number">0</span>) Q=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428012140989.png" alt="image-20210428012140989"></p><h3 id="基本锁存器"><a href="#基本锁存器" class="headerlink" title="基本锁存器"></a>基本锁存器</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428080744342.png" alt="image-20210428080744342" style="zoom:50%;"><p>最大的区别在于锁存器是电平触发</p><p>clk=1的时候，Q随D变化，clk=0时，Q不变</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> LATCH1(CLK,D,Q);<br>    <span class="hljs-keyword">output</span> Q; <span class="hljs-keyword">input</span> CLK,D;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span> @(D oir CLK)<br>        <span class="hljs-keyword">if</span>(CLK) Q&lt;=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>CLK</strong> <strong>==</strong> <strong>1</strong> <strong>时，等于直通电路，等于写入当前状态。</strong></p><p><strong>CLK</strong> <strong>==</strong> <strong>0</strong> <strong>时，保持输出，等于记忆当前状态。</strong></p></blockquote><h3 id="含异步复位的锁存器"><a href="#含异步复位的锁存器" class="headerlink" title="含异步复位的锁存器"></a>含异步复位的锁存器</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428081400344.png" alt="image-20210428081400344" style="zoom:50%;"><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> LATCH3 (CLK,D,Q,RST);<br>    <span class="hljs-keyword">output</span> Q;<br>    <span class="hljs-keyword">input</span> CLK,D,RST;<br>    <span class="hljs-keyword">reg</span> Q;<br>    <span class="hljs-keyword">always</span>@(D <span class="hljs-keyword">or</span> CLK <span class="hljs-keyword">or</span> RST)<br>        <span class="hljs-keyword">if</span>(!RST) Q&lt;=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(CLK) Q&lt;=D;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><blockquote><p>复位的优先级总是最高的。</p><p>锁存器中，CLK往往也被称为LE（latch enable）</p></blockquote><h3 id="触发器和锁存器的比较"><a href="#触发器和锁存器的比较" class="headerlink" title="触发器和锁存器的比较"></a>触发器和锁存器的比较</h3><p><strong>Latch 对输入电平敏感，受布线延时影响大，很难保证没有毛刺的输出；而 DFF 不容易产生毛刺。</strong></p><p><strong>FPGA 中没有 Latch 单元，只有 FF 单元 (我们使用的 Artix-7 中，有 126,800 个 FF)，需要用多个逻辑单元来实现 Latch，因此使用 FF 更节约资源。</strong></p><p><strong>但是，在某些设计中，Latch 不可替代。</strong></p><p><strong>结论：尽可能避免 Latch 的产生。例如：一个不“完备”的条件语句（有 if 而无 else，case 没有 default）（没有完全穷举状态的时候）将会产生 Latch。</strong></p><p>例如3-1 bit选择器，如下只对三种状态赋值，产生锁存器</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">// 3-1 1 bit 选择器</span><br><br><span class="hljs-keyword">module</span> mux_31(a,b,c,sel,out);<br><br>  <span class="hljs-keyword">input</span> a, b, c;<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out;<br><br>  <span class="hljs-keyword">always</span> @(a, b, c, sel)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(sel)<br>      <span class="hljs-number">2</span>’b00: out = a;<br>      <span class="hljs-number">2</span>’b01: out = b;<br>      <span class="hljs-number">2</span>’b10: out = c;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428082140830.png" alt="image-20210428082140830" style="zoom: 50%;"><p>锁存器当sel=11时，锁存器将保持过去的状态不会改变</p><h2 id="寄存器和存储器"><a href="#寄存器和存储器" class="headerlink" title="寄存器和存储器"></a>寄存器和存储器</h2><ul><li><p>寄存器（register）：用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。</p></li><li><p>存储器（memory）：也是用来存放数据的区域，分为 ROM 和 RAM 两类。</p></li><li><p>寄存器与存储器的制造工艺不同：</p><ul><li><p>寄存器通常使用触发器和锁存器来实现，速度快、占用面积大</p></li><li><p>存储器通常使用 6 MOS 管（静态存储器）或 1 MOS 管（动态存储器）实现，速度慢，占用面积小</p></li><li><p>FPGA 中通常配有专门的存储单元，而不用逻辑门来实现存储。Aritx-7 上有大约 5Mbits 的可配置内存块。</p></li></ul></li></ul><h3 id="基本寄存器"><a href="#基本寄存器" class="headerlink" title="基本寄存器"></a>基本寄存器</h3><p>根据触发器和锁存器分析。FPGA中寄存器最好用触发器实现（占用资源少，稳定）</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> register(clk,en,d,q);<br>    <span class="hljs-keyword">parameter</span> WHIDTH = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">input</span> clk,rst_n,en;<br>    <span class="hljs-keyword">input</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] d;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [width-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] q;<br>    <br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(!rst_n) q&lt;=<span class="hljs-number">0</span>;   <span class="hljs-comment">//复位</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(en) q&lt;=d;  <span class="hljs-comment">//能赋值</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="双端口存储器-结构最简单"><a href="#双端口存储器-结构最简单" class="headerlink" title="双端口存储器(结构最简单)"></a>双端口存储器(结构最简单)</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ram(data,read_addr,write_addr,clk,we,q);<br>    <span class="hljs-keyword">parameter</span> DATA_WIDTH=<span class="hljs-number">8</span>; <span class="hljs-comment">//数据宽度</span><br>    <span class="hljs-keyword">parameter</span> ADDR_WIDTH=<span class="hljs-number">3</span>;  <span class="hljs-comment">//地址总线宽度</span><br>    <br>    <span class="hljs-keyword">input</span> clk,we;<br>    <span class="hljs-keyword">input</span> [DATA_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data;<br>    <span class="hljs-keyword">input</span> [ADDR_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] read_addr,write_addr;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DATA_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] q;<br>    <br>    <span class="hljs-comment">//申明存储器数组</span><br>    <span class="hljs-keyword">reg</span> [DATA_WIDTH=<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] ram[ADDR_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];  <span class="hljs-comment">//每个总线对应一个ram，每个ram是8位</span><br>    <br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (we)<br>        ram[write_addr] &lt;= data;   <span class="hljs-comment">//write_addr总线连接的存储单元赋值</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        initial begin   //对存储器初始化</span><br><span class="hljs-comment">            Sreadmemh(&quot;ram_init.txt&quot;,ram)</span><br><span class="hljs-comment">        */</span><br><br>        q &lt;= ram[read_addr];  <span class="hljs-comment">//输出一直是read——addr总选连接的存储单元</span><br>  <span class="hljs-keyword">end</span>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></div></td></tr></table></figure><ul><li><p><strong>双端口</strong> <strong>RAM</strong> <strong>读写端口完全独立</strong></p><ul><li><strong>优点：简单；快速，读写无需等待</strong></li><li><strong>缺点：占用资源多</strong></li></ul></li><li><p><strong>存储大小与地址宽度之间的关系</strong></p><ul><li><strong>size</strong> <strong>=</strong> <strong>2^addr_width</strong></li></ul></li><li><p><strong>实现上，使用了</strong> <strong>FPGA</strong> <strong>中的内存块单元</strong></p></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210428084327484.png" alt="image-20210428084327484"></p><h2 id="数据通路设计"><a href="#数据通路设计" class="headerlink" title="数据通路设计"></a>数据通路设计</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210511121612132.png" style="zoom: 50%;"><p>经典的计算机模型的数据处理器</p><ul><li>数据通路负责数据的操作，包括算是运算和传输数据</li><li>控制器负责数据的控制，通常以有限状态机方式实现，包括控制流的输入、输出，以及控制数据通路钟数据的传输顺序</li><li> 处理器旁通常会有哪一个存储器，可根据地址存取程序指令和数据。</li></ul><hr><h4 id="数据通路设计-1"><a href="#数据通路设计-1" class="headerlink" title="数据通路设计"></a>数据通路设计</h4><ul><li>首先实现各个单元模块，包括计算单元ALU，寄存器单元LA和LB，双端口存储器GR</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/newimg/image-20210429012206972.png" alt="image-20210429011556719"></p><p>首先实现各个模块</p><h5 id="计算单元ALU"><a href="#计算单元ALU" class="headerlink" title="计算单元ALU"></a>计算单元ALU</h5><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> alu(a,b,op,q);<br>    <span class="hljs-keyword">parameter</span> WIDTH = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">input</span>[WIDTH-<span class="hljs-number">1</span>：<span class="hljs-number">0</span>] a,b;<br>    <span class="hljs-keyword">input</span>[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] op;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] q;<br>    <span class="hljs-keyword">always</span>@(*) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span>(op)<br>            <span class="hljs-number">2&#x27;b00</span>:q=a+b;<br>            <span class="hljs-number">2&#x27;b01</span>:q=a&amp;b;<br>            <span class="hljs-number">2&#x27;b10</span>:q=a^b;<br>            <span class="hljs-number">2&#x27;b11</span>:q=a|b;<br>            <span class="hljs-keyword">default</span>: q=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h5 id="寄存器单元LA和LB以及双端口存储器GR上文已经定义"><a href="#寄存器单元LA和LB以及双端口存储器GR上文已经定义" class="headerlink" title="寄存器单元LA和LB以及双端口存储器GR上文已经定义"></a>寄存器单元LA和LB以及双端口存储器GR上文已经定义</h5><p>register(clk,rst_n,end,d,q)</p><p>ram(data,read_addr,write_addr,clk,we,q)</p><p>利用结构描述设计方法，利用以上模块实现数据通路</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/newimg/image-20210429011533770.png" alt="image-20210429012206972"></p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"> <span class="hljs-keyword">module</span> datapath_top(clk,rst,lda,ldb,read_addr,write_addr,we,op);<br>    <span class="hljs-keyword">input</span> clk,rst,lda,ldb,we;<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_addr,write_addr;<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] op;<br>    <br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] gr_data,alu_data;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] la_data,lb_data;<br>    <br>    register<span class="hljs-variable">#(32) LA(clk,rst,lda,gr_data,la_data)</span><br>    register<span class="hljs-variable">#(32) LB(clk,rst,ldb,gr_data,lb_data)</span><br>    ram<span class="hljs-variable">#(32,5) GR(alu_data,read_addr,write_addr,clk,we,gr_data)</span>;<br>    alu<span class="hljs-variable">#(32) ALU(la_data,lb_data,op,alu_data)</span>;<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Verilog及常见电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog，常见电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog填鸭入门</title>
    <link href="/2021/04/24/verilog%E5%85%A5%E9%97%A8/"/>
    <url>/2021/04/24/verilog%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="三种描述方式"><a href="#三种描述方式" class="headerlink" title="三种描述方式"></a>三种描述方式</h2><p>Verilog的<strong>基本设计单元为模块</strong></p><p><strong>结构描述</strong>（侧重于模块内部结构实现的描述方式，实例化语句进行描述）</p><span id="more"></span><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424142401321.png" alt="image-20210424142401321" style="zoom: 33%;"><p><strong>数据流描述</strong>（侧重于数据流动和处理过程的描述方式，简洁，描述输入输出信号的逻辑关系）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424142642643.png" alt="image-20210424142642643" style="zoom:33%;"><p><strong>连续赋值语句：assign</strong>，表述输入端只要有变化，表达式的值就会改变，输出改变。</p><p><strong>行为描述</strong>（侧重于行为方式）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424142849768.png" alt="image-20210424142849768" style="zoom: 33%;"><p>使用<strong>always@语句，表示会不停的运行</strong>，与实际电路一致，后面带有事件控制，一般所有的输入要列在括号中，表示输入有变化就运行后续语句</p><p>一般混合使用</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424142935445.png" alt="image-20210424142935445" style="zoom:33%;"><blockquote><p>上图半加器采用了行为描述，全加器采用了结构描述和数据流描述</p><p>verilog中的语句是<strong>同时进行</strong>的，不具有先后关系，与C语言不同。</p></blockquote><h2 id="原语（软件自带的基本的门，与或非等）"><a href="#原语（软件自带的基本的门，与或非等）" class="headerlink" title="原语（软件自带的基本的门，与或非等）"></a>原语（软件自带的基本的门，与或非等）</h2><ul><li><p>不用声明，直接实例化</p></li><li><p>输出端口在前，输入端口在后  最前的Z为输出，ABC为输入</p></li><li><p>实例名和延时可选  #10 输入输出之间延时10个时间单位</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424143347961.png" alt="image-20210424143347961"></p></li></ul><p>时延仅仅在仿真的时候可以用，综合的时候会被忽略。因为实际电路与你的元器件和材料等有关系，在实际电路不可控。</p><p><strong>结构描述</strong>：<strong>完成最顶层的设计</strong>，定义好所有小模块后连接起来。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424143709319.png" alt="image-20210424143709319" style="zoom: 33%;"><p><strong>wire线网型变量，可以表示电路中的连线</strong></p><p>上图中设计的元件的输入如何对应</p><ol><li><strong>端口位置关联</strong>，直接一一对应，怎么设计的，就直接对应上。</li><li>如果端口位置太多，可采用<strong>端口名称关联</strong>。</li></ol><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424144244364.png" alt="image-20210424144244364" style="zoom:33%;"><p>有的时候有些管脚没有用到，采用空白处理，<strong>空端口</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424144439833.png" alt="image-20210424144439833" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424144625856.png" alt="image-20210424144625856" style="zoom: 50%;"><p>里面的<strong>“，”不能省略</strong>，如果是端口名称关联则**()里不写东西**。</p><p>输入端口如果是空，表示为z高阻态</p><p>输出端口如果是空，表示没有用到。</p><p>但是<strong>要保证输入端口不悬空</strong>，输入端口悬空会产生干扰，噪音</p><p>输出端口无所围，悬空就表示不使用</p><p>给定电路图，通过实例化语句描述电路</p><p>四位加法器</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424144845335.png" alt="image-20210424144845335" style="zoom:33%;"><ol><li><p>声明对外的接口，端口名在模块名后的括号（）中，模块中指明端口类型和宽度</p></li><li><p>声明内部的连线</p></li><li><p>实例化模块</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424145209009.png" alt="image-20210424145209009" style="zoom: 50%;"></li></ol><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424145239870.png" alt="image-20210424145239870" style="zoom:33%;"><p>从上到下的设计顺序。</p><h2 id="层次化与源文件"><a href="#层次化与源文件" class="headerlink" title="层次化与源文件"></a>层次化与源文件</h2><ul><li>多个module是放在同一个文件还是分开放？</li><li>可以放在同一个文件中<ul><li>模块次序自由</li><li>适合小设计</li><li>不太适合模块重用（剪切粘贴）</li></ul></li><li>可以将模块分解成多个文件<ul><li>良好习惯：每个文件只包含一个module</li><li>便于找到一个模块</li><li>有利于模块重用（将文件添加到项目种）</li></ul></li></ul><h2 id="数据流描述的使用要点"><a href="#数据流描述的使用要点" class="headerlink" title="数据流描述的使用要点"></a>数据流描述的使用要点</h2><ul><li><p>最主要机制就是连续赋值语句</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424145807542.png" alt="image-20210424145807542"></p></li></ul><blockquote><p> 关键字assign  +  时延（可选）  +  <strong>线网型变量</strong>  =  赋值表达式</p></blockquote><p>连续赋值：只要右边表达式有变化，左边的变量值就变化。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424150127603.png" alt="image-20210424150127603" style="zoom:33%;"><p>上图种sum，src1，src2都是32位，在下面的加法算式中自动对齐，每位相加，得到结果后赋值给左边。</p><p>{}是连接运算符，将c_out与sum连接合并成了一个33位的变量。</p><h2 id="verilog运算符"><a href="#verilog运算符" class="headerlink" title="verilog运算符"></a>verilog运算符</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424150349910.png" alt="image-20210424150349910" style="zoom: 33%;"><p>与C语言几乎一致，只做少量变化。</p><h2 id="行为描述功能最强大，用法最多"><a href="#行为描述功能最强大，用法最多" class="headerlink" title="行为描述功能最强大，用法最多"></a>行为描述功能最强大，用法最多</h2><ul><li>行为建模的基础是initial和always：</li><li>所有其他的行为语句包含在这两个语句中</li><li>initial和always块不能嵌套，且左边变量必须是reg类型</li></ul><h3 id="仿真测试块Initial语句"><a href="#仿真测试块Initial语句" class="headerlink" title="仿真测试块Initial语句"></a>仿真测试块Initial语句</h3><ol><li><p>initial语句从0时刻开始执行且只执行一次</p><ul><li>如果有多个initial块，它们都从0时刻开始并行独立执行，独立完成执行</li><li>initial语句一般用来仿真，被综合工具忽略，不能综合。但是用来读取初始化存储文件时能够被综合<img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424152347342.png" alt="image-20210424152347342" style="zoom: 50%;"></li></ul><p>仿真模块名后一般加_tb表示这是testbeach文件</p></li></ol><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424152044221.png" alt="image-20210424152044221" style="zoom: 67%;"><p>全加器的测试模块，测试模块没有对外的端口。</p><p>首先要包含测试模块内部的信号，stim连接被测块的输入接口，s，c连接输出端。</p><p>凡是在initial和always语句中左侧的变量必须是寄存器类型（reg）</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424152333370.png" alt="image-20210424152333370"></p><p>stim从0一直赋值到&lt;8，每个值维持5个时间单位，输入变化，输出c，s就有变化。</p><p>仿真时通过波形可以看到值的变化</p><p>或者测试块中通过调用系统输出的任务将变量值输出观察。monitor监控函数，与printf用法差不多，一旦启动后就不断地监控。</p><p>所有的系统任务都是$开头。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424152715002.png" alt="image-20210424152715002" style="zoom: 50%;"><p>延时50个单位</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424153600378.png" alt="image-20210424153600378" style="zoom:33%;"><p>这三个initial语句同时从0时刻启动，无顺序关系</p><p>begin end相当于C中的{}，如果只有一条语句，可以不用begin end</p><h3 id="always语句"><a href="#always语句" class="headerlink" title="always语句"></a>always语句</h3><ul><li>从0时刻开始不断循环执行</li><li>可以使用触发/敏感时间列表来控制操作；@(a or b or c)</li><li>没有触发时间，将在0时刻无限循环执行</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424154001006.png" alt="image-20210424154001006" style="zoom:50%;"><p>如过不加@，敏感事件触发，会不停的执行下面的语句</p><p>always块中赋值左侧的类型一定是reg，下图中的module()中要声明是reg，因为如果不写reg会自动默认为wire型。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424161038637.png" alt="image-20210424161038637"></p><h3 id="always的事件控制方式"><a href="#always的事件控制方式" class="headerlink" title="always的事件控制方式"></a>always的事件控制方式</h3><ul><li>always是基于事件执行，有两种类型的事件控制方式<ul><li>边沿触发事件控制：用来描述时序逻辑电路</li><li>电平敏感事件控制：用来描述组合逻辑电路</li></ul></li></ul><p>时序逻辑电路边沿触发</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)  <span class="hljs-comment">//clk从低电平-&gt;高电平（正沿）</span><br>    cur_state=next_state  <span class="hljs-comment">//就执行赋值语句</span><br>    <br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">negedge</span> reset)  <span class="hljs-comment">//reset从高-&gt;低（负沿）</span><br>    count=<span class="hljs-number">0</span><br>        <br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clear <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> reset)<br></code></pre></div></td></tr></table></figure><p>posedge表示上升沿</p><p>negedge表示下降沿</p><p>不可以同时包括同一个信号的上升沿和下降沿</p><p>组合逻辑电路电平敏感</p> <figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(X1 <span class="hljs-keyword">or</span> X2 <span class="hljs-keyword">or</span> X3)<br><span class="hljs-comment">//or等价于，</span><br><span class="hljs-keyword">always</span>@(X1,X2,X3)<br><span class="hljs-comment">//*表示所有输入信号防止遗漏</span><br><span class="hljs-keyword">always</span>@(*)<br></code></pre></div></td></tr></table></figure><p>不可以同时包括电平敏感事件和边沿敏感事件</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424162156315.png" alt="image-20210424162156315" style="zoom: 33%;"><h2 id="if-else（放在always中）"><a href="#if-else（放在always中）" class="headerlink" title="if else（放在always中）"></a>if else（放在always中）</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424162314753.png" alt="image-20210424162314753" style="zoom:33%;"><p>和C唯一的不同就是{}改用begin end</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424162630348.png" alt="image-20210424162630348"></p><p>综合之后肯定会有选择器。实际的运算是，实现了运算所有可能的值，只不过最后输出的时候<strong>通过选择器输出某个值。</strong></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424162815974.png" alt="image-20210424162815974"></p><p>无else语句，不能覆盖所有可能的结果</p><p>语句不完整即有某些情况的输入对输出无任何影响，根据锁存器的特征，反映到硬件电路即会产生锁存器。</p><p><strong>if语句后要加上else，以防止锁存器的发生。</strong></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424165345023.png" alt="image-20210424165345023"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424182710316.png" alt="image-20210424182710316" style="zoom:50%;"><p>上升沿触发，当if中的reset为1时，才会清零，同步清零。</p><p>同样的set为1时，才会置1。</p><p>当reset和set都为1时，verilog的if else有优先级，第一个if先执行，依次类推。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424183422772.png" alt="image-20210424183422772"></p><p>case的末尾要加default </p><ul><li>Verilog有三种形式的case语句：case，casex，casez</li><li>表达式按顺序与各分支项值按位匹配<ul><li>两者位宽相同</li></ul></li><li>case：是一种全等比较</li><li>casez: 比较双方有一方的某些位的值是z，那么这些位的比较就不予考虑，而只关注其他位的比较结果</li><li>casex：比较双方有一方的某些位的值是x和z，就不予考虑</li><li>?可用来代替z，表示无关位</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424184241426.png" alt="image-20210424184241426" style="zoom: 33%;"><p>若真的要表示出不关心哪一位，上述的case改成casex</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while和for与C完全相同"><a href="#while和for与C完全相同" class="headerlink" title="while和for与C完全相同"></a>while和for与C完全相同</h3><h3 id="repeat循环"><a href="#repeat循环" class="headerlink" title="repeat循环"></a>repeat循环</h3><p>执行指定的循环次数</p><ul><li><p>repeat的循环次数可以是一个变量，但</p><ul><li>其值在开始循环时得到计算，从而得以事先确定循环次数</li><li>如果其值在循环执行期间发生更改，也不会更改迭代次数</li></ul></li><li><p>在teatbench，常与@(posedge)事件控制一起使用，用来等待固定数量的时钟。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424184642168.png" alt="image-20210424184642168"></p></li></ul><h3 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h3><ul><li>无限循环，常用于产生周期性的波形，用来作为仿真测试信号，它与always的不同之处是不能独立在程序中，必须写在initial块中</li><li><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424185022459.png" alt="image-20210424185022459"></li><li>经常用于产生周期性波形</li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424204254143.png" alt="image-20210424204254143" style="zoom: 33%;"><p>循环几次，电路规模就扩大几倍</p><p>若循环次数已知，电路可以综合。</p><p>但是若是循环结束条件是变量，这种就无法综合。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424204410159.png"></p><p>上述电路中的语句没有用assign，是过程赋值语句</p><h3 id="过程赋值语句"><a href="#过程赋值语句" class="headerlink" title="过程赋值语句"></a>过程赋值语句</h3><ul><li><p>阻塞型过程赋值： =</p><p>前一条语句没有完成赋值过程之前，后面的语句不能被执行</p></li><li><p>非阻塞型过程赋值： &lt;=</p><p>一条非阻塞赋值语句的执行，不会影响块中其他语句的执行（意思是同时执行）</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424205106772.png" alt="image-20210424205106772"></p></li></ul><h3 id="阻塞性赋值"><a href="#阻塞性赋值" class="headerlink" title="阻塞性赋值"></a>阻塞性赋值</h3><p>当前的赋值语句阻断了其后的语句，即后面的语句必须等到当前的赋值语句执行完毕后才能执行</p><p>用于<strong>组合逻辑</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424205252988.png" alt="image-20210424205252988" style="zoom:33%;"><h3 id="非阻塞性赋值"><a href="#非阻塞性赋值" class="headerlink" title="非阻塞性赋值"></a>非阻塞性赋值</h3><p>如果没有定时控制，则同时计算RHS和更新LHS</p><p>用于<strong>时序逻辑</strong></p><p>只能用在initial和always中</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424205452445.png" alt="image-20210424205452445" style="zoom:33%;"><p>上图中out0&lt;=out1;out1&lt;=out0，时序逻辑交换变量不需要中间变量，直接赋值。</p><p>组合逻辑就需要<strong>中间变量</strong>来交换。 </p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424205715952.png" alt="image-20210424205715952" style="zoom:33%;"><p>如果上述的电路没有用=，而是用&lt;=,使得三条语句同时执行，不能实现现有的交换</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424210013817.png" alt="image-20210424210013817" style="zoom:33%;"><p>上图电路有误，无法实现交换变量的功能</p><p>同样，若在时序电路中没有用&lt;=，而是用=</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424210157890.png" alt="image-20210424210157890"></p><p>上述q1=d;q2=d1;q=q2;最终就相当于q=d，只有一个触发器（自动优化）</p><p>若上述代码改为&lt;=</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424210503238.png" alt="image-20210424210503238" style="zoom:33%;"><p>每次这三个变量都传递一次，需要三次传递，d才能到q，触发器链</p><p>下列代码中，z就不能正确表示出当前abcd的与或关系，而是上一次的</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424210654928.png" alt="image-20210424210654928" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424210801792.png" alt="image-20210424210801792" style="zoom:33%;"><p>若把temp1和temp2放入敏感列表中，当作触发事件，就可以触发了。</p><p>上述方法可行，但效率不高。一个always块需要多次传递才能得到想要的值，降低了性能。不如采用阻塞赋值，一次传递就能解决。</p><h2 id="任务和函数"><a href="#任务和函数" class="headerlink" title="任务和函数"></a>任务和函数</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424211002819.png" alt="image-20210424211002819" style="zoom:33%;"><p>函数是有返回值的，任务则没有。</p><p>function中的位宽说明就表示了返回值的位宽。对函数来说，只有input参数，无output参数。且至少有一个input</p><p>task中input和output的数量无限制，output就作为返回值返回。</p><ul><li>任务可以含有时序控制，而函数则没有。</li><li>任务可以有输入和输出函数，而函数至少一个输入参数，没有输出参数。</li><li>任务的调用是通过调用语句，而函数调用出现在表达式中。</li></ul><h3 id="函数functions"><a href="#函数functions" class="headerlink" title="函数functions"></a>函数functions</h3><ul><li>函数的定义和调用都包括在一个module内<ul><li>函数调用在表达式中（RHS）</li></ul></li><li>用于实现组合逻辑<ul><li>不能包含任何时延，时序，事件控制</li><li>可以调用其他函数，不能调用任务</li><li>只是用阻塞赋值，行为语句</li></ul></li><li>输入输出<ul><li>至少一个输入函数，不能有输出或者双向inout参数</li><li>返回一个值，与函数同名的寄存器变量在函数中被隐式地声明，通过对该寄存器赋值来返回函数值，可以指定返回值地宽度（缺省1bit）</li></ul></li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424211612718.png" alt="image-20210424211612718" style="zoom:33%;"><p>函数有返回值，调用一定在表达式中</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424211630655.png" alt="image-20210424211630655" style="zoom: 50%;"><p>函数名前为output参数，后为input参数</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424211840370.png" alt="image-20210424211840370" style="zoom: 33%;"><hr><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424211943887.png" alt="image-20210424211943887"></p><p>任务应用的更加广泛。</p><p>任务调用</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212358393.png" alt="image-20210424212358393" style="zoom: 67%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212116741.png" alt="image-20210424212116741" style="zoom:33%;"><p>任务所带地参数可以两种声明方式</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212251638.png" alt="image-20210424212251638" style="zoom:33%;"><p>任务调用的时候输入参数与参数类型一定要对应 </p><p>输出一定为reg类型</p><h3 id="时序控制"><a href="#时序控制" class="headerlink" title="时序控制"></a>时序控制</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212532877.png" alt="image-20210424212532877" style="zoom:33%;"><h3 id="命名程序块"><a href="#命名程序块" class="headerlink" title="命名程序块"></a>命名程序块</h3><ul><li><p>命名块中可以声明局部变量</p></li><li><p>命名块中声明地变量可以通过层次名引用进行访问</p></li><li><p>命名块可以被禁用（例如停止其执行）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212755355.png" alt="image-20210424212755355" style="zoom:33%;"></li></ul><h3 id="禁止语句"><a href="#禁止语句" class="headerlink" title="禁止语句"></a>禁止语句</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424212914240.png" alt="image-20210424212914240" style="zoom:33%;"><p>disable continue停止continue块地执行，上文中是结束当此循环，和C中的continue一致</p><p>disable break是停止break块地执行，上文中是结束循环，和C中的break一致</p><h3 id="文件IO操作"><a href="#文件IO操作" class="headerlink" title="文件IO操作"></a>文件IO操作</h3><p>打开文件，独写，关闭</p><p>与C基本一致</p><p>打开 $fopen(“filename”);</p><p>关闭 $fclose(fd);</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210424213221575.png" alt="image-20210424213221575"></p><p>与fprintf差不多</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Verilog及常见电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>快速入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的触发器</title>
    <link href="/2021/04/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2021/04/22/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="基本RS触发器"><a href="#基本RS触发器" class="headerlink" title="基本RS触发器"></a>基本RS触发器</h2><p>基本R-S触发器是直接复位（Reset）-置位（Set）触发器的简称。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173646020.png" alt="image-20210422173646020"></p><span id="more"></span><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173706121.png" alt="image-20210422173706121" style="zoom:50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173714969.png" alt="image-20210422173714969" style="zoom:50%;"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173754088.png" alt="image-20210422173754088" style="zoom: 50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173804535.png" alt="image-20210422173804535" style="zoom: 50%;"></p><p>次态方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173844473.png" alt="image-20210422173844473"></p><p>约束方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173856943.png" alt="image-20210422173856943"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422173910649.png" alt="image-20210422173910649" style="zoom:50%;"><p>当输入端S连续出现多个置1信号，或者输入端R连续出现多个清0信号，仅第一个信号使粗发起翻转</p><p>也就是说如果波形图中一条线不变，另一条线出现连续的凹陷，只在第一个凹陷的下降沿引起状态改变。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174038087.png" alt="image-20210422174038087"></p><p>可以利用这一特点消除机械开关震动引起的尖脉冲信号</p><h2 id="或非门构成的基本RS触发器"><a href="#或非门构成的基本RS触发器" class="headerlink" title="或非门构成的基本RS触发器"></a>或非门构成的基本RS触发器</h2><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174123861.png" alt="image-20210422174123861"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174134049.png" alt="image-20210422174134049"></p><p>与与非门差不多，只是结果正好相反。</p><h2 id="简单结构的时钟控制触发器"><a href="#简单结构的时钟控制触发器" class="headerlink" title="简单结构的时钟控制触发器"></a>简单结构的时钟控制触发器</h2><p>基本R-S触发器的特点是触发器状态直接受输入信号R、S控制，一旦输入信号变化，触发器的状态随之变化</p><p>实际应用中，要求触发器按一定的时间节拍动作，让输入信号的作用收到时钟脉冲CP的控制。</p><p>时钟脉冲确定触发器状态转换的时刻（何时转换），输入信号确定触发器状态转换的方向。</p><p>时钟脉冲（CP）作用前的状态称为现态，而把时钟脉冲（CP）作用后的状态称为次态</p><h3 id="钟控RS触发器"><a href="#钟控RS触发器" class="headerlink" title="钟控RS触发器"></a>钟控RS触发器</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174224432.png" alt="image-20210422174224432" style="zoom: 67%;"><p>时钟脉冲为0时，触发器状态不变</p><p>时钟脉冲为1时，输入端RS的值可以通过控制门作用于上面的基本RS触发器</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174242225.png" alt="image-20210422174242225"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174255603.png" alt="image-20210422174255603" style="zoom: 50%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174303608.png" alt="image-20210422174303608" style="zoom:50%;"><p>(1)时钟RS触发器的时钟为<strong>电平控制</strong>，在CP=1期间接收输入信号，CP=0时状态保持不变，与基本RS触发器相比，对触发器状态的转变增加了时间控制</p><p>(2)RS之间有约束，不能允许出现R和S同时为1的情况，否则会使触发器处于不确定的状态。</p><img src="https://gitee.com/trent-liuy/blogimage/raw/4fc78eeba0dd8b5ac6fac30b38b151f06a944371/img/image-20210429104508234.png" alt="image-20210422174224432" style="zoom: 67%;"><p>次态方程和约束方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174328549.png" alt="image-20210422174328549"></p><h3 id="钟控D触发器（D锁存器）"><a href="#钟控D触发器（D锁存器）" class="headerlink" title="钟控D触发器（D锁存器）"></a>钟控D触发器（D锁存器）</h3><p>钟控D触发器只有一个输入端，是由钟控R-S触发器的控制电路稍加修改后形成的。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174346174.png" alt="image-20210422174346174"></p><p>无时钟脉冲作用（CP=0）时，触发器状态保持不变</p><p>有时钟时，D为什么，触发器状态就被置为什么</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174359032.png" alt="image-20210422174359032"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174404779.png" alt="image-20210422174404779"></p><p>次态方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174519952.png" alt="image-20210422174519952"></p><img src="https://gitee.com/trent-liuy/blogimage/raw/f8f5c1456211149da510583f12d401ac97ac0e34/newimg/image-20210429111510959.png" alt="image-20210429111510959" style="zoom:50%;"><p>如上图，是<strong>电平触发</strong>。</p><p>在数字电路中，凡在CP时钟脉冲控制下，根据输入信号D情况的不同，具有置0，置1功能的电路，都称为D触发器</p><h3 id="钟控J-K触发器"><a href="#钟控J-K触发器" class="headerlink" title="钟控J-K触发器"></a>钟控J-K触发器</h3><p>R-S触发器不可以使两个输入同时为1</p><p>钟控J-K触发器利用触发器两个输出端信号始终互补的特点，有效地解决了在时钟脉冲作用期间两个输入同时为1将导致触发器状态不确定的问题</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174445698.png" alt="image-20210422174445698"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174454539.png" alt="image-20210422174454539"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174503062.png" alt="image-20210422174503062"></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174535904.png" alt="image-20210422174535904" style="zoom:50%;"><p>次态方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174552805.png" alt="image-20210422174552805"></p><p><img src="https://gitee.com/trent-liuy/blogimage/raw/a0bfae900bc920021e7d6fa553e79fccb8b79ef4/newimg/image-20210429112546859.png" alt="image-20210429112546859"></p><p>如图，仍是<strong>电平触发</strong></p><p>在数字电路中，凡在CP时钟脉冲控制下，根据输入信号JK情况的不同，具有置0、置1、保持和翻转功能的电路，都称为JK触发器。</p><h3 id="钟控T触发器"><a href="#钟控T触发器" class="headerlink" title="钟控T触发器"></a>钟控T触发器</h3><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174615265.png" alt="image-20210422174615265"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174626772.png" alt="image-20210422174626772"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174632210.png" alt="image-20210422174632210"></p><p>次态方程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174649126.png" alt="image-20210422174649126"></p><hr><p>上述简单结构钟控触发器的共同特点是，当时钟控制信号为低电平时（CP=0）时，触发器保持原来状态不变；当时钟控制信号为高电平（CP=1）时，触发器在输入信号作用下发生状态变化。</p><p>换而言之，触发器状态转移是被控制在一个约定的时间间隔内，而不是控制在某一时刻进行。触发器的这种钟控方式被称作电位触发方式。</p><p>电位触发方式的钟控触发器存在一个共同的问题，就是可能出现“空翻”现象。</p><p>空翻：同一个时钟脉冲作用期间触发器状态发生两次或者两次以上变化的现象。引起空翻的原因是在时钟脉冲为高电平期间，输入信号的变化直接控制着触发器状态的变化。</p><p>当CP=1时，如果输入信号发生变化，则触发器状态会跟着发生变化。从而使得一个时钟脉冲作用期间引起多次翻转（电平触发），“空翻”将造成状态的不确定和系统工作的混乱，这是不允许的。如果要使这种触发器在每个时钟脉冲作用期间仅发生一个翻转，则对时钟信号的控制电平宽度要求极其苛刻。这一不足，使这种触发器的应用受到一定限制。</p><h2 id="其他结构的钟控触发器"><a href="#其他结构的钟控触发器" class="headerlink" title="其他结构的钟控触发器"></a>其他结构的钟控触发器</h2><p>克服触发器存在的空翻现象，对控制电路的结构进行改进，将触发器的翻转控制在某一时刻完成。</p><h3 id="主从钟控触发器"><a href="#主从钟控触发器" class="headerlink" title="主从钟控触发器"></a>主从钟控触发器</h3><p>采用具有存储功能的控制电路，避免了空翻现象</p><h3 id="主从R-S触发器"><a href="#主从R-S触发器" class="headerlink" title="主从R-S触发器"></a>主从R-S触发器</h3><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174720714.png" alt="image-20210422174720714"></p><p>主从两个触发器的时钟脉冲是反相的，时钟脉冲CP（1）作为主触发器的控制信号，反相（0）作为从触发器的控制信号</p><p>主触发器的状态Q’与~Q’为从触发器的输入</p><p>从触发器的输出Q与~Q作为整个主从触发器的状态输出</p><p>工作原理：</p><p>CP=1时，主触发器的值取决于RS，与R-S触发器完全相同</p><p>此时从触发器的时钟信号为0，控制门被封锁，从触发器的状态不受主触发器状态变化的影响。整个触发器的状态不变</p><p>CP由1变为0，主触发器被封锁，状态不变，从触发器被打开，从触发器的状态与主触发器相同，总而言之，CP1变0时，将主触发器状态转为整个主从触发器的状态。</p><ul><li><p>触发器状态的变化发生在时钟脉冲CP由1变为0的时刻，因为在CP=0期间主触发器被封锁，其状态不再受输入RS的影响，因此不会引起触发器状态发生两次以上的翻转，从未克服了空翻现象。</p></li><li><p>触发器的状态取决于CP由1变成0时刻主触发器的状态，二主触发器的状态在CP=1期间是随输入RS变化的，所以触发器的状态实际上取决于CP由1变为0之前输入RS的值</p></li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422175311253.png" alt="image-20210422175311253" style="zoom:67%;"><p>主从R-S触发器状态的变化发生在时钟脉冲CP的下降沿时刻，故通常称为下降沿触发。</p><h3 id="主从J-K触发器"><a href="#主从J-K触发器" class="headerlink" title="主从J-K触发器"></a>主从J-K触发器</h3><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210422174748592.png" alt="image-20210422174748592"></p><p>克服了空翻现象，但是存在一次翻转现象。</p><p>一次翻转：在时钟脉冲作用（CP=1）期间，主触发器的状态只能根据输入信号的变化改变一次。即主触发器在接受输入信号发生一次翻转后，其状态保持不变，不再受输入JK变化的影响。</p><h3 id="维持阻塞钟控触发器"><a href="#维持阻塞钟控触发器" class="headerlink" title="维持阻塞钟控触发器"></a>维持阻塞钟控触发器</h3><p>既克服简单结构钟控触发器的空翻现象，又提高触发器的抗干扰能力，引出了边沿触发器。边沿触发器仅在时钟脉冲CP的上升沿或者下降沿时刻响应输入信号。</p><p>维持-阻塞D触发器</p><ul><li><p>时钟脉冲CP=0，触发器状态保持不变。</p><p>此时接受输入信号，A=~D，B=D</p></li><li><p>时钟脉冲CP=1时，触发器的结果状态与D相同</p></li></ul><p>由于维持-阻塞线路的作用，触发器在时钟脉冲的上升沿将D输入端的数据可靠地转换成触发器状态，而在上升沿过后的时钟脉冲期间，不论D的值如何变化，触发器的状态始终以时钟脉冲上升沿时所采样的值为准。</p><p>时钟脉冲的上升边沿采样D输入端的数据，所以要求输入D在时钟脉冲CP由0变为1之前将数据准备好。在CP＝1期间始终有Qm=D</p><p>CP下降沿的时候，主触发器所存的D的值，Qm=D送入从触发器，Q=D，<del>Q=</del>D</p><p>下降沿过后，从触发器的状态也将保持不变。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Verilog及常见电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
      <tag>触发器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java自学——Map</title>
    <link href="/2021/04/22/Java_Map/"/>
    <url>/2021/04/22/Java_Map/</url>
    
    <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map接口时一种<strong>键——值对（key-value）集合</strong>，Map集合中的每一个元素都包含一个键对象和一个值对象。</p><p>键对象不允许重复，值对象可以重复，而且值对象还可以是Map类型的，就像数组中的元素还可以是数组一样。</p><p>它主要有两个实现类：HashMap 类和 TreeMap 类。</p><p>HashMap按哈希算法来存取键对象，而TreeMap类可以对键对象进行排序</p><span id="more"></span><hr><ul><li>可以通过键来访问对应的值</li><li>当访问的值不存在的时候，方法会抛出一个NoSuchElementException异常</li><li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常。</li><li>当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常。</li><li>当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常。</li></ul><hr><p>常用方法</p><table><thead><tr><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>初始化Map</td><td>Map&lt;String, String&gt; map = ``new<code> </code>HashMap&lt;String, String&gt;();</td></tr><tr><td>添加键值对</td><td>map.put(<code>&quot;key1&quot;</code>, <code>&quot;value1&quot;</code>);返回 key 以前对应的 value，如果没有， 则返回 null</td></tr><tr><td>移除键值对</td><td>map.remove(<code>&quot;key1&quot;</code>);返回 key 对应的 value，如果没有，则返回null</td></tr><tr><td>获取值</td><td>map.get(<code>&quot;key1&quot;</code>)</td></tr><tr><td>清空Map</td><td>map.clear();</td></tr><tr><td></td><td></td></tr></tbody></table><p>Map的遍历</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br><span class="hljs-comment">//</span><br>先添加几个元素<br>map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;aaa&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;bbb&quot;</span>);<br>map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;ccc&quot;</span>);<br>map.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;ddd&quot;</span>);<br><span class="hljs-comment">//</span><br>再遍历<br>StringBuffer buf = <span class="hljs-keyword">new</span> StringBuffer();<br><span class="hljs-comment">//</span><br>通过迭代器遍历。Java的集合类都实现了迭代器接口<br>Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it = map.entrySet().iterator();<br><span class="hljs-keyword">while</span> (it.hasNext())&#123;<br>Map.Entry&lt;Integer,String&gt; entry = it.next();<br>buf.append(entry.getKey() + <span class="hljs-string">&quot; ----&gt; &quot;</span> +<br>entry.getValue()).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>System.out.println(buf.toString());<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527200245667.png" alt="image-20210527200245667"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java流，文件，IO</title>
    <link href="/2021/04/22/Java%E6%B5%81/"/>
    <url>/2021/04/22/Java%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p><h3 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h3><p>Java 的控制台输入由 System.in 完成。</p><p>为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。</p><p>下面是创建 BufferedReader 的基本语法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> <br>                      InputStreamReader(System.in));<br></code></pre></div></td></tr></table></figure><p>BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。</p><h3 id="从控制台读取多字符输入"><a href="#从控制台读取多字符输入" class="headerlink" title="从控制台读取多字符输入"></a>从控制台读取多字符输入</h3><p>从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">( )</span> <span class="hljs-keyword">throws</span> IOException</span><br></code></pre></div></td></tr></table></figure><p>每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</p><p>下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 <strong>q</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//使用 BufferedReader 在控制台读取字符</span><br> <br><span class="hljs-keyword">import</span> java.io.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BRRead</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">char</span> c;<br>        <span class="hljs-comment">// 使用 System.in 创建 BufferedReader</span><br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));<br>        System.out.println(<span class="hljs-string">&quot;输入字符, 按下 &#x27;q&#x27; 键退出。&quot;</span>);<br>        <span class="hljs-comment">// 读取字符</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            c = (<span class="hljs-keyword">char</span>) br.read();<br>            System.out.println(c);<br>        &#125; <span class="hljs-keyword">while</span> (c != <span class="hljs-string">&#x27;q&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入字符, 按下 <span class="hljs-string">&#x27;q&#x27;</span> 键退出。<br>runoob<br>r<br>u<br>n<br>o<br>o<br>b<br><br><br>q<br>q<br></code></pre></div></td></tr></table></figure></blockquote><h3 id="从控制台读取字符串"><a href="#从控制台读取字符串" class="headerlink" title="从控制台读取字符串"></a>从控制台读取字符串</h3><p>从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。</p><p>它的一般格式是：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function">String <span class="hljs-title">readLine</span><span class="hljs-params">( )</span> <span class="hljs-keyword">throws</span> IOException</span><br></code></pre></div></td></tr></table></figure><p>下面的程序读取和显示字符行直到你输入了单词”end”。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//使用 BufferedReader 在控制台读取字符</span><br><span class="hljs-keyword">import</span> java.io.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BRReadLines</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 使用 System.in 创建 BufferedReader</span><br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));<br>        String str;<br>        System.out.println(<span class="hljs-string">&quot;Enter lines of text.&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Enter &#x27;end&#x27; to quit.&quot;</span>);<br>        <span class="hljs-keyword">do</span> &#123;<br>            str = br.readLine();<br>            System.out.println(str);<br>        &#125; <span class="hljs-keyword">while</span> (!str.equals(<span class="hljs-string">&quot;end&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">Enter <span class="hljs-keyword">lines</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">text</span>.<br>Enter <span class="hljs-string">&#x27;end&#x27;</span> <span class="hljs-built_in">to</span> quit.<br>This is <span class="hljs-built_in">line</span> <span class="hljs-literal">one</span><br>This is <span class="hljs-built_in">line</span> <span class="hljs-literal">one</span><br>This is <span class="hljs-built_in">line</span> <span class="hljs-literal">two</span><br>This is <span class="hljs-built_in">line</span> <span class="hljs-literal">two</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure></blockquote><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>在此前已经介绍过，控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。</p><p>PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。</p><p>PrintStream 定义 write() 的最简单格式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> byteval)</span></span><br></code></pre></div></td></tr></table></figure><p>该方法将 byteval 的低八位字节写到流中。</p><p>下面的例子用 write() 把字符 “A” 和紧跟着的换行符输出到屏幕：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.io.*;<br> <br><span class="hljs-comment">//演示 System.out.write().</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> b;<br>        b = <span class="hljs-string">&#x27;A&#x27;</span>;<br>        System.out.write(b);<br>        System.out.write(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>A</p></blockquote><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。</p><p>下图是一个描述输入流和输出流的类层次图。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527201707755.png" alt="image-20210527201707755"></p><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。</p><p>有多种构造方法可用来创建对象。</p><p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">InputStream f = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:/java/hello&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:/java/hello&quot;</span>);<br>InputStream in = <span class="hljs-keyword">new</span> FileInputStream(f);<br></code></pre></div></td></tr></table></figure><p>创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法及描述</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public void close() throws IOException{}</strong> 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。</td></tr><tr><td align="left">2</td><td align="left"><strong>protected void finalize()throws IOException {}</strong> 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</td></tr><tr><td align="left">3</td><td align="left"><strong>public int read(int r)throws IOException{}</strong> 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。</td></tr><tr><td align="left">4</td><td align="left"><strong>public int read(byte[] r) throws IOException{}</strong> 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。</td></tr><tr><td align="left">5</td><td align="left"><strong>public int available() throws IOException{}</strong> 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。</td></tr></tbody></table><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>该类用来创建一个文件并向文件中写数据。</p><p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</p><p>有两个构造方法可以用来创建 FileOutputStream 对象。</p><p>使用字符串类型的文件名来创建一个输出流对象：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">OutputStream f = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:/java/hello&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:/java/hello&quot;</span>);<br>OutputStream f = <span class="hljs-keyword">new</span> FileOutputStream(f);<br></code></pre></div></td></tr></table></figure><p>创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法及描述</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public void close() throws IOException{}</strong> 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。</td></tr><tr><td align="left">2</td><td align="left"><strong>protected void finalize()throws IOException {}</strong> 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</td></tr><tr><td align="left">3</td><td align="left"><strong>public void write(int w)throws IOException{}</strong> 这个方法把指定的字节写到输出流中。</td></tr><tr><td align="left">4</td><td align="left"><strong>public void write(byte[] w)</strong> 把指定数组中w.length长度的字节写到OutputStream中。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span>  filecopy;<br><span class="hljs-keyword">import</span> java.lang.System;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Copy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[ ] args)</span> </span>&#123;  <span class="hljs-comment">//参数不含程序名</span><br>        <span class="hljs-keyword">if</span>(args.length!=<span class="hljs-number">2</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Usage: Java  Copy  &lt;sourceFile&gt;   &lt;tagetFile&gt;&quot;</span>);<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;;<br>        File sF=<span class="hljs-keyword">new</span> File(args[<span class="hljs-number">0</span>]);                     <span class="hljs-comment">//args[0]:源文件路径</span><br>        <span class="hljs-keyword">if</span>(!sF.exists( ))&#123;<br>            System.out.println(<span class="hljs-string">&quot;Source Fiel &quot;</span>+args[<span class="hljs-number">0</span>]+ <span class="hljs-string">&quot;does not exist!&quot;</span>);<br>            System.exit(<span class="hljs-number">2</span>);<br>        &#125;;<br>        File tF=<span class="hljs-keyword">new</span> File(args[<span class="hljs-number">1</span>]);      <span class="hljs-comment">//args[1]:目标文件</span><br>        <span class="hljs-keyword">if</span>(tF.exists( ))&#123;<br>            System.out.println(<span class="hljs-string">&quot;Target File &quot;</span>+args[<span class="hljs-number">0</span>]+ <span class="hljs-string">&quot;already exist&quot;</span>);<br>            System.exit(<span class="hljs-number">3</span>);<br>        &#125;;<br>        <span class="hljs-keyword">try</span>&#123;<br>            Scanner input=<span class="hljs-keyword">new</span> Scanner(sF);<br>            PrintWriter output=<span class="hljs-keyword">new</span> PrintWriter(tF);<br>            <span class="hljs-keyword">while</span>(input.hasNext( ))&#123;<br>                String s=input.nextLine(); <span class="hljs-comment">//读取下一行</span><br>                output.println(s);<span class="hljs-comment">//打印这一行</span><br>            &#125;<br>            input.close( );       <br>            output.close( );<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(IOException ioe)&#123;       <br>System.out.println(ioe.toString( ));      <br> &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——多线程和并行程序设计</title>
    <link href="/2021/04/17/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/04/17/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="程序、进程和线程"><a href="#程序、进程和线程" class="headerlink" title="程序、进程和线程"></a>程序、进程和线程</h2><p>“程序”代表一个静态的对象，是内含指令和数据的文件，存储在磁盘或其他存储设备中</p><p>“进程”代表一个动态的对象，是程序的一个执行过程，存在于系统的内存中，一个进程对应于一个程序</p><p>“进程”是运行于某个进程中，用于完成某个具体任务的顺序控制流程，有时被成为轻型进程</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210417081121324.png" alt="image-20210417081121324"></p><span id="more"></span><p>多线程的执行次序完全随机，运行结果随机</p><p>理论上来讲，16G的机器，每个进程有单独的内存空间，都是16G，若多进程不够用，内存和硬盘不断交换</p><ul><li>当一个进程被创建，自动地创建了一个主线程。因此，一个进程至少有一个主线程。</li><li>线程：程序中完成一个任务地有始有终地<strong>执行流</strong>，都有一个执行的起点，经过一系列指令后到达终点。</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210417081330380.png" alt="image-20210417081330380"></p><ul><li>现代OS都将线程作为最小调度单位，进程作为资源分配的最小单位。分配给进程的资源（如文件，外设）可以被进程里的线程使用。</li></ul><h2 id="线程的作用"><a href="#线程的作用" class="headerlink" title="线程的作用"></a>线程的作用</h2><ul><li><p>一个进程的多个子线程可以并发运行</p></li><li><p>多线程可以使程序反应更快、交互性更强、执行效率更高。</p></li><li><p>特别是Server端的程序，都是需要启动多个线程来处理大量来自客户端的请求</p></li><li><p>一个典型的GUI程序分为</p><ul><li>GUI线程：处理UI消息循环，如鼠标消息、键盘消息</li><li>Worker线程：后台的数据处理工作，比如打印文件，大数据量的运算</li></ul></li></ul><hr><h2 id="Runuable接口和线程类Thread"><a href="#Runuable接口和线程类Thread" class="headerlink" title="Runuable接口和线程类Thread"></a>Runuable接口和线程类Thread</h2><h4 id="通过实现Runnable接口创建线程"><a href="#通过实现Runnable接口创建线程" class="headerlink" title="通过实现Runnable接口创建线程"></a>通过实现Runnable接口创建线程</h4><ul><li>实现Runnable接口，需要实现唯一的接口方法run<ul><li>void run()</li><li><strong>该方法定义了线程执行的功能</strong></li></ul></li><li>创建实现Runnable接口的类的对象</li><li>利用Thread类的构造函数创建线程对象<ul><li>public Thread(Runnable target)</li><li>new Thread对象时需要传入Runnable接口实例</li></ul></li><li>通过线程对象的start()方法启动线程</li></ul>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Client Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>   ...<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">(...)</span> </span>&#123;<br>   ...  <br>   <span class="hljs-comment">// Create an instance of TaskClass</span><br>   <span class="hljs-comment">//创建实现Runnable接口的对象</span><br>   Runnable task = <span class="hljs-keyword">new</span> TaskClass(...);<br> <br>   <span class="hljs-comment">// Create a thread</span><br>   <span class="hljs-comment">//以实现Runnable接口的对象为参数创建Thread对象</span><br>   Thread thread = <span class="hljs-keyword">new</span> Thread(task);<br> <br>   <span class="hljs-comment">// Start a thread</span><br>   <span class="hljs-comment">//Thread.start()开始线程</span><br>   thread.start(); <span class="hljs-comment">// 启动后自动执行task.run</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>通过线程任务类(TaskClass)创建任务对象(task),task为实现Runnable接口的对象</li><li>以任务对象task为参数new Thread对象。Thread对象代表一个线程，线程的执行内容由任务对象task定义。</li><li>通过线程对象Thread启动线程thread.start(),任何线程只能启动一次，多次调用产生IllegalThreadStateException异常</li></ol>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Custom task class</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<span class="hljs-comment">//Java.lang.Runnable</span><br>   ... <span class="hljs-comment">//可以有自己的数据成员</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TaskClass</span><span class="hljs-params">(...)</span> </span>&#123;<br>      ...<br>   &#125;<br> <br>   <span class="hljs-comment">//Implement the run method in Runnable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//Tell system how to run custom thread</span><br>      ...<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="通过实现Runnable接口创建线程的例子"><a href="#通过实现Runnable接口创建线程的例子" class="headerlink" title="通过实现Runnable接口创建线程的例子"></a>通过实现Runnable接口创建线程的例子</h3><ul><li><p>程序创建并运行两个线程，第一个线程打印100次字母a，第二个线程打印100次字母b</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintChar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> //实现<span class="hljs-title">Runnable</span>接口</span><br><span class="hljs-class"></span>&#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> charToPrint;  <span class="hljs-comment">// The character to print</span><br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> times;  <span class="hljs-comment">// The times to repeat</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> t)</span></span>&#123;  charToPrint = c;  times = t; &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//实现Runnable中声明的run方法</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt; times; i++) System.out.print(charToPrint);<br>      &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>new Thread对象时需要传入Runnable接口实例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableDemo</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//以PrintChar对象实例为参数构造Thread对象 </span><br>        Thread printA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>));<br>        Thread printB = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>));<br>        printA.start();<br>        printB.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><hr><h4 id="通过继承Thread类创建线程"><a href="#通过继承Thread类创建线程" class="headerlink" title="通过继承Thread类创建线程"></a>通过继承Thread类创建线程</h4><ul><li>线程和线程任务混在一起，不建议使用。</li><li>Java不支持多继承，CustomThread继承了Thread类，不能再继承其他类。</li></ul>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">// Custom thread class</span><br><span class="hljs-comment">//Thread类的拓展类</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>  <span class="hljs-comment">//数据成员</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomThread</span><span class="hljs-params">(...)</span> </span>&#123;<br>    ...<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Tell system how to perform this task</span><br>    ...<br>  &#125;<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>定义Thread类的扩展类（CustomThread）</li><li>通过扩展类（CustonThread）创建线程对象（thead）</li><li>通过线程对象thrad启动线程thread.start()</li></ol>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//Client class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// Create a thread</span><br>    Thread thread1 = <span class="hljs-keyword">new</span> CustomThread();<br>    <span class="hljs-comment">// Start thread</span><br>    thread1.start( ); <span class="hljs-comment">//激活thread1对象的run</span><br>    <br>    <span class="hljs-comment">// Create a thread</span><br>    Thread thread2 = <span class="hljs-keyword">new</span> CustomThread( );<br>    <span class="hljs-comment">// Start thread</span><br>    thread2.start(); <span class="hljs-comment">//激活thread2对象的run</span><br>  &#125;<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="通过继承Thread类创建线程的实例"><a href="#通过继承Thread类创建线程的实例" class="headerlink" title="通过继承Thread类创建线程的实例"></a>通过继承Thread类创建线程的实例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintChar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> //继承<span class="hljs-title">Thread</span>类</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> charToPrint;  <span class="hljs-comment">//要打印的字符</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> times;  <span class="hljs-comment">//打印的次数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> t)</span></span>&#123; charToPrint = c; times = t; &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//覆盖run方法，定义线程要完成的功能</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt; times; i++)<br>System.out.print(charToPrint);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread printA = <span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>); <span class="hljs-comment">//创建二个线程对象</span><br>    Thread printB = <span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>);<br>    printA.start(); <span class="hljs-comment">//启动线程</span><br>    printB.start();<span class="hljs-comment">//启动另外一个线程</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="线程的状态切换"><a href="#线程的状态切换" class="headerlink" title="线程的状态切换"></a>线程的状态切换</h3><ul><li>就绪：万事俱备，等待CPU调度</li><li>运行：线程获得了CPU的所有权并在上面运行</li><li>消亡：当run()执行完毕后，线程就消亡</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421184045450.png" alt="image-20210421184045450"></p><ul><li>下面一些情况导致线程从<strong>运行状态转到阻塞状态</strong>：<ol><li>调用了sleep</li><li>调用了Object wait()方法，条件对象的await方法，Thread的join方法以及等待其他线程，或者等待资源锁</li><li>发出了阻塞式IO操作请求，并等待IO操作结束(如等待阻塞式Socket的数据到来)</li></ol></li><li>线程由<strong>阻塞状态被唤醒后，回到就绪态</strong>。唤醒的原因<ol><li>sleep时间到</li><li>调用wait(await)的线程被其他线程notify，调用join方法的线程等到了其他线程完成，线程拿到了资源锁</li><li>阻塞IO完成</li></ol></li></ul><blockquote><p>Object类定义了wait/notify/notifyAll方法</p><p>Thread类定义了sleep/yield/join方法</p></blockquote><h3 id="Runnable接口和线程类Thread"><a href="#Runnable接口和线程类Thread" class="headerlink" title="Runnable接口和线程类Thread"></a>Runnable接口和线程类Thread</h3><ul><li><p>java.lang.Runnable</p><p>Runnable接口实例定义了线程任务，即线程要执行的逻辑。一个线程任务必须通过线程对象来执行</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421184504711.png" alt="image-20210421184504711" style="zoom: 50%;"><p>Thread()                                    创建一个空的线程</p><p>Thread(task:Runnable)          为指定的任务创建一个线程</p><p>start():void                                开始一个线程，进入Ready状态，如无其它线程等待，可立即Run进入running状态</p><p>isAlive():boolean                      测试线程当前是否在运行</p><p>setPriority(p:int):void             为该线程指定优先值p（1~10）</p><p>join():void                                   等待线程结束</p><p>sleep(millis:long):void             让当前线程休眠若干ms，监视器自动恢复其运行</p><p>yield():void                                  将线程从running变为ready，允许其他线程执行（自己也可能立即执行）</p><p>interrupt():void                            中断该线程</p></li></ul><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><ul><li><p>n线程优先级范围从1－10，数字越高越能被优先执行。但优先级高并不代表能独自占用执行时间片，可能是<strong>优先级高得到越多的执行时间片</strong>，反之，<strong>优先级低的分到的执行时间少但不会分配不到执行时间</strong></p></li><li><p>每个线程创建时赋予默认的优先级Thread.NORM_PRIORITY. </p></li><li><p>通过setPriority(int priority)为线程指定优先级. </p></li><li><p>用getPriority()方法获取线程的优先级.</p></li><li><p>JAVA定义的优先级：1～10</p></li><li><p>Thread类有int 类型的常量：</p><ul><li><p>Thread.MIN_PRIORITY（1）</p></li><li><p>Thread.MAX_PRIORITY（10）</p></li><li><p>Thread.NORM_PRIORITY（5）</p></li></ul></li><li><p>多个线程只能是“宏观上并行，微观上串行”</p></li><li><p>在有限个CPU的系统中确定多个线程的执行顺序称为线程的调度</p></li><li><p>Java的线程调度是抢占式的，这表示调度机制会<strong>周期性地中断线程</strong>，将上下文切换到另一个线程；从而为每个线程都提供时间片</p></li><li><p>自私的线程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">run() &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>应适当地在run()里sleep或yield一下，让其他线程由更多机会被运行。</p><p><em><strong>不要编写依赖于线程优先级的程序</strong></em></p></li></ul><h3 id="线程类Thread的yield，sleep方法"><a href="#线程类Thread的yield，sleep方法" class="headerlink" title="线程类Thread的yield，sleep方法"></a>线程类Thread的yield，sleep方法</h3><h4 id="使用yield-方法为其他线程让出CPU时间"><a href="#使用yield-方法为其他线程让出CPU时间" class="headerlink" title="使用yield()方法为其他线程让出CPU时间"></a>使用yield()方法为其他线程让出CPU时间</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; times; i++) &#123;<br>        System.out.print(charToPrint);<br>        Thread.yield();  <span class="hljs-comment">//挂起进入ready，给其它进程调度机会</span><br>     &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>将线程从running变为ready，允许其他线程执行（自己也可能立即执行）</p></blockquote><h4 id="sleep-long-mills-方法将线程设置为休眠状态，确保其他线程执行："><a href="#sleep-long-mills-方法将线程设置为休眠状态，确保其他线程执行：" class="headerlink" title="sleep(long mills)方法将线程设置为休眠状态，确保其他线程执行："></a>sleep(long mills)方法将线程设置为休眠状态，确保其他线程执行：</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//循环中使用sleep方法，循环放在try-catch块中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; times; i++) &#123;<br>            System.out.print(charToPrint);<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">50</span>) Thread.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 必检异常：其它线程调当前线程（正在休眠）interupt方法会抛出该异常</span><br>    <span class="hljs-keyword">catch</span> (InterruptedException ex &#123; &#125;<br>&#125;<span class="hljs-comment">//处于阻塞状态（如在睡眠，在wait，在执行阻塞式IO）的线程，如果被其他线程打断（即处于阻塞的线程的interupt方法被其它线程调用），会抛出InterruptedException</span><br></code></pre></div></td></tr></table></figure><blockquote><p>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、1.5中的condition.await、以及可中断的通道上的 I/O 操作方法后可进入阻塞状态）</p><p>则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法（sleep、join、wait、1.5中的condition.await及可中断的通道上的 I/O 操作方法）调用处抛出InterruptedException异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为false。</p><p>抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求。</p></blockquote><h4 id="线程类Thread的join方法"><a href="#线程类Thread的join方法" class="headerlink" title="线程类Thread的join方法"></a>线程类Thread的join方法</h4><p>Runnable接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintChar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> //实现<span class="hljs-title">Runnable</span>接口</span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> charToPrint;  <span class="hljs-comment">// The character to print</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> times;  <span class="hljs-comment">// The times to repeat</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> t)</span></span>&#123;  charToPrint = c;  times = t; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//实现Runnable中声明的run方法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt; times; i++) <br>    System.out.print(charToPrint);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行多线程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>    Thread printA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>));<br>    Thread printB = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>));<br>    printA.start();<br>     printB.start();<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421190447197.png" alt="image-20210421190447197"></p><blockquote><p>可以看到屏幕上<strong>无规律的交替输出ab</strong>。这是多线程程序的特点，<strong>每次运行输出结果可能是不一样的</strong>。如果希望把所有a先打印完再打印b，怎么做？</p></blockquote><p>修改代码如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        Thread printA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">100</span>));<br>        Thread printB = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">100</span>));<br>        printA.start();  <span class="hljs-comment">//在主线程里首先启动printA线程</span><br>        printA.join(); <span class="hljs-comment">//主线程被阻塞，等待printA执行完</span><br>        printB.start(); <span class="hljs-comment">//主线程被唤醒，启动printB线程</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421190613062.png" alt="image-20210421190613062"></p><blockquote><p>join方法的作用：在A线程中调用了B线程（对象）的join()方法时，表示A线程放弃控制权（被阻塞了），只有<strong>当B线程执行完毕时，A线程才被唤醒继续执行。</strong></p><p>程序在main线程中调用printA线程（对象）的join方法时，<strong>main线程放弃cpu控制权（被阻塞），直到线程printA执行完毕</strong>，main线程被唤醒执行printB.start();</p><p>运行结果是全部a打印完才开始打印b</p></blockquote><p>定义一个新的线程任务类</p><blockquote><p>在线程任务对象print100的run中启动新线程Thread4，并调用Thread4 的join( ) 方法，，等待Thread4结束:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNum</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123; <span class="hljs-comment">//实现新的线程任务类，打印数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> lastNum;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrintNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123; lastNum = n; &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>       Thread thread4=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">4000</span>));<br>        thread4.start();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;lastNum;i++)&#123;<br>                System.out.print(<span class="hljs-string">&quot; &quot;</span> + i);<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">50</span>) thread4.join(); <span class="hljs-comment">//join方法可以给参数指定至多等若干毫秒</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(InterruptedException e)&#123; &#125; <span class="hljs-comment">//join方法可能会抛出这个异常</span><br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>启动tPrint100线程：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Runnable print100 = <span class="hljs-keyword">new</span> PrintNum(<span class="hljs-number">100</span>); <span class="hljs-comment">//线程任务对象</span><br>Thread tPrint100 = <span class="hljs-keyword">new</span> Thread(print100); <span class="hljs-comment">//线程对象</span><br>tPrint100.start();<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192003612.png" alt="image-20210421192003612"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192306057.png"></p><p>可以看到，thread4打印c一直在执行，同时tPrint100也一直在打印数字，当打印到50的时候，调用了thread4.join()，之后停止tPrint100进程，让thread4打印c，当所有c打印完后，再继续打印数字</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li><p>由于要为每一个线程任务创建一个线程（Thread对象），对于有<strong>大量线程任务的场景就不够高效</strong></p><p>（当线程任务执行完毕，即run方法结束后，Thread对象就消亡，然后又为新的线程任务去new新的线程对象…, <strong>当有大量的线程任务时，就不断的new Thread对象，Thread对象消亡，再new Thread对象…</strong>）</p></li><li><p>线程池适合<strong>大量线程任务的并发执行</strong>。线程池通过有效管理线程、“复用” 线程来提高性能. </p></li><li><p>从JDK 1.5 开始使用Executor接口（执行器）来执行线程池中的任务，Executor的<strong>子接口ExecutorService管理和控制任务</strong></p></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192655047.png" alt="image-20210421192655047"></p><ul><li>使用Executors的类方法创建一个线程池，Eecutors由Object派生</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421192841546.png" alt="image-20210421192841546"></p><blockquote><p>Executors还支持其它类型的线程池的创建方法如：newScheduledThreadPool、newSingleThreadPool</p></blockquote><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExecutorDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// Create a fixed thread pool with maximum three threads</span><br>    ExecutorService es= Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br> <br>    <span class="hljs-comment">// Submit runnable tasks to the executor</span><br> es.execute(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">100</span>));<br> es.execute(<span class="hljs-keyword">new</span> PrintChar(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">100</span>));<br> es.execute(<span class="hljs-keyword">new</span> PrintNum(<span class="hljs-number">100</span>));<br> <br>    <span class="hljs-comment">// Shut down 关闭，不接受新的线程任务，现有的任务将继续执行直到完成</span><br><br>    es.shutdown();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="进一步讨论：区分任务和线程"><a href="#进一步讨论：区分任务和线程" class="headerlink" title="进一步讨论：区分任务和线程"></a>进一步讨论：区分任务和线程</h3><ul><li><p>任务</p><ul><li>任务是实现了Runnable接口的类的实例</li><li>这个任务的逻辑由run方法实现</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-comment">//数据成员和其它方法... </span><br>    <br>   <span class="hljs-comment">//Implement the run method in Runnable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//task logic...</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>线程</p><ul><li>线程是Thread类的实例，是任务的运行载体</li><li>任务必须通过线程来运行</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>        Runnable task = <span class="hljs-keyword">new</span> Task(...); <span class="hljs-comment">// Create an instance of Task</span><br>        <br>        Thread thread = <span class="hljs-keyword">new</span> Thread(task); <span class="hljs-comment">// Create a thread   </span><br>        thread.start(); <span class="hljs-comment">// Start a thread</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421194556081.png" alt="image-20210421194556081" style="zoom:67%;"><blockquote><p>如果这样直接new一个线程，线程启动后，执行任务的run方法，当任务的run方法执行完毕，线程对象使命就结束，被JVM回收。</p><p>如果有大量的任务要运行，会导致频繁创建新线程，销毁线程。</p><p>线程池维护多个创建好的线程，同时可以让多个任务“复用”线程，避免了线程的重复创建和销毁。</p></blockquote><p><strong>但是一个线程任务被线程执行完后，线程就自动消亡。那么如何复用一个线程（即让线程去执行新的任务）？这个问题大家下去思考。</strong>（待解决）</p><h2 id="线程同步-程序清单30-4"><a href="#线程同步-程序清单30-4" class="headerlink" title="线程同步-程序清单30-4"></a>线程同步-程序清单30-4</h2><ul><li><p>如果一个共享资源（比如一个对象）被多个线程<strong>同时访问</strong>，如果不对访问进行控制，会造成<strong>不可预期</strong>的结果。这是需要对线程实施同步控制</p></li><li><p>Account是账户类，其数据成员balance为当前余额，deposit方法往账户存钱，getBalance方法读取账户余额</p></li><li><p>AddPennyTask为任务，每次往账户里存一个便士</p></li><li><p>启动100个线程同时执行AddPennyTask任务</p></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421195919991.png" alt="image-20210421195919991"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountWithoutSync</span></span>&#123;<br>    <br>    <span class="hljs-comment">//内部静态类Account</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> balance;  <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span></span>&#123;<br><span class="hljs-keyword">int</span> newBalance = balance + amount;   <span class="hljs-comment">//读取balance</span><br><span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">//休眠是为了放大数据不一致的可能性</span><br>               &#125;<br><span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>balance = newBalance;<span class="hljs-comment">//写balance</span><br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">//内部静态类AddPennyTask是线程任务类，实现Runnable接口，调用account对象的deposit方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddPennyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  account.deposit(<span class="hljs-number">1</span>); &#125;<br>    &#125;<br>    <br>     <span class="hljs-comment">//account对象被100个线程访问：每个线程的run方法都调用accoun.deposit方法   </span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Account account = <span class="hljs-keyword">new</span> Account();<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> ch30;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountWithoutSync</span> </span>&#123;<br>    <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//newCachedThreadPool()创建一个线程池，会再必要的时候创建新的线程。但是如果以前已经创建好的线程可用，则先宠用之前创建好的线程。</span><br>        ExecutorService executor = Executors.newCachedThreadPool();<br>        <br>        <span class="hljs-comment">//通过线程池启动100个线程，执行AddPenyTask类型的任</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;<br>            executor.execute(<span class="hljs-keyword">new</span> AddPennyTask());<br>        &#125;<br>        <br>        <span class="hljs-comment">//关闭线程池</span><br>        executor.shutdown();<br>        <br>        <span class="hljs-comment">//等待线程池里线程全部结束，线程池中都执行完后，返回true</span><br>        <span class="hljs-keyword">while</span>(!executor.isTerminated())&#123;  &#125;<br>            System.out.println(<span class="hljs-string">&quot;What is balance?&quot;</span> + account.getBalance());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>按理说，结果应该得到100，但是实际上结果如下（每次得到的值都是不同的）</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421202408116.png" alt="image-20210421202408116" style="zoom: 67%;"><p><strong>原因：多个线程访问一个对象，没有同步</strong></p><p>多个线程同时访问公共资源，会导致<strong>竞争状态（同时去修改公共资源）</strong>。为了避免竞争状态，应该<strong>防止多个线程同时进入程序的某一特定部分</strong>，这样的部分叫临界区。<strong>Account类的deposit方法就是临界区</strong>。可<strong>用synchronized关键字来同步</strong>，保证<strong>一次只有一个线程可以访问这个方法</strong>。当一个方法被synchronized修饰，这个方法就是<strong>原子的（一个线程开始执行这个方法，就不可中断）</strong></p><blockquote><p><strong>注意deposit里面每条语句都不是原子的（对应着一堆汇编指令），因此每条(汇编)语句执行时，是随时可能被中断，切换到另外一个线程</strong></p></blockquote><ul><li>task1和task2同时进入account对象的deposit方法</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421203255031.png" alt="image-20210421203255031"></p><blockquote><p>task1还没有对balance进行修改，没执行到blance=newBalance的汇编语句，task2就开始任务，此时task2读取的balance就是0</p></blockquote><hr><ul><li><p>线程同步用于协调<strong>多个线程访问公共资源</strong></p><p>公共资源被多个线程同时访问，可能会遭到破坏</p><p>（程序清单30-4：AccountWithoutSync.java）</p></li><li><p>临界区（critical region）可能被多个线程同时进入的程序的一部分区域</p><ul><li>所以需要对临界区同步，<strong>保证任何时候只能有1个线程进入临界区</strong></li></ul></li><li><p>可以用synchronized关键词来同步临界区</p><ul><li>临界区可以是方法，包括静态方法和实例方法，那么被<strong>synchronized关键字修饰的方法叫同步方法</strong></li><li>临界区也可以是语句块，也可以用synchronized关键字来同步语句块：如synchronized(this){…}</li></ul></li><li><p>除了用synchronized关键字，还可以<strong>利用加锁同步临界区</strong></p></li></ul><h3 id="线程同步-synchronized"><a href="#线程同步-synchronized" class="headerlink" title="线程同步-synchronized"></a>线程同步-synchronized</h3><ul><li><p>synchronized可用于<strong>同步方法</strong></p></li><li><p>使用关键字synchronized来修饰方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span></span><br></code></pre></div></td></tr></table></figure></li><li><p>一次<strong>只有一个线程</strong>可以进入这个同步方法</p></li><li><p>synchronized关键字是如何做到方法同步的？</p><p>通过<strong>加锁</strong>：一个线程要进入同步方法，首先拿到锁，进入方法后立刻上锁，导致<strong>其它要进入这个方法的线程被阻塞</strong>（等待锁）</p><ul><li>锁是一种实现资源排他使用的机制</li><li>对于<strong>synchronized</strong>实例方法，是对调用该方法的<strong>对象(this对象)加锁</strong></li><li>对于<strong>synchronized</strong>静态方法，是对拥有这个静态方法的<strong>类加锁</strong></li></ul></li><li><p>当进入方法的线程执行完方法后，锁被释放，会唤醒等待这把锁的其他进程。</p></li></ul><hr><p><strong>同步对象</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421204754330.png" alt="image-20210421204754330"></p><p><strong>同步语句块</strong></p><ul><li>被synchronized关键字同步的语句块称为同步块(synchronized Block)</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">synchronized</span> (expr) &#123;   statements;  &#125;  ，<br></code></pre></div></td></tr></table></figure><ul><li><p>表达式<strong>expr求值结果必须是一个对象的引用</strong>，因此可以通过对任何对象加锁来同步语句块</p><ul><li>如果expr指向的对象<strong>没有被加锁</strong>，则<strong>第一个执行到同步块的线程对该对象加锁</strong>，线程执行该语句块，然后解锁；</li><li>如果expr指向的对象<strong>已经加了锁</strong>，则执行到同步块的其它线程将<strong>被阻塞</strong></li><li>expr指向的对象解锁后，所有等待该对象锁的线程都被唤醒</li></ul></li><li><p>同步语句块允许同步方法中的<strong>部分代码</strong>，而不必是整个方法，增强了程序的并发能力</p></li><li><p>任何同步的<strong>实例方法</strong>都可以转换为同步语句块。</p></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421205701082.png" alt="image-20210421205701082"></p><hr><h4 id="前面的例子中的如下几种解决方案"><a href="#前面的例子中的如下几种解决方案" class="headerlink" title="前面的例子中的如下几种解决方案"></a>前面的例子中的如下几种解决方案</h4><ol><li>deposit方法改为同步的</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> balance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span></span>&#123;<br><span class="hljs-keyword">int</span> newBalance = balance + amount;<br><span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;<br><span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>balance = newBalance;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>sleep方法调用之后，并没有释放锁。使得线程仍然可以同步控制。sleep不会让出系统资源；</p><p>凡是在上了锁的临界区里，sleep方法不会释放锁</p></blockquote><ol start="2"><li>修改共享资源Account类，在deposit方法内部加同步块</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> balance;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span></span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br><span class="hljs-keyword">int</span> newBalance = balance + amount;<br><span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;<br><span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>balance = newBalance;<br>&#125;<br>&#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><ol start="3"><li>修改线程任务类AddPennyTask，在run方法里加同步块</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddPennyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(account)&#123;<br>account.deposit(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><blockquote><p>注意：是对account对象加锁。不能对this对象加锁，即**synchronized(this)**是错误的</p><p>因为this是AddPennyTask对象（此处，而前两处就是account对象），100个线程任务对象各不相同，因此synchronized(this)是对100个线程任务对象分别加锁，根本没起到同步的作用。100个线程任务对象同时访问的是共享资源account对象，需要加锁同步的是account对象。</p></blockquote><h3 id="线程同步-加锁同步"><a href="#线程同步-加锁同步" class="headerlink" title="线程同步-加锁同步"></a>线程同步-加锁同步</h3><ul><li><p>采用synchronized关键字的同步要<strong>隐式地</strong>在对<strong>象实例或类上加锁</strong>，粒度较大影响性能</p></li><li><p>JDK1.5可以显式地加锁，能够在更小地粒度上进行线程同步</p></li><li><p>一个锁是一个Lock接口的实例</p></li><li><p>类ReentrantLock是Lock的一个具体实现：可重入的锁</p></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421210848626.png" alt="image-20210421210848626"></p><ul><li>可重入性锁描述这样的一个问题：一个线程在<strong>持有一个锁的时候</strong>，它能否<strong>再次（多次）申请该锁</strong>。如果一个线程已经获得了锁，它还可以再次获取该锁而不会死锁，那么我们就称该锁为可重入锁。通过以下伪代码说明：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>&#123;    <br>lock.lock(); <span class="hljs-comment">// 获取锁    </span><br>methodB();    <br>lock.unlock() <span class="hljs-comment">// 释放锁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span></span>&#123;    <br>lock.lock(); <span class="hljs-comment">// 再次获取该锁   </span><br> <span class="hljs-comment">// 其他业务    </span><br>lock.unlock();<span class="hljs-comment">// 释放锁</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>Java关键字synchronized隐式支持重入性</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountWithSyncUsingLock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Account account = <span class="hljs-keyword">new</span> Account();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executor = Executors.newCachedThreadPool();<br>        <br>        <span class="hljs-comment">// Create and launch 100 threads</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;executor.execute(<span class="hljs-keyword">new</span> AddPennyTask());&#125;<br>        executor.shutdown();<br>        <br>        <span class="hljs-comment">// Wait until all tasks are finished</span><br>        <span class="hljs-keyword">while</span> (!executor.isTerminated()) &#123; &#125;<br>        System.out.println(<span class="hljs-string">&quot;What is balance ? &quot;</span> + account.getBalance());<br>    &#125;<br>    <br>    <span class="hljs-comment">// A thread for adding a penny to the account</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddAPennyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;account.deposit(<span class="hljs-number">1</span>); &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>加锁同步</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-comment">// An inner class for account，主要变化在账户类</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(); <br>        <span class="hljs-comment">// 注意这里是静态的，被所有Account实例共享</span><br>        <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;   <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> balance;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>            <br>            <br>            <span class="hljs-comment">//在这里加锁（临界区开始）</span><br>            <span class="hljs-comment">//第一个进入这个方法的线程获得锁，把deposite方法锁住。</span><br>            <span class="hljs-comment">//其他进入方法的线程必须等待这把锁，因为进入阻塞状态</span><br>            lock.lock( ); <span class="hljs-comment">// Acquire the lock</span><br>            <br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">int</span> newBalance = balance + amount;<br>                Thread.sleep(<span class="hljs-number">5</span>);<br>                balance = newBalance;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;   &#125;<br>            <br>            <span class="hljs-comment">//在finally块里释放锁，其它等待这把锁的线程被唤醒</span><br>            <span class="hljs-comment">//第一个获得锁的线程可以进入该方法了，进去后又对deposite上锁…</span><br>            <span class="hljs-keyword">finally</span> &#123; lock.unlock(); <span class="hljs-comment">// Release the lock，在finally中进行锁的释放。&#125;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><h4 id="线程同步-场景1"><a href="#线程同步-场景1" class="headerlink" title="线程同步-场景1"></a>线程同步-场景1</h4><ul><li>假设一个类有多个用<strong>synchronized修饰的</strong>同步实例方法，如果多个线程访问这个类的<strong>同一个对象</strong>，当一个线程获得了该对象锁进入到其中一个同步方法时，这把锁<strong>会锁住这个对象所有的同步实例方法</strong></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421211526607.png" alt="image-20210421211526607"></p><p>设置如下共享资源类，这个类的实例被多个线程访问</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resource</span></span>&#123; <br>    <br>    <span class="hljs-comment">//多个线程会对value读写，因此需要同步控制。</span><br>    <span class="hljs-comment">//value就是竞争性资源。Resource对象也因此成为竞争性资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;   <span class="hljs-comment">//多个线程会同时对这个数据成员读写</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span>  value;&#125;<br>    <br>    <span class="hljs-comment">//inc方法把value值增加，增加量为amount</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span>  </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入inc: &quot;</span>);<br>        <span class="hljs-keyword">int</span> newValue = value + amount;<br>        <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;  <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>        value = newValue;<br>        System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开inc.&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//dec方法把value减少，减少量为amount</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span>  </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入dec: &quot;</span>);<br>        <span class="hljs-keyword">int</span> newValue = value - amount;<br>        <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">2</span>); &#125; <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>        value = newValue;<br>        System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开dec.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>inc,dec两个方法都是synchronized的，两个同步的实例方法</p></blockquote><p><strong>设置如下的两个循环创建线程任务的类</strong></p><ul><li><p>IncTask是线程任务，会循环调用资源对象r.inc方法，loops是循环次数。</p><p>IncTask的构造函数会传入要访问的对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Resource r = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//要访问的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次增加量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IncTask</span><span class="hljs-params">(Resource r,<span class="hljs-keyword">int</span> amount,<span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r; <span class="hljs-keyword">this</span>.amount = amount; <span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123; r.inc(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>DecTask是线程任务，会循环调用资源对象r.dec方法，loops是循环次数。</p><p>DecTask的构造函数会传入要访问的对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Resource r = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//要访问的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次减少量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecTask</span><span class="hljs-params">(Resource r, <span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r;<span class="hljs-keyword">this</span>.amount = amount;<span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;  r.dec(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//每次增加量为10，每次减少量为5，循环次数100</span><br>    <span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> decAmount = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> loops = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-comment">//创建资源对象r</span><br>        Resource r = <span class="hljs-keyword">new</span> Resource();<br>    <br>    <span class="hljs-comment">//构造线程任务incTask，注意传入的第一个参数为对象r，</span><br><span class="hljs-comment">//构造线程任务decTask，注意传入的第一个参数也为对象r，</span><br><span class="hljs-comment">//意味着这二个线程任务一旦执行，对应的二个线程调用的是同一个对象的方法，</span><br>    <span class="hljs-comment">//一个线程(t1)调用r.inc, 另外一个线程(t2)调用r.dec</span><br>        Runnable incTask = <span class="hljs-keyword">new</span> IncTask( r, incAmount, loops );<br>        Runnable decTask = <span class="hljs-keyword">new</span> DecTask( r, decAmount, loops );<br><br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask); es.execute(decTask);<br>        es.shutdown();<br>        <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br><br>    <span class="hljs-comment">//计算出正确的value值</span><br><span class="hljs-comment">//显示实际的计算值和正确的值，验证同步是否正确</span><br>        <span class="hljs-keyword">int</span> correctValue = (incAmount - decAmount)  * loops;<br>        System.out.println(<span class="hljs-string">&quot;\nThe value: &quot;</span> +  r.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + correctValue);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下</p><blockquote><p><strong>Thread 13</strong> <strong>进入inc: –&gt;Thread 13</strong> <strong>离开inc.</strong></p><p><strong>…</strong></p><p><strong>Thread 13进入inc: –&gt;Thread 13</strong> 离开inc.</p><p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p><p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p><p>**Thread 14进入inc: –&gt;Thread 14 **离开inc.</p><p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p><p>**Thread 14 进入inc: –&gt;Thread 14 **离开inc.</p><p>**Thread 13进入inc: –&gt;Thread 13 <strong>离开inc.</strong></p><p><strong>…</strong></p><p><strong>The value: 500, correct value: 500</strong></p></blockquote><blockquote><p>可以看到线程13进入inc，对象被加锁，线程14必须等待线程13退出inc后，才能进入dec。所以输出结果里线程13和14的控制台输出没有乱。</p><p>最下面的输出的value值也是正确的</p></blockquote><blockquote><p><strong>这个例子说明，二个线程访问同一个对象时， 只要一个线程拿到对象锁，这个对象的所有同步实例方法都被锁</strong></p><p>即incTask对应线程进入inc是，decTask的线程不能进入dec</p></blockquote><h4 id="线程同步-场景2"><a href="#线程同步-场景2" class="headerlink" title="线程同步-场景2"></a>线程同步-场景2</h4><ul><li>假设一个类有多个用<strong>synchronized修饰的</strong>同步实例方法，如果多个线程访问这个类的<strong>不同对象</strong>，那么<strong>不同对象的synchronized锁不一样</strong>，<strong>每个对象的锁只能对访问该对象的线程同步</strong></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421212622864.png" alt="image-20210421212622864"></p><p><strong>如下示例创建两个对象</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>,decAmount = <span class="hljs-number">5</span>, loops = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">//注意，和场景1不同，现在创建二个资源对象r1和r2</span><br>        Resource r1 = <span class="hljs-keyword">new</span> Resource();<br>        Resource r2 = <span class="hljs-keyword">new</span> Resource();<br>    <br>    <br>    <span class="hljs-comment">//incTask1和decTask1访问对象r1; 它们的运行线程被r1的对象锁同步；</span><br><span class="hljs-comment">//incTask2和decTask2访问对象r2;它们的运行线程被r2的对象锁同步；</span><br><span class="hljs-comment">//但是这二对线程之间没有同步约束，例如incTask1和incTask2的运行线程不会被同步</span><br>        Runnable incTask1 = <span class="hljs-keyword">new</span> IncTask(r1,incAmount,loops);      Runnable decTask1 = <span class="hljs-keyword">new</span> DecTask(r1,decAmount,loops);<br>        Runnable incTask2 = <span class="hljs-keyword">new</span> IncTask(r2,incAmount,loops);     Runnable decTask2 = <span class="hljs-keyword">new</span> DecTask(r2,decAmount,loops);<br><br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask1);es.execute(decTask1);<br>        es.execute(incTask2);es.execute(decTask2);<br>        es.shutdown();<br>        <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br>        <span class="hljs-keyword">int</span> r1CorrectValue = (incAmount - decAmount)  * loops ;<span class="hljs-keyword">int</span> r2CorrectValue = (incAmount - decAmount)  * loops;<br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r1: &quot;</span> + r1.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r1CorrectValue);<br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r2: &quot;</span> + r2.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r2CorrectValue);<br> &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>4个线程访问两个不同的对象，不同的对象锁不一样，incTask1进入对象r1的inc，和incTask2是否可以进入对象r2的inc无关</p></blockquote><p>结果如下</p><blockquote><p><strong>Thread 13 进入inc:</strong> </p><p><strong>Thread 15 进入inc</strong>: –&gt;Thread 13 离开inc.</p><p><strong>Thread 13  进入inc</strong>: –&gt;Thread 15 离开inc.</p><p><strong>Thread 15 进入inc</strong>: –&gt;Thread 13 离开inc.</p><p><strong>Thread 13  进入inc</strong>: –&gt;Thread 15 离开inc.</p><p><strong>Thread 15进入inc</strong>: –&gt;<strong>Thread 15 离开inc.</strong>–&gt;<strong>Thread 13 离开inc.</strong></p><p><strong>Thread 14 进入dec:</strong> </p><p><strong>Thread 16进入dec</strong>: –&gt;<strong>Thread 14离开dec.</strong></p><p><strong>Thread 14 进入dec:</strong> –&gt;<strong>Thread 16 离开dec.</strong></p><p><strong>Thread 16进入dec</strong>: –&gt;<strong>Thread 14离开dec.</strong></p><p><strong>Thread 14 进入dec:</strong> –&gt;<strong>Thread 16 离开dec.</strong></p><p><strong>Thread 16进入dec</strong>: –&gt;<strong>Thread 16离开dec.</strong>–&gt;<strong>Thread 14离开dec.</strong></p><p><strong>The value of r1: 15, correct value: 15</strong></p><p><strong>The value of r2: 15, correct value: 15</strong></p></blockquote><blockquote><p>计算结果正确。</p><p>13和15分别访问二个对象的inc，没有同步约束，因此它们的System.out.println输出是乱的；14和16也是如此。但</p><p>是13和14是同步的，15和16也是同步的。如果只看13和14的输出，就没有乱。</p></blockquote><h4 id="线程同步-场景3"><a href="#线程同步-场景3" class="headerlink" title="线程同步-场景3"></a>线程同步-场景3</h4><ul><li>n如果采用Lock锁进行同步，一旦Lock锁被一个线程获得，那么被这把锁控制的所有临界区都被上锁，这时所有其他访问这些临界区的线程都被阻塞。</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421213850843.png" alt="image-20210421213850843"></p><p><strong>ResourceWithLock采用Lock对临界区上锁，而不是用synchronized关键字</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceWithLock</span> </span>&#123; <span class="hljs-comment">//重新定义资源类，采用Lock锁</span><br>    <span class="hljs-keyword">private</span>  Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();  <span class="hljs-comment">//创建Lock锁对象，注意是实例变量 </span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;   <span class="hljs-comment">//多个线程会同时对这个数据成员读写</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span>  value; &#125;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span>   </span>&#123;<br>        <span class="hljs-comment">//inc方法在这加Lock锁（临界区开始）</span><br>        lock.lock( ); <span class="hljs-comment">// Acquire the lock</span><br>        <br>        <span class="hljs-keyword">try</span>&#123; System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入inc: &quot;</span>);<br>            <span class="hljs-keyword">int</span> newValue = value + amount;  <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">5</span>); &#125;  <span class="hljs-keyword">catch</span>(InterruptedException e)&#123; &#125;<br>            value = newValue; System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开inc.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span>&#123; lock.unlock(); &#125;<span class="hljs-comment">//inc退出方法前解Lock锁，退出临界区</span><br><br>    &#125;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">//dec方法用同一把Lock锁。</span><br>        lock.lock( ); <span class="hljs-comment">// Acquire the lock</span><br>        <br>        <span class="hljs-keyword">try</span>&#123; System.out.print(<span class="hljs-string">&quot;\nThread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 进入dec: &quot;</span>);<br>            <span class="hljs-keyword">int</span> newValue = value - amount; <span class="hljs-keyword">try</span>&#123; Thread.sleep(<span class="hljs-number">2</span>); &#125;  <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>            value = newValue; System.out.print(<span class="hljs-string">&quot;--&gt;Thread &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot; 离开dec.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123; lock.unlock(); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>Inc，dec方法用同一把Lock锁。因此如果调用lock.lock(); 加锁，这个锁同时锁住inc和dec方法。</strong></p></blockquote><p>与场景一相同的两个类,但是<strong>访问类型不同</strong>了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncTaskWithLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> ResourceWithLock r = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IncTaskWithLock</span><span class="hljs-params">(ResourceWithLock r,<span class="hljs-keyword">int</span> amount,<span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r; <span class="hljs-keyword">this</span>.amount = amount; <span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123; r.inc(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>IncTask是线程任务，会循环调用资源对象r.inc方法，loops是循环次数。</p><p>线程任务现在要访问的资源类型是<strong>ResourceWithLock</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecTaskWithLock</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> ResourceWithLock r = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> amount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loops = <span class="hljs-number">0</span>;  <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecTaskWithLock</span><span class="hljs-params">(ResourceWithLock r, <span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span> loops)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.r = r; <span class="hljs-keyword">this</span>.amount = amount; <span class="hljs-keyword">this</span>.loops = loops;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123; r.dec(amount); &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>DecTask是线程任务，会循环调用资源对象r.dec方法，loops是循环次数。</p><p>线程任务现在要访问的资源类型是<strong>ResourceWithLock</strong></p></blockquote><p>如下运行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> decAmount = <span class="hljs-number">5</span>; <span class="hljs-keyword">int</span> loops = <span class="hljs-number">50</span>;<br><span class="hljs-comment">//创建资源对象r，注意资源类型是ResourceWithLock</span><br>        ResourceWithLock r = <span class="hljs-keyword">new</span> ResourceWithLock();<br>    <br>    <span class="hljs-comment">//构造线程任务incTask，decTask</span><br>    <span class="hljs-comment">//注意:二个任务的线程访问的是同一个ResourceWithLock对象，用的是同一把Lock锁。</span><br>    <span class="hljs-comment">//这时只要一个线程拿到锁，所有被这个锁控制的临界区都被锁住。</span><br>   <span class="hljs-comment">//即incTask的线程进入inc时，decTask的线程不能进入dec</span><br>        Runnable incTask = <span class="hljs-keyword">new</span> IncTaskWithLock( r ,incAmount,loops);<br>        Runnable decTask = <span class="hljs-keyword">new</span> DecTaskWithLock( r ,decAmount,loops);<br><br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask); es.execute(decTask);<br>        es.shutdown(); <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br><br>        <span class="hljs-keyword">int</span> correctValue = (incAmount - decAmount)  * loops;<br>        System.out.println(<span class="hljs-string">&quot;\nThe value: &quot;</span> + r.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + correctValue);<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>结果如下</p><blockquote><p><strong>Thread 13 进入inc: –&gt;Thread 13 离开inc.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>…</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 13 进入inc: –&gt;Thread 13 离开inc.</strong></p><p><strong>Thread 13 进入inc: –&gt;Thread 13 离开inc.</strong></p><p><strong>…</strong></p><p><strong>The value: 250, correct value: 250</strong></p></blockquote><blockquote><p>可以看到线程13进入inc，临界区inc和dec都被加锁，线程14必须等待线程13退出inc后，才能进入dec。所以输出结果里线程13和14的控制台输出没有乱.</p><p>最下面的输出的value值也是正确的</p></blockquote><h4 id="线程同步-场景4"><a href="#线程同步-场景4" class="headerlink" title="线程同步-场景4"></a>线程同步-场景4</h4><ul><li>如果一个类采用Lock锁对临界区上锁，而且这个Lock锁也是该类的实例成员（见ResourceWithLock的里的lock对象定义），那么<strong>这个类的二个实例的Lock锁就是不同的锁</strong>，下面的动画演示了这种场景：对象o1的Lock锁和对象o2的Lock锁是不同的锁对象。</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421214552381.png" alt="image-20210421214552381"></p><blockquote><p><strong>注意，和场景3不同，现在创建二个资源对象r1和r2.注意资源类型是ResourceWithLock</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> incAmount = <span class="hljs-number">10</span>, decAmount = <span class="hljs-number">5</span>,loops = <span class="hljs-number">20</span>; <br>    <br>    <span class="hljs-comment">//两个ResourceWithLock对象</span><br>    ResourceWithLock r1 = <span class="hljs-keyword">new</span> ResourceWithLock();  <br>    ResourceWithLock r2 = <span class="hljs-keyword">new</span> ResourceWithLock();<br><br>    <span class="hljs-comment">/*四个线程访问二个不同对象</span><br><span class="hljs-comment">     *incTask1，decTask1的执行线程访问同一个对象r1，它们之间同步</span><br><span class="hljs-comment">     * incTask2，decTask2的执行线程访问同一个对象r2，它们之间同步</span><br><span class="hljs-comment">     * incTask1执行线程进入对象r1的inc，和incTask2执行线程是否可以进入对象r2的inc无关，因为锁不一样</span><br><span class="hljs-comment">*/</span><br>        <span class="hljs-comment">//incTask1，decTask1访问同一个对象r1，它们之间同步</span><br>        Runnable incTask1 = <span class="hljs-keyword">new</span> IncTaskWithLock(r1,incAmount,loops);<br>        Runnable decTask1 = <span class="hljs-keyword">new</span> DecTaskWithLock(r1,decAmount,loops);<br>        <span class="hljs-comment">//incTask2，decTask2访问同一个对象r2，它们之间同步</span><br>        Runnable incTask2 = <span class="hljs-keyword">new</span> IncTaskWithLock(r2,incAmount,loops);<br>        Runnable decTask2 = <span class="hljs-keyword">new</span> DecTaskWithLock(r2,decAmount,loops);<br><br>    <br>    <br>        ExecutorService es = Executors.newCachedThreadPool();<br>        es.execute(incTask1); es.execute(decTask1); es.execute(incTask2); es.execute(decTask2);<br>        es.shutdown();<br>        <span class="hljs-keyword">while</span>(!es.isTerminated())&#123;  &#125;<br>        <span class="hljs-keyword">int</span> r1CorrectValue = (incAmount - decAmount)  * loops ; <span class="hljs-keyword">int</span> r2CorrectValue = (incAmount - decAmount)  * loops;          <br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r1: &quot;</span> + r1.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r1CorrectValue);<br>        System.out.println(<span class="hljs-string">&quot;\nThe value of r2: &quot;</span> + r2.getValue() + <span class="hljs-string">&quot;, correct value: &quot;</span> + r2CorrectValue);<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><p>输出结果</p><blockquote><p><strong>Thread 13 进入inc:</strong></p><p><strong>Thread 15 进入inc: –&gt;Thread 15 离开inc.</strong></p><p><strong>Thread 16 进入dec: –&gt;Thread 13 离开inc.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 16 离开dec.</strong></p><p><strong>Thread 16 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 16 离开dec.</strong></p><p><strong>Thread 16 进入dec: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 14 进入dec: –&gt;Thread 16 离开dec.</strong></p><p><strong>Thread 15 进入inc: –&gt;Thread 14 离开dec.</strong></p><p><strong>Thread 13 进入inc: –&gt;Thread 15 离开inc.</strong></p><p><strong>Thread 15 进入inc: –&gt;Thread 13 离开inc.</strong></p><p><strong>Thread 13 进入inc: –&gt;Thread 15 离开inc.–&gt;Thread 13 离开inc.</strong></p><p><strong>The value of r1: 15, correct value: 15</strong></p><p><strong>The value of r2: 15, correct value: 15</strong></p></blockquote><blockquote><p>计算结果正确。</p><p>13和15分别访问二个对象的inc，没有同步约束，因此它们的输出是乱的；14和16也是如此。但是13和14是同步的，15和16也是同步的。如果只看13和14的输出，就没有乱。</p></blockquote><h3 id="线程同步-总结和思考"><a href="#线程同步-总结和思考" class="headerlink" title="线程同步-总结和思考"></a>线程同步-总结和思考</h3><ul><li><p>如果采用synchronized关键字对类 A的实例方法进行同步控制，这时等价于synchronized(this){ }</p><ul><li>一旦一个线程进入类A的对象o的synchronized实例方法，<strong>对象o被加锁，对象o所有的synchronized实例方法都被锁住</strong>，从而阻塞了要访问对象o的synchronized实例方法的线程，<strong>但是与访问A类其它对象的线程无关</strong></li></ul></li><li><p>如果采用synchronized关键字对类 A的静态方法进行同步控制，这时等价于synchronized(A.class){ }。一旦一个线程进入A的一个静态同步方法，A所有的静态同步方法都被锁（这个锁是类级别的锁），<strong>这个锁对所有访问该类静态同步方法的线程有效，不管这些线程是通过类名访问静态同步方法还是通过不同的对象访问静态同步方法。</strong></p></li><li><p>如果通过Lock对象进行同步，首先看Lock对象对哪些临界区上锁，一旦Lock锁被一个线程获得，那么被这把锁控制的所有临界区都被上锁（如场景3）；另外要区分Lock对象本身是否是不同的：不同的Lock对象能阻塞的线程是不一样的（如场景4）。</p></li></ul><h3 id="线程同步-线程协作"><a href="#线程同步-线程协作" class="headerlink" title="线程同步-线程协作"></a>线程同步-线程协作</h3><ul><li><p>线程之间有资源竞争，<strong>synchronized和Lock锁这些同步机制解决的是资源竞争问题</strong></p></li><li><p>线程之间还有相互协作的问题</p></li><li><p>假设创建并启动两个任务线程：</p><ul><li><p>存款线程用来向账户中存款</p></li><li><p>提款线程从同一账户中提款</p></li><li><p>当提款的数额大于账户的当前余额时，提款线程必须等待存款线程往账户里存钱</p></li><li><p>如果存款线程存入一笔资金，必须通知提款线程重新尝试提款，如果余额仍未达到提款的数额，提款线程必须继续等待新的存款 </p></li></ul></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210421215036540.png" alt="image-20210421215036540"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——泛型</title>
    <link href="/2021/04/12/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/"/>
    <url>/2021/04/12/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li><p>泛型（Generic）指可以把类型参数化，这个能力使得我们可以定义带类型参数的泛型类、泛型接口、泛型方法，随后编译器会用唯一的具体类型替换它；</p></li><li><p>主要优点是在<strong>编译时</strong>（类型不匹配的错误）而不是运行时<strong>检测出错误</strong>(如果运行时才检查出错误，可能造成严重后果)。泛型类或方法允许用户指定可以和这些类或方法一起工作的对象类型。<strong>如果试图使用一个不相容的对象，编译器就会检测出这个错误。</strong></p></li><li><p>Java的泛型通过擦除法实现，和C++模板生成<strong>多个实例类</strong>不同。<strong>编译时会用<em>类型实参</em>代替<em>类型形参</em>进行严格的语法检查</strong>，（通过编译后）然后擦除类型参数、生成所有实例类型共享的唯一原始类型。这样使得泛型代码能兼容老的使用原始类型的遗留代码。</p></li></ul><span id="more"></span><blockquote><p>若不存在泛型，只能重载</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-keyword">double</span>,<span class="hljs-keyword">double</span>)</span></span><br></code></pre></div></td></tr></table></figure><p>六个基本类型求和要写六个，但是</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">Sum</span><span class="hljs-params">(T o1,T o2)</span></span>;<br></code></pre></div></td></tr></table></figure><p>&lt;T&gt;必须为引用类型，六个基本值类型的包装类</p><p>调用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Sum(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>),<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">2</span>))<br></code></pre></div></td></tr></table></figure></blockquote><hr><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><ul><li><p>泛型类（Generic Class）是带形式化类型参数的类。<strong>形式化类型参数</strong>是一个<strong>逗号分隔的变量名列表</strong>，位于类声明中类名后面的尖括号&lt;&gt;中。下面的代码声明一个泛型类Wrapper，它接受一个形式化类型参数T：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>T是一个类型变量，它可以是Java中的<strong>任何引用类型</strong>，例如String，Integer，Double等。当把一个具体的类型实参传递给类型形参T时，就得到了一系列的<strong>参数化类型</strong>(Parameterized Types)，如Wrapper<String>，Wrapper<Integer> ，这些参数化类型是泛型类Wrapper<T>的<strong>实例类型</strong>（类似于Circle类型有实例对象c1,c2）</T></Integer></String></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Wrapper&lt;String&gt;  stringWrapper = <span class="hljs-keyword">new</span> Wrapper&lt;String&gt;();<br>Wrapper&lt;Circle&gt;  circleWrapper = <span class="hljs-keyword">new</span> Wrapper&lt;Circle&gt;();<br><br></code></pre></div></td></tr></table></figure><blockquote><p>参数化类型(Parameterized Types)是在JLS里面使用的术语，为了方便描述，本章后面称为实例类型</p></blockquote></li></ul><h3 id="RTTI（-Run-Time-Type-Identification）：运行时类型识别"><a href="#RTTI（-Run-Time-Type-Identification）：运行时类型识别" class="headerlink" title="RTTI（ Run-Time Type Identification）：运行时类型识别"></a><strong>RTTI（ Run-Time Type Identification）：运行时类型识别</strong></h3><ul><li>通过<strong>运行时类型</strong>信息，程序在<strong>运行时</strong>能够检查<strong>父类引用所指的对象</strong>的实际派生类型。</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210412170913361.png" alt="image-20210412170913361"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Shape s =<span class="hljs-keyword">null</span>;<br>s = <span class="hljs-keyword">new</span> Circe();<br>s.draw();  <span class="hljs-comment">//draw a circle</span><br><br>If(s <span class="hljs-keyword">instanceof</span> Circle)&#123;<br>    System.out.println(“s is a Circle”)<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>以上代码输出结果s is a Circle，表示s对象是Circle类的实例</p><p>上面的例子都是RTTI在起作用，<strong>程序在运行时，JVM知道一块内存到底是什么类型的对象</strong></p></blockquote><ul><li>要理解RTTI在Java中的工作原理，就必须知道类型信息在<strong>运行时是如何表示</strong>的。</li><li>类型信息是通过<strong>Class类（类名为Class的类，不是class，是一个类）的<em>对象</em></strong>表示的，Java利用Class对象来执行RTTI。</li><li>每个类都有一个对应的Class对象，每当编写并编译了一个类，就会<strong>产生一个Class对象</strong>，这个对象当JVM加载这个类时就产生了。</li></ul><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ol><li>  <strong>Class.forName方法</strong>，是Class类的静态方法</li></ol><p>   ch13下有如下三个类</p>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><blockquote><p>如下代码中，Class clz = Class.forName(“ch13.Manager”);产生ch13.Manager类的Class对象，赋值给Class类型的引用变量clz</p></blockquote>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class clz = Class.forName(“ch13.Manager”); <span class="hljs-comment">//参数是类完全限定名字符串</span><br>            System.out.println(clz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Manager</span><br>            System.out.println(clz.getSimpleName()); <span class="hljs-comment">//产生简单名Manager</span><br><br>            Class superClz = clz.getSuperclass(); <span class="hljs-comment">//获得直接父类型信息</span><br>            System.out.println(superClz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Employee</span><br>            System.out.println(superClz.getSimpleName()); <span class="hljs-comment">//产生简单名Employee</span><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意编译器是无法检查字符串”ch13.Manager”是否为一个正确的类的完全限定名，因此在运行时可能抛出异常，比如当不小心把类名写错了时。</p></blockquote><ol start="2"><li> 利用类字面常量：<strong>类名.class</strong>，得到类对应的Class对象</li></ol><p>   <strong>某个类名.class是Class类型的字面量</strong></p><p>   <strong>正如int类型的字面量有1，2，3，</strong></p><p>   <strong>Class类型的字面量有Person.class, Employee.class, Manager.class，它们都是Class类型的实例</strong></p>   <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Class clz = Manager.class;  <span class="hljs-comment">// Manager.class得到Manager的Class对象.赋给引用clz</span><br>        System.out.println(clz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Manager</span><br>        System.out.println(clz.getSimpleName()); <span class="hljs-comment">//产生简单名Manager   </span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>类字面常量不仅可以用于类，也可用于数组(int[].class)，接口，<strong>基本类型</strong>，如int.class</li><li>相比Class.forName方法，这种方法更安全，<strong>在编译时就会被检查，因此不需要放在Try/Catch块里（见上面的标注里说明）</strong></li><li>Class.forName会引起类的静态初始化块的执行，T.class不会引起类的静态初始化块的执行</li></ul><ol start="3"><li> <strong>通过对象。</strong>如果获得一个对象的引用o，通过<strong>o.getClass()方法</strong>获得这个对象的类型的Class对象</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Object o = <span class="hljs-keyword">new</span> Manager();<br>        Class clz = o.getClass();<br>        System.out.println(clz.getName()); <span class="hljs-comment">//产生完全限定名ch13.Manager</span><br>        System.out.println(clz.getSimpleName()); <span class="hljs-comment">//产生简单名Manager</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>getClass返回的是运行时类型</p></blockquote><h3 id="泛型化的Class引用"><a href="#泛型化的Class引用" class="headerlink" title="泛型化的Class引用"></a>泛型化的Class引用</h3><blockquote><p>非泛化的Class引用（即不带类型参数的Class引用）可指向任何类型的Class对象，但这样不安全</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class clz ;     <span class="hljs-comment">//注意警告， Class is a raw type. References to generic type Class&lt;T&gt; should be parameterized</span><br>clz= Manager.class; <span class="hljs-comment">//OK</span><br>clz = <span class="hljs-keyword">int</span>.class; <span class="hljs-comment">//OK</span><br></code></pre></div></td></tr></table></figure><blockquote><p>有时我们需要限定Class引用能指向的类型：加上&lt;类型参数&gt;。这样可以可以强制编译器进行额外的类型检查，对于类型参数，编译器检测时不看继承关系</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class&lt;Person&gt; genericClz;    <span class="hljs-comment">//泛化Class引用，Class&lt;Person&gt;只能指向Person的类型信息， &lt;Person&gt;为类型参数</span><br>genericClz = Person.class;  <span class="hljs-comment">//OK</span><br><span class="hljs-comment">//genericClz = Manager.class; //Error，不能指向非Person类型信息。注意对于类型参数，编译器检测时不看继承关系。</span><br></code></pre></div></td></tr></table></figure><blockquote><p>能否声明一个可用指向Person及其子类的Class对象的引用？为了放松泛化的限制，用通配符?表示任何类型，并且与extends结合，创建一个范围</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class&lt;? extends Person&gt; clz2;  <span class="hljs-comment">//引用clz2可以指向Person及其子类的类型信息</span><br>clz2 = Person.class;<br>clz2 = Employee.class;<br>clz2 = Manager.class;<br><span class="hljs-comment">//注意Class&lt;?&gt; 与Class效果一样，但本质不同，一个用了泛型，一个没有用泛型。 Class&lt;?&gt; 等价于Class&lt;? extends Object &gt; </span><br></code></pre></div></td></tr></table></figure><h2 id="反射（Reflection）：应用案例：实例化对象"><a href="#反射（Reflection）：应用案例：实例化对象" class="headerlink" title="反射（Reflection）：应用案例：实例化对象"></a>反射（Reflection）：应用案例：实例化对象</h2><ul><li><p>要完成的功能：输入一个完全限定名字符串（如”java.lang.String”）,创建相应的对象：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o = <span class="hljs-keyword">new</span> String(“Hello”); <span class="hljs-comment">//注意String是类名标识符，不是字符串</span><br></code></pre></div></td></tr></table></figure><ol><li><p>方案1</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span>( input.equals(“java.lang.String”) )&#123;<br>     o = <span class="hljs-keyword">new</span> String(“”);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ( input.equals(“ch13.Student”) )&#123;<br>    o = <span class="hljs-keyword">new</span> Student();<br>&#125;<br>…更多的<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>语句<br><br></code></pre></div></td></tr></table></figure><blockquote><p>这种方法显然不行，因为事先不知道会输入一个什么类的完全限定名字符串，if语句不可能列出所有可能的类型</p></blockquote></li><li><p>方案2 实例化对象（java.lang.reflect包）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&quot;unknown&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Name:&quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>clz指向一个类的Class对象时，通过 clz可以得到这个类的所有构造函数对象，一个构造函数对象类型是：</p><p>   java.lang.reflect.Constructor</p><p>一个Constructor对象代表了类的一个构造函数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class  clz = Class.forName(<span class="hljs-string">&quot;ch13.Student&quot;</span>);<br>            <br>            <span class="hljs-comment">//获取所有的Constructor对象</span><br>            Constructor[] ctors = clz.getConstructors();<br>             <span class="hljs-comment">//ctors是clz构造函数对象的数组</span><br>            <span class="hljs-keyword">for</span>(Constructor c : ctors)&#123;<br>                System.out.println(c.toString());<br>        &#125;<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>输出，打印ch13.student的全部构造函数</p><p>public ch13.Student()<br>public ch13.Student(java.lang.String)<br>上述对象得到了这个Class中所有的构造方法，对应的构造方法通过数组返回<br>如果我们要知道一个类中，有那些构造方法，就可以这样去做<br>如下获得一个类中所有的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;<br>          Class clz = Class.forName(<span class="hljs-string">&quot;ch13.Student&quot;</span>);<br>            <span class="hljs-comment">//获取所有的Method</span><br>            <span class="hljs-comment">//Method[] methods = clz.getMethods(); //会显示所有方法，包括继承的</span><br>            Method[] methods = clz.getDeclaredMethods(); <span class="hljs-comment">//本类定义的方法</span><br>            <span class="hljs-keyword">for</span>(Method m: methods)&#123;<br>                System.out.println(m.toString());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>               e.printStackTrace();<br>        &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>输出，打印ch13.Student类的全部方法</p><p><strong>public</strong> <strong>java.lang.String</strong> <strong>ch13.Student.toString()</strong></p><p><strong>public</strong> <strong>java.lang.String</strong> <strong>ch13.Student.getName()</strong></p><p><strong>public void ch13.Student.setName(java.lang.String)</strong></p></blockquote><blockquote><p>得到了构造与方法，也是为了得到实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">  Class clz = Class.forName(<span class="hljs-string">&quot;ch13.Student&quot;</span>);<br>    <span class="hljs-comment">//实例化对象</span><br>    <span class="hljs-comment">//1：如有缺省构造函数，调用Class对象的newInstance方法</span><br>    Student s1 = (Student)clz.newInstance();<br>    <span class="hljs-comment">//2. 调用带参数的构造函数，Instance返回object</span><br>    Student s2 = (Student)clz.getConstructor(String.class).newInstance(<span class="hljs-string">&quot;John&quot;</span>);<br>    <span class="hljs-comment">//invoke method</span><br>    Method m = clz.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>    m.invoke(s1, <span class="hljs-string">&quot;Marry&quot;</span>); <span class="hljs-comment">//调用s1对象的setName方法，实参&quot;Marry&quot;</span><br>    System.out.println(s1.toString());<br>    System.out.println(s2.toString());        <br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>     e.printStackTrace();<br>     <br></code></pre></div></td></tr></table></figure><blockquote><p>Student s2 = (Student)clz.getConstructor(String.class).newInstance(“John”);</p><p>首先得到参数类型为String的构造函数对象，然后调用它的newInstance方法调用构造函数，参数为“John”。等价于：</p><p>Student s2 = new Student(“John”)；</p><p>但是是通过反射机制调用的</p></blockquote><blockquote><p>Method m = clz.getMethod(“setName”, String.class);</p><p>m.invoke(s1, “Marry”); //调用s1对象的setName方法，实参”Marry”</p><p>clz.getMethod(“setName”, String.class);得到方法名为setName,参数为String的方法对象m，类型是Method。</p><p>然后通过m.invoke去调用该方法，第一个参数为对象，第二个参数是传递给被调方法的实参。这二条语句等价于s1.setName(“Marry)，但是是通过反射去调的</p></blockquote></li></ol></li></ul><h2 id="泛型的动机和优点"><a href="#泛型的动机和优点" class="headerlink" title="泛型的动机和优点"></a>泛型的动机和优点</h2><ul><li><p>lJDK1.5开始，Java允许定义<strong>泛型类、泛型接口和泛型方法</strong>，API中的一些接口和类使用泛型进行了修改。如java.lang.comparable</p><blockquote><p>T表示类型形参，之后会用实际的类型实参来替换，称为“泛型实例化”（得到实例类型）。按照惯例，E或T这样的单个大写字母表示泛型类型的参数类型</p></blockquote><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414090606567.png" alt="image-20210414090606567"></p><blockquote><p>1.5之前，Data和String都引用了Comparable接口，因此c.compareTo(String)<strong>编译通过</strong>，但是由于类型不同，<strong>运行时就会出错</strong></p><p>1.5之后，编译时就会产生错误，因为c的Comparable为Data，String为String，<strong>编译就不通过</strong></p></blockquote></li></ul><blockquote><p>非泛型类Comparable接口的CompareTo方法的参数声明类型为Object，而传进去的实参”red”确实是Object类型，因此编译器通过。但实际运行时一个Data对象和字符串对象比较大小肯定出错。<strong>因此在非泛型年代，保证传进去的对象与另一个比较大小的对象实际类型的一致性是程序员的责任</strong></p></blockquote><blockquote><p>现在泛型接口Comparable&lt;T&gt;里的comparaTo方法的参数类型必须是T，这就规定了要比较的另外一个对象类型必须是T，即和this对象的类型必须一致，否则编译器就可以检查出类型不一致</p><p>Comparable&lt;Data&gt;是Comparable&lt;T&gt;的类型实例，因为Comparable&lt;T&gt;是泛型接口，而Comparable&lt;Date&gt;是具体接口类型</p></blockquote><ul><li><p>以ArrayList为例说明看看定义的不同，注意使用了泛型参数E的地方</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414091700351.png" alt="image-20210414091700351"></p><p><strong>下面举出一个非泛型ArrayList</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList list = <span class="hljs-keyword">new</span> ArrayList();   <span class="hljs-comment">//非泛型的ArrayList</span><br></code></pre></div></td></tr></table></figure><blockquote><p>存入String，取出String</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">   <span class="hljs-comment">//非泛型的ArrayList的add方法，参数类型是Object </span><br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);                  <br><span class="hljs-comment">//非泛型的ArrayList的get方法，返回类型也是Object，因此要强制类型转换</span><br>      String s = (String) list.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">//运行起来不报错  </span><br></code></pre></div></td></tr></table></figure><blockquote><p>存入Data，取Data，编译时不报错，但运行时抛出异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">  <span class="hljs-comment">//但是万一程序员不小心加入了Date对象</span><br>  list.add(<span class="hljs-keyword">new</span> Date()); <span class="hljs-comment">//Date对象也是Object类型，因此编译器不报错</span><br>  String s2 = (String)list.get(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译不报错，因为在编译时uncheck</span><br><span class="hljs-comment">//但是在运行时就抛出异常</span><br></code></pre></div></td></tr></table></figure><blockquote><p>因此，对非泛型ArrayList，保证放进去对象的类型一致性变成了程序员的责任</p></blockquote></li></ul><h3 id="泛型的ArrayList"><a href="#泛型的ArrayList" class="headerlink" title="泛型的ArrayList"></a>泛型的ArrayList</h3><blockquote><p>尖括号里E为类型形参，以和方法参数区分开(圆括号)规定了放入ArrayList里必须是某种类型E的对象。类型形参在类体里可以用在任何其它类型可以用的地方，如成员变量类型，方法形参类型，方法返回类型。</p><p>注意抽象父类和实现的接口List也带了类型参数E。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, </span><br><span class="hljs-class">    <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span>&#123;<br>        ...<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>内部结构就是一个Object数组</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">transient</span> Object[] elementData; <br></code></pre></div></td></tr></table></figure><blockquote><p>将下标为index的元素（注意类型是Object）强制转换为E类型返回。为什么不用instanceOf检查？</p><p>因为add方法保证了数组里元素的类型一定是E</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>add方法参数类型是E，这就规定了加入这个集合的元素都必须是E类型，如果add类型不一致的对象，编译器一定报错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><blockquote><p>调用上面elementData方法，该方法直接返回E类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        rangeCheck(index);<span class="hljs-comment">//检查index是否越界</span><br>        <span class="hljs-keyword">return</span> elementData(index);<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>因此，有了泛型机制，程序员的责任（保证类型一致性，例如用instanceOf检查也是程序员的责任）变成了编译器的责任。这就是引入泛型机制的优点。</strong></p></blockquote><ul><li><p>ArrayList<E>定义了一个带<strong>类型形参</strong>的泛型类， 类型参数<strong>E是形参</strong></E></p></li><li><p>ArrayList<String> 是一个参数化类型(<strong>实例类型</strong>)<strong>，</strong>其中String作为一个具体类型（实参）传递给形参E。 这里借用了术语”实例”，不是指对象，而是一个具体的类型</String></p></li><li><p>特别重要的时：<strong>类型实参String传递给类型形参E时发生在编译时（不是运行时）</strong>。因此，对于下面的语句，编译器会用<strong>String代替E，对代码进行类型检查</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//用实例类型ArrayList&lt;String&gt; 声明引用变量list</span><br>list.add(“China”);<span class="hljs-comment">//编译器会根据类型实参String检查传入add方法的对象类型是否匹配，否则报错</span><br><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414093844658.png" alt="image-20210414093844658"></p></li><li><p>ArrayList<String> list = new ArrayList<String>(); </String></String></p></li><li><p>ArrayList<String> list就规定了只能往list里添加String字符串</String></p><p>list.add(“Hust”);     //正确，只能向list中添加字符串</p><p>list.add(new Integer(1)); //错误，list中只能添加字符串</p></li><li><p><strong>泛型类型的参数类型必须是引用类型</strong></p><p>如 ArrayList<int> list = new ArrayList<int>(); //错误</int></int></p><p>ArrayList<Integer> list = new ArrayList<Integer>(); //正确</Integer></Integer></p><p>list.add(5); //正确 <strong>自动打包（装箱）机制</strong></p><p>int i = list.get(0); //正确，如果元素是包装类型，如Integer,Double,Character，可以直接将这个元素赋给一个基本类型的变量。这个过程称为<strong>自动拆箱机制</strong></p></li></ul><h2 id="定义泛型类和接口"><a href="#定义泛型类和接口" class="headerlink" title="定义泛型类和接口"></a>定义泛型类和接口</h2><h3 id="用泛型定义栈类"><a href="#用泛型定义栈类" class="headerlink" title="用泛型定义栈类"></a>用泛型定义栈类</h3><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210414185245589.png" alt="image-20210414185245589" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericStack</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>         <span class="hljs-keyword">private</span> ArrayList&lt;E&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;E&gt;();<br>    <span class="hljs-comment">//判空</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-keyword">return</span> list.isEmpty();<br>         &#125;<br>    <span class="hljs-comment">//获取长度</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> list.size();<br>         &#125;<br>    <span class="hljs-comment">//取值不出栈</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-keyword">return</span> list.get(getSize() - <span class="hljs-number">1</span>);<br>         &#125;<br>    <span class="hljs-comment">//出栈</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br> E o = list.get(getSize() - <span class="hljs-number">1</span>) ;<br> list.remove(getSize() - <span class="hljs-number">1</span>);<br> <span class="hljs-keyword">return</span> o;<br>          &#125;<br>    <span class="hljs-comment">//入栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E o)</span> </span>&#123;<br> list.add(o);<br>           &#125; <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;stack: &quot;</span> + list.toString();<br>          &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>GenericStack<String>是泛型类GenericStack<E>的一个实例类型</E></String></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">GenericStack&lt;String&gt; stack1 = <span class="hljs-keyword">new</span> GenericStack&lt; String &gt;();<br>stack1.push(“Londen”);<br>stack1.push(“Paris”);<br>stack1.push(“New York”);<br></code></pre></div></td></tr></table></figure><p>GenericStack<Integer>是泛型类GenericStack<E>的另一个实例类型</E></Integer></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">GenericStack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>stack1.push(<span class="hljs-number">5</span>);<br>stack1.push(<span class="hljs-number">10</span>);<br>stack1.push(<span class="hljs-number">15</span>);<br></code></pre></div></td></tr></table></figure><ul><li>注意：<strong>GenericStack<E>构造函数形式是擦除参数类型后的GenericStack( ),不是GenericStack&lt;&gt;();</E></strong></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericContainer</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">//注意泛型的构造函数不带泛型参数，连&lt;&gt;都不能有</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericContainer</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><p>注意</p><ul><li><p>泛型类或者泛型接口的一个实力类型，可以作为其他类的父类或者类要实现的接口</p></li><li><p>如Java API中，Java.lang.String类实现Comparable接口的写法是</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-title">inplements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;</span><br><span class="hljs-class">//<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;是泛型类接口<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;类型的实例类型（接口）</span><br><span class="hljs-class"></span><br><span class="hljs-class">//<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;是一个这样接口类型：可以比较两个<span class="hljs-title">String</span>对象的大小</span><br><span class="hljs-class"></span><br><span class="hljs-class">//而<span class="hljs-title">String</span>实现了这个接口<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>这样的目的主要是避免不同类的比较，限定只能String和String比，Circle和Circle比，不能引用了Comparable的类就可以比</p></li><li><p>类似的，如果我们要定义了一个实现Comparable接口的Cricle类，就要这么写</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Cricle</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ul><li><p>除了可以定义泛型接口和泛型类，也可以定义泛型方法。下面的例子在一个非泛型类里定义了泛型方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericMethodDemo</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer[] integers = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        String[] strings = &#123;<span class="hljs-string">&quot;Londen&quot;</span>,<span class="hljs-string">&quot;Paris&quot;</span>,<span class="hljs-string">&quot;New York&quot;</span>,<span class="hljs-string">&quot;Austin&quot;</span>&#125;;  <br>        GenericMethodDemo.&lt;Integer&gt;print(integers);    <br>        GenericMethodDemo.&lt;String&gt;print(strings);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(E[] list)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt;list.length; i++)&#123;<br>            System.out.print(list[i]+<span class="hljs-string">&quot; &quot;</span>);<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>调用泛型方法</strong>，将实际类型放于&lt;&gt;之中方法名之前；</p><p>也可以<strong>不显式指定实际类型（方法名前不加&lt;&gt;）</strong>，而直接给实参调用，如</p><p>print(integers); print(strings);由<strong>编译器自动发现实际类型</strong></p></blockquote><blockquote><p><strong>声明泛型方法</strong>，将类型参数<E>置于返回类型之前</E></p><p>方法的类型参数<strong>可以作为形参类型，方法返回类型，也可以用在方法体内其他类型可以用的地方</strong></p></blockquote></li></ul></li></ul><h2 id="受限泛型"><a href="#受限泛型" class="headerlink" title="受限泛型"></a>受限泛型</h2><ul><li><p>在定义泛型类、泛型接口、泛型方法时，可以将类型参数指定为另外一种类型（或泛型）的子类型（用extends），这样的类型参数称之为<strong>受限的</strong>（bounded）</p></li><li><p>想实现泛型方法比较二个几何对象的面积是否相等，几何对象类型很多，都从GeometricObject派生 （E代表一种几何对象类型，如Circle，Triangel）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoundedTypeDemo</span></span>&#123;<br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equalArea</span><span class="hljs-params">(E object1, E object2 )</span></span><br><span class="hljs-function">        </span>&#123;<br>        <span class="hljs-keyword">return</span> object1.getArea() == object2.getArea( );<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>E extends GeometricObject规定了E必须是GeometricObject及其子类，因此E类型对象有方法getArea</p></blockquote></li><li><p>注意: 类型参数放置的位置，应放在<strong>方法的返回类型之前</strong>(定义泛型方法)或者<strong>类名之后</strong>（定义泛型类时）</p></li></ul><h2 id="原始类型和向后兼容"><a href="#原始类型和向后兼容" class="headerlink" title="原始类型和向后兼容"></a>原始类型和向后兼容</h2><ul><li><p>没有指定具体实现类型的泛型类和泛型接口称为原始类型（raw type）。如：</p><ul><li><p>GenericStack stack = new GenericStack( ); <strong>等价</strong>于</p></li><li><p>GenericStatck&lt;Object&gt; stack = new GenericStack&lt;Object&gt;( );</p><p>(JDK1.5后出现泛型，为了让新老代码兼容，出现泛型后，第一句不报错，但是警告)</p></li></ul></li><li><p><strong>这种不带类型参数的泛型类或泛型接口称为原始类型。</strong>使用原始类型可以向后兼容Java的早期版本。如Comparable类型. </p></li><li><p><strong>尽量不要用！</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//从JDK1.5开始，Comparable就是泛型接口Comparable&lt;T&gt;的原始类型(raw type)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Max</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparable <span class="hljs-title">findMax</span><span class="hljs-params">(Comparable o1, Comparable o2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (o1.compareTo(o2) &gt; <span class="hljs-number">0</span>)?o1:o2;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p> 上例中，Comparable o1和Comparable o2都是原始类型声明，但是，<strong>原始类型是不安全的</strong>。如：Max.findMax(“Welcome”,123）；<strong>编译通过</strong>(都实现了Comparable)，但会<strong>引起运行时错误</strong>（类型不一致）。</p></blockquote></li><li><p>安全的办法是使用泛型，现在将findMax方法改成泛型方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Max</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="hljs-function">E <span class="hljs-title">findMax</span><span class="hljs-params">(E o1, E o2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (o1.compareTo(o2) &gt; <span class="hljs-number">0</span>)?o1:o2;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>E extends Comparable&lt;E&gt;指定类型E必须<strong>实现Comparable接口</strong>，而且接口比较<strong>对象类型必须是E</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Circle</span>&gt; </span>&#123;…&#125;<br><br>Max.findMax(<span class="hljs-keyword">new</span> Circle(),<span class="hljs-keyword">new</span> Circle(<span class="hljs-number">10.0</span>);<br><span class="hljs-comment">//编译上面这条语句时，编译器会自动发现findMax的类型实参为Circle，用Circle替换E</span><br></code></pre></div></td></tr></table></figure><blockquote><p>这个时候语句Max.findMax(“Welcome”,123）；会引起<strong>编译时错误</strong>，因为findMax方法要求两个参数类型必须一致，且<strong>E必须实现Comparable<E> 接口</E></strong></p></blockquote></li></ul><h2 id="通配泛型"><a href="#通配泛型" class="headerlink" title="通配泛型"></a>通配泛型</h2><h3 id="泛型集合类型没有协变性"><a href="#泛型集合类型没有协变性" class="headerlink" title="泛型集合类型没有协变性"></a><strong>泛型集合类型没有协变性</strong></h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WildCardNeedDemo</span> </span>&#123;<br>    <span class="hljs-comment">//参数类型为GenericStack&lt;Number&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(GenericStack&lt;Number&gt; stack)</span></span>&#123;<br>        <span class="hljs-keyword">double</span> max = stack.pop().doubleValue();<br>        <span class="hljs-keyword">while</span> (! stack.isEmpty())&#123;<br>            <span class="hljs-keyword">double</span> value = stack.pop().doubleValue();<br>            <span class="hljs-keyword">if</span>(value &gt; max)<br>                max = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        GenericStack&lt;Integer&gt; intStack = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>        intStack.push(<span class="hljs-number">1</span>);intStack.push(<span class="hljs-number">2</span>);intStack.push(<span class="hljs-number">3</span>);<br>   <span class="hljs-comment">//传入的参数为insack是GenericStack&lt;Integer&gt;</span><br>        System.out.println(<span class="hljs-string">&quot;Th max value is &quot;</span> + max(intStack));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>出错，因为intStack不是GenericStack<Number>实例</Number></p></blockquote><p>Integer是Number的子类，但是</p><p>GenericStack<Integer>并不是GenericStack<Number>的子类。</Number></Integer></p><p>原因：<strong>泛型集合类型没有协变性</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WildCardNeedDemo</span> </span>&#123;<br>    <span class="hljs-comment">//参数GenericStack&lt;？ extends Number&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(GenericStack&lt;？ extends Number&gt; stack)</span></span>&#123;<br>        <span class="hljs-keyword">double</span> max = stack.pop().doubleValue();<br>        <span class="hljs-keyword">while</span> (! stack.isEmpty())&#123;<br>            <span class="hljs-keyword">double</span> value = stack.pop().doubleValue();<br>            <span class="hljs-keyword">if</span>(value &gt; max)<br>                max = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>double max(GenericStack&lt;? extends Number&gt; stack)</strong></p><p><strong>extends表示了类型参数的范围关系。</strong> </p><p><strong>GenericStack&lt;? extends Number&gt;才是GenericStack<Integer>的父类，</Integer></strong>GenericStack<Number>不是GenericStack<Integer> <strong>的父类</strong></Integer></Number></p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        GenericStack&lt;Integer&gt; intStack = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>        intStack.push(<span class="hljs-number">1</span>);intStack.push(<span class="hljs-number">2</span>);intStack.push(<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;Th max value is &quot;</span> + max(intStack));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>如上代码就不报错了</p></blockquote><p>三种形式：</p><ul><li>？ , 非受限通配，等价于 ? extends Object，注意<ul><li>GenericStack&lt;?&gt;不是原始类型， GenericStack是原始类型</li></ul></li><li>？ extends T, 受限通配,表示T或者T的子类，上界通配符，T定义了类型上限</li><li>? super T，下限通配，表示T或者T的父类型，下界通配符，T定义了类型下限</li></ul><h3 id="数组有协变性"><a href="#数组有协变性" class="headerlink" title="数组有协变性"></a>数组有协变性</h3><ul><li>数组的协变性是指，如果类A是类B的父类，那么A[]就是B[]的父类</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jonathan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Apple</span></span>&#123;&#125; <span class="hljs-comment">//一种苹果</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orange</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span></span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//由于数组的协变性，可以把Apple[]类型的引用赋值给Friut[]类型的引用</span><br>Fruit[] fruits = <span class="hljs-keyword">new</span> Apple[<span class="hljs-number">10</span>]; <br>fruits[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Apple();  <br>fruits[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Jonathan(); <span class="hljs-comment">// Jonathan是Apple的子类</span><br></code></pre></div></td></tr></table></figure><p>​                以上都正确，但是下面语句fruits的<strong>声明类型是Fruit</strong>因此编译通过，但<strong>运行时将Fruit转型为Apple错误</strong><br>​                数组是在<strong>运行时才去判断数组元素的类型约束</strong>；<br>​                而泛型正好相反，在<strong>运行时，泛型的类型信息是会被擦除的</strong>，编译的时候去检查类型约束</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">try</span>&#123;<br>    fruits[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Fruit();<span class="hljs-comment">//运行时抛出异常 java.lang.ArrayStoreException，这是数组协变性导致的问题</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    System.out.println(e);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="泛型容器（任何泛型类）没有协变性"><a href="#泛型容器（任何泛型类）没有协变性" class="headerlink" title="泛型容器（任何泛型类）没有协变性"></a>泛型容器（任何泛型类）没有协变性</h3><ul><li><p>为了解决数组协变性导致的问题，Java编译器规定泛型容器（任何泛型类）没有协变性</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;(); <span class="hljs-comment">//编译错误</span><br><span class="hljs-comment">//Type mismatch: cannot convert from ArrayList&lt;Apple&gt; to ArrayList&lt;Fruit&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>因为我们在谈论容器的类型，而不是容器持有对象的类型</p></li><li><p>A是B父类型，但泛型类（比如容器）ArrayList<A>不是ArrayList<B>的父类型，因此上面的语句报错</B></A></p></li><li><p>为什么数组有协变性而泛型没有协变性</p><ul><li>数组具有协变性，因此在运行时才会判断元素的类型约束，这将导致有时发生<strong>运行时错误</strong>，抛出异常java.lang.ArrayStoreException。这个功能在Java中是一个公认的“瑕疵”</li><li>泛型没有协变性：<strong>泛型设计者认为与其在运行失败，不如在编译时就失败（禁止泛型的协变性就是为了杜绝数组协变性带来的问题，即如果泛型有协变性，面临可协变的数组一样的问题）</strong>——静态类型语言（Java，C++）的全部意义再与代码运行前找出错误，Python，JavaScript之类的语言是动态类型语言（不安全）。</li><li>但有时希望像数组一样，一个父类型容器引用变量指向子类型同期，这时要使用通配符</li></ul></li></ul><h3 id="上界通配泛型-extends"><a href="#上界通配泛型-extends" class="headerlink" title="上界通配泛型? extends"></a>上界通配泛型? extends</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? extends Fruit&gt; list = <span class="hljs-keyword">new</span>  ArrayList&lt;Apple&gt;(); <span class="hljs-comment">//左边类型是右边类型的父类型</span><br></code></pre></div></td></tr></table></figure><blockquote><p>上面语句编译通过，但是这样的list不能加入任何东西，下面语句都会编译出错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">list.add(<span class="hljs-keyword">new</span> Apple()); list.add(<span class="hljs-keyword">new</span> Fruit()); <span class="hljs-comment">//编译都报错</span><br><span class="hljs-comment">//可加入null</span><br>list.add(<span class="hljs-keyword">null</span>);<br><br><span class="hljs-comment">//但是从这个list取对象没有问题，编译时都解释成Fruit，运行时可以是具体的类型如Apple（有多态性）</span><br>Fruit f = list.get(<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure><ul><li>因为ArrayList&lt;? entends Fruit&gt;意味着该list集合中存放的都是Fruit的子类型（包括Fruit自身），Fruit的子类型可能有很多，但list只能<strong>存放其中的某一种类型</strong>，编译器<strong>只能知道元素类型的上限是Fruit，而无法知道list引用会指向什么具体的ArrayList</strong>，可以是ArrayList<Apple>,也可能是ArrayList<Jonathan>,<strong>为了安全，Java泛型只能将其设计成不能添加元素</strong>。</Jonathan></Apple></li><li>虽然不能添加元素，但从里面获取元素的类型都是Fruit类型（编译时）</li><li>因此带&lt;! extends&gt;类型通配符的泛型类<strong>不能往里存内容（不能set），只能读取（只能get）</strong></li><li>那这样的声明的容器类型有什么意义？它的意义是作为一个<strong>只读（只从里面取对象）的容器</strong></li></ul><blockquote><p>假设已经实例化好了另外一个容器，对象已经放入其中，这时用ArrayList&lt;? extends Fruit&gt; list <strong>指向这个另外的容器，那么我们可以通过list取出容器的所有对象而没有任何问题</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;();<br><span class="hljs-comment">//调用apples.add方法添加很多Apple及其子类对象</span><br><br>ArrayList&lt;? extends Fruit&gt; list = apples; <span class="hljs-comment">//现在ArrayList&lt;? extends Fruit&gt; 类型的引用指向apples</span><br><span class="hljs-keyword">for</span>（<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++）&#123;<br>    Fruit f = list.get(i)；  <span class="hljs-comment">//运行时从容器里取出的都是Apple及其子类对象，赋值给Fruit引用没问题</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>这个例子还是比较极端（纯粹是语法功能演示），实际更有意义的是作为方法参数：该方法接受一个放好对象的容器，然后在方法里只是逐个取出元素进行处理</strong></p></blockquote><p>运用上限通配泛型</p><ul><li><p>程序的其他地方，创建具体类型的容器，添加对象，ArrayList作为实参调用handle方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;Apple&gt; appleList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">//等价于new ArrayList&lt;Apple&gt;(); </span><br>appleList.add(<span class="hljs-keyword">new</span> Apple());<span class="hljs-comment">//ArrayList&lt;Apple&gt;是具体类型，编译器很清楚地知道类型参数是Apple这时可以add</span><br><span class="hljs-comment">//由于形参类型ArrayList&lt;? extends Fruit&gt;是实参类型ArrayList&lt;Apple&gt;的父类型，因此实参可以传给形参</span><br>handle(appleList); <br></code></pre></div></td></tr></table></figure></li><li><p>handle方法，参数类型设置为ArrayList&lt;? extends Fruit&gt; </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(ArrayList&lt;? extends Fruit&gt; list)</span></span>&#123; <span class="hljs-comment">//注意方法里只能从list get元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++)&#123;<br>Fruit o = list.get(i); <span class="hljs-comment">//可以确定list里面对象一定是Fruit或子类类型</span><br>        <span class="hljs-comment">//处理对象o，注意这时调用o的实例方法时具有多态性</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如上我们可以看到上限通配泛型可以作为只读。</p></li></ul><h3 id="下限通配泛型-super"><a href="#下限通配泛型-super" class="headerlink" title="下限通配泛型? super"></a>下限通配泛型? super</h3><ul><li><p>采用下界通配符 <strong>？****super T</strong> 的泛型类引用，可以指向所有以T及其父类型为类型参数的实例类型</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Fruit&gt;(); <span class="hljs-comment">//这时new后边的Fruit可以省略</span><br>ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;(); <span class="hljs-comment">//允许，Object是Fruit父类</span><br>ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;(); <span class="hljs-comment">//但是不能指向Fruit子类的容器</span><br></code></pre></div></td></tr></table></figure></li><li><p>可以向List里面添加T及T的子类对象</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">list.add(<span class="hljs-keyword">new</span> Fruit()); <span class="hljs-comment">//OK</span><br>list.add(<span class="hljs-keyword">new</span> Apple()); <span class="hljs-comment">//OK</span><br>list.add(<span class="hljs-keyword">new</span> Jonathan()); <span class="hljs-comment">//OK</span><br>list.add(<span class="hljs-keyword">new</span> Orange())；<span class="hljs-comment">//OK</span><br><span class="hljs-comment">//list.add(new Object()); //添加Fruit父类则编译器禁止，报错</span><br></code></pre></div></td></tr></table></figure></li><li><p>但从list里get数据只能被编译器解释称Object</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o1 = list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//OK</span><br>Fruit o2 = list.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">//报错，Object不能赋给Fruit，需要强制类型转换，</span><br></code></pre></div></td></tr></table></figure></li><li><p>因此这种泛型类和采用？extends的泛型类正好相反：<strong>只能存数据</strong>，获取数据<strong>至少部分失效</strong>（编译器解释成Object）</p></li></ul><h3 id="extend和-super的理解"><a href="#extend和-super的理解" class="headerlink" title="? extend和? super的理解"></a>? extend和? super的理解</h3><blockquote><p>现在看看通配泛型 ？ extends，注意右边的new ArrayList的类型参数必须是Fruit的子类型</p><p>//? extends Fruit指定了类型上限，因此下面的都成立：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? extends Fruit&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Fruit&gt;(); <span class="hljs-comment">//=号右边，如果是Fruit，可以不写，等价于new ArrayList&lt;&gt;();</span><br>ArrayList&lt;? extends Fruit&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;();  <span class="hljs-comment">//=号右边，如果是Fruit的子类，则必须写</span><br>ArrayList&lt;? extends Fruit&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Jonathan&gt;(); <span class="hljs-comment">//=号右边，如果是Fruit的子类，则必须写</span><br>ArrayList&lt;? extends Fruit&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Orange&gt;();  <span class="hljs-comment">//=号右边，如果是Fruit的子类，则必须写</span><br></code></pre></div></td></tr></table></figure><ul><li><p>ArrayList&lt;? extends Fruit&gt; list可指向</p><ol><li>ArrayList<Fruit></Fruit></li><li>ArrayList<Apple></Apple></li><li>ArrayList<Jonathan></Jonathan></li><li>ArrayList<Orange>…</Orange></li></ol></li><li><p>一个ArrayList<Fruit>容器可以加入Fruit、Apple、Jonathan、Orange，</Fruit></p></li><li><p>一个ArrayList<Apple>容器可以加入Apple、Jonathan，</Apple></p></li><li><p>一个ArrayList<Orange>容器可以加入Orange，</Orange></p></li></ul><blockquote><p>假如当ArrayList&lt;? extends Fruit&gt; list为<strong>方法形参</strong>时，如果方法内部调list.add，</p><p>由于编译时，编译器无法知道ArrayList&lt;? extends Fruit&gt;类型的引用变量会<strong>指向哪一个具体容器类型</strong>，编译器<strong>无法知道该怎么处理add</strong>。</p></blockquote><blockquote><p>例如当add的对象类型是Orange，如果list指向ArrayList<Apple>，加不进去。但如果list指向为ArrayList<Orange>，就可以加进去。</Orange></Apple></p></blockquote><blockquote><p><strong>为了安全，编译器干脆禁止ArrayList&lt;? extends Fruit&gt;类型的list添加元素。</strong></p></blockquote><blockquote><p><strong>但从list里get元素，都解释成Fruit类型</strong></p></blockquote><hr><blockquote><p>? super Fruit指定了类型下限，因此下面二行都成立</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Fruit&gt;(); <span class="hljs-comment">//=号右边，这时Fruit可以省略，等价于new ArrayList&lt;&gt;();</span><br>ArrayList&lt;? <span class="hljs-keyword">super</span> Fruit&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;(); <span class="hljs-comment">//允许。=号右边，如果是Fruit的父类，必须写出类型</span><br><span class="hljs-comment">//ArrayList&lt;? super Fruit&gt; list3 = new ArrayList&lt;Apple&gt;(); //但是不能指向Fruit子类的容器</span><br></code></pre></div></td></tr></table></figure><blockquote><p>因此ArrayList&lt;? super Fruit&gt; list引用可以指向ArrayList<Fruit>以及Fruit父类型的容器如ArrayList<Object>。</Object></Fruit></p></blockquote><ul><li>当ArrayList&lt;? super Fruit&gt; list为方法形参时,<strong>编译器知道list指向的具体容器的类型参数至少是Fruit</strong>。当向list里add对象o时，分析几种可能的情况：<ol><li>o是Fruit及其子类类型，这里面又分二种情况<ol><li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Fruit>，可以加入</Fruit></li><li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Object>,可以加入</Object></li></ol></li><li> o是Fruit的父类型如Object，这里面又分二种情况</li><li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Fruit>，这时编译器不允许加入，Object不能转型为Fruit</Fruit></li><li>ArrayList&lt;? super Fruit&gt; list实际指向ArrayList<Object>，可以加入</Object></li></ol></li></ul><blockquote><p>综合以上四种情况，可以看到，只要对象o的类型是Fruit及其子类型，这时将对象o加入list一定是安全的（1.1, 1.2）；</p><p>如果对象是Fruit父类型，则不允许加入最安全（因为可能出现2.1的情况)。由于? super Fruit规定了list元素类型的下限，因此取元素时编译器只能全部解释成Object</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">list1.add(<span class="hljs-keyword">new</span> Fruit()); <br>list1.add(<span class="hljs-keyword">new</span> Apple()); <br>list1.add(<span class="hljs-keyword">new</span> Jonathan());<span class="hljs-comment">//只要加入Fruit及其子类对象都OK</span><br><span class="hljs-comment">//list1.add(new Object()); //添加Fruit父类则编译器禁止，报错</span><br></code></pre></div></td></tr></table></figure><blockquote><p>取对象时都必须解释成Object类型。因此我们说带&lt;? super&gt;通配符的泛型类的get方法至少是部分失效</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Object o1 = list.get(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//Fruit o2 = list.get(0);  //报错，Object不能赋给Fruit，需要强制类型转换，但是引入泛型就是想去掉强制类型转换</span><br></code></pre></div></td></tr></table></figure><h4 id="extends和-super的使用原则"><a href="#extends和-super的使用原则" class="headerlink" title="? extends和? super的使用原则"></a>? extends和? super的使用原则</h4><p>Producer Extends，Consumer Super原则（PECS）</p><blockquote><p>Producer Extends: 如果需要一个只读泛型类，用来Produce T，那么用? extends T</p><p>Consumer Super： 如果需要一个只写泛型类，用来Consume T，那么用? super T</p><p>如果需要同时读取和写入，那么久不能用通配符</p></blockquote><p>例如我们读JDK的Collections类的copy方法，可以看到一个经典使用PECS原则的例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collections</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br><span class="hljs-comment">//其中重要的代码片段为</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;srcSize; i++)<br>                dest.set(i, src.get(i)); <span class="hljs-comment">//dest:写，src：读</span><br>        &#125; <br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>看如下代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperWildCarDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        GenericStack&lt;String&gt; strStack= <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>  GenericStack&lt;Object&gt; objStack = <span class="hljs-keyword">new</span> GenericStack&lt;&gt;();<br>  objStack.push(“Java<span class="hljs-string">&quot;);</span><br><span class="hljs-string">  objStack.push(2); //装箱</span><br><span class="hljs-string">  strStack.push(“Sun&quot;</span>);<br>  add(strStack , objStack);<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>方法1</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(GenericStack&lt;T&gt; stack1,</span></span><br><span class="hljs-function"><span class="hljs-params">GenericStack&lt;? <span class="hljs-keyword">super</span> T&gt; stack2)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!stack1.isEmpty())<br>stack2.push(stack1.pop()); <span class="hljs-comment">//只写</span><br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>编译时，编译器根据实参strStack的类型参数String确定类型形参T为String。GenericStack&lt;? super T&gt;stack2表示元素类型是String父类的堆栈，因此实参objStack的类型GenericStack<Object>与形参stack2的类型匹配，参数传递也没问题。<strong>注意stack2只写。</strong></Object></p></blockquote><p>方法2</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(GenericStack&lt;？extends T&gt; stack1,GenericStack&lt;T&gt; stack2)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!stack1.isEmpty())<br>stack2.push(stack1.pop());<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>add方法参数类型改为（GenericStack&lt;？extends T&gt; stack1,GenericStack<T> stack2）也没问题，这时根据第二个实参类型推断出T为Object，而第一个实参类型GenericStack<String>是GenericStack&lt;? Extends Object&gt;的子类型，因此参数传递也没问题。<strong>注意stack1只读。</strong></String></T></p></blockquote><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416203513322.png" alt="image-20210416203513322"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416203550072.png" alt="image-20210416203550072"></p><h2 id="泛型擦除和对泛型的限制"><a href="#泛型擦除和对泛型的限制" class="headerlink" title="泛型擦除和对泛型的限制"></a>泛型擦除和对泛型的限制</h2><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><ul><li>泛型是用类型擦除（type erasure）方法实现的。泛型的作用就是使得编译器在编译时通过类型参数来检测代码的类型匹配性。<strong>当编译通过，意味着代码里的类型都是匹配的。因此，所有的类型参数使命完成而全部被擦除</strong>。因此，泛型信息(类型参数)在运行时是不可用的，这种方法使得泛型代码<strong>向后兼容使用原始代码的遗留代码</strong>。</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416203725935.png" alt="image-20210416203725935"></p><ul><li><strong>泛型存在于编译时</strong>，当编译器认为泛型类型是安全的，就会将其转化为原始类型。<strong>这时(a)所示的源代码编译后变成(b)所示的代码</strong>。注意在(b)里，由于list.get(0)返回的对象运行时类型一定是String，因此<strong>强制类型转换一定是安全的。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeErasureTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        ArrayList&lt;String&gt; strList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Fruit&gt; fruitList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <br>        Class clz1 = strList.getClass(); <span class="hljs-comment">//getClass返回运行时信息</span><br>        Class clz2 = fruitList.getClass();<br>        <br>        System.out.println(clz1.getSimpleName());   <span class="hljs-comment">//ArrayList</span><br>        System.out.println(clz2.getSimpleName());   <span class="hljs-comment">//ArrayList</span><br>        System.out.println(clz1 == clz2);           <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>**所有参数化类型（实例类型）ArrayList<String> **、ArrayList<Fruit>在运行时共享同一个类型：ArrayList。</Fruit></String></p></blockquote><ul><li>当编译泛型类，接口和方法时，会用Object代替非首先类型参数E,<E extends object></E></li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416204338780.png" alt="image-20210416204338780"></p><ul><li>如果一个泛型的参数类型是受限的，编译器会用该受限类型来替换它</li></ul><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210416204444415.png" alt="image-20210416204444415"></p><hr><ul><li><p>泛型类会擦除类型参数，所有泛型的实例类型共享擦除后形成的原始类型如ArrayList</p><ul><li><p>泛型类所有实例类型在运行时共享原始类型，如：</p><p>ArrayList<String> list1 = new ArrayList&lt;&gt;( );</String></p><p>ArrayList<Integer> list2= new ArrayList&lt;&gt;( );</Integer></p><p>在运行时只有一个擦除参数类型后的原始ArrayList类被加载到JVM中</p></li><li><p>所以， list1 instanceOf ArrayList<String>是错误的，可用：</String></p><p>list1 instanceOf ArrayList</p><p>list2 instanceOf ArrayList</p><p>instanceOf是根据运行时类型进行检查</p></li></ul></li></ul><h3 id="使用泛型类型的限制"><a href="#使用泛型类型的限制" class="headerlink" title="使用泛型类型的限制"></a>使用泛型类型的限制</h3><ul><li><p>不能使用new E( ); //只能想办法得到E的类型<strong>实参</strong>的Class信息，再newInstance(…)</p><p>不能用泛型的类型参数创建实例，如： E object = new E( ); //错误，泛型类型参数在运行时不可用</p></li><li><p>不能使用new E[ ]</p><p>不能用泛型的类型参数创建数组，如： E[ ] element = new E[cpacity]; //错误</p><ul><li><strong>new是运行是发生的，因此new 后面一定不能出现类型形参E，运行时类型参数早没了</strong></li></ul></li><li><p>强制类型转换可以用类型形参E，通过类型转换实现无法确保运行时类型转换是否成功</p><ul><li>E[ ] element = (E[ ])new Object[cpacity];  //编译可通过(所谓编译通过就是指编译时uncheck，至于运行时是否出错，那是程序员自己的责任</li></ul></li></ul><p>实例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericOneDimensionArray</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <br>    <span class="hljs-keyword">private</span> T[] elements = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//T[]类型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericOneDimensionArray</span><span class="hljs-params">(Class&lt;? extends T&gt; clz,<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>        elements = (T[])Array.newInstance(clz,size);<br>    &#125;<br>    <span class="hljs-comment">//get, put等其他方法省略</span><br><br>    <span class="hljs-keyword">public</span> T[] getElements()&#123; <span class="hljs-keyword">return</span> elements; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        GenericOneDimensionArray&lt;String&gt; stringArray = <br>                <span class="hljs-keyword">new</span> GenericOneDimensionArray(String.class,<span class="hljs-number">10</span>);<br>        String[] a = stringArray.getElements();  <span class="hljs-comment">//这里不会抛出运行时异常了</span><br><span class="hljs-comment">//        a[0] = new Fruit(); //不是String类型的对象，编译报错</span><br>        a[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意如下的构造函数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> T[] elements = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//T[]类型</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericOneDimensionArray</span><span class="hljs-params">(Class&lt;? extends T&gt; clz,<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>    elements = (T[])Array.newInstance(clz,size);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>这里第一个参数是Class&lt;? extends T&gt; clz，表示一个T类型及其子类的Class对象。通过Class对象，可以通过反射创建运行时类型为T[]的数组。</p></blockquote><blockquote><p>但是Array.newInstance方法返回的是Object，因此需要强制类型转换。但这里的强制类型转换是安全的，因为创建的数组的运行时类型就是T[]</p></blockquote><blockquote><p>Array.newInstance(数组元素类型的Class对象, size)</p><p>通过反射机制创建运行时类型为T[]的数组</p></blockquote><p>这个泛型数组实现的版本比前一个要好多了，但构造函数要多传一个<em><strong>Class</strong></em>对象，指明数组元素类型信息。举这个例子还想说明反射机制的重要性。</p><hr><ul><li><p>使用泛型类型的限制：不能new泛型数组（数组元素是泛型），但可以声明</p><ul><li><p>不能使用new A<E>[ ]的数组形式，因为E已经被擦除</E></p><p>ArrayList<String>[ ] list = new ArrayList<String>[10]；//错误</String></String></p></li></ul></li><li><p>E已经被擦除，只能用泛型的原始类型初始化数组, 必须改为new ArrayList[10]</p><p>ArrayList<String> [ ] list = new ArrayList[10]；</String></p><ul><li><p>为什么这里不需要强制类型转换：参数化类型与原始类型的兼容性</p></li><li><p>参数化类型对象可以被赋值为原始类型的对象，原始类型对象也可以被赋值为参数化类型对象</p><p> ArrayList a1 = new ArrayList(); //原始类型</p><p> ArrayList<String> a2 = a1; //参数化类型</String></p></li></ul></li></ul><hr><ul><li><strong>静态上下文</strong>中不允许使用泛型的类型参数。由于泛型类的所有实例类型都共享相同的运行时类，所以<strong>泛型类的静态变量和方法都被它的所有实例类型所共享</strong>。因此，在静态方法、数据域或者初始化语句中，使用泛型的参数类型是非法的。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(E o1)</span></span>&#123;<span class="hljs-comment">//Illegal</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> E o1; <span class="hljs-comment">//Illegal</span><br>    <br>    <span class="hljs-keyword">static</span>&#123;<br>        E o2;<span class="hljs-comment">//Illegal</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>Test<String>和Test<Integer>这二个实例类型共享同一个运行时类型，如果静态上下文可以使用类型参数E, 会导致矛盾：</Integer></String></p><p>m方法的形参类型到底是String还是Integer？</p></blockquote><hr><ul><li><p>异常类不能是泛型的。泛型类不能继承java.lang.Throwable。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>非法，因为如果允许这么做，则应为MyException添加一个catch语句</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">try</span>&#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">catch</span>(MyException&lt;T&gt; ex)&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>JVM必须检查这个从try语句中抛出的异常以确定与catch语句中的异常类型匹配，但这不可能，因为运行时的类型信息是不可获得的。</p></li></ul><h2 id="实现带泛型参数的对象工厂（一种设计模式）"><a href="#实现带泛型参数的对象工厂（一种设计模式）" class="headerlink" title="实现带泛型参数的对象工厂（一种设计模式）"></a>实现带泛型参数的对象工厂（一种设计模式）</h2><ul><li><p>使用泛型类型的限制</p><ul><li>不能使用new E();//只能用newInstance(…)</li></ul></li><li><p>如何利用反射机制，通过newInstance()来创建对象？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectFactory</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-keyword">private</span> Class&lt;T&gt; type;  <span class="hljs-comment">//定义私有数据成员，保存要创建的对象的类型信息</span><br>    <br><span class="hljs-comment">//构造函数传入要创建的对象的类型信息</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObjectFactory</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.type = type;<br>&#125;<br><span class="hljs-comment">//对象工厂的create方法负责产生一个T类型的对象，利用newInstance</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>T o = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>o= type.newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;<br>e.printStackTrace();<br>&#125;<br>        <span class="hljs-comment">//这里顺便说明和强调一下，一个类定义缺省构造函数（不带参数）多么重要</span><br><span class="hljs-keyword">return</span> o;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如下为一个实例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//首先创建一个负责生产Car的对象工厂，传进去需要创建对象的类的Class信息</span><br>ObjectFactory&lt;Car&gt; carFactory = <span class="hljs-keyword">new</span> ObjectFactory&lt;Car&gt;(Car.class);<br>Car o = carFactory.create();  <span class="hljs-comment">//由对象工厂负责产生car对象</span><br>System.out.println(carFactory.create().toString());<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br><span class="hljs-keyword">private</span> String s = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">()</span> </span>&#123;<br>s = <span class="hljs-string">&quot;Car&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>  以Car.class为参数去构造一个ObjectFactory<Car>类型的对象工厂，再调用对象工厂的create方法，一定会返回Car对象。</Car></p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java自学——List</title>
    <link href="/2021/04/12/Java_ArrayList/"/>
    <url>/2021/04/12/Java_ArrayList/</url>
    
    <content type="html"><![CDATA[<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 接口实现了 Collection 接口。</p><p>它主要有两个实现类：ArrayList 类和 LinkedList 类。</p><p>在 List 集合中允许出现重复元素。与 Set 集合不同的是，在 List 集合中的元素是有序的，可以根据索引位置来检索 List 集合中的元素，第一个添加到 List 集合中的元素的索引为 0，第二个为 1，依此类推。</p><p> List<String> person=new ArrayList&lt;&gt;();</String></p><span id="more"></span><h3 id="List中添加获取删除元素"><a href="#List中添加获取删除元素" class="headerlink" title="List中添加获取删除元素"></a>List中添加获取删除元素</h3><p>添加方法是：.add(e)；　　</p><p>获取方法是：.get(index)；　　</p><p>删除方法是： </p><p> .remove(index)； 按照索引删除；</p><p>.remove(Object o)； 按照元素内容删除；</p><h3 id="是否包含某个元素"><a href="#是否包含某个元素" class="headerlink" title="是否包含某个元素"></a>是否包含某个元素</h3><p>方法：.contains（Object o）； 返回true或者false</p><h3 id="根据索引将元素数值改变（替换）"><a href="#根据索引将元素数值改变（替换）" class="headerlink" title="根据索引将元素数值改变（替换）"></a>根据索引将元素数值改变（替换）</h3><p>.set(index, element)</p><h3 id="查看（判断）元素的索引"><a href="#查看（判断）元素的索引" class="headerlink" title="查看（判断）元素的索引"></a>查看（判断）元素的索引</h3><p>.indexOf（）； 和 lastIndexOf（）</p><h3 id="利用list中索引位置重新生成一个新的list-截取集合"><a href="#利用list中索引位置重新生成一个新的list-截取集合" class="headerlink" title="利用list中索引位置重新生成一个新的list(截取集合)"></a>利用list中索引位置重新生成一个新的list(截取集合)</h3><p>方法： .subList(fromIndex, toIndex)；　　</p><h3 id="获取list长度（元素个数）"><a href="#获取list长度（元素个数）" class="headerlink" title="获取list长度（元素个数）"></a>获取list长度（元素个数）</h3><p>.size() ； </p><h3 id="对比两个list中的所有元素"><a href="#对比两个list中的所有元素" class="headerlink" title="对比两个list中的所有元素"></a>对比两个list中的所有元素</h3><p>.equals()  .hashcode()</p><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><p>.isEmpty()</p><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><p>.toString()</p><h3 id="转换为数组"><a href="#转换为数组" class="headerlink" title="转换为数组"></a>转换为数组</h3><p>.toArray()</p><h3 id="数组转化为List"><a href="#数组转化为List" class="headerlink" title="数组转化为List"></a>数组转化为List</h3><p>.asList(array)</p><h2 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h2><p><strong>ArrayList 类提供了快速的基于索引的成员访问方式</strong>，对尾部成员的增加和删除支持较好。使用 ArrayList 创建的集合，允许对集合中的元素进行快速的随机访问，不过，向 ArrayList 中插入与删除元素的速度相对较慢。</p><h2 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h2><p>LinkedList 类采用<strong>链表结构</strong>保存对象，这种结构的优点是便于向集合中插入或者删除元素。需要频繁向集合中插入和删除元素时，使用 LinkedList 类比 ArrayList 类效果高，但是 LinkedList 类随机访问元素的速度则相对较慢。</p><p>除了List中的方法，还包括链表特有，</p><p>addFirst(E e)   addLast(E e)   getFirst()   getLast()   removeFirst()   removeLast()</p><p>直接打印List，是[a,b,c]</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git的一些常用操作</title>
    <link href="/2021/04/09/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/04/09/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>对于每一个计算机小白来讲，学习新事物总是不简单的，但是计算机专业的学生总是要强迫自己不断学习的。</p><p>我也总少了一份学习新知识的勇气，但是走出第一步就好了，不管是学习一门语言还是学习一种工具</p><p>学会git操作应该是程序员必备的，但是对于小白可能有点难入门（拖了一年多才开始学习使用git），感谢stormzhang的learn github from zero这本书，让我简单入门了git。</p><p>整理以下有关git操作的代码，只是浅尝辄止，整理如何用git的一些操作和如何和github联动</p><p>关于git的安装和github的注册等，此文不做记录</p><hr><h1 id="git仓库的创建"><a href="#git仓库的创建" class="headerlink" title="git仓库的创建"></a>git仓库的创建</h1><p>当你建立一个github仓库，想要在这个仓库中上传文件，可以先在本地创建一个git仓库，之后再push到github仓库，这样你在github建立的仓库里就有本地仓库的内容了。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p><strong>git init 初始化仓库</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181537402.png" alt="image-20210409181537402" style="zoom:33%;"><p>会提示你已初始化一个空仓库</p></li></ul><span id="more"></span><ul><li><p><strong>git status 查看当前目录的状态</strong></p><p>若当前目录未初始化</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181608273.png" alt="image-20210409181608273" style="zoom:33%;"><p>表示当前目录还不是一个仓库</p><p>若已初始化</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181629821.png" alt="image-20210409181629821" style="zoom:33%;"><p>默认在master分支，untracked files表示文件没有被追踪，还没有提交在git仓库</p></li><li><p><strong>git add将文件放入缓存中待提交</strong></p><p><strong>也可以用git rm –cached &lt;文件名&gt; 将其从缓存中移除</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181651251.png" alt="image-20210409181651251" style="zoom:33%;"><p>add后文件就处于待commit状态，处在缓存中</p><p>不过我一般情况下喜欢使用 git add .  空格加点，表示add所有待add的文件。</p></li><li><p><strong>git commit -m’first commit’  提交</strong>，其中-m表示附带信息，’’内包括此次提交的注释，github的文件后会附带这个提示，可以用来记录第几次提交</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png" alt="未命名图片" style="zoom:33%;"></li><li><p>如果想<strong>查看commit的记录</strong>，可以输入</p><p><strong>git log</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181721340.png" alt="image-20210409181721340" style="zoom:33%;"></li></ul><hr><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>git init初始化git仓库之后会默认生成一个主分支master，默认分支，也基本是实际开发正式环境下的分支，一般情况下master分支不会轻易直接在上面操作</p><ul><li><p><strong>git branch 查看分支情况</strong>，默认就一个分支</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181751811.png" alt="image-20210409181751811" style="zoom:33%;"><p>这样就查看了分支的情况，上图只有一个分支master，且在此分支</p></li><li><p><strong>git branch xxx 新建分支</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181804691.png" alt="image-20210409181804691" style="zoom:33%;"><p>git branch other，就是新建一个other分支，新建的分支和master分支是一样的内容</p><ul><li><p><strong>git branch -d xxx</strong></p><p><strong>删除分支xxx</strong></p></li><li><p><strong>git branch -D xxx</strong></p><p><strong>xxx分支中还有未合并的代码，强制删除</strong></p></li></ul></li><li><p><strong>git checkout xxx</strong> 切换分支，xxx为另一分支的名字</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181832481.png" alt="image-20210409181832481"></p><p>切换后就可以在新建的分支上任意代码改动</p><p> <strong>git checkout -b xxx</strong></p><p><strong>新建一个xxx分支并自动切换到xxx分支</strong></p></li><li><p>分支的作用是这样：在xxx分支完成代码，测试完成，准备上线，这时候将代码合并到主分支master中，然后发布，避免了直接在主分支上操作</p><ol><li><p>切换到master分支 git checkout master</p></li><li><p>合并xxx的代码 git merge xxx</p></li></ol></li><li><p><strong>合并xxx分支的代 码 git merge xxx</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181845551.png" alt="image-20210409181845551" style="zoom:33%;"></li><li><p><strong>git tag v1.0</strong> </p><p>表示在当前代码状态下<strong>新建了一个v1.0的标签</strong></p><p><strong>git tag</strong></p><p><strong>查看历史tag记录</strong></p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181905098.png" alt="image-20210409181905098" style="zoom:33%;"></li><li><p><strong>git checkout XXXtag</strong></p><p><strong>切换到xxxtag的代码状态</strong></p></li></ul><h2 id="Github的重要操作"><a href="#Github的重要操作" class="headerlink" title="Github的重要操作"></a>Github的重要操作</h2><p>流程大概如下</p><p>如果你想从github上下载别人写好的一个项目，或者想修改你已经有的仓库里的内容，可以通过clone实现(别再下载zip了！)</p><ul><li><p><strong>git clone 项目地址</strong></p><p>将项目clone到了本地，由于项目本身就为git仓库，就不需要git init再进行初始化了，此时得到的项目文件夹就是个仓库</p><p>远程仓库也默认关联好了，就是你clone的github仓库。在本地目录下任意修改，commit后，就可以上传。</p><p>项目地址相关的内容不赘述，主要有这两种</p><hr><ol><li><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409165138302.png" alt="image-20210409165138302" style="zoom:33%;"></li></ol><p>HTTPS，项目地址就是上图的<a href="https://github.com/Trent-Liu/ML_demo.git%EF%BC%8C%E5%8F%AF%E4%BB%A5git">https://github.com/Trent-Liu/ML_demo.git，可以git</a> clone 地址，但是用HTTPS需要你输入你的账号密码</p><ol start="2"><li><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409165242378.png" alt="image-20210409165242378" style="zoom:33%;"></li></ol><p>SSH，非常好用，需要你自己添加SSH key，具体添加方法不予说明了，这样的好处是 git clone 地址，不需要你再输入账号密码了</p><hr><p>之后你对clone下来的仓库进行了内容的改动，想要将改动提交到github上的远程仓库上</p></li><li><p><strong>git push origin master</strong></p><p>将修改后的代码push到远程仓库的master分支（github现在的默认为main分支）</p></li></ul><p>如果你想把本地的某个test2项目变成git的仓库，不要一个文件一个文件的上传了</p><ol><li><p><strong>在github上建立一个空仓库，比如test</strong></p></li><li><p><strong>cd到本地当前目录test2</strong></p><p><strong>git remote add origin &lt;远程仓库地址&gt;</strong></p><p>为test2添加一个远程仓库，origin为给这个项目的远程仓库起的名字，这个名字可以任意取，只有一个时一般默认为origin。远程仓库的地址就是上面说的HTTPS或者SSH</p></li><li><p><strong>git push origin master</strong>  </p><p>就将test2push到github上的test仓库中了。</p></li></ol><p>还有几个可能需要的代码</p><ul><li><p><strong>git remote -v</strong></p><p>查看当前目录有哪些远程仓库</p></li><li><p><strong>git remote rm origin</strong></p><p>删除已存在的远程仓库origin，是当你想换一个远程仓库的时候。</p></li></ul><p>由于github是个协同开发的环境，当别人修改了你的github仓库内容，push后，你如果想把别人修改的内容覆盖你的仓库（该仓库的远程仓库已经设置成你要拉取的了）</p><p><strong>git pull origin master</strong></p><p>把远程最新的代码更新到本地。一般我们再push之前都会先pull，这样不容易冲突</p><hr><h2 id="配置及技巧"><a href="#配置及技巧" class="headerlink" title="配置及技巧"></a>配置及技巧</h2><ol><li><p>每一次commit都会产生一条log，log标记了提交人的姓名与邮箱，以便其他人方便查看与联系提交人</p><p>设置用户名与邮箱</p><p><strong>git config –global user.name “XXX”</strong></p><p><strong>git config –global user.email “XXX@XX”</strong></p><p>为全局配置，若某个项目要用特定邮箱，就在该项目下，把global去除重新设置</p></li><li><p>你是否感觉git的代码挺长，如checkout之类的</p><p><strong>替换操作</strong></p><p><strong>alias</strong></p><p><strong>git config –global alias.co checkout</strong></p><p>此时checkout的别名就为co， 可以直接git co，等价于之前的git checkout</p><p>想定义成什么你可以随心所欲，甚至还可以设置组合</p><p>git config –global alias.psm ‘push origin master’</p><p>此时输入psm，就等价于输入push origin master</p><p>你可以尝试输入这样</p><p>git config –global alias.lg “log –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –date=relative”</p><p>这样设置了你的git log查看日志的颜色</p></li><li><p><strong>查看自己的配置</strong></p><p><strong>git config -l</strong></p></li><li><p>修改git用的编辑器</p><p><strong>git config –global core.editor “vim” #设置Editor使用vim</strong></p></li><li><p>给git终端增加颜色</p><p><strong>git config –global color.ui true</strong></p></li><li><p><strong>git config –global core.quotepath false #设置中文文件名</strong></p></li></ol><p>git config都是修改~/.gitconfig文件的内容。</p><h2 id="diff操作-比较不同"><a href="#diff操作-比较不同" class="headerlink" title="diff操作 比较不同"></a>diff操作 比较不同</h2><p>diff很常用，比如下面这个场景</p><p>我们经常改动代码，但是有时候一个代码两天之后，你忘记了你做过什么改动，两天前的代码是什么样子，在提交之前需要确认以下你添加了什么新功能，这时候要用diff来查看你到底做了哪些改动。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409181942708.png" alt="image-20210409181942708" style="zoom:33%;"><p>红色为删除绿色为增加，git diff是比较当前文件和暂存区文件的差异，当前的暂存区文件就是你最后一次add的文件</p><p>你也许也想知道你在项目过程中，在某两次之间做过什么改动，可以比较两次commit之间的差异，比较两个分支之间的差异，比较暂存区和版本库之间的差异等。</p><p><strong>git diff &lt;$id1&gt; &lt;$id2&gt; 比较两次commit之间的差异</strong>，&lt;$id1&gt;tag或者SHA1值,同样也可以单独比较两个分支中的某个文件</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409182027293.png" alt="image-20210409182027293" style="zoom:33%;"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210409182049017.png" alt="image-20210409182049017" style="zoom:33%;"><p><strong>git diff <branch1><branch2> 比较两个分支之间的差异</branch2></branch1></strong></p><p><strong>git diff –staged 比较暂存区和版本库的差异</strong></p><h2 id="checkout-切换-撤销"><a href="#checkout-切换-撤销" class="headerlink" title="checkout 切换+撤销"></a>checkout 切换+撤销</h2><p><strong>checkout</strong>不止用作切换分支，还可以用来切换tag，切换到某次的commit</p><p><strong>git checkout v1.0  切换到v1.0的代码状态</strong></p><p><strong>git checkout ffafasdfasdf……</strong>      fafasdfasdf…是commit_id,是每次commit的SHA1值，可以通过git log看到每次commit的SHA1值</p><hr><p>还有一个撤销的作用</p><p>在一个分支开发小功能，刚写完一半，需求变了，而且是大变化，之前写的代码完全用不了了，好在还没git add进暂存区，</p><p><strong>git checkout a.md</strong></p><p>原文件还原，a.md还原到之前的状态</p><p>只能撤销还<strong>没有add进暂存区的文件</strong></p><h2 id="stash操作-暂存代码"><a href="#stash操作-暂存代码" class="headerlink" title="stash操作 暂存代码"></a>stash操作 暂存代码</h2><p>（学生可能不会出现的）场景：程序员正在项目的一个新的分支添加新功能，这时候突然出现一个紧急的bug要修复， 并且要立即修复。</p><p>但是你已经写了好多新功能的代码了，如果没提交，切换分支以后新代码就没了。</p><p>总不能把新写的那些代码提交了，理论上是可以，但是这回产生垃圾commit，原则上每次的commit都要有实际意义，代码只写了一般，没什么实际意义是不建议commit。</p><p>stash提供了一种方法，可以让我们先暂时切到别的分支，修复完bug再切换回来，代码也能保留</p><p>使用前提：没有commit，add过也可以使用</p><ul><li><p><strong>git stash</strong></p><p>把当前分支所有还没commit的代码先暂存，如果这个时候执行git status可以发现目前分支很干净，你的代码改动也看不见，实际上是存起来。</p></li><li><p><strong>git stash</strong></p><p>发现暂存区已经有了记录</p></li><li><p>当你切换分支，改完了bug提交后，再切换回这个分支，想要继续写代码</p><p><strong>git stash apply</strong></p><p>代码全部回来了</p></li><li><p>建议接着就把暂存区的这次stash记录删除</p><p><strong>git stash drop</strong></p></li><li><p>如果还想图方便</p><p><strong>git stash pop</strong></p><p>这个代码等同于上两个，apply+drop，意思是还原后直接删除记录</p></li><li><p><strong>git stash clear</strong></p><p>删除所有暂存区的记录，drop只是删除一条，drop后面跟着stash_id就是删除指定的记录，不加stash_id是删除最近一条</p></li></ul><h2 id="merge-amp-rebase-分支合并"><a href="#merge-amp-rebase-分支合并" class="headerlink" title="merge &amp; rebase 分支合并"></a>merge &amp; rebase 分支合并</h2><p>再other分支上完成了某个功能，需要合并到主分支master上</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git checkout <span class="hljs-literal">master</span><br>git merge other<br></code></pre></div></td></tr></table></figure><p>或者使用rebase</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git checkout <span class="hljs-literal">master</span><br>git rebase other<br></code></pre></div></td></tr></table></figure><p>merge指直接将other分支的内容并入master，相当于合并两个书架，直接将一个书架清空一个位置，放入另一个书架的书</p><p>rebase指将other分支修改的次序和自己改动的次序依次合并，相当于other书架的书向master书架移动的时候，按照购书顺序给其排序</p><p>未完待续…</p><p>​     </p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客图床的搭建——国内快速访问</title>
    <link href="/2021/04/08/%E5%8D%9A%E5%AE%A2%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/04/08/%E5%8D%9A%E5%AE%A2%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>昨天发布游记文章发生了很尴尬的事情，图片加载不出来。  </p><p>因为我是小白，并不清楚具体原因，后来经过试验后得到结论：  </p><p>我为了方便，直接用github的仓库当作图床，来保存我博客上的图片，由于我的设备是一直科学上网的，因此图片在我看来是一直可以加载出来的。</p><p>实际上对于不能翻墙的用户来说，我博客上的图片由于链接是github，因此加载的极慢——国内对于github一直是半墙的状态，十分不稳定，且速度很慢。</p><p>更别说最开始我竟然还上传了15M大小的图片了。</p><span id="more"></span><p>今日想了不少办法解决这个事情，找了许多的教程，其中包括Coding平台搭建图床，在尝试过程中我的RSA公钥一直出问题，最后不得不放弃。</p><p>但是我后来找到了一个很不错的方法——<strong>gitee（码云）</strong>+ PicGo +Typora<br>Gitee有5G的免费容量，而且国内访问速度还是很快的，很适合作为图床使用。</p><p>下面根据个人经历做一个对新手友好的教程。</p><h2 id="Gitee（码云）"><a href="#Gitee（码云）" class="headerlink" title="Gitee（码云）"></a>Gitee（码云）</h2><p>简单来讲，码云相当于一个国内版的Github，它的其他功能暂且不提，这里只用它搭建一个图床。</p><p><a href="https://gitee.com/">https://gitee.com/</a></p><p>若还没有Gitee账号，请先注册一个账号。</p><p>注册成功后，点击右上角加号</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408202539662.png" alt="image-20210408202539662"></p><p>选择新建仓库</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408202612734.png" alt="image-20210408202612734" style="zoom:33%;"><p>如下，设置仓库名称</p><p>是否开源选择公开，添加开源许可证根据提示选一个</p><p>勾选使用Readme文件初始化这个仓库，这样可以使仓库直接创建一个master分支。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408203011885.png" alt="image-20210408203011885" width="%70"><p>点击创建，创建成功。</p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>下载PicGo： <a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>windows用户下载exe文件，下载后找路径安装。</p><p>打开PicGo，下载gitee-uploader插件</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408203455640.png" alt="image-20210408203455640"></p><p>重启gitee-uploader，左侧图床设置栏内就多出了gitee</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408203638826.png" alt="image-20210408203638826" style="zoom:33%;"><p>打开图床设置栏的gitee</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408203824864.png" alt="image-20210408203824864"></p><p>如图，repo栏填写 gitee的用户名/刚刚建立的仓库</p><p>如我的名字是Trent-Liuy，我建立的想要当图床的仓库名为blogimage，我就填的Trent-Liuy/blogimage</p><p>branch栏填master</p><p>path栏可以填img，意思是在仓库中创建一个文件夹img，上传的图片保存在img中</p><hr><p>下面讲token栏如何填写。</p><p>回到gitee码云，打开右上角的设置</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408204123927.png" alt="image-20210408204123927" style="zoom:33%;"><p>在设置界面找到打开私人令牌</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408204252976.png" alt="image-20210408204252976" style="zoom:33%;"><p>点击生成新令牌</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408204334101.png" alt="image-20210408204334101"></p><p>只勾选projects，随便添加描述</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408204409888.png" alt="image-20210408204409888" style="zoom:33%;"><p>注意，生成的令牌内容要及时保存，关闭此窗口后就再也不能找到此令牌内容。之后要用只能再重新生成令牌。</p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408204631385.png" alt="image-20210408204631385" style="zoom:33%;"><h2 id="将刚刚复制的内容粘贴进PicGo的token里就可以了"><a href="#将刚刚复制的内容粘贴进PicGo的token里就可以了" class="headerlink" title="将刚刚复制的内容粘贴进PicGo的token里就可以了"></a>将刚刚复制的内容粘贴进PicGo的token里就可以了</h2><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408203824864.png" alt="image-20210408203824864" style="zoom:33%;"><p>点击确定，设置成功。</p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>下面介绍一个功能很强的markdown编辑工具Typora</p><p><a href="https://typora.io/">https://typora.io/</a></p><p>我之前一直用VScode变击md文件，虽然VScode有很多插件使用，但使用Typora后我还是觉得后者更香——毕竟是专业的markdown编辑工具。</p><p>下载成功后，文件——偏好设置或者直接ctrl+，进入设置</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210408205140536.png" alt="image-20210408205140536"></p><p>如图，对其进行如上设置，注意PicGo路径是你安装路径下的exe文件，安装成功后便大功告成了。</p><p>当你再写博客的时候，可以直接复制本地图片或者网络图片，直接在Typora上粘贴，PicGo会将图片自动上传到Gitee上，并且得到Gitee上的图片链接，自动生成Markdown图片格式。</p><p>十分的方便。</p><p>同时gitee的国内访问还是很快的，这样我的博客分享给不能翻墙的小伙伴时，博客里的图片就能很快的加载出来了。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——面向对象思考</title>
    <link href="/2021/04/08/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E8%80%83/"/>
    <url>/2021/04/08/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="面向过程开发"><a href="#面向过程开发" class="headerlink" title="面向过程开发"></a>面向过程开发</h2><p>一个软件系统由一系列过程构成。因而采用功能划分或模块分解的方法进行。  </p><h2 id="面向对象开发"><a href="#面向对象开发" class="headerlink" title="面向对象开发"></a>面向对象开发</h2><p>一个软件系统由一系列参与活动的对象构成。故需建立对象模型、动态模型和功能模型。</p><ul><li><strong>对象模型</strong>：描述对象的组织结构。是核心模型。</li><li><strong>动态模型</strong>：描述对象之间的交互行为。</li><li><strong>功能模型</strong>：描述对象的行为或状态变化。<span id="more"></span><ul><li><strong>对象模型：描述类和类之间的关系，包括：关联、聚合、组合、依赖、继承。</strong></li><li><strong>UML建模语言的类图能够描述对象(类）的组织结构和行为。</strong></li></ul></li></ul><h2 id="类间的关系描述方法"><a href="#类间的关系描述方法" class="headerlink" title="类间的关系描述方法"></a>类间的关系描述方法</h2><h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联关系(association)是一种通用的二元关系，对象间通过活动发生联系。例如，学生(Student)选学课程(Course)，教师(Faculty)教授课程(Course)，这些联系可以在UML中表示。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E8%80%831.png?raw=true" alt="haha"></p><blockquote><p>一个关联可以用两个类之间的实线表示。<br>可带描述关系的标签。<br>关联中的每个类可以指定一个数目或数字<br>区间，指出这个关系涉及多少个对象  </p></blockquote><ul><li>在Java代码中，关联关系可以用数据域或方法来实现。对于方法，一个类中的方法包含另一个类的参数。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Course[] courseList;<span class="hljs-comment">//一对多用数组实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCourse</span><span class="hljs-params">( Course c)</span></span>&#123; …… &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Course</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Student[] classList;<br>    <span class="hljs-keyword">private</span> Faculty faculty;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">( Students s)</span></span>&#123; …… &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFaculty</span><span class="hljs-params">( Faculty f)</span> </span>&#123; …… &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Faculty</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Course[] courseList;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCourse</span><span class="hljs-params">( Course c)</span></span>&#123; …… &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>如果学生或教师不需要知道课程的信息，可以去掉courseList域，形成单向关联。这时可将Student类和Faculty类中的数据域courseList和addCourse方法去掉。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E8%80%832.png?raw=true" alt="haha"></li></ul><h4 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h4><p>同一个类的对象间存在关联，称自关联。例如，一个人有一个领导。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E8%80%833.png?raw=true" alt="haha"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Person supervior；<br>    ……<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>聚合关系(aggregation)是一种拥有关系，表示整体与部分之间的关系，即<strong>has-a</strong>的关系。所有者成为聚集者，从属对象称为被聚集者。<strong>在聚合关系中，一个对象可以被多个聚集者拥有(Weak has a)。</strong></p><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合关系(composition)是一种隶属关系，表示从属者强烈依赖于聚集者。<strong>一个从属者只能被一个聚集者所拥有，聚集者负责从属者的创建和销毁(Strong has a)。</strong><br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%833.png?raw=true" alt="haha"></p><blockquote><p>一个Name对象只能为一个Person所有，但一个Address对象可以被多个Person共享</p></blockquote><ul><li><p>聚合关系和组合关系在代码中通常表示为聚集类中的数据域，如上图中的关系可以表示为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span></span>&#123;<br><br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Name name;<br>    <span class="hljs-keyword">private</span> Address address;<br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span></span>&#123;<br><br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>对于组合关系，聚集者往往负责对从属者的创建和销毁，而聚集关系则不是</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Name name;<br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(Address a)</span></span>&#123;<br>name = <span class="hljs-keyword">new</span> Name();<br>address = a;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>Address对象是传递进来的一个引用，而Name对象是在Person对象创建时才创建。<br>当Person对象被析构时，Name对象也被析构，而Address对象可能还存在</p></blockquote></li></ul><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>依赖关系（dependency）指的是两个类之间一个（称为client）依存另一个（称为supplier）的关系。<br>在UML中，从client画一条带箭头的虚线指向supplier类<br>例如，可以向容器类ArrayList添加对象，因此ArrayList和Object之间的关系可以用依赖描述。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%835.png?raw=true" alt="haha"><br>依赖关系在代码中通常表示为client类的成员函数以supplier类型的对象为参数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object o)</span></span>&#123;<br>       …<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>继承关系(inheritance)表示子类与父类之间的is-a关系。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%836.png?raw=true" alt="[haha](6)"></p><blockquote><p>通过继承，子类可以重用父类的数据和代码。</p></blockquote><h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>实现关系(realization)表示类和接口之间的关系。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%837.png?raw=true" alt="[haha](7)"></p><hr><h2 id="类的设计原则"><a href="#类的设计原则" class="headerlink" title="类的设计原则"></a>类的设计原则</h2><ul><li>确定系统中的类</li><li>建立类之间的关系</li><li>描述每个类的属性和方法</li><li>编写类的代码</li><li>例如建立一个借方和贷款的模型，借方是要贷款的人，人有姓名和地址，因此可以确定以下类：<ul><li>人Person</li><li>姓名Name</li><li>地址Address</li><li>借方Borrow</li><li>一笔贷款Loan</li></ul></li></ul><h3 id="分析类的关系"><a href="#分析类的关系" class="headerlink" title="分析类的关系"></a>分析类的关系</h3><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%838.png?raw=true" alt="[haha](8)"></p><ul><li>Person对象包含Name对象和Address对象，Person和Name之间为组合关系，Person和Address之间为聚集关系</li><li>Borrower继承Person</li><li>Borrower对象包含一笔贷款，Borrower和Loan之间为组合关系。</li></ul><h3 id="设计实例-贷款的类模型"><a href="#设计实例-贷款的类模型" class="headerlink" title="设计实例-贷款的类模型"></a>设计实例-贷款的类模型</h3><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%80%9D%E8%80%839.png?raw=true" alt="[haha](9)"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面向对象思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>准程序员和女朋友在武汉</title>
    <link href="/2021/04/07/%E6%AD%A6%E6%B1%89%E6%81%8B%E7%88%B1%E5%AD%A3/"/>
    <url>/2021/04/07/%E6%AD%A6%E6%B1%89%E6%81%8B%E7%88%B1%E5%AD%A3/</url>
    
    <content type="html"><![CDATA[<p>更新内容：解决国内网络访问无法加载图片的情况<br>解决方案：<a href="https://trent-liu.github.io/2021/04/08/%E5%8D%9A%E5%AE%A2%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/">https://trent-liu.github.io/2021/04/08/%E5%8D%9A%E5%AE%A2%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</a><br><strong>综述</strong>  </p><p>  　　2021年4月2日下午，湖南省长沙市中南大学的小杨同志冒雨深入武汉市进行小刘同志的学习生活及安全工作视察。  </p><p>  　　刘同学全程陪同。刘同学首先向杨同志汇报了近期对其的想念之情及其美貌的不吝夸赞以及对未来三天的吃喝规划等。刘同学特别介绍了江汉路步行街和光谷的美食之多，为此做了许多工作。特别是今年，刘同学较去年的仓促准备，此次准备相对充分，挑选了以下一些特色美食：肉蟹煲，蔡林记，半秋山，夏氏砂锅，鲍师傅等，想法颇多。杨同志听完后露出了满意的笑容，肯定了小刘能的吃货本色，做足大量工作无私养胖自己和女朋友的行为值得颂赞，希望继续把吃喝玩乐做好，使双方继续展开体重的增长。  </p><span id="more"></span><p>  　　接着杨同志在绵绵的细雨中随小刘乘坐地铁来到了江汉路步行街，并在接下来的两天基本逛了个遍，后又来到光谷，视察了刘同学的校园生活及附近美食。觉得虽然人很多，但热闹非凡，同时也要求小刘还要加强身体素质锻炼，坚决杜绝继续变胖，并结合当前形势特别指出，由于异地恋十分不易，一定要在思想建设工作上下功夫，做好洁身自好努力学习等工作，要利用QQ、微信等形式加强沟通，共筑恋爱防护墙。杨同志的一席话，体现了其对刘同学的关心、关爱。我将不辜负领导希望，把生活中的各项工作继续做好、做扎实。</p><hr><p>文末贴一些女朋友精心修的图<br>想必会和下文的直男拍照风形成<strong>鲜明对比</strong>  </p><p><strong>记录一些吃吃喝喝玩乐的日子</strong></p><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><blockquote><p>华中科技大学站相遇——得到老板从长沙带来的一大包茶颜的茶包  </p></blockquote><blockquote><p>来到江汉路步行街，细雨蒙蒙<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/wx_camera_1617354771428.jpg" alt="wx_camera_1617354771428" width="50%"></p></blockquote><blockquote><p>晚上去江汉路的M+购物中心吃的胖哥俩肉蟹煲，七点半才到，但是前面还有四十桌，等到九点才入座<br>早就听舍友说味道不错，吃了以后确实不错，但是不愧是南方，微辣就让我这个青岛小哥受不了啦<br>第一次吃就吃肉蟹煲，但是吃螃蟹还是有点点麻烦，下次尝试牛蛙煲<br>鸡爪好吃，但是吃多了有点腻  </p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210402_203719.jpg" alt="IMG_20210402_203719" width="44%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210402_204151.jpg" alt="IMG_20210402_204151" width="25%"></blockquote><blockquote><p>晚上买了无骨鸡爪，糖葫芦和周黑鸭，用我的笔记本一起看了料理鼠王，童年回忆</p></blockquote><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><blockquote><p>第二天去地铁站接了小杨的闺蜜，买了一些廖记棒棒鸡，然后一起去万松园吃夏氏砂锅，据说是不错的湖北菜。<br>没想到前面有二十桌，又到了熟悉的等位时间<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_122551.jpg" alt="IMG_20210403_122551" width="40%"></p></blockquote><blockquote><p>点了牛蛙砂锅，味道很不错，有点油腻但是山东大汉狂喜<br>许久没吃的烤鸭，荷叶饼小葱烤鸭甜面酱永远的神！！  </p></blockquote><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_124311.jpg" alt="IMG_20210403_124311" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_124314.jpg" alt="IMG_20210403_124314" width="40%"><blockquote><p>香辣蟹烩面，也是听说很不错，吃了这一大碗让山东汉子辣哭啦<br>锅边馍，挺好吃，但是没想到底味是偏甜的。  </p></blockquote><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_125557.jpg" alt="IMG_20210403_125557" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_131030.jpg" alt="IMG_20210403_131030" width="40%"><blockquote><p>回江汉路的时候给小杨买了束雏菊<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_-2d4849fdde6c9cba..jpg" alt="Cache_-2d4849fdde6c9cba." width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_713b9e32662d1445..jpg" alt="Cache_713b9e32662d1445." width="40%"></p></blockquote><blockquote><p>晚上准备出去吃饭的时候，一出门当场愣住。<br>锣鼓喧天，鞭炮齐鸣，红旗招展，人山人海<br>人多的太吓人啦  </p></blockquote><blockquote><p>在人群中挤到了大洋百货，又一次熟悉的等位<br>为减肥（并没有）的我点了份金枪鱼沙拉  　　西冷牛排<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_200541.jpg" alt="IMG_20210403_200541" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_201200.jpg" alt="IMG_20210403_201200" width="40%"></p></blockquote><blockquote><p>我很喜欢的牛奶绵绵冰　　　　　　　　　半熟芝士<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_204447.jpg" alt="IMG_20210403_204447" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_200728.jpg" alt="IMG_20210403_200728" width="40%"></p></blockquote><blockquote><p>小杨喜欢的缤纷水果披萨<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210403_203542.jpg" alt="IMG_20210403_203542" width="40%"></p></blockquote><blockquote><p>吃完后一起去看了个电影<br>万万没想到小杨背着我先看了哥斯拉大战金刚<br>呜呜<br>然后就一起看了我的姐姐  </p></blockquote><hr><blockquote><p>非专业人士对电影不做点评，但是莫名突然想起了知乎上各种有关山东不让女性上桌吃饭的谣言<br>山东的酒桌文化深入生活，但男女分桌的目的一方面方便喝酒的人吹牛拉胡，另一方面也防止女性和儿童闻烟味之类的<br>往往是喝酒抽烟的男性在一桌吃饭，妇女儿童在另一桌吃饭<br>在我能喝酒之前我也是妇女桌的常客<br>跑题了跑题了<br>总之我觉得绝大部分山东好青年还是很尊重女同志的  </p></blockquote><hr><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><blockquote><p>一起去买了鲍师傅，鲍师傅的小贝还是那么好吃  </p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210404_150611.jpg" alt="IMG_20210404_150611" width="40%">  </blockquote><blockquote><p>一起去吃了蔡林记，第一次带小杨吃了正宗的热干面，豆皮，蛋酒，热干面yyds！！  </p></blockquote>   <img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210404_112903.jpg" alt="IMG_20210404_112903" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210404_112907.jpg" alt="IMG_20210404_112907" width="40%"><blockquote><p>下午一起回到了光谷，带着小杨逛了逛我的校园，骑上共享小电动，拉着女朋友到处乱窜<br>有点小激动<br>这是我来到华中大以后第一次不是<strong>载男生</strong>  </p></blockquote><blockquote><p>森林大学里这种阴雨天气总是有些冷冽，逛了一大圈没想好带小杨吃什么，吉野家周麻婆还是我很喜欢的越南粉，最后去了百景园<br>请小杨吃了锅盔，还买了她最喜欢的甜红烧肉，玉米水饺和黑米糕<br>这张图我忘记拍啦<br>晚上一起逛了光谷步行街，我基本每个周都去玩的地方，但是这次终于有女朋友陪着啦，给小杨买了个兔兔，对的,和我一样可爱<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_-27cfa259814a90df..jpg" alt="Cache_-27cfa259814a90df." width="40%">   </p></blockquote><blockquote><p>夜宵狂魔lyk买了一大碗炸串,据说这个胡炸炸还是个武汉老店    </p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210404_203731.jpg" alt="IMG_20210404_203731" width="40%"></blockquote><hr><blockquote><p>最后一天，一起去做了蛋糕<br>那种看上去很简单但是做起来很难的工作<br>我觉得我抹的挺好看<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210405_120431.jpg" alt="IMG_20210405_120431" width="40%"><br>和小杨一起做的蛋糕，画的图案，提前纪念一千天纪念日  </p></blockquote><p><strong>高二——大二了</strong>  </p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_294eccba82cb0c5c..jpg" alt="Cache_294eccba82cb0c5c." style="zoom:25%;">  <blockquote><p>吉野家的饭<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/IMG_20210405_135648.jpg" alt="IMG_20210405_135648" width="40%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_42ba23b3e6b3218a..jpg" alt="Cache_42ba23b3e6b3218a." width="40%/">  </p></blockquote><blockquote><p>下午四点半和小杨分别<br>有些些难过，异地恋总是这样，披着恋爱的皮过着单身的生活<br>感觉能坚持下去<br>有爱就可以吧  </p></blockquote><blockquote><p>篇末附一张合照(别骂了一定减肥——恋爱使我肥胖)<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/Cache_4efbb5ccbd6d4139..jpg" alt="Cache_4efbb5ccbd6d4139." width="40%/">  </p></blockquote><hr><p>女朋友的图  </p><p>&lt;<img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795804095.jpeg" alt="1617795804095" width="25%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795808363.jpeg" alt="1617795808363" width="25%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795806185.jpeg" alt="1617795806185" width="25%"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795814863.jpeg" alt="1617795814863" width="25%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795810524.jpeg" alt="1617795810524" width="25%"><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/1617795812595.jpeg" alt="1617795812595" width="25%"></p><p><strong>异地恋是挺辛苦的，<br>但我不希望有谁因为一时的距离，<br>和一些细枝末节的疏忽，<br>错过本该厮守一生的人。<br>“距离之于爱情，就像风之于火，<br>它吹熄那些微弱的，它助长那些强烈的。”</strong><br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/v2-98b6b849a347031ff2a458091f0f2a37_r.jpg" alt="v2-98b6b849a347031ff2a458091f0f2a37_r" style="zoom: 33%;">  </p><p><strong>完</strong></p>]]></content>
    
    
    <categories>
      
      <category>大学生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——异常处理</title>
    <link href="/2021/03/31/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2021/03/31/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li>异常(Exception)：又称为例外，是程序在<strong>运行过程中发生的非正常事件</strong>，其发生会影响程序的正常执行。</li><li>当一个方法中发生错误时，将<strong>创建</strong>一个<strong>对象</strong>并将它<strong>交给运行时系统</strong>，此对象被称为异常对象(exception object)</li><li>创建异常对象并将它交给运行时系统被称为<strong>抛出一个异常</strong>(throw an exception) 。</li></ul><h3 id="异常产生的原因"><a href="#异常产生的原因" class="headerlink" title="异常产生的原因"></a>异常产生的原因</h3><ul><li>Java虚拟机同步检测到一个<strong>异常的执行条件</strong>，间接抛出异常，例如：<ul><li>表达式违反了正常的语义，例如整数除零。</li><li>通过<strong>空引用</strong>访问<strong>实例变量或方法</strong>。</li><li>访问数组超界。</li><li>资源超出了某些限制，例如使用了过多的内存。</li></ul></li></ul><span id="more"></span><ul><li>显式地执行throw语句抛出异常</li></ul><hr><h3 id="异常的抛出都是由throw语句直接或间接抛出"><a href="#异常的抛出都是由throw语句直接或间接抛出" class="headerlink" title="异常的抛出都是由throw语句直接或间接抛出"></a>异常的抛出都是由throw语句直接或间接抛出</h3><ol><li><p>程序运行时的逻辑错误导致异常间接抛出，例如通过空引用访问实例变量和方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123; &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>       A o = <span class="hljs-keyword">null</span>;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">通过空引用访问实例方法, 会间接地抛出异常NullPointerException</span><br><span class="hljs-comment">*/</span>       <br>       o.m1(); <br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E5%BC%82%E5%B8%B81.png" alt="异常1"></p></li><li><p>程序在满足某条件时，用throw语句直接抛出异常，如</p><blockquote><p>if(满足某条件){<br>  throw new Exception(“异常描述信息”);}</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>   <span class="hljs-comment">//由于main方法里抛出的异常没有被处理,因此在main方法必须加上异常声明throws Exception</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>       <span class="hljs-keyword">int</span> i = <span class="hljs-keyword">new</span> Scanner(System.in).nextInt();<br>       <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">10</span>)&#123; <span class="hljs-comment">//假设应用逻辑要求用户输入整数不能大于10</span><br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Input value is too big&quot;</span>); <span class="hljs-comment">//显式地用throw抛出异常</span><br>       &#125;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>这里的main函数，加异常声明，但前一个例子没有加，因为一个是必检异常，一个不是。<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E5%BC%82%E5%B8%B82.png" alt="异常2"></p></blockquote><h3 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h3><ul><li>Java异常都必须<strong>继承Throwable</strong>的直接或间接子类。用户<strong>通过继承自定义异常</strong>。</li><li>Java的异常分为二大类：从Exception派生的是<strong>程序级错误</strong>，<strong>可由程序本身处理</strong>；从Error派生是<strong>系统级错误</strong>，程序可不用处理（也基本上<strong>处理不了</strong>，例如JVM内存空间不够）。</li><li>Exception的子类里，除了RuntimeException这个分支外，其他的都是<strong>必检异常（即：要么在函数里用catch子句捕获并处理，要么在所在函数加上异常声明</strong>，PPT第5页例子）。 RuntimeException的子类是<strong>非必检异常</strong>（PPT第4页例子）（这类异常一般我们是不处理的，因为会很判断会出现什么问题，而且有些异常你也无法运行时处理，比如空指针。）<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E5%BC%82%E5%B8%B83.png" alt="异常3">  </li></ul><hr><ul><li>运行时异常系统处理异常的过程如下：<ul><li>当发生异常时，运行时系统按与方法调用次序相反的次序搜索调用堆栈，寻找一个包含可处理异常的代码块的方法，这个代码块称为异常处理器(exception handler)，即try/catch语句</li><li>如果被抛出的异常对象与try/catch块可以处理的类型匹配，运行时系统将异常对象传递给它，这称为捕获异常(catch the exception)</li><li>如果运行时系统彻底搜索了调用堆栈中的所有方法（一直返回到了JVM还没有处理好），但没有找到合适的异常处理器，程序则终止<br><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E5%BC%82%E5%B8%B84.png" alt="异常4"></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallStack</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;in methodA&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;  <br>methodB(); <br>&#125; <br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>System.out.println(e);   <span class="hljs-comment">//方法A捕获异常兵处理，这里只是简单打印出异常对象e</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;end methodA&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;in methodB&quot;</span>);<br>        methodC();    <span class="hljs-comment">//方法B没有处理，顺着调用栈向上抛到方法A</span><br>        System.out.println(<span class="hljs-string">&quot;end methodB&quot;</span>);<br>    &#125;<br><br>     <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodC</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;in methodC&quot;</span>);<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;        <span class="hljs-comment">//方法C出现异常，抛出异常，但没有处理，顺着调用栈向上抛到方法B</span><br>        System.out.println(i);  <br>        System.out.println(<span class="hljs-string">&quot;end methodC&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;in methodMain&quot;</span>);<br>        methodA();<br>        System.out.println(<span class="hljs-string">&quot;end methodMain&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/%E5%BC%82%E5%B8%B85.png" alt="异常5"></p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img/image-20210411202840760.png" alt="image-20210411202840760"></p><h3 id="非必检异常-Unchecked-Exception"><a href="#非必检异常-Unchecked-Exception" class="headerlink" title="非必检异常(Unchecked Exception)"></a>非必检异常(Unchecked Exception)</h3><ul><li>非必检异常是<strong>运行时异常(RuntimeException)<strong>和</strong>错误(Error)类及它们的子类</strong>, 非必检异常在方法里可不捕获异常同时方法头<strong>可不声明异常，编译器不会报错</strong>。但该发生的异常还是要发生。<h3 id="其它的异常称为必检异常-Checked-Exception"><a href="#其它的异常称为必检异常-Checked-Exception" class="headerlink" title="其它的异常称为必检异常(Checked Exception)"></a>其它的异常称为必检异常(Checked Exception)</h3></li><li>非必检异常，编译器确保<strong>必检异常被捕</strong>获或<strong>声明（即要不在方法里捕获异常，要不在方法头声明异常）</strong><ul><li><strong>捕获</strong>：方法可以通过try/catch语句来捕获异常</li><li><strong>声明</strong>：方法可以在方法头使用throws子句声明可能抛出异常</li></ul></li><li>方法可以抛出的异常<ul><li>方法里调用throw语句直接抛出的任何异常</li><li>调用另一个方法时，由被调用方法间接抛出的异常</li></ul></li></ul><h2 id="异常声明，抛出及保护"><a href="#异常声明，抛出及保护" class="headerlink" title="异常声明，抛出及保护"></a>异常声明，抛出及保护</h2><h3 id="异常声明，抛出异常"><a href="#异常声明，抛出异常" class="headerlink" title="异常声明，抛出异常"></a>异常声明，抛出异常</h3><ul><li>异常声明：由方法声明可能抛出的异常</li><li><strong>如果方法不捕获其中发生的必检异常，那么方法必须声明它可能抛出的这些异常</strong></li><li>通过<strong>throws</strong>子句<strong>声明</strong>方法<strong>可能抛出的异常</strong>。throws子句由throws关键字和一个以逗号分隔的<strong>列表</strong>（可能很多异常种类）组成，列表列出此方法抛出的所有异常，即<strong>一个方法可以声明多个可能抛出的异常</strong><br>例如<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;  <br>    <span class="hljs-comment">//声明可能抛出的异常</span><br>InputStream in = <br><span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(“C:\\<span class="hljs-number">1.</span>txt”));<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>抛出异常</li><li>抛出异常有二种情况</li></ul><ol><li>间接抛出：执行语句（如new FileInputStream(new File(“C:\1.txt”)); ）或调用方法时由<strong>被调用方法抛出的异常</strong>（如上），当前发生异常的方法自动抛出</li><li>显式直接抛出，人为手动抛出<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> i = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>.next<span class="hljs-constructor">Int()</span>;<br>         <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">10</span>)&#123; <span class="hljs-comment">//假设应用逻辑要求用户输入整数不能大于10</span><br> throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Exception(<span class="hljs-string">&quot;Input value is too big&quot;</span>)</span>; <br>         &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>上图就是调用throw，显式</p></blockquote></li></ol><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;<br>statements<br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType1 id1) &#123;<br>statements1<br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType2 id2) &#123;<br>statements2<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>statements3<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>当包含catch语句时，finally子句是可选的<br>当包含finally子句时，catch子句是可选的  </p></blockquote><ul><li>将可能抛出异常的语句放在try块中。<strong>当try块中的语句发生异常时</strong>，异常由后面的<strong>catch块捕获处理</strong>。</li><li>一个try块后面可以有<strong>多个catch块</strong>。每个catch块可以处理的异常类型由异常类型参数指定。异常参数类型必须是从<strong>Throwable派生的类</strong>。</li><li>当try块中的语句抛出异常对象时，运行时系统将调用第一个异常对象类型与参数类型匹配的catch子句。<strong>如果被抛出的异常对象可以被合法地赋值给catch子句的参数，那么系统就认为它是匹配的（和方法调用传参一样，子类异常对象匹配父类型异常参数类型）</strong>。</li><li><strong>无论try块中是否发生异常，都会执行finally块中的代码</strong>。通常用于关闭文件或释放其它系统资源。</li><li><strong>处理异常时</strong>，也可以抛出新异常，或者处理完异常后继续向上（本方法调用者）抛出异常以让上层调用者知道发生什么事情：链式异常。</li><li>当一个catch匹配时，别的就都被跳过了。</li></ul><blockquote><p>读取整个文件的操作，其中就应用了上述。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">read</span><span class="hljs-params">(String filePath)</span></span>&#123;<br>   <br>    String s = <span class="hljs-keyword">null</span>;<br>    BufferedReader reader = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//BufferedReader一次读文本文件一行，也是一个类。</span><br>    <br>    <span class="hljs-keyword">try</span>&#123;<br>        StringBuffer buf = <span class="hljs-keyword">new</span> StringBuffer();<br>        reader <br>        = <span class="hljs-keyword">new</span> BufferedReader<br>        (<span class="hljs-keyword">new</span> InputStreamReader<br>        (<span class="hljs-keyword">new</span> FileInputStream   <span class="hljs-comment">//这一句可能抛出FileNotFoundException。</span><br>        (<span class="hljs-keyword">new</span> File(filePath))));  <br>        <span class="hljs-comment">//这个操作记住就可以，reader就得到了整个文件</span><br>        <br>        <span class="hljs-keyword">while</span>( (s = reader.readLine()) != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//readLine方法读取到文件末尾返回null</span><br>            buf.append(s).append(<span class="hljs-string">&quot;\n&quot;</span>); <span class="hljs-comment">//readLine自动去掉\n，因此结尾要再加上</span><br>        &#125;<span class="hljs-comment">//readLine可能抛出IOException</span><br> s = buf.toString().trim();<br>    &#125; <br>    <br>    <span class="hljs-keyword">catch</span> (FileNotFoundException e)  <span class="hljs-comment">//上文new FileInputStream可能抛出的</span><br>    &#123; <br>        e.printStackTrace();  <span class="hljs-comment">//打印调用栈</span><br>    &#125; <br>    <br>    <span class="hljs-keyword">catch</span> (IOException e)    <span class="hljs-comment">//上文readLine可能抛出的</span><br>    &#123; <br>        e.printStackTrace();<br>    &#125;<br>    <br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span>(reader != <span class="hljs-keyword">null</span>) &#123;   <br>    <span class="hljs-keyword">try</span> &#123; reader.close()&#125;   <span class="hljs-comment">//也可能发生异常</span><br>    <span class="hljs-keyword">catch</span> (IOException e) &#123; e.printStackTrace();&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//由于reader打开后，执行readLine时可能抛出异常，因此在finally块里关闭流是最合适的地方。</span><br>    <span class="hljs-comment">//注意close也可能抛出异常，因此还得用try/catch处理</span><br><br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>方法read内部已经处理了所有可能发生的异常，因此方法首部不需要加throws声明。同时外部read方法的调用代码不需要try/catch</p></blockquote><h3 id="方法异常声明与方法内捕获处理异常的关系"><a href="#方法异常声明与方法内捕获处理异常的关系" class="headerlink" title="方法异常声明与方法内捕获处理异常的关系"></a>方法异常声明与方法内捕获处理异常的关系</h3><ol><li>方法内部处理了所有异常，没有throws声明<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowDeclaration1</span> </span>&#123;<br>    <span class="hljs-comment">//由于m1内部处理了所有异常，因此不用加throws声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//执行可能抛出异常的语句</span><br>        &#125;<br>        <span class="hljs-keyword">catch</span>(Throwable e)&#123; <span class="hljs-comment">//由于Throwable是所有异常的父类，因此这里可以捕获所有异常</span><br>            <span class="hljs-comment">//处理异常</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span></span>&#123;<br>        m1(); <br>        <span class="hljs-comment">//由于m1没有异常声明，因此m1的调用者不需要try/catch</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>方法内部可能抛出的异常没有处理，要加throws声明<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThrowDeclaration2</span> </span>&#123;<br>    <span class="hljs-comment">//m1内部可能抛出的异常没有处理，因此必须加throws声明</span><br>    <span class="hljs-comment">//throws声明就是告诉方法的调用者，调用本方法可能抛出什么异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        <span class="hljs-comment">//执行可能抛出异常IOException的语句,但没有try/catch</span><br><br>    &#125;<br></code></pre></div></td></tr></table></figure>如上的m1没有处理异常，m2有两个选择<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//由于m1有异常声明，因此m2调用m1时有第一个选择：1 用try/catch捕获和处理异常</span><br><span class="hljs-comment">//这时m2就不用加throws异常声明</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            m1();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>或者<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//由于m1有异常声明，因此m2调用m1时有第2个选择：</span><br>    <span class="hljs-comment">//2 也在方法头声明异常，方法体里不捕获异常。</span><br>    <span class="hljs-comment">//这时如果有方法m3调用m2, m3也就面临二个选择：声明异常或者在m3里捕获异常</span><br>    m1();<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><blockquote><p>非必检异常(Unchecked Exception)是运行时异常(RuntimeException)和错误(Error)类及它们的子类, 方法<strong>可以不捕获同时不声明非必检异常</strong>（注意只是编译器不检查了，但如果真的有异常该抛出还是会抛出）<br>10/0这种异常<br><strong>方法如果声明或捕获非必检异常也没问题</strong></p></blockquote><hr><h3 id="异常的捕获顺序"><a href="#异常的捕获顺序" class="headerlink" title="异常的捕获顺序"></a>异常的捕获顺序</h3><ul><li>每个catch<strong>根据自己的参数类型</strong>捕获相应的类型匹配的异常。</li><li>由于父类引用参数可接受子类对象，因此，<strong>若把Throwable作为第1个catch子句的参数，它将捕获任何类型的异常，导致后续catch没有捕获机会。</strong></li><li>通常将继承链最底层的异常类型作为第1个catch子句参数，次底层异常类型作为第2个catch子句参数，以此类推。<strong>越在前面的catch子句其异常参数类型应该越具体</strong>。以便所有catch都有机会捕捉相应异常。<blockquote><p>异常类，最底层的类放入第1个catch子句，最后一个放Throwable</p></blockquote></li><li>无论何时，throw以后的语句都不会执行。</li><li><strong>无论同层catch子句是否捕获、处理本层的异常</strong>（即使在catch块里抛出或转发异常），<strong>同层的finally总是都会执行。</strong></li><li><strong>一个catch捕获到异常后，同层其他catch都不会执行</strong>，然后执行同层finally。</li></ul><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.lang.System;<br><span class="hljs-keyword">import</span> java.lang.ArithmeticException;<br><span class="hljs-keyword">public</span>  <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-comment">//各种Exception都被捕获，函数无须声明异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;  <br>        <span class="hljs-keyword">int</span>   r=<span class="hljs-number">0</span>;  <span class="hljs-comment">//2</span><br>        <br>        <span class="hljs-keyword">try</span>&#123;  <br><span class="hljs-comment">//自己抛出异常对象 </span><br><span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)   <span class="hljs-comment">//3 发现异常</span><br>        <span class="hljs-keyword">throw</span>  <span class="hljs-keyword">new</span> ArithmeticException( ); <span class="hljs-comment">//抛出这个异常      </span><br>        <br>        r=x/y; <br>        &#125;<br>        <span class="hljs-keyword">catch</span>(ArithmeticException  ae)   <span class="hljs-comment">//4  从具体异常到不具体，catch发现就是这个异常</span><br>        &#123;   <br>            System.out.print(ae.toString( ));   <span class="hljs-comment">//5</span><br>            <span class="hljs-keyword">throw</span> ae;   <br>            <span class="hljs-comment">//处理完异常后可以继续抛出异常，交给上层调用者继续处理。</span><br>            <span class="hljs-comment">//注意即使这里抛出异常，同层的finally仍会执行</span><br>        &#125; <br>        <span class="hljs-keyword">catch</span>(Exception  ae)<br>        &#123;<span class="hljs-comment">//捕获各种Exception：若是第1个catch，则后续的catch子句无机会捕获   </span><br>    System.out.print(ae.toString( ));   <br>        &#125; <br>        <span class="hljs-keyword">finally</span>&#123;  r=-<span class="hljs-number">1</span>; &#125;  <span class="hljs-comment">//6   //无论是否有异常，r=-1</span><br>        <br>        <span class="hljs-keyword">return</span>  r;       <span class="hljs-comment">//7        </span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title">main</span><span class="hljs-params">(String[ ] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;   <br>            div(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>);   <br>            &#125; <span class="hljs-comment">//1</span><br>        <span class="hljs-keyword">catch</span>(Throwable  ae) &#123; <span class="hljs-comment">//任何异常都被捕获，包括Error类型异常</span><br>            <span class="hljs-comment">//8  div方法内的继续抛出了异常，交给了上层调用者继续处理</span><br>System.out.print(ae.toString( ));   <br>        &#125;<span class="hljs-comment">//虽然div没有异常声明，再main里调用div也用了try/catch</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><ul><li>自定义异常类必须继承Throwable或其子类。//太抽象了</li><li>自定义异常类<strong>通常继承Exception及其子类</strong>，因为Exception是程序<strong>可处理</strong>的类。</li><li>如果自定义异常类在父类的基础上增加了成员变量，<strong>通常需要覆盖toString函数。</strong>//通常返回描述异常的字符串</li><li>自定义异常类通常不必定义clone：捕获和处理异常时通常只是引用异常对象而已。//不需要clone，仅仅引用。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span>  java.lang.<span class="hljs-keyword">Exception</span>;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ValueBeyondRangeException extends <span class="hljs-keyword">Exception</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">value</span>, range;<br>    <span class="hljs-built_in">public</span> ValueBeyondRangeException(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> r)&#123; <span class="hljs-keyword">value</span>=v; range=r; &#125;<br>    <span class="hljs-built_in">public</span> toString( )&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> + ” beyonds “ + range;<br>    &#125;<br>&#125;<br>//使用例子,自定义了一个异常<br><span class="hljs-type">int</span> v = <span class="hljs-number">1000</span>，range = <span class="hljs-number">100</span>；<br>try&#123; <br><span class="hljs-keyword">if</span>(v &gt; range)<br>throw <span class="hljs-built_in">new</span> ValueBeyondRangeException （v,range）;<br>&#125;<br>catch(ValueBeyondRangeException e)&#123; <br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(e.toString( )); <br>    &#125;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>异常处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——抽象类及接口</title>
    <link href="/2021/03/31/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/03/31/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>子类继承父类后，通常会添加新的属性和方法。因此沿着继承链<strong>越往下继承的子类其属性和方法越来越具体</strong>。相反，越<strong>上层的祖先类其实现越抽象</strong>，甚至无法给出具体实现。一个长方形图形有面积，但其祖先类GeometricObject的getArea()方法可能没法给出具体实现，这时可以定义成抽象方法。</li><li>Java可定义<strong>不含方法体</strong>的方法（由子类覆盖），其方法体由子类根据具体情况实现，这样的方法称为抽象方法(abstract method)，包含抽象方法的类必须是抽象类(abstract clas给子类的一个约束s)。</li><li>抽象类和抽象方法的声明<strong>必须加上abstract关键字</strong>。<span id="more"></span></li><li>抽象方法的<strong>意义</strong>：加<strong>给子类的一个约束</strong>。例如Circle类和Rectangle类计算面积<strong>必须使用父类规定的函数签名</strong>。这样可以充分利用多态特性使得代码变得<strong>更通用</strong><br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8A%BD%E8%B1%A1%E7%B1%BB1.png?raw=true" alt="RUNOOB 图标">  <blockquote><p>包含抽象方法的类必须是抽象类<br>抽象类和抽象方法必须用abstract关键字修饰<br>没有包含抽象方法的类也可以定义成抽象类  </p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeometricObject</span></span>&#123;<br>    <span class="hljs-comment">//属性和方法定义</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPerimeter</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GeometricObject</span></span>&#123;<br>    <span class="hljs-comment">//新的属性</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//给出具体实现</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPerimeter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//给出具体实现</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>抽象方法：使用<strong>abstract</strong>定义的方法或者<strong>接口中定义的</strong>方法（接口中定义的方法<strong>自动是抽象的</strong>，可以省略abstract）。</li><li>一个类C如果满足下面的任一条件，则该类包含抽象方法且是抽象类：<ol><li>类C显式地包含一个抽象方法的声明；</li><li>类C的父类中声明的抽象方法未在类C中实现；</li><li>类C所实现的接口中有的方法在类C里没有实现</li><li><strong>只要类C有一个未实现的方法（自己定义的或继承的），就是抽象类</strong>,new后的类一定不可以时抽象类。</li></ol></li><li>但是，一个不包含任何抽象方法的类，也可以定义成抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-comment">//抽象类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-comment">//抽象类</span><br>     <span class="hljs-comment">//B继承了二个抽象方法，但是只实现了m1,方法m2在B里还是抽象的，因此B必须是抽象类</span><br>     <span class="hljs-meta">@OverrideA</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span>&#123;       <span class="hljs-comment">//所有方法均实现，因此不是抽象类了</span><br>     <span class="hljs-comment">//C继承B，又实现了方法m2, 因此m1,m2二个方法在C里都有了具体实现</span><br>     <span class="hljs-comment">//因此C就是可以是具体类</span><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>     <br>     <span class="hljs-comment">//当然，C还可以继续覆盖B的m1，给出C的m1实现</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">//接口里方法编译器自动加上public abstract来修饰</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m4</span><span class="hljs-params">()</span></span>;<br> &#125;<br><br> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">I</span></span>&#123;<br>     <span class="hljs-comment">//class D声明实现了接口I，但只实现了一个接口方法m3</span><br>     <span class="hljs-comment">//接口方法m4在D里还是抽象的，因此D只能是抽象类</span><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123; &#125;<br> &#125;<br><br> <span class="hljs-comment">//类E继承D，并实现了另一个接口方法m4</span><br> <span class="hljs-comment">//因此类E是具体类</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">I</span></span>&#123; <span class="hljs-comment">//注意既然E继承了D，所以这里的implements I可以不写</span><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m4</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>     <span class="hljs-comment">//当然，E还可以继续覆盖D的m3，给出自己的的m3实现</span><br> &#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>只有实例方法可以声明为抽象方法</strong>（Java里所有实例方法自动是虚函数，因此Java里没有virtual关键字）。</li><li><strong>抽象类不能被实例化</strong>，即不能用new关键字创建对象（即<strong>new 右边的类型不能是抽象类</strong>）。<ul><li>但是抽象类可以作为<strong>变量声明类型</strong>、<strong>方法参数类型</strong>、<strong>方法返回类型</strong>（强烈建议）</li><li>为什么？因为一个抽象类型引用变量可以指向具体子类的对象</li></ul></li><li>抽象类可以定义构造函数，并可以被子类调用。</li><li>抽象类可以<strong>定义变量、非抽象方法</strong>并被子类使用（抽象类中可以先实现基础方法，供各种子类使用）</li><li><strong>抽象类的父类可以是具体类：自己引入了抽象方法</strong>。例如，具体类Object是所有类的祖先父类。  </li></ul><h2 id="接口-本文章均按JDK8标准"><a href="#接口-本文章均按JDK8标准" class="headerlink" title="接口(本文章均按JDK8标准)"></a>接口(本文章均按JDK8标准)</h2><ul><li>接口是<strong>公共静态常量（public,static,final）</strong>和<strong>公共抽象实例方法</strong>的集合。接口是<strong>能力、规范、协议</strong>的反映。</li><li>接口不是类：(1)<strong>不能定义构造函数</strong>；(2)<strong>接口之间可以多继承</strong>，类可implements<strong>多个</strong>接口。(3)和抽象类一样，<strong>不能new</strong>一个接口</li><li>语法：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">[modifier]  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interfaceName</span> </span>&#123;<br>             constant_declaration*   <br>             abstract_method_declaration* <br>      &#125;<br></code></pre></div></td></tr></table></figure></li><li>接口中的所有数据字段隐含为public static final</li><li>接口体中的所有方法隐含为public abstract  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I1</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>；<span class="hljs-comment">//可省略public static final</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">//可省略public abstract</span><br>&#125;<br></code></pre></div></td></tr></table></figure>等价<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I1</span></span>&#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>；  <span class="hljs-comment">//=1不可省略，因为它是final的，必须初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">( )</span></span>;   <span class="hljs-comment">//不可定义函数体，它是abstract</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>类和类之间是ISA关系，但是类和接口之间是实现关系。这种实现关系是<strong>CANDO</strong>关系。例如Airplane实现接口Flayer，意味着Airplane的实例CANDO Flyer<br>实例：  </li></ul><ol><li>接口<strong>描述了一种能力</strong>。Flyer接口描述了一种飞行的能力，飞行能力包括三个行为：takeOff、land、fly。但接口需要<strong>类来实现</strong>，因为接口描述的能力需要具体类的对象来体现。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyer</span> </span>&#123; <span class="hljs-comment">//程序文件1</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">takeOff</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>一个类实现一个接口，表示这个类<strong>具有接口规定的能力</strong>。Airplane实现接口Flyer，表示Airplane具有飞行的能力，因此Airplane 必须给出飞行能力的三个行为takeOff、land、fly的具体实现<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Airplane</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeOff</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//程序文件2</span><br>        <span class="hljs-comment">// 加速直到离地升空</span><br>        <span class="hljs-comment">// 收起起落架</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 放下起落架</span><br>        <span class="hljs-comment">// 减速并降低副翼直到降落</span><br>        <span class="hljs-comment">// 刹车</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 保持引擎运转   </span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><ul><li><p>接口中的方法通过“接口类型的引用变量.方法名”调用，但接口类型的引用变量必须指向<strong>实现了该接口的类</strong>的<strong>实例对象</strong></p></li><li><p>接口中的常量名通过“接口名.常量名”访问。<br>接口方法的访问</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//接口方法的访问</span><br>Flyer f = <span class="hljs-keyword">new</span> AirPlane();<br><br>f.takeOff( ); <span class="hljs-comment">//f传给this</span><br>f.fly( );<br>f.land( );    <span class="hljs-comment">//f传给this </span><br></code></pre></div></td></tr></table></figure><p>这是接口f的行为是飞机的飞行行为：多态。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A32.png?raw=true" alt="RUNOOB 图标"></p></li><li><p>可以在能够使用任何其他数据类型的地方使用接口。（定义接口后，就是种数据类型了）</p></li><li><p>接口类型属于引用类型，接口类型的变量可以是：</p><ul><li>空引用(null)</li><li>引用实现了该接口的类的实例</li></ul></li><li><p>接口需要具体的类去实现。类实现接口的语法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">[modifier] class className [extends superclass][implements interfaceNameList ] &#123;<br> member_declaration*<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>除非类为abstract,所有接口的成员方法必须被实现（只要不是抽象类，所有方法就要实现）</p></li><li><p>一个类只能继承一个父类（类为单继承），但可以实现<strong>多个接口</strong>，多个接口以“，”分开（多接口，多种能力）。</p></li></ul><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A33.png?raw=true" alt="RUNOOB 图标">  </p><blockquote><p>这一个UML模型描述了AirPlane、Bird、Superman都实现了Flayer接口，因此这三个类型都具有飞行的能力(CANDO Fly)。但是他们各自的飞行行为可以不一样（<strong>每个类对takeOff、land、fly的具体实现都不一样</strong>），当用接口类型引用变量引用了三个类的实例时，通过接口引用变量调用接口方法就呈现出多态性。  </p></blockquote><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A35.png?raw=true" alt="RUNOOB 图标">  </p><blockquote><p>接口描述了能力，继承描述了类之间的血缘关系。来自不同继承链(树）的类可以具有相同的能力。（像家谱一样）</p></blockquote><blockquote><p>例如：Airplane和Superman来自不同的继承链（即来自不同的家族，没有血缘关系），但他们都实现了接口Flyer，都具有飞行的能力。</p></blockquote><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A36.png?raw=true" alt="RUNOOB 图标">  </p><blockquote><p>这个图描述了二个继承树（二个家族），二个接口，其中：<br> Airplane、Bird、Superman实现了接口Flyer<br> RiverBarge实现了接口Sailer<br> SeaPlane同时实现了接口Flyer和Sailer，这意味着Seaplane同时具有飞行能力和海上巡航的能力。这个例子说明了一个类可以实现多个接口（具备多种能力）  </p></blockquote><h3 id="接口-继承"><a href="#接口-继承" class="headerlink" title="接口-继承"></a>接口-继承</h3><ul><li> 接口不是类（Java支持单继承类），一个接口<strong>可以继承多个接口</strong>。</li><li>语法<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">[modifier] interface interfaceName [extends interfaceNameList] &#123;<br>declaration* <br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>如果接口声明中提供了<strong>extends子句</strong>，那么该接口就<strong>继承了父接口的方法和常量</strong>。被继承的接口称为声明接口的直接父接口。</li><li>任何实现该接口的类，<strong>必须实现该接口继承的其他接口。</strong></li></ul><ul><li>实例<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I1</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>;<br>&#125; <br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">I1</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I3</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">I2</span>, <span class="hljs-title">I3</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// implements&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// implements&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// implements&#125;</span><br><br>&#125;<br><br><br>A a = <span class="hljs-keyword">new</span> A();<br><br><span class="hljs-function">a <span class="hljs-keyword">instanceof</span> <span class="hljs-title">I1</span>         <span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span><br><span class="hljs-function">a <span class="hljs-keyword">instanceof</span> <span class="hljs-title">I2</span>         <span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span><br><span class="hljs-function">a <span class="hljs-keyword">instanceof</span> <span class="hljs-title">I3</span>         <span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span><br><span class="hljs-function">a <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Object</span>     <span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">I1 i1 </span>= <span class="hljs-keyword">new</span> A();<br>I2 i2 = <span class="hljs-keyword">new</span> A();<br>I3 i3 = <span class="hljs-keyword">new</span> A();<br></code></pre></div></td></tr></table></figure><blockquote><p>当一个类实现多个接口时，<br>这个类的实例可以是多种类型<br>如下列表达式都返回true</p></blockquote></li></ul><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><ul><li>有时需要比较二个对象，但不同类型对象的比较具有不同的含义，因此Java定义了Comparable接口（比较对象的大小，而不是变量）。</li><li>因此，任何需要比较对象的类，都要实现该接口。</li><li>Cloneable、Runnable、Comparable等接口均在包java.lang中：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java.lang;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span></span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>CompareTo判断this对象相对于给定对象o的顺序，当this对象小于、等于或大于给定对象o时，分别返回负数、0或正数</li></ul><ul><li>有了Comparable接口，我们可以实现很通用的类来比较对象，例如实现一个从两个对象中找出最大者的方法。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Max</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparable <span class="hljs-title">findMax</span> <span class="hljs-params">(Comparable o1, Comparable o2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(o1.CompareTo(o2) &gt; <span class="hljs-number">0</span> )<br>            <span class="hljs-keyword">return</span> o1;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> o2;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>注意findMax方法的<strong>参数类型和返回类型都是Comparable</strong>（<strong>只要是实现了Comparable接口的对象都可以传进</strong>来。 Comparable接口描述了可以比较大小的能力，一个类实现了这个接口，意味着这个类的<strong>对象</strong>直接可以比较大小）</li><li>Max.findMax与Comparable接口的具体实现子类无关。<strong>只要是实现了Comparable接口的具体类的二个对象（注意是同一个具体类的二个对象）传进来， Max.findMax都能工作。</strong>这就是接口的好处。（程序存在的问题：如果是2个实现了Comparable接口的不同具体类对象传进来怎么办？最好通过泛型解决）</li><li>另外要注意的是：o1.CompareTo(o2)调用是动态绑定（<strong>多态</strong>，compateTo是什么，取决于O的类型）（调用具体子类对象的CompareTo方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComparableRectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/** Construct a ComparableRectangle with specified properties */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ComparableRectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> width, <span class="hljs-keyword">double</span> height)</span>   <span class="hljs-comment">//构造函数</span></span><br><span class="hljs-function">    </span>&#123;<br><span class="hljs-keyword">super</span>(width, height);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Implement the compareTo method defined in Comparable */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span>    <span class="hljs-comment">//定义ComparableRectangle类的比较是通过比较面积来完成</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getArea( ) &gt;((ComparableRectangle)o).getArea()) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getArea( ) &lt;((ComparableRectangle)o).getArea()) <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125; <br>注意由于篇幅所限没有用instanceOf检查o的类型。但如果o不是ComparableRectangle类型怎么办？这时返回什么样的整数都不合适，最好的这个问题最好的解决办法是用泛型。<br></code></pre></div></td></tr></table></figure><ul><li> 对于ComparableRectangle的两个对象r1和r2，直接调用Max.findMax(r1,r2)找出最大的对象</li><li>对于实现了Comparable接口任何类的二个对象（同一个类）(不管其具体实现是什么)a1和a2，都可以调用Max.findMax(a1,a2)找出最大的对象。这就是接口和多态的威力。</li></ul><hr><h3 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h3><ul><li>Java定义了Cloneable接口，任何想克隆的类必须<strong>实现该接口</strong>，同时<strong>覆盖从Object类继承的clone方法</strong>，并将访问属性改为public</li><li>Cloneable接口为空接口(未定义任何函数)，其定义为<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java.lang;<br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cloneable</span> </span>&#123; &#125;<br></code></pre></div></td></tr></table></figure></li><li>空接口称为标记接口(markup interface)      </li><li>空接口有什么作用？唯一目的允许你用instanceof检查对象的类型：   <div class="hljs code-wrapper"><pre><code>  `if(obj instanceof Cloneable)…//任何一个实现Cloneable的对象，类型一定是Cloneable`  例子见继承与多态下。</code></pre></div></li></ul><h3 id="接口与抽象类的比较"><a href="#接口与抽象类的比较" class="headerlink" title="接口与抽象类的比较"></a>接口与抽象类的比较</h3><p><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A38.png?raw=true" alt="RUNOOB 图标"></p><blockquote><p>JDK8之后，其差距越来越小，接口越来越像抽象类。</p></blockquote><hr><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ul><li>基本数据类型包装类的作用<ul><li>为基本数据类型提供有用的方法和常量值</li><li>用于只能处理对象引用的地方（比如Java所有的集合类里只能放对象）</li></ul></li><li>包装类对象的值不变（内部valule是final的），只能读取。<blockquote><p>8个包装类都实现了Comparable接口。Number为抽象类。<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E6%8E%A5%E5%8F%A37.png?raw=true" alt="RUNOOB 图标"></p></blockquote></li></ul><ul><li>构造函数<ul><li>以一个对应的基本数据类型为参数</li><li>以字符串为参数(除了Character)</li></ul></li><li>如Double类的构造函数如下：（别的都是这样，只有Character类只有char）<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Double</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Double</span> <span class="hljs-params">(String value)</span></span>;<br></code></pre></div></td></tr></table></figure></li><li>例如<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Double doubleObject = <span class="hljs-keyword">new</span> Double(<span class="hljs-number">5.0</span>);<br>Double doubleObject = <span class="hljs-keyword">new</span> Double(<span class="hljs-string">&quot;5.0&quot;</span>);<br></code></pre></div></td></tr></table></figure></li><li><strong>包装类没有无参构造方法</strong></li></ul><hr><ul><li>每一个数值包装类都有相应类型常量MAX_VALUE和MIN_VALUE。<ul><li>MAX_VALUE对应本数据类型的最大值。</li><li>对Byte ,Short ,Integer和Long， MIN_VALUE对应最小值</li><li>对Float和Double， MIN_VALUE对应最小正值</li></ul></li><li>上述常量用于排序算法时很有用。</li><li>直接用包装类名访问其常量值：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">System.out.println(“The maximum integer is”+ <br>Integer.MAX_VALUE); <span class="hljs-comment">//MAX_VALUE是int类型</span><br>System.out.println(“The minimum positive <span class="hljs-keyword">float</span> <br>is”+ Float.MIN_VALUE); <span class="hljs-comment">//MIN_VALUE是float类型</span><br></code></pre></div></td></tr></table></figure></li></ul><hr><ul><li><p>Number是基本数值类型包装类的抽象父类，里面有如下方法返回包装类对象对应的基本数据类型值：</p><ul><li>public abstract int intValue()</li><li>public abstract long longValue()</li><li>public abstract float floatValue()</li><li>public abstract double doubleValue()</li><li>public byte byteValue()</li><li>public short shortValue()</li></ul></li><li><p>如 int i = new Integer(10).intValue();</p></li><li><p>另外每个类的toString（）方法将数值转换成字符串</p></li><li><p>字符串转数值<br> 转换为Byte，Short，Integer，Long，Float，Double</p><ul><li>public static type parseType(String s)</li><li>public static type parseType(String s, int radix)<br>如<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">int</span> i = Integer.parseInt(“<span class="hljs-number">11</span>”,<span class="hljs-number">2</span>); <span class="hljs-comment">//3</span><br><span class="hljs-keyword">int</span> i = Integer.parseInt(“<span class="hljs-number">12</span>”,<span class="hljs-number">8</span>); <span class="hljs-comment">//10</span><br><span class="hljs-keyword">int</span> i = Integer.parseInt(“1A”,<span class="hljs-number">16</span>); <span class="hljs-comment">//26</span><br><span class="hljs-keyword">double</span> d = Double.parseDouble(“<span class="hljs-number">3.14</span>”);<span class="hljs-comment">//3.14</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p> 方法valueOf创建一个新的包装对象，并将它初始化为指定字符串的值<br>例如:(返回的是包装类)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Double doubleObject = Double.valueOf(“<span class="hljs-number">12.4</span>”);<br>Integer integerObject = Integer.valueOf(“<span class="hljs-number">12</span>”);<br></code></pre></div></td></tr></table></figure></li><li><p>JDK1.5开始允许基本类型和包装类之间的自动转换。</p><ul><li>将基本类型的值转换为包装类对象，称为装箱(boxing)</li><li>将包装类对象转换为基本类型的值，称为开箱(unboxing)</li></ul></li></ul><p><code>Integer intObject = 2; //装箱</code><br>等价于<br><code>Integer intObject = new Integer(2); </code>  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Integer intObject1 = <span class="hljs-number">2</span>, intObject2 = <span class="hljs-number">3</span> ;<br>System.out.println(intObject1 + intObject2 );<span class="hljs-comment">//开箱</span><br><span class="hljs-keyword">int</span> j = intObject ; <span class="hljs-comment">//开箱</span><br></code></pre></div></td></tr></table></figure><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>抽象类</tag>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的常用包</title>
    <link href="/2021/03/28/Java%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85/"/>
    <url>/2021/03/28/Java%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="import-java-util-Scanner-输入的一种方式"><a href="#import-java-util-Scanner-输入的一种方式" class="headerlink" title="import java.util,Scanner; //输入的一种方式"></a>import java.util,Scanner; //输入的一种方式</h2><blockquote><p>Scanner scanner =new Scanner(System.in);<br>double d=scanner.nextDouble();//举例，输入double型<br>nextInt() nextFloat() next()分别输入int，float，String</p></blockquote><h2 id="import-javax-swing-JOptionPane；-弹窗输入字符串"><a href="#import-javax-swing-JOptionPane；-弹窗输入字符串" class="headerlink" title="import javax.swing.JOptionPane； //弹窗输入字符串"></a>import javax.swing.JOptionPane； //弹窗输入字符串</h2><blockquote><p>String string = JOptionPane.showInputDialog(<br>null,”Prompting Message”,”Dialog Title”,JOptionPane.QUESTION_MESSAGE));<br>由从控制台输入变为弹出一个弹窗输入  </p><span id="more"></span><h2 id="import-java-lang-Math；-数学函数-定义了一些常量如PI，E"><a href="#import-java-lang-Math；-数学函数-定义了一些常量如PI，E" class="headerlink" title="import java.lang.Math；  //数学函数   定义了一些常量如PI，E"></a>import java.lang.Math；  //数学函数   定义了一些常量如PI，E</h2></blockquote><ul><li>Math中的三角函数<ul><li>sin(radians)–返回以弧度为单位的角度的三角正弦函数值  </li><li>cos(radians)–返回以弧度为单位的角度的三角余弦函数值</li><li>tan(radians)–返回以弧度为单位的角度的三角正切函数值</li><li>toRandians(degree)–将以度为单位的角度值转化为以弧度表示</li><li>toDegrees(radians)–将以弧度为单位的角度值转化为以度表示</li><li>sain(a)–返回以弧度为单位的角度的反三角正弦函数值</li><li>acos(a)–返回以弧度为单位的角度的反三角余弦函数值</li><li>atan(a)–返回以弧度为单位的角度的反三角正切函数值</li></ul></li><li>Math中的指数函数<ul><li>exp(x)–返回e的x次方</li><li>log(x)–返回x的自然底数</li><li>log10(x)–返回x的以10为底的对数</li><li>pow(a,b)–返回a的b次方</li><li>sqrt(x)–对于x&gt;=0的数字，返回x的平方根</li></ul></li><li>Math中的取整函数<ul><li>ceil(x)–x向上取整为它最接近的整数，该整数作为一个双精度值返回</li><li>floor(x)–x向下取整为它最接近的整数，该整数作为一个双精度值返回</li><li>rint(x)–x取整为它最接近的整数，如果x与两个整数的距离相等，偶数的整数作为一个双精度值返回</li><li>round(x)–如果x是单精度数，返回(int) Math.floor(x+0.5);如果x是双精度数，返回(long)Math.floor(x+0.5)</li></ul></li><li><strong>Math中的随机数</strong><br>  Math.random方法生成[0.0,1.0)之间的double类型的随机数，可以用它写出简单的任意范围的随机数  </li></ul><ol><li><strong>生成整数</strong><br> <code>a+(int)(Math.random()*b)</code><br> 返回[a,a+b)  <strong>不包括b</strong><br> <code>a+(int)(Math.random()*(b+1))</code><br> 返回[a,a+b]  </li><li><strong>生成随机字符</strong><br> Java采用<strong>UniCode编码</strong>，0000到FFFF，生成随机字符就是生成0到65535之间的随机数<br> <code>(int)(Math.random()*(65535+1))</code><br> 随机生成所有的字符<br> <code>(char)(&#39;a&#39;+(int)(Math.random()*(&#39;z&#39;-&#39;a&#39;+1)))</code><br> 随机生成’a’-‘z’之间的字符<br> 随机生成别的区间字符的同理  </li></ol><blockquote><p>Java为每个基本类型实现了对应的包装类，char类型的包装类是Character类。包装类的对象为引用类型，不是值类型</p></blockquote><h2 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h2><ol><li>将char类型的数据封装成对象  </li><li>包含处理字符的方法和常量  <ul><li>isDigit方法判断一个字符是否是数字</li><li>isLetter方法判断一个字符是否是字母</li><li>isLetterOrDigit方法判断一个字符是否是字母或数字</li><li>isLowerCase方法判断一个字符是否是小写</li><li>isUpperCase方法判断一个字符是否是大写</li><li>toLowerCase方法将一个字符转换成小写</li><li>toUpperCase方法将一个字符转换成大写</li></ul></li></ol><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>是一个final类，不能被继承<br>java.lang.String表示一个固定长度的字符串序列，实例化后其内容不能改<br>按照规范来说，创建一个字符串应该是<br><code>String newString=new String(stringLiteral);   //存入堆中</code><br>由于字符串经常使用，java提供了创建字符串的简写形式<br><code>String newString =stringLiteral;   //存入常量池中</code></p><p><code>String m4 = &quot;Wel&quot; +new String(&quot;come&quot;)； //存入堆中，只要new的使用就存入堆中</code><br><img src="https://raw.githubusercontent.com/Trent-Liu/picture/main/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%851.png" alt="avatar"><br>intern()方法——堆-&gt;常量池<br><img src="https://raw.githubusercontent.com/Trent-Liu/picture/main/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%852.png" alt="avatar"><br>改变字符串的值，实际上是改变了指向，并没有在原有的基础上修改</p><ul><li><strong>字符串的比较</strong><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">String s=<span class="hljs-string">&quot;Welcome to Java&quot;</span>;   <span class="hljs-comment">//常量池</span><br>String s1=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Welcome to Java&quot;</span>);   <span class="hljs-comment">//堆</span><br></code></pre></div></td></tr></table></figure>如果直接比较s==s1，返回为false，因为比较的是指向的是不是一个内容，显然不是  </li></ul><ol><li><strong>equals</strong> 比较两个字符串是否包含相同的内容，这时候就可以s.equals(s1),返回值为TRUE，表示内容相同。  </li><li><strong>equalsIgnoreCase</strong>忽略大小写比较内容是否相同  </li><li><strong>regionMatch</strong>比较部分内容是否相同   </li></ol><p><strong>s2.regionMatches(11,s0,0,4)</strong> 要给定两个串的起始位置和长度<br>4. <strong>startsWith</strong>判断是否以某个字符串开始<br>5. <strong>endsWith</strong>判断是否以某个字符串结束<br>6. <strong>compareTo</strong>方法用于比较两个字符串的大小，即第一个不同字符串的差值（字典序）。<br>**s1.compareTo(s2)**，相同返回0，s1&gt;s2返回小于0的值，反之。</p><ul><li><p><strong>字符串长度</strong><br>调用length()方法可以获取字符串的长度  </p></li><li><p><em>message.length()</em>* 返回长度   </p></li><li><p>获取单个字符   </p></li><li><p><em>charAt(index)*</em> 方法可以获取指定位置的字符。<strong>index必须在0——s.length-1之间。</strong><br><img src="https://raw.githubusercontent.com/Trent-Liu/picture/main/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%853.png" alt="avatar">  </p></li><li><p><strong>连接字符串</strong>  </p></li></ul><ol><li><strong>concat</strong>方法用于连接两个字符串<br><code>String s3=s1.concat(s2);</code></li><li>(+)连接<br><code>String s3=s1+s2;</code>  </li></ol><p><strong>s1+s2+s3等价于s1.concat(s2).concat(s3)</strong><br>连接操作返回一个新得字符串，因为String类型的实例内容不可修改。  </p><ul><li><p><strong>截取子串</strong>  </p></li><li><p><em>substring</em>* 用于截取字符串的一部分，返回新字符串<br><code>public String substring(int beginIndex,int endIndex)</code><br>返回字符串的子串。子串从beginIndex开始，直到endIndex-1<br>或者只写beginIndex，就从beginIndex字符开始直到结尾。</p></li><li><p><strong>字符串转换</strong>  </p></li><li><p>*toLowerCase**将字符串转换成小写,得到新串  </p></li><li><p><em>toUpperCase</em>* 大写  </p></li><li><p><em>trim</em>* 删除两端空格  </p></li><li><p>*replace**字符替换<br><code>s1.replace(&quot;Java&quot;,&quot;HTML&quot;) 将s1中的Java换成HTML</code></p></li><li><p>查找字符或字符串  </p></li><li><p>*indexOf**返回字符串中字符或字符串匹配的位置，返回-1表示未找到。  </p></li><li><p>*lastIndexOf**返回字符串中字符或字符串最后出现的位置，返回-1表示未找到   </p></li><li><p><strong>字符数组和字符串之间的转换</strong>  </p></li></ul><p><strong>toChararray</strong>将字符串转换成字符数组</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">String s=<span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-keyword">char</span>[] charArray=s.toCharArray(); <span class="hljs-comment">//charArray.length=4</span><br></code></pre></div></td></tr></table></figure><p> <strong>将字符数组转换成字符串</strong>  </p><ol><li>使用String的构造函数，可同时初始化<br><code>new String(new char[]&#123;&#39;J&#39;,&#39;a&#39;,&#39;v&#39;,&#39;a&#39;&#125;);</code>  </li><li>使用valueOf方法：静态方法<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">String.valueOf(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]&#123;<span class="hljs-string">&#x27;J&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>&#125;);<br>String.vaueOf(<span class="hljs-number">2.34</span>); <span class="hljs-comment">//2.34转&quot;2.34&quot;</span><br></code></pre></div></td></tr></table></figure></li></ol><ul><li><strong>基本数据类型和字符串之间的转换</strong>  </li></ul><p><strong>valueOf</strong>方法将基本数据类型转换为字符串。例如  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">String s1=String.valueOf(<span class="hljs-number">1.0</span>); <span class="hljs-comment">//&quot;1.0&quot;</span><br>String s2=String.valueOf(<span class="hljs-keyword">true</span>);  <span class="hljs-comment">//&quot;true&quot;</span><br></code></pre></div></td></tr></table></figure><p>字符串转换为基本类型：利用<strong>包装类</strong>  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Double.parseDouble(str)<br>Integer.parseInt(str)<br>Boolean.parseBoolean(str)<br></code></pre></div></td></tr></table></figure><blockquote><p>String类一旦初始化完成，字符串就是不可修改的<br>StringBuilder与StringBuffer(final类)初始化后还可以修改字符串<br>StringBuffer修改缓冲区的方法是同步（synchronized）的，更适合多线程环境。<br>StringBuilder线程不安全，与StringBuffer工作机制类似。<br>由于可修改字符串， StringBuilder 与StringBuffer 增加了String类没有的一些函数，例如：append、insert、delete、replace、reverse、setCharAt等。<br>仅以StringBuilder为例：<br>StringBuilder  stringMy=new StringBuilder( );<br>StringMy.append(“Welcome to”);<br>      StringMy.append(“ Java”);  </p></blockquote><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><ul><li>修改StringBuffer中的字符串<ul><li><strong>追加</strong><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">StringBuffer bf = <span class="hljs-keyword">new</span> StringBuffer();<br>bf.append(“Welcome”);<br>bf.append(‘ ‘);<br>bf.append(“to ”);<br>bf.append(“Java”);<br>System.out.println(bf.toString()); <span class="hljs-comment">//Welcome to Java</span><br></code></pre></div></td></tr></table></figure>上式中的toString是将StringBuffer类型转化为String类型  </li><li>*toString()**:从缓存区返回字符串</li><li><strong>插入</strong><br><code>bf.insert(11,”HTML and ”) //Welcome to HTML and JAVA</code>  </li><li><strong>删除</strong>：Welcome to Java<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">bf.delete(<span class="hljs-number">8</span>,<span class="hljs-number">11</span>); <span class="hljs-comment">//Welcome Java,将第8到第10删除，不含11</span><br>bf.deleteCharAt(<span class="hljs-number">8</span>);<span class="hljs-comment">//Welcome o Java 删除第8个</span><br>bf.reverse(); <span class="hljs-comment">//avaJ ot emocleW 字符串反转</span><br>bf.replace（<span class="hljs-number">11</span>，<span class="hljs-number">15</span>，“HTML”）;<span class="hljs-comment">//Welcome to HTML，第11到第14替换，不含15</span><br>bf.setCharAt(<span class="hljs-number">0</span>,’w’);<span class="hljs-comment">//welcome to Java</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ul><blockquote><p>所有对StringBuffer对象内容进行修改的方法，都返回指向相同StringBuffer对象的引用<br>StringBuffer bf = new StringBuffer();<br>StringBuffer bf1 = bf.append(“Welcome “);<br>StringBuffer bf2 = bf.append(“to “);<br>StringBuffer bf3 = bf.append(“Java”);<br>assert bf==bf1 &amp;&amp; bf==bf2 &amp;&amp; bf == bf3;<br>因此以上语句可以直接写成：<br>bf.append(“Welcome “).append(“to “).append(“Java”);  </p></blockquote><p><strong>toString()</strong>: 从缓冲区返回字符串<br>**capacity()**：返回缓冲区容量。length &lt;= capacity<br>    当字符串长度超过缓冲区容量，capacity会自动增加<br>**length()**：返回缓冲区中字符数量<br>**setLength(newLength)**：设置缓冲区长度<br>**charAt(index)**：返回下标为index的字符  </p><ul><li>StringBuffer实例<br>编写程序，检查回文。<br>解决方案<br>创建一个新的StringBuffer，将字符串的字母和数字添加到StringBuffer中，返回过滤后的String对象。<br>翻转过滤后的字符串，并与过滤后的字符串进行比较，如果内容相同则是回文。  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br><br><span class="hljs-comment">// Create a new string that is the reversal of s</span><br>String s2 = reverse(s);<br><span class="hljs-comment">// Compare if the reversal is the same as the original stringreturn s2.equals(s);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">reverse</span><span class="hljs-params">(String s)</span> </span>&#123;<br>StringBuffer strBuf = <span class="hljs-keyword">new</span> StringBuffer(s);<br>strBuf.reverse();<br><span class="hljs-keyword">return</span> strBuf.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>arrayRefVar.length</strong>  直接求数组长度  </p><ul><li>复制数组的方法</li></ul><ol><li>使用<strong>循环</strong>来复制每个元素  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[ ] sourceArray = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>&#125;;<br><span class="hljs-keyword">int</span>[ ] targetArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sourceArray.length];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sourceArray.length; i++)&#123;<br>targetArray[i] = sourceArray[i];<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>使用 <strong>System.arraycopy</strong><br>前提： sourceArray和targetArray都已经实例化好  </li></ol><p><code>arraycopy(sourceArray,srcPos,targetArray,tarPos,length)</code><br>原数组下标为几的元素开始，目标数组从几开始，长度</p><p><code>System.arraycopy(sourcearray,0,targetArray,0,sourceArray.length)</code>  </p><ol start="3"><li>数组<strong>克隆</strong><br>int [] targetArray=sourceArray.clone()  直接初始化。  </li></ol><ul><li>java.util.Array类包括各种静态方法，其中实现了数组的<strong>排序和查找</strong></li></ul><p><strong>排序</strong><br><code>double[] numbers=&#123;6.0,4.4,1.9,2.9&#125;;</code><br>java.util.Arrays.sort(numbers);  //直接在原数组排序</p><p><strong>二分查找</strong>  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">int</span> [] list=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">45</span>,<span class="hljs-number">50</span>&#125;  <br><span class="hljs-keyword">int</span> index=java.util.Arrays.binarySearch(list,<span class="hljs-number">11</span>)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>常用的包</tag>
      
      <tag>String</tag>
      
      <tag>StringBuffer</tag>
      
      <tag>随机数，数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——继承和多态下</title>
    <link href="/2021/03/26/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E4%B8%8B/"/>
    <url>/2021/03/26/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="实例方法覆盖"><a href="#实例方法覆盖" class="headerlink" title="实例方法覆盖"></a>实例方法覆盖</h2><ul><li>如果子类<strong>重新定义</strong>了从父类中继承的实例方法，称为方法覆盖(method override)。<ul><li>仅当父类方法在子类里是<strong>可访问的</strong>，该实例方法<strong>才能被子类覆盖</strong>，即父类<strong>私有</strong>（private）实例方法不能被子类覆盖，private方法子类不可见。父类实例私有方法自动视为final的。</li><li>静态方法不能被覆盖，如果静态方法在子类中重新定义，那么父类方法将被<strong>隐藏</strong>。</li><li><strong>覆盖特性</strong>：一旦父类中的实例方法被子类覆盖，同时用 <strong>父类型的引用变量</strong>（类型为父类） 引用了 <strong>子类对象</strong>（内存中的实例是子类），这时不能通过这个父类型引用变量去访问被覆盖的父类方法(即这时被覆盖的父类方法不可再被发现)，实际指向的对象的空间是子类的。因为实例方法具有多态性（晚期绑定）<ul><li>在子类类体函数中可以使用super调用被覆盖的父类方法。</li></ul></li><li>隐藏特性：指父类的变量（实例变量、静态变量）和静态方法在子类被重新定义，但由于<strong>类的变量和静态方法没有多态性</strong>，因此通过<strong>父类型引用变量（类型为父类）访问的一定是父类变量、静态方法</strong>(即被隐藏的可再发现)。</li><li>方法覆盖的哲学涵义：子对象当然可以修改父类的行为（生物进化除了遗传，还有变异）  </li></ul></li></ul><p>例子：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;               <span class="hljs-comment">//父类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A&#x27;s m&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A&#x27;s s&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-comment">//子类</span><br>    <span class="hljs-comment">//覆盖父类实例方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B&#x27;s m&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//隐藏父类静态方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B&#x27;s s&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OverrideDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A o = <span class="hljs-keyword">new</span> B();  <span class="hljs-comment">//父类型变量引用子类对象</span><br>        o.m();  <span class="hljs-comment">//由于父类实例方法m被子类覆盖，o运行时指向B类对象，由于多态性，执行的是B的m</span><br>        o.s();    <span class="hljs-comment">//由于s是静态方法，没有多态性，编译器编译时对象o的声明类型是A，所以执行的是A的s</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>父类型变量o引用了子类对象，通过o调用被覆盖的实例方法m时，调用的一定是子类方法，这时不可能调用到父类的方法m(父类函数不能被发现），因为多态特性。<strong>多态性使得根据new 后面的类型决定调用哪个m</strong>，new后是谁，实例方法就是谁的  </p></blockquote><blockquote><p>静态方法和成员变量没有多态性，因此要<strong>根据声明类型决定调用哪个s</strong>，声明是谁，静态方法就是谁。</p></blockquote><p>因此上面的结果为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">B<span class="hljs-string">&#x27;s m</span><br><span class="hljs-string">A&#x27;</span>s s<br></code></pre></div></td></tr></table></figure><p>A o = new B();<br>o的实例方法是B的，静态方法是A的</p><blockquote><p>引用变量o有二个类型：声明类型A，实际运行时类型B  </p></blockquote><blockquote><p>判断o.s()执行的是哪个函数按照o的<strong>声明类型</strong>，因为静态函数s<strong>没有多态性</strong>，<br>函数入口地址在<strong>编译时</strong>就确定（早期绑定），而编译时所有变量的类型都按声明类型。  </p></blockquote><blockquote><p>判断o.m()执行的是哪个函数按照o的<strong>实际运行类型</strong>，在<strong>运行时</strong>按照o指向<br>的实际类型B来<strong>重新计算函数入口地址</strong>（晚期绑定。多态性），因此调用的是B的m</p></blockquote><blockquote><p>因此一旦引用变量o指向了B类型对象（A o = new B()），o.m()调用的永远是B的m，再也无法通过o调用A的m，哪怕强制转换都不行： ((A)o).m();调用的还是B的m这就是前面PPT所说的不能再发现。</p></blockquote><p>对上面AB两个类，如果这样</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"> B o = <span class="hljs-keyword">new</span> B();<br> o.s(); <span class="hljs-comment">//调用B的s，将父类A的s隐藏，即通过B类型的引用变量o是不可能调用A的s</span><br>((A)o).s(); <span class="hljs-comment">//通过强制类型转换，可以调用A的s，可以找回。也可以通过类名调用来找回:A.s( );</span><br></code></pre></div></td></tr></table></figure><p>这就是被隐藏的变量和静态方法可以再发现</p><p>实例方法覆盖的一个应用：在子类里覆盖父类方法  (父类的toString可以打印颜色，填充等)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A circle &quot;</span> + <span class="hljs-keyword">super</span>.toString() <br>        + <span class="hljs-string">&quot;\n\tradius: &quot;</span> + radius;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>这样做的好处是Circle对象的基本属性,如color，filled，dateCreated由父类方法打印，Circle对象只负责打印新的属性值  </p></blockquote><h2 id="Object中的方法"><a href="#Object中的方法" class="headerlink" title="Object中的方法"></a>Object中的方法</h2><blockquote><p>任何类在设计时应考虑覆盖祖先类Object的如下函数： equal，clone，toString等。</p></blockquote><ul><li>java.lang.Object类是<strong>所有类的祖先类</strong>。如果一个类在声明时没有指定父类，那么这个类的<strong>父类是Object类</strong>。<ul><li>它提供方法如<strong>toString</strong>、<strong>equals</strong>、<strong>getClass</strong>、<em>clone</em>、<em>finalize</em>。前3个为公有，后2个为保护。getClass为final（用于泛型和反射机制，禁止覆盖）。</li><li>equals方法:用于测试两个对象是否相等。<strong>Object类的默认实现是比较两个对象引用是否引用同一个对象。</strong> 只是比较引用是否相同，不能真正判断是否相同，引用相同一定相同，但是相同不一定是引用相同， 在很多子类中要覆盖。</li><li>toString方法：返回代表这个对象的字符串。<strong>Object类的默认实现是返回由类名、@和hashCode组成。</strong><br>Circle circle = new Circle();<br>circle.toString();//Circle@15037e5，如果Circle没有覆盖toString<br>Object的toString方法提供的信息不是很有用。因此<strong>通常子类应该覆盖该方法，提供更有意义的信息</strong></li></ul></li></ul><h3 id="equals的覆盖"><a href="#equals的覆盖" class="headerlink" title="equals的覆盖"></a>equals的覆盖</h3><ul><li>equals用于判断一个对象同另一个对象的所有成员内容是否相等。覆盖时应考虑：<ul><li>对<strong>基本类型数值</strong>成员。直接使用==判断即可。</li><li>对<strong>引用类型变量</strong>成员。则需要对这些变量成员调用equals判断，不能用==。</li></ul></li><li>覆盖equals函数，最好<strong>同时覆盖hashCode()方法</strong>，该方法返回对象的hashCode值。<ul><li>需要对比的时候，<strong>首先用hashCode去对比</strong>，如果hashCode不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,<strong>如果hashCode相同，此时再用equals()比，如果equals()也相同</strong>，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</li></ul></li><li>覆盖equals函数，首先用instanceof检查参数的类型是否和当前对象的类型一样。<br>instanceof和加减乘除一样，当作运算符。<br>例如在Circle类中覆盖<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>&#123;   <span class="hljs-comment">//父类的参数就为Object，覆盖参数必须与父类一致</span><br>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Circle)<span class="hljs-comment">//应先检查另一对象o的类型 检查参数o的类型是否与当前对象的类型一样。</span><br>            <span class="hljs-keyword">return</span>  radius==((Circle)o).radius;  <span class="hljs-comment">//o中无radius这个变量，需要强制类型转换</span><br>        <span class="hljs-comment">//上面的式子，radius也可以写成this.radius,是c1的radius</span><br>        <span class="hljs-comment">//o是c2传进equals时被转换为的Object，需要强制类型转换。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br>Circle c1= ...;<br>Circle c2= ...;<br>c1.equals(c2);<br><span class="hljs-comment">//c1为Circle，为this引用，在对象中就是Circle</span><br><span class="hljs-comment">//c2在进入函数后被转换为Object类，相当于 Object o=c2； 实际上在函数中，o还是有Circle类的各种实例</span><br><span class="hljs-comment">//只不过由于在进入equals时转换成Object，在上文中需要再强制转换为Circle再与this.radius比较</span><br></code></pre></div></td></tr></table></figure></li></ul><blockquote><p>hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？  </p></blockquote><p>     因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？  </p><p>           因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：  </p><p>         1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。<br>         2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。  </p><p>所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！  </p><h3 id="clone的覆盖"><a href="#clone的覆盖" class="headerlink" title="clone的覆盖"></a>clone的覆盖</h3><ul><li>要实现一个类的clone方法，首先这个类需要实现Cloneable接口，否则会抛出CloneNotSupportedException异常</li><li>Cloneable接口其实就是一个标记接口，里面没有定义任何接口方法，只是用来<strong>标记</strong>一个类是否支持克隆：没有实现该接口的类不能克隆</li><li>还要公有覆盖clone方法，即Object类里clone方法是保护的，<strong>子类覆盖这个方法时应该提升为public</strong></li><li>方法里应实现<strong>深拷贝</strong>clone，Object的clone实现是<strong>浅拷贝</strong>。<ul><li>浅拷贝指所有类型都直接赋值=，这就导致数值类型没问题，但是引用类型就不是拷贝，而是指向同一个值<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    String j;<br>&#125;<br><br>A o1=...;<br>A <span class="hljs-number">02</span>;<br>o2.i=o1.i; <span class="hljs-comment">//值类型可以</span><br><span class="hljs-number">02.</span>j=o1.j; <span class="hljs-comment">//引用类型不可以，因为这会导致o2.j指向o1.j，而不是拷贝。</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li>克隆的深度：要克隆的对象可能包含基本类型数值成员或引用类型变量成员，对于基本类型数值成员使用=赋值即可，对于引用类型成员则需要<strong>进一步嵌套调用该成员的克隆方法</strong>进行赋值。  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">o2.j=o1.j  <span class="hljs-comment">//错误，引用类型</span><br>o2.j=o1.j.clone();  <span class="hljs-comment">//实现该成员的克隆方法后</span><br></code></pre></div></td></tr></table></figure></li></ul><p>实例</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//首先必须实现Cloneable接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] values = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE]; <span class="hljs-comment">//A的values成员是数组</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getValues()&#123;<br>        <span class="hljs-keyword">return</span> values;<br>    &#125;<br>    <span class="hljs-comment">//覆盖clone方法，提升为public，只是调用Object的的clone，</span><br>    <span class="hljs-comment">//不修改行为</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<span class="hljs-comment">//Clone方法不带参数，返回Object，同时可能会抛出CloneNotSupportedException异常</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<span class="hljs-comment">//调用Object的clone</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        A o1 = <span class="hljs-keyword">new</span> A();<br>        A o2 = (A)(o1.clone()); <span class="hljs-comment">//clone返回Object，因此要强制类型转换</span><br>        System.out.println(o1 == o2); <span class="hljs-comment">//false，说明clone返回的是新的引用</span><br>        System.out.println(o1.getValues() == o2.getValues()); <span class="hljs-comment">//true 但为浅拷贝克隆</span><br>    &#125;<span class="hljs-comment">//因为o1和o2内部values引用指向了内存里同一个数组</span><br>    <span class="hljs-comment">//说明A的clone方法里，所调用的super.clone()是浅拷贝</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>如上，A实现Cloneable接口，表示A支持克隆，然后A中的clone覆盖父类Object中的clone，直接调用了父类clone，得到的结果表示父类clone为浅拷贝。  </p></blockquote><p>为此，若要实现类A的深拷贝，如下  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] values = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE];<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getValues()&#123; <span class="hljs-keyword">return</span> values; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValues</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] newValues)</span> </span>&#123;<span class="hljs-comment">//添加setValues方法，设置内部数组内容</span><br><span class="hljs-keyword">this</span>.values = newValues;<br>    &#125;<br>    <br>    <span class="hljs-comment">//覆盖equals方法，比较二个A类型对象内容是否一样</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> A)&#123;<br>            A o = (A)obj;<br>            <span class="hljs-keyword">return</span> java.util.Arrays.equals(<span class="hljs-keyword">this</span>.getValues(),o.getValues());<br>        &#125;<span class="hljs-comment">//Attays中已完备的equals</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//覆盖clone方法，提升为public，重新实现为深拷贝</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        A newObj = <span class="hljs-keyword">new</span> A(); <span class="hljs-comment">//new一个新对象，不好的选择</span><br>  建议：  上一行语句换为 A newObj=(A)<span class="hljs-keyword">super</span>.clone();<br>newObj.values = <span class="hljs-keyword">this</span>.values.clone(); <span class="hljs-comment">//数组的clone是深拷贝，如果去掉clone，则是浅拷贝</span><br><span class="hljs-keyword">return</span> newObj;<br>    &#125;<br><br>    <span class="hljs-comment">//覆盖toString方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuffer buf = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v : values)&#123;<br>            buf.append(v + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> buf.toString().trim(); <span class="hljs-comment">//去掉最后多余的空格</span><br>    &#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        A o1 = <span class="hljs-keyword">new</span> A();<br>        o1.setValues(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;);<br>        A o2 = (A)(o1.clone());<br>        System.out.println(o1 == o2); <span class="hljs-comment">//false</span><br>        System.out.println(o1.getValues() == o2.getValues()); <span class="hljs-comment">//false 说明不是浅拷贝克隆</span><br>        System.out.println(o1.equals(o2)); <span class="hljs-comment">//true,二个对象的内容相等， 说明是深拷贝克隆          </span><br>        System.out.println(o2.toString()); <span class="hljs-comment">//显示 1 2 3 4 5 6 7 8 9 10</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><ul><li>如果B类里包含了A类型成员，只要A实现了深拷贝克隆，则B可以很方便地实现深拷贝克隆。如C类里包含了B类型成员，D类型里包含了C类型成员…,以此类推，只要每个类型都实现了深拷贝克隆，那么<strong>最外层的包装类可以非常方便的实现深拷贝克隆</strong>。这就是第37页PPT里讲到的<strong>克隆的深度问题</strong><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    A a;    <span class="hljs-comment">//引用类型成员</span><br>    <span class="hljs-keyword">int</span> i;  <span class="hljs-comment">//值类型</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        B newObj = <span class="hljs-keyword">new</span> B();<br>        newObj.i = <span class="hljs-keyword">this</span>.i;   <span class="hljs-comment">//值类型成员直接=赋值</span><br>        newObj.a = (A)(<span class="hljs-keyword">this</span>.a.clone()); <span class="hljs-comment">//引用类型的成员不能直接赋值，必须调用clone方法，深拷贝</span><br>        <span class="hljs-keyword">return</span> newObj;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="多态性、动态绑定和对象的强制类型转换"><a href="#多态性、动态绑定和对象的强制类型转换" class="headerlink" title="多态性、动态绑定和对象的强制类型转换"></a>多态性、动态绑定和对象的强制类型转换</h2><ul><li>继承关系使一个子类可以继承父类的特征(属性和方法），并附加新特征</li><li>子类是父类的具体化（沿着继承链从祖先类到后代类，特征越来越具体；反过来，从后代类往祖先类回溯，越来越抽象）</li><li>每个<strong>子类的实例都是父类的实例</strong>（<strong>子类对象ISA父类</strong>），但反过来不成立  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Class Student extends Person&#123; …&#125;<br>Person p = <span class="hljs-keyword">new</span> Student();<span class="hljs-comment">//OK 父类引用可直接指向子类对象</span><br>Student s = <span class="hljs-keyword">new</span> Person();<span class="hljs-comment">//error  子类引用不能指向父类对象</span><br></code></pre></div></td></tr></table></figure></li><li>这个特性是多态的重要基础  <blockquote><p>多态：通过引用变量调用实例函数时，根据所引用的实际对象的类型，执行该类型的相应实例方法，从而表现出不同的行为称为多态。通过<strong>继承</strong>时<strong>覆盖父类的实例方法实现多态</strong>。多态实现的原理：在<strong>运行时</strong>根据引用变量指向对象的实际类型，<strong>重新计算调用方法的入口地址（晚期绑定）。</strong></p></blockquote></li></ul><p>先看一个例子</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-comment">//父类</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Greeting</span><span class="hljs-params">()</span></span>&#123; <br>        System.out.println(<span class="hljs-string">&quot;Best wish from a person!&quot;</span>); <br>        &#125; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123; <span class="hljs-comment">//子类</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Greeting</span><span class="hljs-params">( )</span></span>&#123; <br>        System.out.println(<span class="hljs-string">&quot;Best wish from a employee!&quot;</span>);<br>        &#125; <br>    &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;   <span class="hljs-comment">//子类的子类</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Greeting</span><span class="hljs-params">( )</span></span>&#123; <br>            System.out.println(<span class="hljs-string">&quot;Best wish from a manager!&quot;</span>);<br>            &#125; <br>        &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingTest1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>       <span class="hljs-comment">//父类引用变量可以引用本类和子类对象，p1,p2,p3的声明类型都是Person(父类型），p2,p3执行子类对象</span><br>       Person p1= <span class="hljs-keyword">new</span> Person( ),p2= <span class="hljs-keyword">new</span> Employee( ),p3= <span class="hljs-keyword">new</span> Manager( );      <br>p1.Greeting( ); <span class="hljs-comment">//调用Person的Greeting()    ，由于实际指向对象类型是Person</span><br> p2.Greeting( ); <span class="hljs-comment">//调用Employee的Greeting()  ，由于实际指向对象类型是Employee</span><br> p3.Greeting( ); <span class="hljs-comment">//调用Manager的Greeting()   ，由于实际指向对象类型是Manager</span><br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//根据实际指向的类型，执行实际的实例方法</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingSender</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span> <span class="hljs-params">(Person p)</span></span>&#123; <br>        p.Greeting(); <span class="hljs-comment">//编译时应该是Person的Greeing</span><br>        &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingTest1</span></span>&#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>GreetingSender g = <span class="hljs-keyword">new</span> GreetingSender();<br>       g.newYearGreeting(<span class="hljs-keyword">new</span> Person()); <span class="hljs-comment">//调用Person的Greeting()</span><br>       g.newYearGreeting(<span class="hljs-keyword">new</span> Employee());<span class="hljs-comment">//调用Employee的Greeting()</span><br>       g.newYearGreeting(<span class="hljs-keyword">new</span> Manager());<span class="hljs-comment">//调用Manager的Greeting()</span><br>      &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>以最后一条语句为例来解释多态特性：<br>当<strong>实参new Manager()传给形参Person p</strong>时，<strong>等价于Person p = new Manager()</strong>, 因此执行p.Greeting()语句时根据形参p指向的对象的<strong>实际类型动态计算</strong>Greeting方法的入口地址，调用了Manager的Greeting()</p><ul><li><p>这段程序的微妙之处在于：</p><ul><li>GreetingSender类的newYearGreeting方法的参数是Person类型，那么<br>newYearGreeting的行为应该是Person对象的行为。</li><li>但是在实际运行时我们看到<strong>随着实参对象类型的变化</strong>， newYearGreeting<br>方法却表现出了多种不同的行为，这种机制称为多态</li></ul></li><li><p>仔细观察程序，可以发现产生多态的三个重要因素：</p></li></ul><ol><li>不同类之间有继承链</li><li>newYearGreeting方法的<strong>参数</strong>类型用的<strong>父类类型</strong></li><li>newYearGreeting调用的Greeting方法都被<strong>子类</strong>用自己的行为<strong>覆盖</strong><br>满足了这三个条件，用继承链中不同子类的对象做为方法的实参去调用方法会使该方法表现出不同的行为。由于子类的实例也是父类的实例，所以用子类对象作为实参传给方法中的父类型的形参是没有问题的。</li></ol><ul><li>多态条件：<strong>父类变量可引用本类和子类对象</strong>，子类对象isA父类对象</li><li>当调用<strong>实例方法</strong>时，由Java虚拟机动态地决定所调用的方法，称为动态绑定(dynamic binding)或者晚期绑定或者延迟绑定(lazy binding)或者多态。<br>假定对象o是类C1的实例，C1是C2的子类，C2是C3的子类，…，Cn-1是Cn的子类。也就是说，Cn是最一般的类，C1是最具体的类。在Java中，Cn是Object类。<br>如果调用继承链里子类型C1对象o的方法p，Java虚拟机按照C1、C2、…、Cn的顺序依次查找方法p的实现。一旦找到一个实现，将停止查找，并执行找到的第一个实现(覆盖的实例函数)。<br><img src="https://raw.githubusercontent.com/Trent-Liu/picture/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-03-29%20231337.png" alt="haha">  </li></ul><p>上例中，若p3指向Manager类的对象。当通过newYearGreeting(p3)方法去调用p3.Greeting()方法时，Java虚拟机会沿着继承链，从Manager类到父类查找Greeting的实现，结果找到Manager自己的实现<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-03-29%20231740.png?raw=true" alt="haha">  </p><p>若Employee覆盖了Greeting，而Manager没有覆盖，那么p3.Greeting()调用的是Employeede的  </p><h3 id="通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用"><a href="#通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用" class="headerlink" title="通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用"></a>通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用</h3><ul><li>由于父类变量可以引用子类对象，针对父类型设计的任何代码都可以<strong>应用于子类对象</strong>。  <ul><li>newYearGreeting(Person p){p.Greeting()}这段代码可以应用于所有Person子类型对象</li><li>多态性允许方法使用更通用的类作为参数类型。</li><li>如果方法参数是父类，那么这个参数可以接受任何子类对象作为实参。当调用这对象的方法时，将动态绑定方法的实现。<ul><li>newYearGreeting(Person p):该方法能接受从Person类型开始所有子类型对象作为实参</li><li>newYearGreeting(Manager p):该方法只能能接受从Manager类型开始所有子类型对象作为实参  </li></ul></li></ul></li></ul><p>哪个更好？<br>显然前者通用性更强。  </p><p>如果没有多态机制，针对Person，Employee及Manager类，我们必须写出三个重载版本的newYearGreeting函数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingSender</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span><span class="hljs-params">(Person p)</span></span>&#123; p.Greeting(); &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span><span class="hljs-params">(Employee e)</span></span>&#123; e.Greeting(); &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newYearGreeting</span><span class="hljs-params">(Manager m)</span></span>&#123; m.Greeting(); &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>假如我们新增加一个从Manager派生的CEO类，也实现了Greeting方法，我们需要增加一个新的newYearGreeing的重载版本。</li><li>更为糟糕的是，我们需要重新编译GreetingSender类。</li><li>回到第44页实现的多态版的GreetingSender类，可以适用于任何Person子类型，哪怕GreetingSender类作为商业类已经卖出去了，对后来新派生的CEO类型都可以不用重新编译地很好地工作</li></ul><hr><ul><li><p>父类变量引用子类对象，可视为将子类对象转换为父类（不需强制类型转换）。</p></li><li><p>类型转换(type casting)可以将一个对象的类型转换成继承链中的另一种类型。</p><ul><li>从子类到父类的转换是合法的，称为隐式转换。<br><code>Person p=new Manager();//将子类对象转换为父类对象</code></li><li>从父类到子类必须显式（强制）转换。<br><code>Manager m = p; //编译错 ，p是Person父类型，Person不一定是Manager</code><br><code>Manager m = (Manager)p;//ok，但转换前没有检查 </code>  </li><li>从父类到子类转换必须显式转换，转换前应进行检查更安全。<br><code>Manager m = null;</code><br><code>if(p instanceof Manager) m= (Manager)p; //安全：转换前检查 </code>  </li></ul></li><li><p>为什么从父类到子类转换必须强制类型转换？</p></li><li><p>首先要理解类型检查（type checking）发生在编译时</p></li><li><p>然后要理解Person p = new Manager()的真正涵义<br><img src="https://github.com/Trent-Liu/picture/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-03-29%20232726.png?raw=true" alt="haha">  </p></li><li><p>但是创建Manager对象并由p来引用是在运行时发生</p></li><li><p>因为程序还没运行，编译器无法知道p会指向什么对象，<strong>编译器在编译时只能根据变量p的声明类型（Person）来类型检查</strong></p></li><li><p>当编译器检查到 Manager m = p；编译器认为Person类型引用p要赋值给类型为Manager类型引用，扩展内存可能引起麻烦且不安全，因此，编译器认为类型不匹配，会报错。</p></li><li><p>加上强制转换 Manager m = (<strong>Manager</strong>)p；意思是强烈要求编译器，把p解释成Manager类型，风险我来承担。这个时候编译器就按Manager类型来解释p</p></li><li><p>因此，强制类型转换意味着你自己承担风险，编译器不会再做类型检查。</p></li><li><p>强制类型转换的风险是：运行时如果p指向的对象不是Manager的实例时程序会出错。</p></li><li><p>为了避免风险，最好用instanceof来做实例类型检查。</p></li></ul><h4 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h4><ul><li>可以用instanceof操作符判断一个引用指向的对象是否是一个类的实例。表达式返回boolean值。</li><li>语法  <div class="hljs code-wrapper"><pre><code>`referenceVariable  instanceof  TypeName`  </code></pre></div></li><li>所以上面的例子安全的写法为： <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Person p = <span class="hljs-keyword">new</span> Manager()<br><span class="hljs-keyword">if</span>（p <span class="hljs-keyword">instanceof</span> Manager）<br>Manager m = （Manager）p;<br></code></pre></div></td></tr></table></figure></li><li>意思是如果p指向的对象真的是Manager实例，再强制转换类型</li></ul><hr><ul><li>重载发生在编译时(Compile time)，编译时编译器根据实参比对重载方法的形参找到最合适的方法。</li><li>多态发生在运行(Run time)时，运行时JVM根据变量所引用的对象的真正类型来找到最合适的实例方法。</li><li>有的书上把重载叫做“编译时多态”，或者叫“早期绑定”(早期指编译时)。</li><li>多态是晚期绑定(晚期指运行时)</li><li>绑定是指找到函数的入口地址的过程。</li></ul><hr><ul><li>编写程序，创建两个几何对象：圆和矩形。调用displayObject来显示结果。<ul><li>如果对象是圆，显示半径和面积</li><li>如果对象是矩形，显示面积</li><li>警告: 对象访问运算符(.)优先于类型转换运算符。使用括号保证在(.)运算符之前转换<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">((Circle)object).getArea() <span class="hljs-comment">//OK</span><br>(Circle)object.getArea(); <span class="hljs-comment">//错误</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>实例方法覆盖</tag>
      
      <tag>Object中的方法</tag>
      
      <tag>clone的覆盖</tag>
      
      <tag>equals的覆盖</tag>
      
      <tag>！多态</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——继承和多态上</title>
    <link href="/2021/03/26/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <url>/2021/03/26/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>利用继承机制（提供了源代码重用机制，提高了<strong>开发效率</strong>（直接继承已有）同时也提高了软件可靠性：父类的代码如果经过了<strong>可靠性测试，我们通过继承机制可放心直接使用</strong>，只需要关注子类代码的实现）<br>总的来说，不需要重新写，而且父类可靠，继承下来的子类一定也可靠。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> salary;<br>    <span class="hljs-keyword">public</span> Date birthDate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDetails</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name; <span class="hljs-comment">//同名成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> salary; <span class="hljs-comment">//同名成员</span><br>    <span class="hljs-keyword">public</span> Date birthDate; <span class="hljs-comment">//同名成员</span><br>    <span class="hljs-keyword">public</span> String department;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDetails</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><span id="more"></span><p>以上两个类，Manager只比Employee多出了一个，其他的都重复定义。  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> salary;<br>    <span class="hljs-keyword">public</span> Date birthDate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDetails</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String department;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>继承就可以省去很多麻烦。  </p></li><li><p>语法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Superclass</span> </span>&#123;  <br>             <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">body</span></span><br><span class="hljs-class">      &#125;</span><br></code></pre></div></td></tr></table></figure><p>如果父类是Object，则extends部分可省略（前面的示例代码里，每个的父类都是Object)</p></li><li><p>如果class C1 extends C2，则称C1为子类(subclass)，C2为父类(superclass)。</p><ul><li>子类继承了父类中可访问的数据和方法，子类也可添加新的数据和方法，</li><li>子类不继承父类的<strong>构造函数</strong>。</li><li>一个类只能有一个直接父类（Java不支持多重继承，因为Java的设计者认为没有必要）。</li></ul></li><li><p>Java的继承都是公有继承，因此被继承的就是父类，继承的类就是子类。因此父类的成员如果被继承到子类，访问权限不变(public还是public，protected还是protected)<br>因此子类和父类是ISA关系：一个子类对象ISA父类对象</p></li></ul><h3 id="设计案例"><a href="#设计案例" class="headerlink" title="设计案例"></a>设计案例</h3><blockquote><p>假设要设计模拟几何对象的类，如圆和矩形，考虑的因素有颜色，是否填充，创建日期，圆的半径，矩形的周长等<br>不要直接就定义Class Circle和Class Rectangle,<strong>先分析几何对象的共同属性和行为</strong>。共同的属性和行为有颜色、是否填充，创建时间，以及这些属性的getter和setter行为。而圆的半径、矩形的长宽不是几何图形共有的属性。<br>可以设计<strong>通用类GeometricObject来模拟共有的属性和方法</strong>。而Circle、Rectangle类通过继承GeometricObject获得共同的属性和行为，同时添加自己特有的属性和行为  </p></blockquote><p>  如下设计一个通用类，定义了一些共同属性和方法,如图形的颜色，是否填充等</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeometricObject</span> </span>&#123; <span class="hljs-comment">//等价于public class GeometricObject extends Object</span><br>    <span class="hljs-keyword">private</span> String color = <span class="hljs-string">&quot;white&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> filled;<br>    <span class="hljs-keyword">private</span> Date dateCreated; <span class="hljs-comment">//java.util.Date是JDK定义的类，表示日期和时间</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GeometricObject</span><span class="hljs-params">()</span> </span>&#123; dateCreated = <span class="hljs-keyword">new</span> Date();&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> color; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(String color)</span> </span>&#123; <span class="hljs-keyword">this</span>.color = color;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFilled</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> filled; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFilled</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> filled)</span> </span>&#123; <span class="hljs-keyword">this</span>.filled = filled;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getDateCreated</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> dateCreated;&#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//覆盖Object类的toString()方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">( )</span> </span>&#123; <span class="hljs-comment">//还应考虑equals，clone</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;created on &quot;</span> + dateCreated + <span class="hljs-string">&quot;\n\tcolor: &quot;</span> + color<br>+ <span class="hljs-string">&quot; and filled: &quot;</span> + filled;<br>   &#125;<span class="hljs-comment">//toString方法应该返回一个描述当前对象的有意义的字符串</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>如下为这个通用类的继承类，只需要添加一些自己特有的东西就可以。比如圆的半径</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GeometricObject</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius; <span class="hljs-comment">//新增属性</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span> </span>&#123; &#125;   <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>&#123; <span class="hljs-keyword">this</span>.radius = radius; &#125; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> radius; &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRadius</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>&#123; <span class="hljs-keyword">this</span>.radius = radius; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> radius * radius * Math.PI;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getDiameter</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * radius;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPerimeter</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * radius * Math.PI;<br>&#125;<br>       <span class="hljs-comment">//还应考虑equals，clone，toString等函数</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>父类<br>私有属性： color  filled  dateCreated<br>公有方法： getColor  setColor IsFilled setFilled getDataCreated<br>GeometricObject的私有属性在子类中<br>不可见（即不能在子类里直接访问）<br>但可以通过所继承的get和set<br>方法设置和访问</p><h2 id="实例初始化模块"><a href="#实例初始化模块" class="headerlink" title="实例初始化模块"></a>实例初始化模块</h2><ul><li><p>初始化块是Java类中可以出现的第四种成员（前三种包括属性、方法、构造函数），分为实例初始化块和静态初始化块。</p></li><li><p>实例初始化模块（instance initialization block，IIB）是一个用<strong>大括号括住的语句块</strong>，直接<strong>嵌套于类体中</strong>，不在方法内。</p></li><li><p>它的作用就像把它放在了类中<strong>每个构造方法的最开始位置</strong>（也是为了省事，不用每个构造函数中都写一遍）。用于初始化对象。<strong>实例初始化块先于构造函数执行</strong>  （相当于C++成员初始化列表）</p></li><li><p>作用：如果<strong>多个构造方法共享一段代码</strong>，并且每个构造方法不会调用其他构造方法，那么可以把这段<strong>公共代码</strong>放在初始化模块中。</p></li><li><p>一个类可以有多个初始化模块，模块按照<strong>在类中出现的顺序</strong>执行  </p></li><li><p>作用</p></li></ul><ol><li>简化代码：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numOfObjects;<br>  <span class="hljs-keyword">private</span> String title<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(String title)</span></span>&#123;<br>    numOfObjects++;    <span class="hljs-comment">//一个</span><br>    <span class="hljs-keyword">this</span>.title = title;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>    numOfObjects++;  <span class="hljs-comment">//两个</span><br>    <span class="hljs-keyword">this</span>.id = id<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>和如下等价，只需要将构造函数中公共的部分放到块中。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numOfObjects;<br>  <span class="hljs-keyword">private</span> String title<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(String title)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.title = title;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.id = id<br>  &#125;<br>  <br>  &#123;<br>    numOfObjects++;   <span class="hljs-comment">//只需要这一个</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>截获异常<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-comment">//下面数据成员初始化语句可能会抛出异常，所以下面语句不成立</span><br>    <span class="hljs-keyword">private</span> InputStream fs = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(“C:\\<span class="hljs-number">1.</span>txt”));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>； <span class="hljs-comment">//InputStream fs是所有输入流的主线类</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-comment">//在实例初始化块里初始化数据成员可以截获异常</span><br>    <span class="hljs-keyword">private</span> InputStream fs = <span class="hljs-keyword">null</span>;<br>    &#123;<br>      <span class="hljs-keyword">try</span>&#123; fs = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(“C:\\<span class="hljs-number">1.</span>txt”));&#125;  <span class="hljs-comment">//试图执行，若无此文件会异常。</span><br>      <span class="hljs-keyword">catch</span>(Exception e)&#123; …&#125;                  <span class="hljs-comment">//解惑异常</span><br>    &#125;      <span class="hljs-comment">//任何一种面向对象语言都有try和catch</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>&#123; … &#125;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>实例初始化模块最重要的作用是当我们需要写一个内部匿名类时：匿名类不可能有构造函数，这时可以用实例初始化块来初始化数据成员<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISay</span></span>&#123; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>; <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceInitializationBlockTest</span> </span>&#123;    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <br>        ISay say = <span class="hljs-keyword">new</span> ISay()        <br>        &#123;   <span class="hljs-comment">//这里定义了一个实现了ISay接口的匿名类say            </span><br>            <span class="hljs-comment">//final类型变量一般情况下必须马上初始化，一种例外是：final实例变量可以在构造函数里再初始化。            </span><br>            <span class="hljs-comment">//但是匿名类又不可能有构造函数，因此只能利用实例初始化块            </span><br>         <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> j;  <span class="hljs-comment">//为了演示实例初始化块的作用，这里特意没有初始化常量j            </span><br>         &#123;                <br>             j = <span class="hljs-number">0</span>;  <span class="hljs-comment">//在实例初始化块里初始化j     final类型在实例初始化块中可以后赋值。       </span><br>         &#125;            <br>         <span class="hljs-meta">@Override</span>            <br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123; <br>             System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>                                &#125;        <br>         &#125;;        <br>         say.sayHello();    <br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure></li></ol><ul><li>实例初始化模块只有在创建类的实例时才会调用。</li><li><strong>定义并初始化类的实例变量等价于实例初始化块</strong>：private int id = 0；</li><li>一个类可以有多个实例初始化块，对象被实例化时，模块按照在<strong>类中出现的顺序执行</strong>，构造函数最后运行。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;<span class="hljs-comment">//执行次序：1</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<span class="hljs-comment">//执行次序：4，构造函数最后运行</span><br>    <span class="hljs-keyword">this</span>.id = id<br>  &#125;<br>  <br>  &#123;<br>     <span class="hljs-comment">//实例初始化块//执行次序：2</span><br>  &#125;<br>  <br>  &#123;<br>     <span class="hljs-comment">//实例初始化块//执行次序：3</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="静态初始化模块"><a href="#静态初始化模块" class="headerlink" title="静态初始化模块"></a>静态初始化模块</h2><ul><li>静态初始化模块是由<strong>static修饰</strong>的初始化模块{}，只能访问类的静态成员，并且在JVM的Class Loader将类装入内存时调用。<strong>（类的装入和类的实例化是两个不同步骤，首先是将类装入内存，然后再实例化类的对象）。</strong></li><li>在类体里直接定义静态变量相当于静态初始化块<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>   <span class="hljs-comment">//类的属性和方法定义</span><br>   &#123;<br>     <span class="hljs-comment">//实例初始化模块</span><br>   &#125;<br><br>   <span class="hljs-keyword">static</span> &#123;<br>     <span class="hljs-comment">//静态初始化模块</span><br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//直接定义静态变量相当于静态初始化块</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>一个类可以有多个静态初始化块，类被加载时，这些模块按照在类中出现的顺序执行<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;<span class="hljs-comment">//执行次序：1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br> <span class="hljs-keyword">this</span>.id = id     <br>  &#125;<br>  <span class="hljs-keyword">static</span> &#123;<br>     <span class="hljs-comment">//静态初始化块//执行次序：2</span><br>  &#125;<br>  <span class="hljs-keyword">static</span> &#123;<br>     <span class="hljs-comment">//静态初始化块//执行次序：3</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="初始化模块的执行顺序"><a href="#初始化模块的执行顺序" class="headerlink" title="初始化模块的执行顺序"></a>初始化模块的执行顺序</h2><ul><li><p>第一次使用类时装入类（此时是装载进JVM）</p><ul><li>如果父类没装入则<strong>首先装入父类</strong>，这是个<strong>递归</strong>的过程，直到继承链上所有祖先类全部装入</li><li>装入一个类时，类的<strong>静态数据成员和静态初始化模块</strong>按它们在类中出现的顺序执行</li></ul></li><li><p>实例化类的对象</p><ul><li>首先<strong>构造父类对象</strong>，这是个<strong>递归</strong>过程，直到继承链上所有祖先类的对象构造好</li><li>构造一个类的对象时，按在类中出现的顺序执行<strong>实例数据成员的初始化及实例初始化模块</strong></li><li>执行<strong>构造函数</strong>函数体</li></ul></li><li><p>注意，如下语句等价</p><blockquote><p>如果声明类的实例变量时具有初始值，如</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">double</span> radius = <span class="hljs-number">5.0</span>；<br></code></pre></div></td></tr></table></figure><blockquote><p>变量的初始化就像在实例初始化模块中一样，即等价于</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">double</span> radius；<br>&#123; radius = <span class="hljs-number">5.0</span>；&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>如果声明类的静态变量时具有初始值，如</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numOfObjects = <span class="hljs-number">0</span>；<br></code></pre></div></td></tr></table></figure><blockquote><p>变量的初始化就像在静态初始化模块中一样，即等价于</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numOfObjects；<br><span class="hljs-keyword">static</span>&#123; numOfObjects = <span class="hljs-number">0</span>；&#125;<br></code></pre></div></td></tr></table></figure><p>在Java中，变量声明的位置是任意的（不同于C，定义必须在声明之后。）<br>因此声明类的实例/静态变量就相当于一个初始化块，按照实例和静态先后顺序完成。</p></li><li><p>下面举出一个案例，查看各个代码块的运行先后顺序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">N</span></span>&#123;      <span class="hljs-comment">//子类N</span><br>    N()&#123; System.out.println(<span class="hljs-string">&quot;(6) &quot;</span>); &#125;   <span class="hljs-comment">//子类N的构造函数</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;(5) &quot;</span>);    <span class="hljs-comment">//子类N的实例初始化模块</span><br>    &#125;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;(3) &quot;</span>);   <span class="hljs-comment">//子类N的静态初始化模块</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">N</span></span>&#123;     <span class="hljs-comment">//父类M</span><br>    M()&#123; System.out.println(<span class="hljs-string">&quot;(8) &quot;</span>); &#125;    <span class="hljs-comment">//父类M的构造函数</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;(7) &quot;</span>);     <span class="hljs-comment">//父类M的实例初始化模块</span><br>    &#125;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;(4) &quot;</span>);     <span class="hljs-comment">//父类M的静态初始化模块</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitDemo</span></span>&#123;<br>    InitDemo()&#123;<br>        <span class="hljs-keyword">new</span> M();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;(1) &quot;</span>);     <span class="hljs-comment">//main中第一条语句</span><br>  <span class="hljs-keyword">new</span> InitDemo();               <span class="hljs-comment">//实例化主类方法</span><br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;(2) &quot;</span>);   <span class="hljs-comment">//主类的实例初始化模块</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;(0) &quot;</span>);    <span class="hljs-comment">//主类的静态初始化模块</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>分析：<br>主类InitDemo是程序入口，因此先加载JVM，将Init的静态先初始化，输出0;<br>主类还没有实例化，因此还不需要运行主类的实例化初始模块，进入main，打印1;<br>new InitDemo()，实例化主类，运行主类的实例化初始模块，打印2;<br>主类的实例化初始模块都运行后，进入主类的构造函数。<br>构造函数中要第一次实例化M，而M是N的子类，因此要先将父类N的静态初始化模块加载，打印3<br>父类的静态模块加载后，加载子类M的静态模块，打印4<br>由于实例化了M，因此先实例化父类N，先加载父类N的实例初始化块，再加载父类N的构造函数，打印5，6。<br>实例化父类完成后，回到子类M，同样先实例化初始化块，再构造函数，打印7，8  </p></li></ul><p><strong>总之，若实例化一个类，那就按最原始的祖先直到它的顺序，加载它们的静态初始化块，递归完成。</strong><br><strong>然后由于实例化，需要不断实例化父类，还是按照最原始的祖先直到它的顺序，加载实例初始化块和构造函数</strong></p><p>在IDEA代码运行后得到结果为</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-string">&quot;C:\Program Files\Java\jdk-15.0.2\bin\java.exe&quot;</span> <span class="hljs-string">&quot;-javaagent:E:\Download\IDEA\IntelliJ IDEA Community Edition 2020.3.2\lib\idea_rt.jar=2843:E:\Download\IDEA\IntelliJ IDEA Community Edition 2020.3.2\bin&quot;</span> -Dfile.encoding=UTF-<span class="hljs-number">8</span> -classpath E:\eclipse-workspace\JavaTest\out\production\Module01 InitDemo<br>(<span class="hljs-number">0</span>) <br>(<span class="hljs-number">1</span>) <br>(<span class="hljs-number">2</span>) <br>(<span class="hljs-number">3</span>) <br>(<span class="hljs-number">4</span>) <br>(<span class="hljs-number">5</span>) <br>(<span class="hljs-number">6</span>) <br>(<span class="hljs-number">7</span>) <br>(<span class="hljs-number">8</span>) <br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><ul><li><p>利用super可以显式调用父类的构造函数  </p><ul><li>super(parametersopt)调用<strong>父类的的构造函数</strong>。  </li><li>必须是子类构造函数的**第1条且仅1条语句(先构造父类)**。  </li><li>如果子类构造函数中没有显式地调用父类的构造函数，那么将<strong>自动调用父类不带参数的构造函数。</strong></li><li>父类的构造函数在子类构造函数<strong>之前</strong>执行。  </li></ul></li><li><p>访问父类的<strong>成员（包括静态和实例成员）</strong></p><ul><li>super<strong>不能用于静态</strong>上下文（即静态方法和静态初始化块里不能使用super），this也不能用于静态上下文</li><li>super.data（如果父类属性在子类可访问）</li><li>super.method(parameters)（如果父类方法在子类可访问（无限定词））</li><li>不能使用super.super.p()这样的super<strong>链</strong>（Java创造者认为没有必要）  </li></ul></li><li><p>如果子类中没有显式地调用父类的构造函数，那么将<strong>自动调用父类不带参数的构造函数</strong>，因为编译器会偷偷地在子类构造函数第一条语句前加上super() ；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> A（）&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>等价于</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> A（）&#123;<br>  <span class="hljs-keyword">super</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> A（<span class="hljs-keyword">double</span> d）&#123;<br><span class="hljs-comment">//some statements</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>等价于</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> A（<span class="hljs-keyword">double</span> d）&#123;<br>  <span class="hljs-keyword">super</span>();<br><span class="hljs-comment">//some statements</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>在任何情况下，构造一个类的实例时，会沿着继承链调用所有父类的构造方法，这叫构造方法链。<br>先构造最祖先的父类，依次往前调用，直到调用自己的。</li></ul><ol><li>如果一个类自定义了构造函数（不管有无参数），编译器不会自动加上无参构造函数。</li><li>如果一个类没定义任何构造函数，编译器会<strong>自动地</strong>加上无参构造函数。</li><li>编译器在为子类添加无参构造函数时，函数体里会用super( )默认调用父类的无参构造函数，<strong>如果找不到父类无参构造函数，则编译器为子类添加无参构造函数失败</strong>，编译报错。</li><li>如果一个类定义了带参数的构造函数，一定别忘了<strong>定义一个无参的构造函数</strong>，原因是：由于系统不会再自动加上无参构造函数，就造成该类没有无参构造函数</li></ol><ul><li>如果父类没有无参构造函数，那么子类构造函数里若调用父类无参构造函数就会编译出错。<br>以下为实例及解释<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fruit</span><span class="hljs-params">(String name)</span> </span>&#123;      <span class="hljs-comment">//父类，没有无参构造函数</span><br>System.out.println(<span class="hljs-string">&quot;调用Fruit的构造函数&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123; &#125;       <span class="hljs-comment">//子类</span><br></code></pre></div></td></tr></table></figure><blockquote><p>//编译器为Apple提供无参构造函数时出错<br>//子类Apple没定义任何构造函数，故编译为子类提供无参构造函数Apple();<br>//提供的Apple()会调用父类无参构造函数Fruit(),因下列原因无法调用：<br>//父类定义了有参构造函数，所以编译没有为父类提供无参Fruit( )。</p></blockquote></li></ul><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>Java 中可以实现一个类中包含另外一个类，且不需要提供任何的类名直接实例化。</p><p>主要是用于在我们需要的时候创建一个对象来执行特定的任务，可以使代码更加简洁。</p><p>匿名类是不能有名字的类，它们不能被引用，只能在创建时用 <strong>new</strong> 语句来声明它们。</p><p>匿名类语法格式：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">outerClass</span> </span>&#123;<br><br>    <span class="hljs-comment">// 定义一个匿名类</span><br>    object1 = <span class="hljs-keyword">new</span> Type(parameterList) &#123;<br>         <span class="hljs-comment">// 匿名类代码</span><br>    &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上的代码创建了一个匿名类对象 object1，匿名类是表达式形式定义的，所以末尾以分号 <strong>;</strong> 来结束。</p><p>匿名类通常继承一个父类或实现一个接口。</p><p><img src="https://gitee.com/Trent-Liuy/blogimage/raw/master/img1/image-20210527141545572.png" alt="image-20210527141545572"></p><h4 id="匿名类继承一个父类"><a href="#匿名类继承一个父类" class="headerlink" title="匿名类继承一个父类"></a>匿名类继承一个父类</h4><p>以下实例中，创建了 Polygon 类，该类只有一个方法 display()，AnonymousDemo 类继承了 Polygon 类并重写了 Polygon 类的 display() 方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Polygon</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;在 Polygon 类内部&quot;</span>);<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnonymousDemo</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createClass</span><span class="hljs-params">()</span> </span>&#123;<br><br>      <span class="hljs-comment">// 创建的匿名类继承了 Polygon 类</span><br>      Polygon p1 = <span class="hljs-keyword">new</span> Polygon() &#123;<br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;在匿名类内部。&quot;</span>);<br>         &#125;<br>      &#125;;<br>      p1.display();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       AnonymousDemo an = <span class="hljs-keyword">new</span> AnonymousDemo();<br>       an.createClass();<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行以上代码，匿名类的对象 p1 会被创建，该对象会调用匿名类的 display() 方法，输出结果为：</p><blockquote><p>在匿名类内部</p></blockquote><h4 id="匿名类实现一个接口"><a href="#匿名类实现一个接口" class="headerlink" title="匿名类实现一个接口"></a>匿名类实现一个接口</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Polygon</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnonymousDemo</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createClass</span><span class="hljs-params">()</span> </span>&#123;<br><br>      <span class="hljs-comment">// 匿名类实现一个接口</span><br>      Polygon p1 = <span class="hljs-keyword">new</span> Polygon() &#123;<br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;在匿名类内部。&quot;</span>);<br>         &#125;<br>      &#125;;<br>      p1.display();<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      AnonymousDemo an = <span class="hljs-keyword">new</span> AnonymousDemo();<br>      an.createClass();<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果为</p><blockquote><p>在匿名类内部</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>继承</tag>
      
      <tag>super关键字</tag>
      
      <tag>实例初始化模块&amp;静态初始化模块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——包以及方法重载、覆盖、隐藏</title>
    <link href="/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%E3%80%81%E9%9A%90%E8%97%8F/"/>
    <url>/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%E3%80%81%E9%9A%90%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li>包除了起到名字空间的作用外，还有个很重要的作用：提供了package一级的访问权限控制（在Java里，成员访问控制权限除了公有、保护、私有，还多了包一级的访问控制；类的访问控制除了public外，也多了包一级的访问控制）</li><li>包的命名习惯: 将Internet域名作为包名 （但级别顺序相反），这样的好处是<strong>避免包名的重复</strong><ul><li>org.apache.tools.zip</li><li>cn.edu.hust.cs.javacourse.ch1</li><li>如果所有程序员都遵循这种包命名的约定，包名重复的可能性就非常小</li></ul></li></ul><h2 id="方法的重载、覆盖、隐藏"><a href="#方法的重载、覆盖、隐藏" class="headerlink" title="方法的重载、覆盖、隐藏"></a>方法的重载、覆盖、隐藏</h2><ul><li>方法重载：同一个类中、或者父类子类中的多个方法具有<strong>相同的名字</strong>，但这些方法具有<strong>不同的参数列表</strong>(不含返回类型，即<strong>无法以返回类型</strong>作为方法重载的区分标准）<span id="more"></span></li><li>方法覆盖和方法隐藏：发生在<strong>父类和子类</strong>之间，<strong>前提是继承</strong>。子类中定义的方法与父类中的方法具有<strong>相同的方法名字、相同的参数列表、相同的返回类型</strong>（也允许子类中方法的返回类型是父类中方法返回类型的子类。<ul><li>方法覆盖：实例方法</li><li>方法隐藏：静态方法<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;&#125;<br><br><span class="hljs-comment">//下面语句报错m(int,int)已经定义, 重载要求参数列表不同,下图重构</span><br><span class="hljs-comment">//重载函数不能通过返回类型区分</span><br><span class="hljs-comment">//    public int m(int x, int y) &#123; return 0;&#125;; </span><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123; <span class="hljs-comment">//B继承了A</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y)</span> </span>&#123; &#125; <span class="hljs-comment">//重载了父类的m(int,int)和m(double,double)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;&#125; <span class="hljs-comment">//覆盖了父类的void m(int,int)，注意连返回类型都必须一致</span><br><br>    <span class="hljs-comment">//注意下面这个语句报错，既不是覆盖（与父类的void m(int,int)返回类型不一样）</span><br>    <span class="hljs-comment">// 也不是合法的重载（和父类的m(int,int)参数完全一样，只是返回类型不一致</span><br><span class="hljs-comment">//    public int m(int x, int y) &#123;&#125; //错误</span><br>    <br>    <span class="hljs-comment">//子类定义了新的重载函数int m()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>C++重载会报错，不认为子类定义会覆盖父类。<br>final关键字修饰的方法不可以被覆盖或隐藏。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m4</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-comment">//覆盖父类A的void  m1()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123; &#125;<br><br>    <span class="hljs-comment">//下面语句报错，不能覆盖父类的final 方法</span><br><span class="hljs-comment">//    public void m2()&#123; &#125;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123; &#125; <span class="hljs-comment">//隐藏了父类的static void m3()</span><br>    <span class="hljs-comment">//下面语句报错，父类final 静态方法不能被子类隐藏</span><br><span class="hljs-comment">//    public static void m4() &#123; &#125;</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>重载</tag>
      
      <tag>隐藏</tag>
      
      <tag>覆盖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——对象</title>
    <link href="/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><ul><li><p>new创建对象  </p><ul><li>与基本数据类型一样，可声明并用new创建对象数组。<br>int[]a=new int[10];//所有元素缺省初值=0  </li><li>当创建对象数组时，数组元素的缺省初值为null。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Circle[] circleArray = <span class="hljs-keyword">new</span> Circle[<span class="hljs-number">10</span>]; <span class="hljs-comment">//这时没有构造Circle对象，只是构造数组,此时的circleArray[i]都指向null</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; circleArray.length; i++) &#123;<br>circleArray[i] = <span class="hljs-keyword">new</span> Circle( );    <span class="hljs-comment">//这时才构造Circle对象，可使用有参构造函数  </span><br>&#125;  <br></code></pre></div></td></tr></table></figure><span id="more"></span></li></ul></li><li><p>对象是引用变量，当new出的对象没有变量来引用时，该对象会由JVM自动回收。</p></li><li><p>对象引用，可以</p><ul><li><p>访问实例变量 c2.radius</p></li><li><p>调用对象的实例方法 c2.rindArea();</p></li><li><p>实例对象也可以访问静态成员和静态方法，但是很不推荐，<strong>静态建议用类名来访问</strong>。</p></li></ul></li><li><p>匿名对象也可访问实例(或静态)成员：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">new</span> Circle( ).radius=<span class="hljs-number">2</span>;<br></code></pre></div></td></tr></table></figure></li><li><p> 在实例方法中有个this引用，代表当前对象(引用当前对象：相当于指针)，因此在实例方法里，可以用this引用访问当前对象成员</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> radius = <span class="hljs-number">1.0</span>;<br><br>    Circle() &#123;  <br>radius = <span class="hljs-number">1.0</span>;<br>    &#125;<br><br>    Circle(<span class="hljs-keyword">double</span> r) &#123;    <span class="hljs-comment">//this可以省略，this就指当前对象</span><br>        <span class="hljs-keyword">this</span>.radius = r;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findArea</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> radius * radius * Math.PI;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRadius</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newRadius)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.radius = newRadius;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSimpleCircle</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Circle c1 = <span class="hljs-keyword">new</span> Circle();<br>        System.out.println(<span class="hljs-string">&quot;Area = &quot;</span> + c1.findArea() + <br>                <span class="hljs-string">&quot;, radius = &quot;</span> + c1.radius);   <span class="hljs-comment">//c1调用类中方法，当进入c1对象时，this就自动赋值，变成c1</span><br><br>        Circle c2 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">10.0</span>);<br>        System.out.println(<span class="hljs-string">&quot;Area = &quot;</span> + c2.findArea() + <br>                <span class="hljs-string">&quot;, radius = &quot;</span> + c2.radius);<br><br>        <span class="hljs-comment">//modify radius</span><br>        c2.setRadius(<span class="hljs-number">20.0</span>);<br>        System.out.println(<span class="hljs-string">&quot;Area = &quot;</span> + c2.findArea() + <br>                <span class="hljs-string">&quot;, radius = &quot;</span> + c2.radius);  <span class="hljs-comment">//c2调用，进入对象调用值时，this就自动变成c2</span><br>    &#125;<br></code></pre></div></td></tr></table></figure></li><li><p>this引用指向调用某个方法的当前对象</p><ul><li>在实例方法中，实例变量被同名局部变量或方法形参隐藏，可以通过this.instanceVariable访问实例变量。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;<br>   <span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> k = <span class="hljs-number">0.0</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setI</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;   <span class="hljs-comment">//i为局部变量，若不加下面的this，调用完后上面i的值不变，</span><br>                       <span class="hljs-comment">//this.i指的是上面的i,i则是方法的形参i</span><br>      <span class="hljs-keyword">this</span>.i= i;<br>   &#125;<br><br>   Foo f1 =<span class="hljs-keyword">new</span> Foo();<br>Foo f2 = <span class="hljs-keyword">new</span> Foo();<br><br>f1.setI(<span class="hljs-number">10</span>);<span class="hljs-comment">//这时this引用f1</span><br>f2.setI(<span class="hljs-number">45</span>);<span class="hljs-comment">//这时this引用f2</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>调用当前类的其它构造函数，需防止递归调用。</p></li><li><p>对象的参数传递</p><ul><li>基本数据类型传递的是实际值的拷贝，传值后形参和实参不再相关：修改形参的值，不影响实参。</li><li>引用类型变量传递的是对象的引用，通过形参修改对象object，将改变实参引用的对象object。</li><li>Java无类似C++的&amp;或者C#的ref来修饰方法参数，只能靠形参的声明类型来区分是传值还是传引用，因此一定要区分。</li></ul></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>对象</tag>
      
      <tag>this</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——构造函数</title>
    <link href="/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2021/03/25/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><ul><li><p><strong>无返回类型</strong>（包括void，void也是返回类型：无返回值），名字与类名相同，用于初始化对象。  </p><blockquote><p>注意的是构造函数是对象一建立就运行，给对象初始化，包括属性、方法中的语句。只<strong>运行一次</strong><br>而一般函数是对象调用才执行，用“.方法名”的方式。</p></blockquote></li><li><p>注意JAVA如果类名前加了void，定义void className(…),被认为是普通方法，而不是构造函数。（如果是C++语言，这样写void 类名 会报错）</p></li><li><p>只在new时被自动执行，不可以被显示调用（<del>.构造函数（）</del>）。</p></li><li><p>必须是实例方法（无static），可为公有、保护、私有和包级权限。</p></li><li><p>类的变量为引用(相当于C指针)，指向实例化好的对象。  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Circle c2=<span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5.0</span>);<span class="hljs-comment">//调用时必须有括弧,可带参初始化</span><br></code></pre></div></td></tr></table></figure><span id="more"></span></li><li><p>缺省构造函数(同C++)  </p><blockquote><p>如果类未定义任何构造函数，编译器会自动提供一个不带参数的默认构造函数。<br>如果已自定义构造函数，则<strong>不会提供默认构造函数</strong>。<br>因此如果程序员定义了一个带参数的构造函数，最好再定义一个不带参数的构造函数。</p></blockquote></li><li><p>Java没有析构函数，但垃圾自动回收之前会自动调用finalize( ),可以覆盖定义该函数（但是finalize调用时机程序员无法控制，C++则需要手动调用）。  </p></li><li><p>如果定义了构造函数和一个与类名相同的方法  </p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructorTest</span> </span>&#123;<br>  <span class="hljs-comment">//构造函数前面不能有void   </span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConstructorTest</span><span class="hljs-params">()</span> </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;constructor&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//如果和类名同名函数前面加了void(可返回任何类型), 编译器看成是普通函数，这和C++不一样 </span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConstructorTest</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;normal instance method return void&quot;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">ConstructorTest</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d)</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;normal method return double&quot;</span>);<br>      <span class="hljs-keyword">return</span> d;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String ... args)</span></span>&#123;<br><span class="hljs-comment">//先调用构造，再调用void ConstructorTest() </span><br>      <span class="hljs-keyword">new</span> ConstructorTest().ConstructorTest();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意上图中，先调用了构造函数后，紧接着调用普通函数。</p><ul><li>注意在构造函数中调用构造函数，需要防止递归调用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>构造函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——修饰符</title>
    <link href="/2021/03/23/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2021/03/23/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><hr><ul><li>修饰变量：  <blockquote><p><strong>未用static修饰的成员变量</strong>，属于类的具体实例（对象），只能通过对象访问，如“对象名.变量名”<br><strong>使用static修饰的变量</strong>，被类的所有实例（对象）<strong>共享</strong>，也称类变量。可以通过对象或类名访问，提倡“类名.变量名”访问。<br>实际上，实例变量是作为对象内存的一部分存在，每new一个对象，内存中就分配一个无静态变量的对象。<br>静态变量是<strong>单独的内存单元</strong>，与对象内存分开，任何对象都可访问。而且此内存单元不需要实例化方法，事先分配。被所有对象共享。</p></blockquote></li></ul><hr><span id="more"></span><ul><li>修饰方法  <blockquote><p><strong>静态方法</strong>：用static修饰的方法。<br>静态方法只能访问类的静态成员（因为实例成员必须有实例才存在，当通过类名调用静态方法时，可能该类还没有一个实例）<br>静态方法无多态性（无this引用）<br>静态方法，方法名和类名都可以调用<br>每个程序必须有<strong>piblic static void main(String[])</strong> 方法</p></blockquote></li></ul><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li>实例常量：没有用static修饰的final常量。<br>静态常量：使用static修饰的final常量。<br>如 public static final double PI =3.13315….</li><li>常量不可以用等号赋值修改，由于不能修改，故通常定义为public</li><li>final还可以修饰方法：<br>修饰实例方法：表示该方法不可以被子类覆盖。<br>修饰静态方法：表示该方法不能被子类隐藏。</li><li>构造函数不可以为final</li></ul><hr><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><ul><li><p>修饰成员变量  </p><blockquote><p>被private修饰的变量和方法，只能在自己对象<strong>内部</strong>使用<br>面向对象的<strong>封装性</strong>要求最好把实例成员变量设为私有的或保护的<br>为私有、保护的实例成员变量提供公有的<strong>get</strong>和<strong>set</strong>方法。get和set方法遵循JavaBean的命名规范  </p></blockquote><p>DataType为私有成员  </p></li><li><p><strong>get获取成员值</strong>  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> DataType <span class="hljs-title">getPropertyName</span><span class="hljs-params">()</span>   </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">return</span> a;  <br>&#125;  <br></code></pre></div></td></tr></table></figure></li><li><p><strong>set设置成员值</strong>  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPropertyName</span><span class="hljs-params">(DataType value)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    value =xx;  <br>&#125; <br></code></pre></div></td></tr></table></figure></li></ul><blockquote><p>封装起来，防止程序员写出类似o.radius=-100（radius要求&gt;0）这样的错误值，类是给别人使用的，要防止别人乱写，因此将这个元素封装起来，起控制作用。<br>  可以在上面set中添加if判断条件语句，保证一定设置正值。<br>    另一应用:<strong>计数器</strong>  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius;<br>    <span class="hljs-comment">/** 私有静态变量，记录当前内存里被实例化的Circle对象个数*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numberOfObjects = <span class="hljs-number">0</span>; <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span> </span>&#123; radius = <span class="hljs-number">1.0</span>; numberOfObjects++; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newRadius)</span> </span>&#123; radius = newRadius; numberOfObjects++; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> radius;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRadius</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newRadius)</span> </span>&#123; radius = newRadius;&#125;<br>    <span class="hljs-comment">/** 公有静态方法，获取私有静态变量内容*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumberOfObjects</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> numberOfObjects;&#125;<br><br>    <span class="hljs-comment">/** Return the area of this circle */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findArea</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> radius * radius * Math.PI; &#125;<br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-comment">/*覆盖从Object继承的finalize方法，该方法在对象被回收时调用，方法里对象计数器-1。</span><br><span class="hljs-comment">    注意该方法调用时机不可控制。</span><br><span class="hljs-comment">    @Override是注解（annotation），告诉编译器这里是覆盖父类的方法。*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        numberOfObjects--; <span class="hljs-comment">//对象被析构时，计数器减1</span><br>        <span class="hljs-keyword">super</span>.finalize();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>private static构造计数器，在每个重载的构造函数里计数器+1。  </p></blockquote><p>  @Override可以不加，但是使用@Override注解有如下好处：<br>1：可以当注释用,方便阅读；<br>2：编译器可以给你验证@Override下面的方法名是否是父类中所有的，如果没有则报错。例如，如果没写@Override，而下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。</p><p>Java注解为 Java 代码提供元数据。注解可以指示编译器做些额外的动作，甚至可以自定义Java注解让编译器执行自定义的动作。Java提供了Annotation API让我们自定义注解。</p><h2 id="类的成员访问控制符"><a href="#类的成员访问控制符" class="headerlink" title="类的成员访问控制符"></a>类的成员访问控制符</h2><blockquote><p>private：只能被当前类定义的函数访问。<br>包级：无修饰符的成员，可以被同一包中的类访问。<br>protected： 子类 ，同一包中的类的函数可以访问。<br>public： 所有类的函数都可以访问。<br>以上访问权限由小到大。<br>后两者可以被子类访问。继承会自动继承除私有成员外的父类成员。<br>子类类体可以访问从父类继承来的protected成员。如果子类和父类不在一个包里，子类不能访问另外的父类实例（非继承）的protected成员。  </p></blockquote><table><thead><tr><th>访问权限</th><th>本类</th><th>本包</th><th>子类</th><th>它包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>包级</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h2><ul><li>有一些对象只需要一个，并且可以在需要时才开始创建对象，保证只有一对象被创建。<br>不能在外部创建对象，只能在类的内部<br>可以定义全局变量，但是全局变量会在程序一开始就创建好，如果该对象在程序执行过程中对资源消耗非常大且使用率不高，就非常累赘。  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>  </span><br><span class="hljs-class"></span>&#123;  <br>　　　<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance =<span class="hljs-keyword">null</span>;  <br>  <br>  <br>  <span class="hljs-comment">//其他的实例变量  </span><br>    <br>    <span class="hljs-comment">//构造方法是私有的，所以在类外不能new出多个实例  </span><br> 　　　<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">singleton</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"> 　　 </span>&#123;  <br> 　　 &#125;<br>　　　<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">　　 </span>&#123;  <br> 　　　　　 <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-keyword">null</span>)  <br> <span class="hljs-comment">//如果为null，就创建对象，否则不创建，直接在下面返回已经存在的对象  </span><br> 　　　 &#123;  <br>  　　　　　　　  uniqueInstance == <span class="hljs-keyword">new</span> Singleton();  <br>  　　　 &#125;  <br>  　　　 <span class="hljs-keyword">return</span> uniqueInstance;  <br>&#125;  <br></code></pre></div></td></tr></table></figure>//调用的时候，我们可以通过<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">Singleton uniqueInstance = Singleton.getInstance();  <br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance =<span class="hljs-keyword">null</span>;<span class="hljs-keyword">static</span>，<span class="hljs-comment">//静态变量，是所有实例化对象共有的  </span><br> <span class="hljs-comment">// 就算构造多个对象，它们指向的都是一个实例对象。</span><br></code></pre></div></td></tr></table></figure></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>单件模式</tag>
      
      <tag>计数器</tag>
      
      <tag>访问控制符</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
